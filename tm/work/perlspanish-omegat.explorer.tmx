<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.2.3_2"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, these operators are covered in precedence order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En las secciones siguientes, estos operadores están descritos en orden de precedencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example takes advantage that C&lt;NaN != NaN&gt; to
eliminate any C&lt;NaN&gt;s from the input list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el ejemplo siguiente se aprovecha de que C&lt;NaN != NaN&gt; para eliminar cualquier C&lt;NaN&gt; de la lista de entrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transliterates all occurrences of the characters found in the search list
with the corresponding character in the replacement list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Translitera todas las apariciones de los caracteres que se encuentran en la lista de búsqueda con el carácter correspondiente en la lista de reemplazo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the search for the end, backslashes that escape delimiters
are removed (exactly speaking, they are not copied to the safe location).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Durante la búsqueda del final, las barras invertidas que escapan delimitadores son eliminados (hablando más exactamente, no se copian al lugar seguro).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The integer formats C&lt;s&gt;, C&lt;S&gt;, C&lt;i&gt;, C&lt;I&gt;, C&lt;l&gt;, C&lt;L&gt;, C&lt;j&gt;, and C&lt;J&gt; are
inherently non-portable between processors and operating systems because
they obey native byteorder and endianness.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los formatos enteros C&lt;s&gt;, C&lt;S&gt;, C&lt;i&gt;, C&lt;I&gt;, C&lt;l&gt;, C&lt;L&gt;, C&lt;j&gt;, y C&lt;J&gt; inherentemente no portátiles entre procesadores y sistemas operativos porque siguen el orden nativo de los bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Conditions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Condiciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the command &quot;make install&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejecute el comando &quot;make install&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub unimplemented { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub no_implementado { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the bottom of L&lt;perlfunc/open()&gt; for an
example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver la parte inferior de L&lt;perlfunc/open()&gt; para un ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;feature&gt; and
L&lt;perlsyn/&quot;Switch statements&quot;&gt; for more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012006Z" changeid="explorer">
        <seg>Ver L&lt;feature&gt; y L&lt;perlsyn/&quot;Instrucciones switch&quot;&gt; para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Modifiers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Modificadores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL until (EXPR) BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA until (EXPR) BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item say LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item say LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @part, $AoA[$x][$y];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053000Z" changeid="explorer">
        <seg>push @part, $AoA[$x][$y];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@them          = @folks[0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ellos          = @gente[0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T010643Z" changeid="explorer">
        <seg>#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlintern		Perl internal functions (autogenerated)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlintern		Funciones internas de Perl (autogenerada)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl applies the format to
each integer in turn, then joins the resulting strings with a separator (a
dot C&lt;.&gt; by default).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl aplica el formato a cada entero por turno, luego une las cadenas resultantes con un separador (un punto C&lt;.&gt; por defecto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub&gt; for examples of using these as indirect filehandles
in functions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005457Z" changeid="explorer">
        <seg>Véase L&lt;perlsub&gt; por ejemplos del uso de estos gestores indirectos de archivo en funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These special variables are used for all
kinds of purposes, and are documented in L&lt;perlvar&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224832Z" changeid="explorer">
        <seg>Estas variables especiales se usan para diversos fines y se describen en L&lt;perlvar&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;=&quot; is the ordinary assignment operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;=&quot; es el operador ordinario de asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002221Z" changeid="explorer">
        <seg>1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Setuid\n&quot; if -u _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Setuid\n&quot; if -u _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Devel::Peek: display UTF-8 SVs also as \x{...}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devel::Peek: muestra SVs UTF-8 como \x{...}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004946Z" changeid="explorer">
        <seg>0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would not have worked, since a pattern match in scalar context will
only return true or false, rather than a count of matches.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no habría funcionado, ya que una expresión regular en contexto escalar sólo devolverá verdadero o falso, en lugar de un recuento de las coincidencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item quotemeta</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item quotemeta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232559Z" changeid="explorer">
        <seg>;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%f    a floating-point number, in fixed decimal notation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%f    un número en punto flotante, en notación decimal fija</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>E</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;readline&gt; X&lt;&lt; &lt;&gt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;readline&gt; X&lt;&lt; &lt;&gt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl582delta	Perl changes in version 5.8.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl582delta	Cambios en la versión 5.8.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $mixed[$#mixed];       # last element, prints 1.23</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121156Z" changeid="zipf">
        <seg>print $mezcla[$#mezcla];  # último elemento, imprime 1.23 en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We hope.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esperamos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these
cases, it probably pays not to trust whichever system rounding is
being used by Perl, but to instead implement the rounding function you
need yourself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estos casos, es mejor no confiar en el sistema de redondeo que está siendo utilizado por Perl, sino que en su lugar deba implementar la función de redondeo que necesite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Comma Operator
X&lt;comma&gt; X&lt;operator, comma&gt; X&lt;,&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001331Z" changeid="explorer">
        <seg>=head2 Operador coma
X&lt;comma&gt; X&lt;operator, comma&gt; X&lt;,&gt; X&lt;coma&gt; X&lt;operador, coma&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlos2		Perl notes for OS/2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlos2		Notas para OS/2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can also be that long doubles and doubles are the same thing:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede ser que los long doubles y doubles sean la misma cosa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The comparison function is required to behave.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se requiere que la función de comparación se comporte de forma correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have an optional comma before the closing parenthesis of a
list literal, so that you can say:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede tener una coma opcional, antes del paréntesis de cierre en una lista literal, de modo que puede decir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The permission (or &quot;mode&quot;)
values you pass C&lt;mkdir&gt; or C&lt;sysopen&gt; are modified by your umask, so
even if you tell C&lt;sysopen&gt; to create a file with permissions C&lt;0777&gt;,
if your umask is C&lt;0022&gt; then the file will actually be created with
permissions C&lt;0755&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de permiso (o &quot;modo&quot;) que se pasa a C&lt;mkdir&gt; o C&lt;sysopen&gt; son modificados por su umask, así que incluso si usted dice C&lt;sysopen&gt; para crear un archivo con permisos de C&lt;0777&gt;, y su umask es C&lt;0022&gt;, entonces el archivo realmente es creado con permisos C&lt;0755&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keys %hash = 200;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>keys %hash = 200;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;a3 x2 /A A*&quot;, &quot;007: Bond, J.&quot;)  gives (&quot;Bond, J&quot;, &quot;.&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;a3 x2 /A A*&quot;, &quot;007: Bond, J.&quot;)  da (&quot;Bond, J&quot;, &quot;.&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlepoc		Perl notes for EPOC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlepoc		Notas para EPOC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>package other;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>package otro;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See your native chmod(2) and stat(2) documentation for more details
about the C&lt;S_*&gt; constants.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consulte su documentación de las nativas chmod(2) y stat(2) para obtener más detalles acerca de las constantes C&lt;S_*&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @INC, [ \&amp;my_sub, $x, $y, ... ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @INC, [ \&amp;mi_sub, $x, $y, ... ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your input lines might end in backslashes to indicate continuation, you
want to skip ahead and get the next record.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si las líneas de entrada acaban en contra barras para indicar continuación, querrá saltarlo y obtener el siguiente registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&gt;&gt;&quot; returns the value of its left argument shifted right by
the number of bits specified by the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&gt;&gt;&quot; devuelve el valor de su argumento izquierdo desplazado a la derecha por el número de bits especificado por el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pop ARRAY
X&lt;pop&gt; X&lt;stack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192604Z" changeid="explorer">
        <seg>=item pop ARRAY
X&lt;pop&gt; X&lt;stack&gt; X&lt;pila&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>^	Match the beginning of the line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>^	Coincide con el principio de la línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$val\n&quot; while defined($val = pop(@ary));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$valor\n&quot; while defined($valor = pop(@ary));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;@utmp1&quot; eq &quot;@utmp2&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># &quot;@utmp1&quot; eq &quot;@utmp2&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LABEL is optional, and if present, consists of an identifier followed
by a colon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La ETIQUETA es opcional, y si está presente, consiste en un identificador seguido por el carácter dos puntos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(PASSWD, '/etc/passwd');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(PASSWD, '/etc/passwd');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000658Z" changeid="explorer">
        <seg>|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qq/STRING/
X&lt;qq&gt; X&lt;quote, double&gt; X&lt;&quot;&gt; X&lt;&quot;&quot;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010140Z" changeid="explorer">
        <seg>=item qq/CADENA/
X&lt;qq&gt; X&lt;quote, double&gt; X&lt;&quot;&gt; X&lt;&quot;&quot;&gt; X&lt;comilla, doble&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens because the pattern match is in list context (since it
is being assigned to the empty list), and will therefore return a list
of all matching parts of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto sucede porque la expresión regular está en contexto lista (ya que se asigna a la lista vacía), y por lo tanto se obtendrá una lista de todas las coincidencias de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value can be used as an indirect
filehandle, usually the real filehandle name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211324Z" changeid="explorer">
        <seg>GESTOR_ARCHIVO puede ser una expresión cuyo valor puede ser usado como un gestor indirecto, normalmente el nombre real del gestor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlstyle		Perl style guide</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlstyle		Guía de estilo Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-e  File exists.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004612Z" changeid="explorer">
        <seg>-e  Archivo existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System calls also set the special C&lt;$!&gt;
variable on failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llamadas al sistema también actualizan la variable especial C&lt;$!&gt; en caso de fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>regular($_) when [ qw/Chris David Ellen/ ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>normal($_) when [ qw/Chris David Ellen/ ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Matching in list context</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Coincidencia en contexto de lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to close FILEHANDLE if you are immediately going to do
another C&lt;open&gt; on it, because C&lt;open&gt; closes it for you.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211312Z" changeid="explorer">
        <seg>No tiene porqué cerrar el GESTOR_ARCHIVO si inmediatamente va a hacer otro C&lt;open&gt; sobre él mismo, porque C&lt;open&gt; lo cierra por usted.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir DIRHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chdir GESTOR_DIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly like C:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Exactamente igual que en C:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next if $x == $y;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next if $x == $y;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $ref-&gt;{&quot;Some key&quot;})    { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $ref-&gt;{&quot;Alguna clave&quot;})    { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;elt $i $j is $AoA[$i][$j]\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052929Z" changeid="explorer">
        <seg>print &quot;ítem $i $j es $AoA[$i][$j]\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIMIT is negative, it is treated as if an arbitrarily large LIMIT
had been specified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LÍMITE es negativo, se trata como si se hubiera especificado un LÍMITE arbitrariamente grande.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Cephes		uses external Cephes C library (no big numbers)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::Cephes             usa biblioteca C externa Cephes (no grandes números)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to
be portable, this behavior is not reflected by the Perl-level function
C&lt;getppid()&gt;, that returns a consistent value across threads.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ser portable, este comportamiento no está reflejado en la función  C&lt;getppid()&gt;, que devuelve un valor consistente a través de los hilos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>c	Do not reset search position on a failed match when /g is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>c	No reinicia la posición de búsqueda en una coincidencia fallida cuando /g esté en efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need an installed and working gccsdk cross compiler
L&lt;http://gccsdk.riscos.info/&gt; and REXEN
L&lt;http://www.cp15.org/programming/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Necesita tener instalado y funcionando un compilador cruzado gccsdk L&lt;http://gccsdk.riscos.info/&gt; y REXEN L&lt;http://www.cp15.org/programming/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is %d\n&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es %d\n&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use integer constants provided by the C&lt;Socket&gt; module for
LEVEL and OPNAME.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilice constantes enteras proporcionadas por el módulo C&lt;Socket&gt; para NIVEL y OPCIÓN_NOMBRE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$key=$value\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$clave=$valor\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The range operator also works on strings, using the magical
auto-increment, see below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador rango también trabaja en las cadenas, usando el auto-incremento mágico, ver abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or for initializing hash references to be used as records:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o para inicializar referencias hash para ser utilizados como registros:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Equality Operators
X&lt;equality&gt; X&lt;equal&gt; X&lt;equals&gt; X&lt;operator, equality&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235041Z" changeid="explorer">
        <seg>=head2 Operadores de igualdad
X&lt;equality&gt; X&lt;equal&gt; X&lt;equals&gt; X&lt;operator, equality&gt; X&lt;igualdad&gt; X&lt;operador, igualdad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the
previous example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el ejemplo anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To suppress this warning, say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>To suppress this warning, say</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlre		Perl regular expressions, the rest of the story</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlre		Expresiones regulares, el resto de la historia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closing the read end of a pipe before the process writing to it at the
other end is done writing results in the writer receiving a SIGPIPE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cerrar la lectura final de una tubería antes de que el proceso de escritura en el otro extremo termine resulta en que el escritor recibe un SIGPIPE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A package statement affects dynamic variables only, including those
you've used C&lt;local&gt; on, but I&lt;not&gt; lexical variables, which are created
with C&lt;my&gt; (or C&lt;our&gt; (or C&lt;state&gt;)).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012530Z" changeid="explorer">
        <seg>Una instrucción package afecta sólo a las variables dinámicas, incluyendo las que haya usado con C&lt;local&gt;, pero I&lt;no&gt; a las variables léxicas, que se crean con C&lt;my&gt; (u C&lt;our&gt; (o C &lt;state&gt;)).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item The empty pattern //</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item El patrón vacío //</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support fchmod(2), you may pass filehandles among the
files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soporten fchmod(2), puede pasar gestores de archivo entre los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Quoting metacharacters</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230505Z" changeid="explorer">
        <seg>=head2 Escapando metacaracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/&quot;Regexp Quote-Like Operators&quot;&gt; for details and
L&lt;perlretut&gt; for examples using these operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/&quot;Operadores Regexp entrecomillados&quot;&gt; para más detalles y L&lt;perlretut&gt; para ejemplos usando estos operadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declare a picture format for use by the C&lt;write&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Declara una imagen de formato para usar con la función C&lt;write&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item snazzle($)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item snazzle($)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12 blocks   actual number of blocks allocated</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>12 blocks   número actual de bloques reservados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (/.\G/g) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (/.\G/g) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 2) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 2) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Goto
X&lt;goto&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042956Z" changeid="explorer">
        <seg>=head2 Goto
X&lt;goto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used with C&lt;Z&gt;, a C&lt;*&gt; as the repeat count is guaranteed to add a
trailing null byte, so the resulting string is always one byte longer than
the byte length of the item itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se utiliza con C&lt;Z&gt;, un C&lt;*&gt; como el número de repeticiones, está garantizado que añadirá un byte nulo final, por lo que la cadena resultante es siempre un byte más largo que la longitud en bytes del propio elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the combination C&lt;\\&gt; is left intact, since escaped delimiters
are not available for here-docs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que la combinación C&lt;\\&gt; se mantiene intacta, ya que no están disponibles delimitadores escapados para los documentos incrustados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># make divide-by-zero nonfatal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># hace la división-por-cero no fatal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the arguments C&lt;debug&gt;/C&lt;debugcolor&gt;
in the C&lt;use L&lt;re&gt;&gt; pragma, as well as Perl's B&lt;-Dr&gt; command-line
switch documented in L&lt;perlrun/&quot;Command Switches&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver los argumentos C&lt;debug&gt;/C&lt;debugcolor&gt; en el pragma C&lt;use L&lt;re&gt;&gt;, así como la opción en línea de comandos de Perl B&lt;-Dr&gt; documentado en L&lt;perlrun/&quot;Opciones de comando&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># you don't have to use the default $_ either...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002742Z" changeid="zipf">
        <seg># tampoco tiene que usar la variable $_ predeterminada...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>package Bar;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>package Bar;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special case the 3-arg form with a read/write mode and the third
argument being C&lt;undef&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como un caso especial, de la forma de tres argumentos con un modo de lectura/escritura y el tercer argumento siendo C&lt;undef&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Gory details of parsing quoted constructs
X&lt;quote, gory details&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010437Z" changeid="explorer">
        <seg>=head2 Detalles sangrientos del análisis de construcciones entrecomilladas
X&lt;quote, gory details&gt; X&lt;entrecomillado, detalles sangrientos&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| warn &quot;couldn't touch $file: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>|| warn &quot;no puedo tocar $archivo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some brief examples:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235546Z" changeid="zipf">
        <seg>Algunos ejemplos breves:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For cryptographic purposes, however, you need something much more random 
than the default seed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para propósitos criptográficos, necesita algo mucho más aleatorio para el valor por defecto de la semilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this is a wide-open interface, pragmas (compiler directives)
are also implemented this way.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que esta es una interfaz ampliamente abierta, pragmas (directivas del compilador), también son implementadas de esta manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; line-noise&quot;),	redo LOOP if /\G[^A-Za-z0-9]+/gc;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(&quot; línea-ruidosa&quot;),	redo LOOP if /\G[^A-Za-z0-9]+/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Symbolic Unary Operators
X&lt;unary operator&gt; X&lt;operator, unary&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234225Z" changeid="explorer">
        <seg>=head2 Operadores unarios simbólicos
X&lt;unary operator&gt; X&lt;operator, unary&gt; X&lt;operador unario&gt; X&lt;operador, unario&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns 1 if the next read on FILEHANDLE will return end of file, or if
FILEHANDLE is not open.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211402Z" changeid="explorer">
        <seg>Devuelve 1 si la siguiente lectura sobre GESTOR_ARCHIVO devolverá un fin de archivo, o si GESTOR_ARCHIVO no está abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($_ = &lt;STDIN&gt;) ne '0') { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (($_ = &lt;STDIN&gt;) ne '0') { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some systems the $comment field may be $class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas el campo $comentario puede ser $clase.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise it matches any character but C&lt;\n&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, equivale a cualquier carácter, excepto C&lt;\n&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is omitted, chops C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE se omite, recorta C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A unary operator generally provides a scalar context to its
argument, while a list operator may provide either scalar or list
contexts for its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un operador unario generalmente proveé de un contexto escalar a su argumento, mientras que un operador de listas puede proveer tanto de un contexto escalar como un contexto de lista, a sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the end of all C&lt;when&gt; blocks, there is an implicit C&lt;next&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al final de todos los bloques C&lt;when&gt;, hay un implícito C&lt;next&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can modify @ARGV before the first &lt;&gt; as long as the array ends up
containing the list of filenames you really want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede modificar @ARGV antes del primer &lt;&gt; siempre que el array termine conteniendo la lista de nombres de archivos que realmente quiere.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not use this function for rounding: one because it truncates
towards C&lt;0&gt;, and two because machine representations of floating-point
numbers can sometimes produce counterintuitive results.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No debe usar esta función para redondear: primero, porque trunca hacia C&lt;0&gt; y segundo, porque las representaciones máquina de números en punto flotante puede producir, algunas veces, resultados dispares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @new = sort {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @nuevo = sort {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LAYER is omitted or specified as C&lt;:raw&gt; the filehandle is made
suitable for passing binary data.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite CAPA o se especifica como C&lt;:raw&gt; el gestor se prepara para pasar datos binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUPER-UX: add hints file</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004048Z" changeid="explorer">
        <seg>SUPER-UX: añadido archivo de sugerencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 128 == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 128 == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># didn't</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># no hacer nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its major
features are that it's easy to use, supports both procedural and
object-oriented (OO) programming, has powerful built-in support for text
processing, and has one of the world's most impressive collections of
third-party modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224622Z" changeid="explorer">
        <seg>Se caracteriza principalmente por su facilidad de uso (permite programar tanto de manera procedural como orientada a objetos (OO)), su magnífica capacidad para procesamiento de texto y por tener una de las colecciones de módulos de terceros más impresionantes del mundo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;tr&gt; does B&lt;not&gt; do regular expression character classes
such as C&lt;\d&gt; or C&lt;[:lower:]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que C&lt;tr&gt; B&lt;no&gt; usa expresiones regulares de clases de caracteres, tales como C&lt;\d&gt; o C&lt;[:lower:]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $x;           # prints &quot;foo&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002203Z" changeid="zipf">
        <seg>print $x;           # imprime &quot;foo&quot; en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rindex STR,SUBSTR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item rindex CADENA,SUBCADENA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\1 through \9 are always interpreted as
backreferences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De \1 a \9 son siempre interpretados como contrareferencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This used to be the preferred way to
pass arrays and hashes by reference into a function, but now that
we have real references, this is seldom needed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005333Z" changeid="explorer">
        <seg>Esta es la forma preferida para pasar arrays y hashes por referencia, a una función, pero como ahora tenemos referencias de verdad, esto es raramente necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a non-empty string if EXPR is a reference, the empty
string otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una cadena no vacía si EXPR es una referencia; de otra manera, devuelve una cadena vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (@keys) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (@claves) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LOCK_SH
requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN
releases a previously requested lock.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LOCK_SH solicita un bloqueo compartido, LOCK_EX solicita un bloqueo exclusivo y LOCK_UN devuelve un bloqueo solicitado previamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose wisely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elija con cuidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for representing
Unicode strings, and for comparing version &quot;numbers&quot; using the string
comparison operators, C&lt;cmp&gt;, C&lt;gt&gt;, C&lt;lt&gt; etc.  If there are two or
more dots in the literal, the leading C&lt;v&gt; may be omitted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para la representación de cadenas Unicode, y para comparar la versión &quot;en números&quot; que utilizan los operadores de comparación de cadenas, C&lt;cmp&gt;, C&lt;gt&gt;, C&lt;lt&gt;, etc. Si hay dos o más puntos en el literal, el prefijo C&lt;v&gt; puede omitirse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar values are always named with '$', even when referring to a
scalar that is part of an array or a hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores escalares se nombran siempre con '$', incluso cuando se accede a un escalar que es parte de un array o un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@sortedclass = sort byage @class;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@claseordenada = sort por_edad @clase;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mode you specify should match the mode of the original filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El modo que especifique debe coincidir con el modo del gestor de archivo original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it does guess wrong, or if you're just
plain paranoid, you can force the correct interpretation with curly
braces as above.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se equivoca, o si es usted un sencillo paranoico, puede forzar la interpretación correcta con llaves, como en el caso anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 4) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 4) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#days		# the last index of array @days</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#dias		# el último índice del array @dias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.6 and earlier used a quicksort algorithm to implement sort.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl v5.6 y anteriores usaban un algoritmo quicksort para implementar sort.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-B  File is a &quot;binary&quot; file (opposite of -T).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-B  archivo es un archivo &quot;binario&quot; (opuesto de -T).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Irix 6.2 with perl threads, you have to have the following
patches installed:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T012315Z" changeid="explorer">
        <seg>En Irix 6.2 con hilos perl, tiene que tener los siguientes parches instalados:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map {  lc($_) =&gt; 1  } @array  # as does this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map {  lc($_) =&gt; 1  } @array  # y como esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an internal function used by C&lt;format&gt;s, though you may call it,
too.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es una función interna usada por C&lt;format&gt;, aunque también puede llamarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Running Perl programs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T000713Z" changeid="zipf">
        <seg>=head2 Ejecución de programas Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\a		alarm (bell)    (BEL)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002830Z" changeid="explorer">
        <seg>\a		alarma (campana) (BEL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our($bar, $baz);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>our($bar, $baz);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since I am running a very recent Hurd snapshot, in which a lot of
bugs that were exposed by the Perl test suite have been fixed, you may
encounter more failures.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, desde que estoy corriendo en la reciente distribución de Hurd, y aunque un montón de errores expuestos por el conjunto de test de Perl han sido arreglados, usted puede encontrar más fallos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Address-of operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operador Dirección-de.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List values are denoted by separating individual values by commas
(and enclosing the list in parentheses where precedence requires it):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lista de valores se indican mediante la separación de los valores individuales por comas (y encerrando la lista entre paréntesis donde la precedencia lo requiera):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Slices</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Porciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The B&lt;-w&gt; switch is not mandatory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La opción B&lt;-w&gt; no es obligatoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/([^ ]*) *([^ ]*)/$2 $1/;	# reverse 1st two fields</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/([^ ]*) *([^ ]*)/$2 $1/;	# invierte los dos primeros campos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlport		Perl portability guide</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlport		Guía de portabilidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the delimiter is C&lt;/&gt;, one cannot get
the combination C&lt;\/&gt; into the result of this step.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el delimitador es C&lt;/&gt;, no se puede obtener la combinación C&lt;\/&gt; en el resultado de este paso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Same as C&lt;tr///&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Igual que C&lt;tr///&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sleep;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sleep;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $item (split(/:[\\\n:]*/, $ENV{TERMCAP})) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $item (split(/:[\\\n:]*/, $ENV{TERMCAP})) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfunc - Perl builtin functions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfunc - Funciones incluídas en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($folks[0], $folks[-1]) = ($folks[-1], $folks[0]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($gente[0], $gente[-1]) = ($gente[-1], $gente[0]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying an assignment is equivalent to doing the assignment and
then modifying the variable that was assigned to.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Modificando una asignación es equivalente a realizar la asignación y luego modificando la variable que le fue asignada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$shell = '/bin/csh';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$shell = '/bin/csh';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it
returns the empty string, use C&lt;getpwuid&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si devuelve la cadena vacía, utilice C&lt;getpwuid&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact semantics and interface of TYPE and ATTRS are still
evolving.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La semántica exacta e interfaz de TIPO y ATRIBUTOS están aún en evolución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How about this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194306Z" changeid="explorer">
        <seg>¿Qué le parece esto?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For characters C&lt;&quot;a&quot;..&quot;f&quot;&gt; and C&lt;&quot;A&quot;..&quot;F&quot;&gt;, the result
is compatible with the usual hexadecimal digits, so that C&lt;&quot;a&quot;&gt; and
C&lt;&quot;A&quot;&gt; both generate the nybble C&lt;0xa==10&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para los caracteres C&lt;&quot;a&quot; .. &quot;f&quot;&gt; y C&lt;&quot;A&quot; .. &quot;F&quot;&gt;, el resultado es compatible con los dígitos hexadecimales de costumbre, de modo que C&lt;&quot;a&quot;&gt; y C&lt;&quot;A&quot;&gt; generan el nible C&lt;0xa==10&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
C&lt;continue&gt; block, if any, is not executed:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bloque C&lt;continue&gt;, si está, no es ejecutado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl592delta	Perl changes in version 5.9.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl592delta	Cambios en la versión 5.9.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bugs in OS/2 sockets and tmpfile have been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Errores corregidos en sockets en OS/2 y tmpfile.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>document that use utf8 is not the right way most of the time</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>documentar que el uso de UTF-8 no es la manera correcta en la mayoría de las ocasiones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main use of typeglobs in modern Perl is create symbol table aliases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso principal de los typeglobs en el Perl moderno es crear alias en la tabla de símbolos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the cosine of EXPR (expressed in radians).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el coseno de EXPR (expresado en radianes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Test: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt;
              $str,     $%,    '$' . int($num)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050028Z" changeid="explorer">
        <seg>Test: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt;
              $str,     $%,    '$' . int($num)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timeout, if specified, is
in seconds, which may be fractional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El tiempo de espera, si se especifica, en segundos, puede ser decimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operating system, device drivers, C libraries, and Perl run-time
system all work together to let the programmer treat a single
character (C&lt;\n&gt;) as the line terminator, irrespective of the external
representation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El sistema operativo, gestores de dispositivos, bibliotecas C y Perl en tiempo de ejecución trabajan al unísono para permitirle al programador tratar un simple carácter (C&lt;\n&gt;) como el final de línea, independientemente de su representación externa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, &quot;echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C-style Logical Or
X&lt;||&gt; X&lt;operator, logical, or&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235541Z" changeid="explorer">
        <seg>=head2 Or lógico al estilo del C
X&lt;||&gt; X&lt;operator, logical, or&gt; X&lt;operador, lógico, or&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;next&gt; will exit such a block early.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto C&lt;next&gt; saldrá del primer bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;bits are %0*v8b\n&quot;, &quot; &quot;, $bits;   # random bitstring</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;bits son %0*v8b\n&quot;, &quot; &quot;, $bits;     # cadena de bits aleatoria</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, don't call srand() more than once in your program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, no llame a srand() más de una vez en su programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perldata&gt;, L&lt;perlref&gt;, L&lt;perldsc&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200441Z" changeid="explorer">
        <seg>L&lt;perldata&gt;, L&lt;perlref&gt;, L&lt;perldsc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-S&gt; ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-S&gt; ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsyn		Perl syntax</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsyn		Sintaxis Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>alarm $timeout;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>alarm $timeout;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current position I&lt;in bytes&gt; for FILEHANDLE, or -1 on
error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204726Z" changeid="explorer">
        <seg>Devuelve la posición actual I&lt;en bytes&gt; para GESTOR_ARCHIVO, o -1 en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;tr/$oldlist/$newlist/, 1&quot; or die $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;tr/$viejalista/$nuevalista/, 1&quot; or die $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those functions all
have return values, so use them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todas estas funciones tienen valores de retorno, así que úselos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of
C&lt;open&gt; with more than three arguments for non-pipe modes is not yet
defined, but experimental &quot;layers&quot; may give extra LIST arguments
meaning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El significado de C&lt;open&gt; con más de tres argumentos para modos no entubados aún no está definido, pero &quot;capas&quot; experimentales puede dar significados adicionales a la LISTA de argumentos adicionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readlink</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item readlink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Experimental Support for Sun Studio Compilers for Linux OS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Soporte Experimental para compiladores Sun Studio para sistemas operativos Linux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use Perl on the Hurd, I recommend using the Debian
GNU/Hurd distribution ( see http://www.debian.org/ ), even if an
official, stable release has not yet been made.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere usar Perl sobre Hurd, le recomiendo usar la distribución Debian
GNU/Hurd ( ver http://www.debian.org/ ), incluso aunque todavía no exista una versión estable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The character after the question mark indicates
the extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El carácter situado detrás del signo de interrogación indica la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map {  &quot;\L$_&quot; =&gt; 1  } @array  # perl guesses EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map {  &quot;\L$_&quot; =&gt; 1  } @array  # perl lee mal la EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cd /
chmod +t /tmp (=set the sticky bit to /tmp).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040230Z" changeid="explorer">
        <seg>cd /
chmod +t /tmp (=pone el sticky bit a /tmp).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REFERENCES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>REFERENCIAS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $first, &lt;$handle&gt; if $ALL;  # Or here.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return $primero, &lt;$handle&gt; if $TODO;  # O aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$now_string = strftime &quot;%a %b %e %H:%M:%S %Y&quot;, gmtime;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ahora = strftime &quot;%a %b %e %H:%M:%S %Y&quot;, gmtime;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readdir DIRHANDLE
X&lt;readdir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194424Z" changeid="explorer">
        <seg>=item readdir GESTOR_DIR
X&lt;readdir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either way, the implementation isn't going to generate results
larger than the size of the integer type Perl was built with (32 bits
or 64 bits).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De cualquier manera, la aplicación no va a generar resultados más grandes que el tamaño del tipo entero con el que Perl fue construido (32 o 64 bits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;tr/$oldlist/$newlist/&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;tr/$viejalista/$nuevalista/&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a side effect, calling keys() resets the HASH or ARRAY's internal iterator
(see L&lt;/each&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como efecto colateral, llamando a keys() resetea el iterador interno del HASH o ARRAY (ver L&lt;/each&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldos		Perl notes for DOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldos		Notas para DOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &quot;input line number&quot; (also
known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to
be currently in effect, and is also available as the special variable
C&lt;$.&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que el &quot;número de línea de entrada&quot; (también conocido como &quot;chunk&quot; -tarugo-) está sujeto a cualquier noción de &quot;línea&quot; que sea efectiva en ese momento, y también está disponible en la variable especial C&lt;$.&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An inner BLOCK may countermand this by saying</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un BLOQUE interno puede revocar esto diciendo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generalized quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comillas generales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the examples in
L&lt;perlipc/&quot;Sockets: Client/Server Communication&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver los ejemplos en L&lt;perlipc/&quot;Sockets: Comunicación Cliente/Servidor&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ( ! eof($fh) ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050731Z" changeid="explorer">
        <seg>while ( ! eof($fh) ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>threadsafe DynaLoader, re, Opcode, File::Glob, and B</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DynaLoader, re, Opcode, File::Glob, y B, compatibles con threads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (@a) {
            return 0 if pop(@a) ne pop(@b);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051518Z" changeid="explorer">
        <seg>while (@a) {
            return 0 if pop(@a) ne pop(@b);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mark Kettenis &lt;kettenis@gnu.org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mark Kettenis &lt;kettenis@gnu.org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;abcd&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># &quot;abcd&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>comp/decl..........FAILED at test 0
op/write...........FAILED at test 0
lib/filefind.......FAILED at test 2
lib/io_udp.........FAILED at test 2
lib/findbin........stat(/ressel/ABT/USER/vta/jk/proj.local/perl/perl5.005_03-MAINT_TRIAL_5/t/lib/): No such file or directory at ../lib/FindBin.pm line 162
stat(/ressel/ABT/USER/vta/jk/proj.local/perl/perl5.005_03-MAINT_TRIAL_5/t/lib/): No such file or directory at ../lib/FindBin.pm line 163
FAILED at test 1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040141Z" changeid="explorer">
        <seg>comp/decl..........FAILED at test 0
op/write...........FAILED at test 0
lib/filefind.......FAILED at test 2
lib/io_udp.........FAILED at test 2
lib/findbin........stat(/ressel/ABT/USER/vta/jk/proj.local/perl/perl5.005_03-MAINT_TRIAL_5/t/lib/): No such file or directory at ../lib/FindBin.pm line 162
stat(/ressel/ABT/USER/vta/jk/proj.local/perl/perl5.005_03-MAINT_TRIAL_5/t/lib/): No such file or directory at ../lib/FindBin.pm line 163
FAILED at test 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when C&lt;use integer&gt; is in scope, &quot;%&quot; gives you direct access
to the modulo operator as implemented by your C compiler.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que cuando C&lt;use integer&gt; está en su ámbito, &quot;%&quot; le da acceso directo al operador módulo, implementado por su compilador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @lines = &lt;$in&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T003557Z" changeid="zipf">
        <seg>my @lineas = &lt;$entrada&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;Encode&gt; and L&lt;perlunicode&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;Encode&gt; y L&lt;perlunicode&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here is a loop that inserts index producing entries
before any line containing a certain pattern:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, aquí hay un bucle que inserta índices de entradas antes de cualquier línea que contenga un cierto patrón:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think about reusability.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Piense en la reutilización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 5 of Perl changed the semantics of C&lt;$[&gt;: files that don't set
the value of C&lt;$[&gt; no longer need to worry about whether another
file changed its value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La versión 5 de Perl cambió la semántica de C&lt;$[&gt;: los archivos que no asignen un valor a C&lt;$[&gt; no necesitan preocuparse nunca más de si otro archivo ha cambiado su valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or two.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or programmatically via the C&lt;Config&gt; module:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o programáticamente vía el módulo C&lt;Config&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of elements in the array following
the completed C&lt;push&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de elementos en el ARRAY tras la llamada a C&lt;push&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (undef) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (undef) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the program's responsibility to
C&lt;close DATA&gt; when it is done reading from it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es responsabilidad del programa hacer C&lt;close DATA&gt; cuando se termine la lectura del mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt; &quot;EOF&quot;; # same as above</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt; &quot;EOF&quot;; # lo mismo que el anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fork</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item fork</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space around a &quot;complex&quot; subscript (inside brackets).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio alrededor de un subíndice &quot;complejo&quot; (entre corchetes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
C&lt;require&gt; makes sure the module is loaded into memory if it hasn't been
yet.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;require&gt; se asegura que el módulo esté cargado en memoria, si todavía no lo está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[[:...:]] [2]  Match a character according to the rules of the POSIX
                    character class &quot;...&quot; within the outer bracketed character
                    class.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223449Z" changeid="explorer">
        <seg>[[:...:]] [2]  Busca un carácter de acuerdo a las reglas de la clase
                    carácter POSIX &quot;...&quot; dentro de la clase carácter exterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lcfirst</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item lcfirst</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># line 345 &quot;goop&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># line 345 &quot;goop&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $log $logmessage;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T225647Z" changeid="zipf">
        <seg>print $registro $mensaje_registro;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behavior of this function varies wildly depending on your system
implementation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento de esta función varía enormemente dependiendo de la implementación de su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make h2ph understand constants like 1234L and 5678LL</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make h2ph entiende las constantes como 1234L y 5678LL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;POSIX::getattr&gt; function can do this more portably on
systems purporting POSIX compliance.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función C&lt;POSIX::getattr&gt; puede hacer esto de forma más portable en sistemas compatibles con POSIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Will cause C&lt;$sentence&gt; to become C&lt;'The big bad wolf jumped over...'&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012602Z" changeid="explorer">
        <seg>Hará que C&lt;$instruccion&gt; se convierta en C&lt;'El gran lobo malo saltó sobre ...'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @numbers = (23, 42, 69);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025651Z" changeid="explorer">
        <seg>my @numeros  = (23, 42, 69);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that the globbing is actually done internally using the standard
C&lt;File::Glob&gt; extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>salvo que la expansión realmente se hace internamente usando la extensión estándar C&lt;File::Glob&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;__FILE__&gt; X&lt;__LINE__&gt; X&lt;__PACKAGE__&gt; X&lt;line&gt; X&lt;file&gt; X&lt;package&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004146Z" changeid="explorer">
        <seg>X&lt;__FILE__&gt; X&lt;__LINE__&gt; X&lt;__PACKAGE__&gt; X&lt;line&gt; X&lt;línea&gt; X&lt;file&gt; X&lt;archivo&gt; X&lt;package&gt; X&lt;paquete&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL
X&lt;socketpair&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200826Z" changeid="explorer">
        <seg>=item socketpair SOCKET1,SOCKET2,DOMINIO,TIPO,PROTOCOLO
X&lt;socketpair&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, you can write:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, puede escribir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is available for most operating systems, including virtually
all Unix-like platforms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl está disponible para la mayoría de sistemas operativos, incluyendo a casi todas las plataformas Unix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/oct&gt;, if all you have is a string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/oct&gt;, si todo lo que tiene es una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MiXeD line-noise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>MeZcLaDoS línea-ruidosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if it's an integer I&lt;n&gt;, the offset is relative to the start of the
I&lt;n&gt;th innermost C&lt;()&gt; group, or to the start of the string if I&lt;n&gt; is
bigger then the group level.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y si es un número entero I&lt;n&gt;, el desplazamiento es relativo al inicio del I&lt;n&gt;-ésimo grupo C&lt;()&gt; más interno, o al inicio de la cadena si I&lt;n&gt; es más grande que el número de grupos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = '150' | '105';	# yields string '155' (under ASCII)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = '150' | '105';	# produce la cadena '155' (bajo ASCII)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lock() is a &quot;weak keyword&quot; : this means that if you've defined a function
by this name (before any calls to it), that function will be called
instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lock() es una &quot;palabra clave débil&quot;: significa que si usted ha definido una función con este nombre (antes de cualquier llamada a ella), esa función es la que se llamará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, it's getting a bit complicated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194003Z" changeid="explorer">
        <seg>Como puede ver, se está haciendo un poco complicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may combine several flags
using the C&lt;|&gt;-operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede combinar varias banderas con el operador C&lt;|&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 16  ==         16 00001000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 16  ==         16 00001000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would use C&lt;$a&gt; for the width and precision, and C&lt;$b&gt; as the
value to format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>usaría C&lt;$a&gt; para el ancho y precisión, y C&lt;$b&gt; como el valor a formatear.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can test the right operand and become false on the
same evaluation it became true (as in B&lt;awk&gt;), but it still returns
true once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador rango puede probar el operando de la derecha y convertirse en falso en la misma evaluación en que se hizo verdadero (como en B&lt;awk&gt;), pero aún así devuelve verdadero al menos una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $x (1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $x (1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the referenced object has been blessed into a package, then that package
name is returned instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el objeto referenciado ha sido bendecido en un paquete, entonces es el nombre de este paquete el que es devuelto en su lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a context not requiring a list value, the value of what appears
to be a list literal is simply the value of the final element, as
with the C comma operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En un contexto que no requiera una lista de valores, el valor de lo que parece ser una lista literal es, simplemente, el valor del último elemento, como ocurre con el operador coma en C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With EXPR, it returns some extra information that the debugger uses to
print a stack trace.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con EXPR, devuelve alguna información extra que el depurador usa para imprimir un rastreo de la pila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns a
list of lines (however you've defined lines with $/ or
$INPUT_RECORD_SEPARATOR), or an empty list if the command failed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, devuelve una lista de líneas (según haya definido líneas con $/ o $INPUT_RECORD_SEPARATOR), o una lista vacía si el comando ha fallado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/anydbm.t                 12    1   8.33%  12</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lib/anydbm.t                 12    1   8.33%  12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proper way
to get a 4-digit year is simply:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma apropiada para obtener un año con los 4 dígitos es simplemente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,27, 1) = 1   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,27, 1) = 1   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The PLAINTEXT and SALT is turned
into a short string, called a digest, which is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El TEXTOPLANO y el SALTO se convierten en un pequeño string, llamado I&lt;digest&gt; (compendio, resumen), que es devuelto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But wait, there's more...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero espere, aún hay más...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local $_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/exp&gt; for the inverse operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también L&lt;/exp&gt; para la operación inversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>INNER:   for my $jet (@ary2) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>INTERNO:   for my $jet (@ary2) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\N{U+I&lt;wide hex char&gt;}&gt; means the Unicode character whose Unicode ordinal
number is I&lt;wide hex char&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;\N{U+I&lt;car. hex. ancho&gt;}&gt; significa el carácter Unicode cuyo número ordinal Unicode es I&lt;car. hex. ancho&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates BLOCK or EXPR in
list context, so each element of LIST may produce zero, one, or
more elements in the returned value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa BLOQUE o EXPR en contexto lista, de manera que cada elemento de la LISTA puede producir cero, uno o más elementos en el valor devuelto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that Module I&lt;must&gt; be a bareword.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>excepto que el módulo I&lt;debe&gt; ser una palabra simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>logger(&quot;We have a logger subroutine!&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T233913Z" changeid="zipf">
        <seg>registrador(&quot;Tenemos una subrutina para registrar.&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function behaves the same way under various pragma, such as in a locale,
as L&lt;/lc&gt; does.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175338Z" changeid="explorer">
        <seg>Esta función se comporta de la misma manera bajo varios I&lt;pragma&gt;, como por ejemplo en una configuración regional, como lo hace L&lt;/lc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 ino      inode number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 ino      número de inodo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not a natural number&quot; unless /^\d+$/;             # rejects -3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es número natural&quot; unless /^\d+$/;             # rechaza -3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># my $tcp = IPPROTO_TCP; # Alternative</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># my $tcp = IPPROTO_TCP; # Alternativa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use User::pwent;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use User::pwent;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n}    Match exactly n times</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n}    Coincide exactamente n veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub log10 {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub log10 {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you have to
set the top of form format for more than one output channel, you might
do the following:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, si tiene que fijar la parte superior del formato de un formulario para más de un canal de salida, puede hacer lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to send the scalar MSG to the SOCKET
filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intenta enviar el escalar MSG al gestor de archivo SOCKET.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next LINE if /^#/;  # discard comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next LINEA if /^#/;  # descartar comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a workaround for this problem, Perl 5.10.0 introduces C&lt;${^PREMATCH}&gt;,
C&lt;${^MATCH}&gt; and C&lt;${^POSTMATCH}&gt;, which are equivalent to C&lt;$`&gt;, C&lt;$&amp;&gt;
and C&lt;$'&gt;, B&lt;except&gt; that they are only guaranteed to be defined after a
successful match that was executed with the C&lt;/p&gt; (preserve) modifier.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como solución a este problema, Perl Perl 5.10.0 introduce C&lt;${^PREMATCH}&gt;, C&lt;${^MATCH}&gt; y C&lt;${^POSTMATCH}&gt;, que son equivalentes a C&lt;$`&gt;, C&lt;$&amp;&gt; y C&lt;$'&gt;, B&lt;excepto&gt; que solo se tiene garantizado que estarán definidos después de una coincidencia exitosa, ejecutada con un modificador C&lt;/p&gt; (preserva).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of C&lt;goto-LABEL&gt; or C&lt;goto-EXPR&gt; to jump into a construct is
deprecated and will issue a warning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de C&lt;goto-LABEL&gt; o C&lt;goto-EXPR&gt; para saltar en una construcción es obsoleto y emitirá una advertencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, functions in Perl that serve as wrappers for system calls (&quot;syscalls&quot;)
of the same name (like chown(2), fork(2), closedir(2), etc.) all return
true when they succeed and C&lt;undef&gt; otherwise, as is usually mentioned
in the descriptions below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, funciones en Perl que sirven como envoltorios para llamadas al sistema (&quot;syscalls&quot;) del mismo nombre (como  chown(2), fork(2), closedir(2), etc.) todas ellas devuelven verdadero cuando tienen éxito y C&lt;undef&gt; en otro caso, como se menciona en las descripciones de más abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using ACLs, there is a pragma called C&lt;filetest&gt; that may
produce more accurate results than the bare stat() mode bits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está usando ACL, hay un pragma llamado C&lt;filetest&gt; que puede producir resultados más precisos que los simples bits de modo de stat().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the documentation of your operating system's C&lt;open&gt; to see which
values and flag bits are available.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consulte la documentación de C&lt;open&gt; de su sistema operativo para ver qué valores y bits de bandera están disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perllol		Perl data structures: arrays of arrays</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perllol		Estructuras de datos: arrays de arrays</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(To view the differences between the 5.6.0 release and the 5.7.0
release, see L&lt;perl570delta&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para ver las diferencias entre la versión 5.6.0 y la versión 5.7.0, véase L&lt;perl570delta&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using gcc, just</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002920Z" changeid="explorer">
        <seg>Si está empleando gcc, entonces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As more recent versions of autoconf require flock() support, I wrote a flock()
emulation (flock_server) and released it on BeBits:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como las versiones más recientes de autoconf requieren soporte de flock(), he escrito una emulación de flock() (flock_server) y la publiqué en BeBits:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 2) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 2) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dereference-address operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operador de Desreferencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Encode</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Encode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sends a message on a socket.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Envía un mensaje sobre un socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because patterns are processed as double quoted strings, the following
also work:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110214T010813Z" changeid="explorer">
        <seg>Dado que los patrones se procesan como cadenas doblemente entrecomilladas, lo que sigue también funciona:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\W                  a non-word character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230259Z" changeid="zipf">
        <seg>\W                  un carácter que no sea de palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %h = (&quot;something&quot;, 23);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my %h = (&quot;algo&quot;, 23);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A statement sequence may contain declarations of lexically-scoped
variables, but apart from declaring a variable name, the declaration acts
like an ordinary statement, and is elaborated within the sequence of
statements as if it were an ordinary statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012842Z" changeid="explorer">
        <seg>Una secuencia de instrucciones pueden contener declaraciones de variables en ámbito léxico (privado), pero, aparte de declarar un nombre de variable, la declaración actúa como una instrucción normal y es elaborada dentro de la secuencia de instrucciones como si fuera una instrucción normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$^ = 'report2_top';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$^ = 'informe2_top';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Older programs did this by setting C&lt;$*&gt;,
but this practice has been removed in perl 5.9.)
X&lt;^&gt; X&lt;$&gt; X&lt;/m&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Antiguos programas hacían esto estableciendo C&lt;$*&gt;, pero esta práctica ha sido eliminada en perl 5.9).
X&lt;^&gt; X&lt;$&gt; X&lt;/m&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I have built and tested Perl 5.8.6 and 5.9.1 under BeOS R5 x86 net server.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He construido y probado Perl 5.8.6 y 5.9.1 bajo BeOS R5 x86 net server.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5110delta	Perl changes in version 5.11.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5110delta	Cambios en la versión 5.11.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Yow!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110204T164416Z" changeid="zipf">
        <seg>print &quot;¡Caramba!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the syntax descriptions that follow, list operators that expect a
list (and provide list context for elements of the list) are shown
with LIST as an argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En las descripciones sintácticas que siguen a continuación, los operadores de listas que esperan una lista (y proveen de un contexto lista para los elementos de la lista) se muestran con un argumento así: LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[]	Bracketed Character class</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110214T002228Z" changeid="explorer">
        <seg>[]	Clase carácter encorchetada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%6s&gt;', &quot;a&quot;;      # prints &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%6s&gt;', &quot;a&quot;;      # imprime &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
&quot;lib/anydbm&quot; and &quot;pragma/warnings&quot; tests will almost certainly fail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las pruebas El &quot;lib/anydbm&quot; y &quot;pragma/warnings&quot; son casi seguro que fracasarán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The equivalent numeric version should be used instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se debe usar en su lugar la versión equivalente numérica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item strict</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item strict</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item seek FILEHANDLE,POSITION,WHENCE
X&lt;seek&gt; X&lt;fseek&gt; X&lt;filehandle, position&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200237Z" changeid="explorer">
        <seg>=item seek GESTOR_ARCHIVO,POSICIÓN,DESDE
X&lt;seek&gt; X&lt;fseek&gt; X&lt;filehandle, position&gt; X&lt;gestor de archivo, posición&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This start line assumes you have the B&lt;env&gt; program.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T001820Z" changeid="zipf">
        <seg>(En esta línea se supone que dispone del programa B&lt;env&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = (1)[1,0];          # @a has two elements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@a = (1)[1,0];          # @a tiene dos elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial Haiku port was done by Ingo Weinhold &lt;ingo_weinhold@gmx.de&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La primera adaptación de Haiku fue realizada por Ingo Weinhold &lt;ingo_weinhold@gmx.de&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;bless&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;package&gt;, C&lt;ref&gt;, C&lt;tie&gt;, C&lt;tied&gt;,
C&lt;untie&gt;, C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202058Z" changeid="explorer">
        <seg>C&lt;bless&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;package&gt;, C&lt;ref&gt;, C&lt;tie&gt;, C&lt;tied&gt;,
C&lt;untie&gt;, C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>arbitrarily nested data structures and anonymous functions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>estructuras de datos arbitrariamente anidadas y funciones anónimas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>char   c;    /* one signed, 8-bit character */</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>char   c;    /* uno con signo, carácter 8-bit */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings that would cause
integer overflow trigger a warning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Strings que podrían causar desbordamiento de enteros lanzará un aviso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hex strings may only represent integers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Strings hexadecimales sólo pueden representar enteros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Could not determine the protocol number for tcp&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo determinar el número de protocolo para tcp&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but that makes no difference compared with the -Duse64bitint because
of the C&lt;cc -64&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002712Z" changeid="explorer">
        <seg>pero no genera diferencias comparado con -Duse64bitint debido al C&lt;cc -64&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl ':mode';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl ':mode';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\h        [3]  Horizontal whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224945Z" changeid="explorer">
        <seg>\h        [3]  Espacio en blanco horizontal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An explicit format parameter index, such as C&lt;2$&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un explícito índice de parámetros de formato, tales como C&lt;2$&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%HASH = ();     # completely empty %HASH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%HASH = ();     # vaciar completamente %HASH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>q, L or ll  interpret integer as C type &quot;long long&quot;, &quot;unsigned long long&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>q, L o ll   interpreta un entero como un &quot;long long&quot;, &quot;unsigned long long&quot; del C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in the example above, a bare C&lt;l&gt; means
exactly 32 bits, although the native C&lt;long&gt; as seen by the local C compiler
may be larger.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como se muestra en el ejemplo anterior, una simple C&lt;l&gt; significa exactamente 32 bits, aunque el C&lt;long&gt; nativo, tal como lo ve el compilador de C local, puede ser mayor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the second way hides the main point of the statement in a
modifier.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>porque la segunda forma esconde el objetivo principal de la instrucción dentro de un modificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list C&lt;1,,3&gt; is a
concatenation of two lists, C&lt;1,&gt; and C&lt;3&gt;, the first of which ends
with that optional comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La lista C&lt;1,,3&gt; es una concatenación de dos listas, C&lt;1,&gt; y C&lt;3&gt;, la primera de las cuales termina con una coma opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rin = fhbits('STDIN TTY SOCK');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$rin = fhbits('STDIN TTY SOCK');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item no MODULE LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item no MÓDULO LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.linux - Perl version 5 on Linux systems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.linux - Perl versión 5 sobre sistemas Linux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rindex STR,SUBSTR,POSITION
X&lt;rindex&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194751Z" changeid="explorer">
        <seg>=item rindex CADENA,SUBCADENA,POSICIÓN
X&lt;rindex&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item caller EXPR
X&lt;caller&gt; X&lt;call stack&gt; X&lt;stack&gt; X&lt;stack trace&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165937Z" changeid="explorer">
        <seg>=item caller EXPR
X&lt;caller&gt; X&lt;call stack&gt; X&lt;stack&gt; X&lt;stack trace&gt; X&lt;llamador&gt; X&lt;pila de llamdas&gt; X&lt;pila&gt; X&lt;traza de pila&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all fields are supported on all filesystem types.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No todos los campos están soportados por todos los sistemas de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>uses C&lt;$a&gt; for the width, C&lt;$b&gt; for the precision, and C&lt;$c&gt;
as the value to format; while:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>usa C&lt;$a&gt; para el ancho, C&lt;$b&gt; para la precisión, y C&lt;$c&gt; como el valor a formatear; mientras:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Occasionally, you can't use just a C&lt;/g&gt; to get all the changes
to occur that you might want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De vez en cuando, no solo se puede utilizar un C&lt;/g&gt; para obtener todos los cambios posibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Perl value which may be used instead of the
corresponding C&lt;/STRING/msixpo&gt; expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve un valor de Perl que puede utilizarse en lugar de la correspondiente expresión C&lt;/CADENA/msixpo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wanted just to append to a row, you'd have
to do something a bit funnier looking:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sólo quiere añadir a una fila, tendrá que hacer algo un poco más divertido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the random number seed for the C&lt;rand&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Establece la semilla de números aleatorios para el operador C&lt;rand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,16, 1) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,16, 1) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and the C&lt;S_IF*&gt; functions are</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y las funciones C&lt;S_IF*&gt; son</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual location
where C&lt;\G&gt; will match can also be influenced by using C&lt;pos()&gt; as
an lvalue: see L&lt;perlfunc/pos&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203647Z" changeid="explorer">
        <seg>La ubicación actual donde C&lt;\G&gt; coincidirá también puede modificarse usando C&lt;pos()&gt; como un I&lt;ivalor&gt;: véase L&lt;perlfunc/pos&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, each call reads and
returns the next line until end-of-file is reached, whereupon the
subsequent call returns C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, cada llamada lee y devuelve la siguiente línea hasta que se alcance el final del archivo, en cuyo caso la ulterior llamada devuelve C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The point of the function is to &quot;seed&quot; the C&lt;rand&gt; function so that
C&lt;rand&gt; can produce a different sequence each time you run your
program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La misión de la función es &quot;alimentar&quot; a la función C&lt;rand&gt; para que C&lt;rand&gt; pueda producir una secuencia diferente cada vez que ejecute su programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the terminator of
C&lt;(?{...})&gt; is found using the same rules as for finding the
terminator of a C&lt;{}&gt;-delimited construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, el terminador de C&lt;(?{...})&gt; es encontrado usando las mismas reglas como para encontrar el terminador de una construcción delimitada por C&lt;{}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;pos&gt; is only updated on a C&lt;/g&gt; match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;pos&gt; sólo es actualizado en una coincidencia C&lt;/g&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/Time: (..):(..):(..)/) {   # parse out values</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/Tiempo: (..):(..):(..)/) {   # extrae valores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$baz = pack('s.l', 12, 4, 34);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$baz = pack('s.l', 12, 4, 34);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should build miniperl and then fail when it tries to run it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto debería construir miniperl y luego fallar cuando trate de ejecutarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $&amp;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $&amp;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$fh = newopen('/etc/passwd');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$fh = nuevoopen('/etc/passwd');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Finding the end</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Encontrando el final</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item reset EXPR
X&lt;reset&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194628Z" changeid="explorer">
        <seg>=item reset EXPR
X&lt;reset&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LIMIT parameter can be used to split a line partially</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El parámetro LÍMITE puede usarse para dividir una línea de forma parcial</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>WRITE this, scalar, length, offset</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>WRITE este, escalar, longitud, desplazamiento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 No-ops
X&lt;no-op&gt; X&lt;nop&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011026Z" changeid="explorer">
        <seg>=head2 No-operaciones
X&lt;no-op&gt; X&lt;nop&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on writing subroutines, see L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225537Z" changeid="explorer">
        <seg>Para obtener más información sobre cómo escribir subrutinas, consulte L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It operates on
C&lt;$_&gt; by default, or can be bound to another variable using the C&lt;=~&gt;
binding operator (also documented in L&lt;perlop&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225413Z" changeid="explorer">
        <seg>Opera en C&lt;$_&gt; de manera predeterminada, o se puede enlazar a otra variable con el operador de enlace C&lt;=~&gt; (que también se describe en L&lt;perlop&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print if /$arg/o;	# compile only once</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print if /$arg/o;	# compilar solo una vez</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the owner (and group) of a list of files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia el propietario (y grupo) de una lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for a seed can fall prey to the mathematical property that</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para una semilla puede caer presa en la propiedad matemática</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;LABEL&gt; is omitted, restarts the program from the top.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite C&lt;ETIQUETA&gt;, reinicia el programa desde el principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ARTICLE = 100;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ARTICULO = 100;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @newAoA, [ @{ $AoA[$x] } [ 7..12 ] ];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053017Z" changeid="explorer">
        <seg>push @newAoA, [ @{ $AoA[$x] } [ 7..12 ] ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the format specification
uses C&lt;*&gt; to require additional arguments, these are consumed from
the argument list in the order they appear in the format
specification I&lt;before&gt; the value to format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la especificación de formato utiliza C&lt;*&gt; para exigir argumentos adicionales, estos se consumen de la lista de argumentos en el orden en que aparecen en la especificación del formato I&lt;antes&gt; del valor a dar formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General examples:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplos generales:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 DATE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 FECHA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;array&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;array&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL foreach VAR (LIST) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA foreach VAR (LIST) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; gt &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; gt &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is written in the POD format (see pod/perlpod.pod) which is
specifically designed to be readable as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está escrito en formato POD (ver pod/perlpod.pod) que está específicamente diseñado para ser legible de forma sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include such functions as C&lt;time&gt;
and C&lt;endpwent&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas incluyen funciones como C&lt;time&gt; y C&lt;endpwent&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because
C&lt;*HANDLE{IO}&gt; only works if HANDLE has already been used as a handle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004240Z" changeid="explorer">
        <seg>Esto es porque C&lt;*HANDLE{IO}&gt; sólo funciona si HANDLE ya se ha utilizado como un gestor de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FH, &quot;&gt;&gt;&amp;=&quot;, OLDFH)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FH, &quot;&gt;&gt;&amp;=&quot;, OLDFH)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$fh = *STDOUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$fh = *STDOUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$search .= &quot;++\$seen{\$ARGV} if /\\b$word\\b/;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$buscar .= &quot;++\$visto{\$ARGV} if /\\b$palabra\\b/;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use wait in your handler for $SIG{CHLD} it may accidently wait for the
child created by qx() or system().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210941Z" changeid="explorer">
        <seg>Si utiliza wait en su controlador de $SIG{CHLD} puede, accidentalmente hacer esperar por el hijo creado por qx() o system().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Array Joining Delimiter
X&lt;array, interpolation&gt; X&lt;interpolation, array&gt; X&lt;$&quot;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035653Z" changeid="explorer">
        <seg>=head3 Delimitador uniendo Array
X&lt;array, interpolation&gt; X&lt;interpolation, array&gt; X&lt;$&quot;&gt; X&lt;array, interpolación&gt; X&lt;interpolación, array&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(.)\1/                         # find first doubled char
         and print &quot;'$1' is the first doubled character\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230153Z" changeid="explorer">
        <seg>/(.)\1/                         # busca el primer carácter repetido
         and print &quot;'$1' es el primer carácter repetido\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./Configure -de</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>./Configure -de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then give &quot;make&quot; to compile.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Luego ejecute &quot;make&quot; para compilar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, exits with C&lt;0&gt; status.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es omitida, sale con estado C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, there is a distinction between omitting LIST (C&lt;import&gt; called
with no arguments) and an explicit empty LIST C&lt;()&gt; (C&lt;import&gt; not
called).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una vez más, hay una distinción entre omitir LISTA (C&lt;import&gt; llamado sin argumentos) y una explícita LISTA vacía C&lt;()&gt; (C&lt;import&gt; no se llama).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PRINTF this, format, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>PRINTF este, formato, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no double interpolation in Perl, so the C&lt;$100&gt; is left as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay doble interpolación en Perl, por lo que el C&lt;$100&gt; se deja tal como está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With or without parentheses, an empty list is returned upon
failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con o sin paréntesis, se devuelve una lista vacía en caso de fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 64  ==      16384 00000000000000100000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 64  ==      16384 00000000000000100000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlvos		Perl notes for Stratus VOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlvos		Notas para Stratus VOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-t  Filehandle is opened to a tty.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-t  Gestor está abierto a una tty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some systems may have even weirder byte orders such as</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos sistemas pueden tener ordenaciones de byte aún más raras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form is typically used to
delay parsing and subsequent execution of the text of EXPR until run time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma es típicamente usada para retrasar el interpretado subsecuente ejecución del texto de EXPR hasta el momento de la ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property, known as &quot;magic open&quot;,
can often be used to good effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta propiedad, conocida como &quot;open() mágico&quot;, a menudo se puede utilizar con buenos resultados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $z = substr $s, 14, 7, &quot;jumped from&quot;;    # climbed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $z = substr $s, 14, 5, &quot;saltó desde&quot;;    # subió</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($user,$system,$cuser,$csystem) = times;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($usuario,$sistema,$husuario,$hsistema) = times;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $ALL = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $TODO = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the address
of the sender if SOCKET's protocol supports this; returns an empty
string otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la dirección del remitente si el protocolo del SOCKET lo soporta; de otra manera, devuelve una cadena vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result C&lt;Regexp&gt; indicates that the argument is a regular expression
resulting from C&lt;qr//&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resultado C&lt;Regexp&gt; indica que el argumento es una expresión regular como resultado de C&lt;qr//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print uc(scalar(&amp;foo,$bar)),$baz;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print uc(scalar(&amp;foo,$bar)),$baz;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example uses the operator form of
C&lt;readline&gt; and dies if the result is not defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el ejemplo siguiente se utiliza la forma del operador de C&lt;readline&gt; y muere si el resultado no está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FINIS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FINIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;last&gt; command immediately exits the loop in question.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;last&gt; sale inmediatamente del bucle en cuestión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$search .= &quot;}&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$buscar .= &quot;}&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that $foo
and @foo are two different variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Significa entonces que $foo y @foo son dos variables distintas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También tenga en cuenta que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't start sort: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo iniciar sort: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's psychology...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esa es la psicología...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, the shortest way to do the above is:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por supuesto, el camino más corto para hacer lo anterior es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--prefix=/boot/home/config</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>--prefix=/boot/home/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfaq8&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlfaq8&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Break out of a C&lt;given()&gt; block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sale de un bloque C&lt;given()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $mbox, &quot;&gt;&gt;&quot;, &quot;/usr/spool/mail/$ENV{'USER'}&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $mbox, &quot;&gt;&gt;&quot;, &quot;/usr/spool/mail/$ENV{'USER'}&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File types such
as terminals may lose the end-of-file condition if you do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tipos de archivos como por ejemplo terminales pueden perder la condición de fin-de-archivo si lo hace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>P  A pointer to a structure (fixed-length string).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>P  Un puntero a una estructura (una cadena de longitud fija).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bucle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you may tell the compiler that it's okay to use integer operations
(if it feels like it) from here to the end of the enclosing BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>puede indicar al compilador que es correcto utilizar operaciones con enteros (si se siente a gusto con ello) desde aquí hasta el final del BLOQUE actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A negative OFFSET specifies
placement at that many characters counting backwards from the end of
the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DESPLAZAMIENTO negativo especifica el desplazamiento en número de caracteres contando desde el final de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The null filehandle &lt;&gt; is special: it can be used to emulate the
behavior of B&lt;sed&gt; and B&lt;awk&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El gestor de archivo nulo &lt;&gt; es especial: puede ser utilizado para emular el comportamiento de B&lt;sed&gt; y B&lt;awk&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a script that saves, redirects, and restores C&lt;STDOUT&gt; and
C&lt;STDERR&gt; using various methods:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un script que salva, redirecciona, y restaura C&lt;STDOUT&gt; y C&lt;STDERR&gt; usando varios métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:-)
If I were you, I'd put that in a function:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200348Z" changeid="explorer">
        <seg>:-)
Si yo fuera usted, lo pondría en una función:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since C&lt;system&gt; does a C&lt;fork&gt; and C&lt;wait&gt; it may affect a C&lt;SIGCHLD&gt;
handler.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204458Z" changeid="explorer">
        <seg>Debido a que C&lt;system&gt; hace un C&lt;fork&gt; y un C&lt;wait&gt; puede afectar al controlador C&lt;SIGCHLD&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Following a C&lt;&lt; &lt;&lt; &gt;&gt; you specify a string to terminate
the quoted material, and all lines following the current line down to
the terminating string are the value of the item.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siguiendo a C&lt;&lt; &lt;&lt; &gt;&gt; especifica una cadena que termine el material entrecomillado, y todas las líneas siguientes a la actual hacia abajo hasta la cadena de terminación, son el valor del elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's often used to
remove the newline from the end of an input record when you're worried
that the final record may be missing its newline.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se utiliza a menudo para eliminar el carácter de nueva línea del final de un registro de entrada cuando es importante que el registro al final le pueda faltar ese carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, a side effect
of the current implementation means that the effects of C&lt;shift @_&gt; can
I&lt;normally&gt; be undone (but not C&lt;pop @_&gt; or other splicing, and not if a
reference to C&lt;@_&gt; has been taken, and subject to the caveat about reallocated
elements), so C&lt;@DB::args&gt; is actually a hybrid of the current state and
initial state of C&lt;@_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por último, un efecto secundario de la implementación actual es que los efectos de C&lt;shift @_&gt; pueden I&lt;normalmente&gt; ser deshechos (pero no C&lt;pop @_&gt; u otras operaciones de troceado, y tampoco si se ha tomado una referencia a C&lt;@_&gt;, y con la salvedad sobre los elementos reasignados), por lo que C&lt;@DB::args&gt; es realmente un híbrido de la situación actual y del estado inicial de C&lt;@_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When LAYER is present using binmode on a text file makes sense.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tiene sentido que CAPA esté presente usando binmode sobre un archivo de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bits = unpack(&quot;b*&quot;, $vector);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bits = unpack(&quot;b*&quot;, $vector);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, change &quot;^&quot; and &quot;$&quot; from matching
the start or end of the string to matching the start or end of any
line anywhere within the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, cambia &quot;^&quot; y &quot;$&quot; de coincidir con el inicio y el final de la cadena a coincidir con el inicio y el final de cualquier línea en cualquier lugar dentro de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># wipe out *all* compile-time warnings</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># limpiar *todas* las advertencias en tiempo de compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@bits = split(//, unpack(&quot;b*&quot;, $vector));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@bits = split(//, unpack(&quot;b*&quot;, $vector));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pipe READHANDLE,WRITEHANDLE
X&lt;pipe&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192555Z" changeid="explorer">
        <seg>=item pipe CONTROLADOR_LECTURA,CONTROLADOR_ESCRITURA
X&lt;pipe&gt; X&lt;tubería&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your platform supports NaNs (not-a-numbers) as numeric
values, using them with &quot;&lt;=&gt;&quot; returns undef.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su plataforma es compatible con NaN (I&lt;not-anumbers&gt;, no-es-un-número) como valores numéricos, usándolos con &quot;&lt;=&gt;&quot; devuelve undef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%p    a pointer (outputs the Perl value's address in hexadecimal)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%p    un puntero (sale la dirección del valor Perl en hexadecimal)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eval EXPR
X&lt;eval&gt; X&lt;try&gt; X&lt;catch&gt; X&lt;evaluate&gt; X&lt;parse&gt; X&lt;execute&gt;
X&lt;error, handling&gt; X&lt;exception, handling&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eval EXPR
X&lt;eval&gt; X&lt;try&gt; X&lt;catch&gt; X&lt;evaluate&gt; X&lt;parse&gt; X&lt;execute&gt; X&lt;error, handling&gt; X&lt;exception, handling&gt; X&lt;manejo de excepciones&gt; X&lt;interpretar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read all about it (and other special variables) in
L&lt;perlvar&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224942Z" changeid="explorer">
        <seg>Encontrará información sobre este hash (y sobre otras variables especiales) en L&lt;perlvar&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>^                   start of string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235515Z" changeid="zipf">
        <seg>^                   principio de una cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resets only package
variables; lexical variables are unaffected, but they clean themselves
up on scope exit anyway, so you'll probably want to use them instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Restablece sólo las variables del paquete; las variables léxicas no se ven afectadas, pero ellas mismas se limpiarán, de todos modos, a la salida de su ámbito, por lo que probablemente querrá usarlas en su lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>WinCE: integrate the port</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>WinCE: integrar su versión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One level of double-quote interpretation is done first, but you can't
say C&lt;&lt; &lt;$foo&gt; &gt;&gt; because that's an indirect filehandle as explained
in the previous paragraph.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se hace en primer lugar una interpretación por comilla doble, pero no puede escribir C&lt;&lt; &lt;$foo&gt; &gt;&gt; porque eso es un gestor de archivo indirecto, como se ha explicado en el párrafo anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL until (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA until (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$gid   = getgrnam($name);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$gid   = getgrnam($name);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Malloc in Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003937Z" changeid="explorer">
        <seg>=head2 Malloc en Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;sysopen&gt; depends on the fdopen() C library function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que C&lt;sysopen&gt; depende de la función de biblioteca C fdopen().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;false\n&quot; if (8 | 2) != 10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;falso\n&quot; if (8 | 2) != 10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlopentut	Perl open() tutorial</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlopentut	Seminario sobre open()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For integer conversions, specifying a precision implies that the
output of the number itself should be zero-padded to this width,
where the 0 flag is ignored:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las conversiones de entero, especificando una precisión implica que la salida del número en sí mismo debería ser rellenado con ceros a este ancho, donde se pasa por alto a la bandera 0:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't really want to execute the first argument, but want to lie
to the program you are executing about its own name, you can specify
the program you actually want to run as an &quot;indirect object&quot; (without a
comma) in front of the LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si realmente no quiere ejecutar el primer argumento, pero quiere engañar al programa que está ejecutando sobre su propio nombre, puede especificar el programa que quiera ejecutar como un &quot;objeto indirecto&quot; (sin la coma) enfrente de la LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note
that the use of these six specific operators to verify if some operation
is possible is usually a mistake, because it may be open to race
conditions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que el uso de seis operadores específicos para verificar si cierta operación es posible, es usualmente una equivocación, porque puede ser el inicio de bloqueos de carrera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\N{U+263D}	Unicode character     (example: FIRST QUARTER MOON)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\N{U+263D}	carácter Unicode      (ejemplo: FIRST QUARTER MOON)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Haiku specific problems contact the HaikuPorts developers:
http://ports.haiku-files.org/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para problemas específicos de Haiku, póngase en contacto con los desarrolladores HaikuPorts: http://ports.haiku-files.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A comment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item bless REF,CLASSNAME
X&lt;bless&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165811Z" changeid="explorer">
        <seg>=item bless REF,NOMBRECLASE
X&lt;bless&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If used in list context, returns all the rest of the entries in the
directory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se usa en contexto de lista, devuelve el resto de las entradas en el directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use diagnostics;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use diagnostics;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, '-|', &quot;cat -n '$file'&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, '-|', &quot;cat -n '$archivo'&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
buckets will be retained even if you do C&lt;%hash = ()&gt;, use C&lt;undef
%hash&gt; if you want to free the storage while C&lt;%hash&gt; is still in scope.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos alojamientos serán mantenidos incluso si hace C&lt;%hash = ()&gt;. Use C&lt;undef %hash&gt; si quiere liberar el almacenamiento mientras mantiene a C&lt;%hash&gt; en el ámbito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a problem that would ordinarily use B&lt;sed&gt; or B&lt;awk&gt; or
B&lt;sh&gt;, but it exceeds their capabilities or must run a little faster,
and you don't want to write the silly thing in C, then Perl may be for
you.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si tiene un problema en que normalmente utilizaría B&lt;sed&gt; o B&lt;awk&gt; o B&lt;sh&gt;, pero excede sus capacidades o debe funcionar un poco más rápido, y usted no desea escribir esa tontería en C, Perl puede ser para usted.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The table of smart matches is not identical to that proposed by the
Perl 6 specification, mainly due to the differences between Perl 6's
and Perl 5's data models.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La tabla de coincidencias inteligentes no es idéntica a la propuesta por la especificación Perl 6, principalmente debido a las diferencias entre los modelos de datos entre Perl 6 y Perl 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item no MODULE VERSION LIST
X&lt;no declarations&gt;
X&lt;unimporting&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item no MÓDULO VERSIÓN LISTA
X&lt;no declarations&gt; X&lt;unimporting&gt; X&lt;declaraciones no&gt; X&lt;desimportando&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to print the whole thing, though, you can't
say</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193242Z" changeid="explorer">
        <seg>Si desea imprimir toda el conjunto, sin embargo, no se puede decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded newlines
will not be matched by &quot;^&quot; or &quot;$&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los caracteres de nueva línea incrustados dentro de la cadena no coincidirán con &quot;^&quot; o &quot;$&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because you'll get just references listed, and perl will never
automatically dereference things for you.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193407Z" changeid="explorer">
        <seg>porque solo va a conseguir un listado de referencias, y perl nunca desreferencia de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%-10.6d&gt;', 1;   # prints &quot;&lt;000001    &gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%-10.6d&gt;', 1;   # imprime &quot;&lt;000001    &gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays are zero-indexed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T000921Z" changeid="zipf">
        <seg>El índice de un array empieza en cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is what
you want for text files, but it can be disastrous for binary files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es lo que quiere para archivos de texto, pero puede ser desastroso para archivos binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One or more modifiers below may optionally follow certain letters in the
TEMPLATE (the second column lists letters for which the modifier is valid):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Uno o más de los modificadores siguientes pueden, opcionalmente, seguir a ciertas letras en la PLANTILLA (la segunda columna enumeran las letras para las cuales el modificador es válido):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is what C has that Perl doesn't:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es lo que C tiene que Perl no:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;C0U4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;C0U4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's why
sometimes is easier to take a temporary on your way through:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194158Z" changeid="explorer">
        <seg>Es por eso que a veces es más fácil tomar un descanso en su marcha campo a través:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this is useful and supported,
it can cause bizarre results if the elements of LIST are not variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras que esto suele ser útil, puede causar resultados extraños si los elementos de la LISTA no son variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;This element is $_\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234902Z" changeid="zipf">
        <seg>print &quot;Este elemento es $_\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now the yada yada works:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora el blablablá funciona:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPSTRING must be a packed array of
semop structures.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>OPSTRING debe ser un array empaquetado de estructuras semop.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@AoA = (</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@AoA = (</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space after last parenthesis matching on current line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio después del último paréntesis coincidente en la línea actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 4) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 4) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a2p	awk to perl translator</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a2p	traductor awk a perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now
network socket support should remain enabled on BONE systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora, el soporte para red debe permanecer habilitado en los sistemas BONE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4-column indent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sangrado a 4 columnas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$days[28]		# the 29th element of array @days</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$dias[28]		# el elemento número 29 del array @dias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This was due to incorrect UTF8 offsets being
cached, and is now fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se debió a que se almacenaban desplazamientos UTF8 incorrectos, y ahora ya está arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Socket qw(:all);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Socket qw(:all);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tom Christiansen &lt;F&lt;tchrist@perl.com&gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200445Z" changeid="explorer">
        <seg>Tom Christiansen &lt;F&lt;tchrist@perl.com&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ( condition ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234837Z" changeid="zipf">
        <seg>while ( condición ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For B&lt;sed&gt; devotees, C&lt;y&gt; is provided as a synonym for C&lt;tr&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para los devotos de B&lt;sed&gt;, C&lt;y&gt; se ofrece como un sinónimo de C&lt;tr&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Custom matching via overloading</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Coincidencia personalizada vía sobrecarga del operador</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FUNCTION RETURN LISTS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FUNCTION RETURN LISTS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; MiXeD&quot;),		redo LOOP if /\G[A-Za-z]+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(&quot; MeZcLaDoS&quot;),	redo LOOP if /\G[A-Za-z]+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This calls the select(2) syscall with the bit masks specified, which
can be constructed using C&lt;fileno&gt; and C&lt;vec&gt;, along these lines:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto llama a la función del sistema select(2) con las máscaras de bits especificadas, que pueden ser construidas usando C&lt;fileno&gt; y C&lt;vec&gt;, como muestran estas líneas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Num       numeric equality         $a == $b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  Número     igualdad numérica                $a == $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\s+$//;           # trim trailing whitespace</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/\s+$//;           # quita los últimos espacios en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if the context of the currently executing subroutine or
C&lt;eval&gt; is looking for a list value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si el contexto de ejecución de la subrutina actual o C&lt;eval&gt; está buscando por una lista de valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But it's better just to put the C&lt;1;&gt;, in case you add more
statements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012100Z" changeid="explorer">
        <seg>Pero es mejor sólo para poner C&lt;1;&gt;, en caso de que añada más instrucciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before C&lt;require&gt; looks for a &quot;F&lt;.pm&gt;&quot; extension, it will
first look for a similar filename with a &quot;F&lt;.pmc&gt;&quot; extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Antes de C&lt;require&gt; busque una extensión &quot;F&lt;.pm&gt;&quot;, en primer lugar, buscará un nombre de archivo similar con una extensión &quot;F&lt;.pmc&gt;&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item map EXPR,LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item map EXPR,LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;my&gt; is actually not required; you could just use:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181535Z" changeid="zipf">
        <seg>En realidad no es obligatorio usar C&lt;my&gt;; se puede usar simplemente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our earlier example, C&lt;$days{'Feb'}&gt; can be written as
C&lt;$days{Feb}&gt; and the quotes will be assumed automatically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En un ejemplo anterior, C&lt;$dias{'Feb'}&gt; puede ser escrito como C&lt;$dias{Feb}&gt; y las comillas serán asumidas automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto&gt;-LABEL form finds the statement labeled with LABEL and resumes
execution there.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013546Z" changeid="explorer">
        <seg>La forma C&lt;goto&gt;-ETIQUETA busca la instrucción etiquetada con ETIQUETA y continua la ejecución desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print if defined $switch{'D'};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print if defined $switch{'D'};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setuid scripts have additional constraints that can produce error
messages such as &quot;Insecure dependency&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>scripts setuid tienen restricciones adicionales que pueden producir mensajes de error como &quot;dependencia insegura&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During compilation you will see this warning from toke.c:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004815Z" changeid="explorer">
        <seg>Durante la compilación, verá esta advertencia de toke.c:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl motto is &quot;There's more than one way to do it.&quot;  Divining
how many more is left as an exercise to the reader.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El lema de Perl es &quot;Hay más que una manera de hacerlo&quot;. Adivinar cuántas más se deja como ejercicio para el lector.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$yday&gt; is the day of the year, in the range C&lt;0..364&gt;
(or C&lt;0..365&gt; in leap years.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$ydia&gt; es el día del año, en el rango C&lt;0..364&gt; (o C&lt;0..365&gt; en los años bisiestos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ARG must consist of a vector of native
short integers, which may be created with C&lt;pack(&quot;s!&quot;,(0)x$nsem)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El ARG debe consistir en un vector de enteros cortos nativos, que pueden ser creados con C&lt;pack(&quot;s!&quot;,(0)x$nsem)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$hasargs&gt; is true if a new instance of C&lt;@_&gt; was set up for the frame.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$hasargs&gt; es verdadero si una nueva instancia de C&lt;@_&gt; fue creada para este marco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Building 64-bit Perl in Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002540Z" changeid="explorer">
        <seg>=head2 Compilando Perl de 64 bit en Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item q/STRING/
X&lt;q&gt; X&lt;quote, single&gt; X&lt;'&gt; X&lt;''&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010125Z" changeid="explorer">
        <seg>=item q/CADENA/
X&lt;q&gt; X&lt;quote, single&gt; X&lt;'&gt; X&lt;''&gt; X&lt;comilla, simple&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the notion of &quot;line&quot;
used here is whatever you may have defined with C&lt;$/&gt; or
C&lt;$INPUT_RECORD_SEPARATOR&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la noción de &quot;línea&quot; usada aquí es según tenga definido C&lt;$/&gt; o C&lt;$INPUT_RECORD_SEPARATOR&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UNSHIFT this, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>UNSHIFT este, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open returns nonzero on success, the undefined value otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open() devuelve un valor distinto de cero en caso de éxito, indefinido en otro caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sleep EXPR
X&lt;sleep&gt; X&lt;pause&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200756Z" changeid="explorer">
        <seg>=item sleep EXPR
X&lt;sleep&gt; X&lt;pause&gt; X&lt;pausa&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 42;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232604Z" changeid="explorer">
        <seg>print 42;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readline EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item readline EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.2g&gt;', 100.01; # prints &quot;&lt;1e+02&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.2g&gt;', 100.01; # imprime &quot;&lt;1e+02&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, C&lt;(?:...)&gt; can't have a space between the C&lt;?&gt; and C&lt;:&gt;,
but can between the C&lt;(&gt; and C&lt;?&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, C&lt;(?:...)&gt; no puede tener ningún espacio entre C&lt;?&gt; y C&lt;:&gt;, pero puede tenerlos entre C&lt;(&gt; y C&lt;?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ARGV = @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ARGV = @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>searches</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>búsquedas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to write LENGTH bytes of data from variable SCALAR to the
specified FILEHANDLE, using write(2).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211910Z" changeid="explorer">
        <seg>Intenta escribir LONGITUD bytes de datos desde la variable ESCALAR al GESTOR_ARCHIVO especificado, utilizando write(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if all deleted elements fall at the end of an
array, the array's size shrinks to the position of the highest element that
still tests true for exists(), or to 0 if none do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si todos los elementos eliminados están al final del array, el tamaño del array se reduce al de la posición del elemento más alto que aún devuelve verdadero para exists(), o 0 si no hay ninguno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression
C&lt;glob(&quot;.* *&quot;)&gt; matchs all files in the current working directory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La expresión C&lt;glob(&quot;.* *&quot;)&gt; coincide con todos los archivos en el directorio de trabajo actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or to block until something becomes ready just do this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o bloquear hasta que algo esté preparado, sólo hacemos esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basically, Intel and VAX CPUs are little-endian, while everybody else,
including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are
big-endian.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Básicamente, Intel y VAX son little-endian, mientras que todos los demás, incluyendo Motorola m68k/88k, PPC, Sparc, HP PA, Power y Cray, son big-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!   sSlLiI     Forces native (short, long, int) sizes instead
                   of fixed (16-/32-bit) sizes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050548Z" changeid="explorer">
        <seg>!   sSlLiI     Fuerza a tamaños nativos (short, long, int) en lugar
                   de tamaños fijos (16/32 bit)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...		# code for each line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>...		# código por cada línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%f&gt;', 1;    # prints &quot;&lt;1.000000&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%f&gt;', 1;    # imprime &quot;&lt;1.000000&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The usual idiom is:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El modismo habitual es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlform&gt; for many details and examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlform&gt; para más detalles y ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used without arguments in scalar context, reverse() reverses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se utiliza sin argumentos en contexto escalar, reverse() invierte C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-f  File is a plain file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004637Z" changeid="explorer">
        <seg>-f  Archivo es un archivo normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar&gt; for a description of Perl's built-in variables and
a discussion of legal variable names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar&gt; para una descripción de las variables internas de Perl y una discusión de nombres de variables legales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A WHENCE of C&lt;1&gt; (C&lt;SEEK_CUR&gt;) is useful for not moving the file position:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DONDE de C&lt;1&gt; (C&lt;SEEK_CUR&gt;) es útil para no mover la posición del archivo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hexdigit = (0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$hexdigito = (0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &quot;|&quot; and &quot;^&quot; have lower priority than relational operators, so
for example the brackets are essential in a test like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que &quot;|&quot; y &quot;^&quot; tienen menor prioridad que los operadores relacionales, así que, por ejemplo, los paréntesis son esenciales en una prueba como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read L&lt;perlboot&gt;, L&lt;perltoot&gt;, L&lt;perltooc&gt; and L&lt;perlobj&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225544Z" changeid="explorer">
        <seg>Lea L&lt;perlboot&gt;, L&lt;perltoot&gt;, L&lt;perltooc&gt; y L&lt;perlobj&gt; para obtener más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $result = $num * $num;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235526Z" changeid="zipf">
        <seg>my $resultado = $num * $num;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Following the normal C&lt;Configure&gt;, you have to run make as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siguiendo el tradicional C&lt;Configure&gt;, tiene que ejecutar make de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Simple substitution</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T232319Z" changeid="zipf">
        <seg>=item Sustitución simple</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item grep EXPR,LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item grep EXPR,LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, let's look at reading it in from a file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En primer lugar, echemos un vistazo a la lectura desde un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a string formatted by the usual C&lt;printf&gt; conventions of the C
library function C&lt;sprintf&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una cadena formateada por los habituales convenios de C&lt;printf&gt; de la función de biblioteca C&lt;sprintf&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>anything else           that number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>otra cosa          ese número</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the file named by FILENAME does not exist and the C&lt;open&gt; call creates
it (typically because MODE includes the C&lt;O_CREAT&gt; flag), then the value of
PERMS specifies the permissions of the newly created file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el archivo con el nombre ARCHIVO no existe y la llamada C&lt;open&gt; lo crea (por lo general porque el modo incluye la bandera C&lt;O_CREAT&gt;), entonces el valor de PERMISOS especifica los permisos del archivo recién creado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,21, 1) = 1   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,21, 1) = 1   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;,&quot; is the comma operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;,&quot; es el operador coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T001222Z" changeid="explorer">
        <seg>$!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '%*4$vX %*4$vX %*4$vX', @addr[1..3], &quot;:&quot;;   # 3 IPv6 addresses</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '%*4$vX %*4$vX %*4$vX', @addr[1..3], &quot;:&quot;;   # 3 direcciones IPv6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 4) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 4) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have to use C&lt;sysread&gt; instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tiene que usar en su lugar C&lt;sysread&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># this sorts the %age hash by value instead of key</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># esto ordena el hash %edad por valor en lugar de por clave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression providing the return value is evaluated
in void, scalar, or list context, depending on the context of the C&lt;eval&gt; 
itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La expresión que da el valor de retorno es evaluada en contexto vacío (void), escalar o lista, dependiendo del contexto en que se encuentre el C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default    { say '$foo does not contain a y' }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>default    { say '$foo no contiene una y' }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default the top-of-page format is the name of the filehandle with
&quot;_TOP&quot; appended, but it may be dynamically set to the format of your
choice by assigning the name to the C&lt;$^&gt; variable while the filehandle is
selected.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto, el formato de principio de página es el nombre del gestor de archivo con &quot;_TOP&quot; añadido al final, pero puede ser configurada de forma dinámica con el formato de su elección mediante la asignación del nombre a la variable C&lt;$^&gt; mientras que el gestor de archivo esté seleccionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;*&gt; for the repeat count uses all characters of the input field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;*&gt; como contador de repetición utiliza todos los caracteres del campo de entrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($uid, $dir)   = (getpwnam(&quot;daemon&quot;))[2,7]; # list slice</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($uid, $dir)    = (getpwnam(&quot;daemon&quot;))[2,7]; # porción lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, when accepting string input from
the user, quotemeta() or C&lt;\Q&gt; must be used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194321Z" changeid="explorer">
        <seg>Normalmente, deben ser usados quotemeta() o C&lt;\Q&gt; al aceptar cadenas de entrada provenientes del usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Although case 2 has misleading double quotes making
the reader wonder what else might be happening (nothing is).)  Cases 3
and 4 likewise behave in the same way: they run the code C&lt;'$x'&gt;, which
does nothing but return the value of $x.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Aunque el caso 2 tiene unas engañosas dobles comillas haciendo maravillar al lector de qué es lo que que puede pasar -que es nada-).  Los casos 3 y 4 se comportan de la misma manera: ejecutan el código C&lt;'$x'&gt;, que no hace nada excepto devolver el valor de $x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One may also use pod directives to quickly comment out a section
of code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Uno puede también usar directivas pod para comentar, de forma rápida, una sección de código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class implementing a filehandle should have the following methods:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una clase que implementa un gestor de archivo debe tener los siguientes métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If umask(2) is not implemented on your system and you are trying to
restrict access for I&lt;yourself&gt; (i.e., C&lt;&lt; (EXPR &amp; 0700) &gt; 0 &gt;&gt;), 
raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si umask(2) no está implementada en su sistema y está tratando de restringir el acceso por I&lt;sí mismo&gt; (es decir, C&lt;&lt; (EXPR &amp; 0700) &gt; 0 &gt;&gt;), se lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following
all do the same thing:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo lo siguiente hace lo mismo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To read more about them check their respective manual pages at L&lt;strict&gt;
and L&lt;warnings&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224716Z" changeid="explorer">
        <seg>Para obtener más información, consulte las páginas de manual correspondientes a L&lt;strict&gt; y L&lt;warnings&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When N is a negative
integer then it is a relative backreference referring to the previous N'th
capturing group.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando N es un entero negativo, entonces es una contrareferencia relativa a la N-ésima anterior grupo de captura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>seek(TEST,0,1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>seek(TEST,0,1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compilation errors will tell you the line number of the error, with an
indication of the next token or token type that was to be examined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los errores de compilación le indicarán el número de línea del error, con indicación del siguiente símbolo que iba a ser examinado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(  Start of a ()-group.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(  Inicia un grupo ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$checksum = do {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$checksum = do {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;p&gt; format packs a pointer to a null-terminated string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El formato C&lt;p&gt; empaqueta un puntero a una cadena terminada en nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Case 4 is preferred for
purely visual reasons, but it also has the advantage of compiling at
compile-time instead of at run-time.)  Case 5 is a place where
normally you I&lt;would&gt; like to use double quotes, except that in this
particular situation, you can just use symbolic references instead, as
in case 6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(El caso 4 es el preferido por razones puramente visuales, pero también tiene la ventaja de la compilación en tiempo de compilación en lugar de en tiempo de ejecución). Caso 5 es aquel donde normalmente I&lt;debería&gt; usar dobles comillas, excepto que en esta situación en particular, puede usar en su lugar referencias simbólicas instead, como en el caso 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local  *FH;  # not my!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local  *FH;  # ¡no my!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before starting the child process, but this may not be supported
on some platforms (see L&lt;perlport&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de la versión v5.6.0, Perl intentará vaciar todos los archivos abiertos para salida antes de iniciar un proceso hijo, pero esto puede no estar soportado en todas las plataformas (ver L&lt;perlport&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is omitted, it chomps C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE se omite, usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12542</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12542</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension modules can also hook into the Perl parser to define new
kinds of keyword-headed expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay módulos con expansiones que también pueden engancharse en el intérprete Perl para definir nuevas clases de expresiones basadas en palabras clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use L&lt;/exists&gt; for the latter
purpose.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use L&lt;/exists&gt; para este propósito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\s                  a whitespace character (space, tab, newline, ...)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T221938Z" changeid="zipf">
        <seg>\s                  un espacio en blanco (espacio, tabulación, nueva línea, ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>42;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>42;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one or more of:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>uno o más de:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operands
C&lt;$a&gt; and C&lt;$b&gt; are floating point values and the absolute value of
C&lt;$b&gt; (that is C&lt;abs($b)&gt;) is less than C&lt;(UV_MAX + 1)&gt;, only
the integer portion of C&lt;$a&gt; and C&lt;$b&gt; will be used in the operation
(Note: here C&lt;UV_MAX&gt; means the maximum of the unsigned integer type).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los operandos C&lt;$a&gt; y C&lt;$b&gt; son valores en punto flotante y el valor absoluto de C&lt;$b&gt; (es decir, C&lt;abs($b)&gt;) es menor que C&lt;(UV_MAX + 1)&gt;, solo la porción de entero de C&lt;$a&gt; y C&lt;$b&gt; será usada en la operación (Nota: aquí C&lt;UV_MAX&gt; significa el máximo valor del tipo entero sin signo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that whether C&lt;select&gt; gets restarted after signals (say, SIGALRM)
is implementation-dependent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que cuando C&lt;select&gt; es reiniciado después de señales (por ejemplo, SIGALRM) es algo dependiente de la implementación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str = '\t';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$str = '\t';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\033	octal char            (example: ESC)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\033		car. octal            (ejemplo: ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{ ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{ ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a block by itself is semantically identical to a loop
that executes once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que un bloque por sí mismo es semánticamente idéntico a un bucle que se ejecuta una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See select(2) and fcntl(2) for further
details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver select(2) y fcntl(2) para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub foo {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub foo {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Hash      hash entry existence     exists $b-&gt;{$a}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  Hash       existencia de un valor hash      exists $b-&gt;{$a}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A position
of zero is returned as the string C&lt;&quot;0 but true&quot;&gt;; thus C&lt;sysseek&gt; returns
true on success and false on failure, yet you can still easily determine
the new position.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una posición de cero es devuelto como cadena C&lt;&quot;0 but true&quot;&gt; (I&lt;&quot;0 pero verdadero&quot;&gt;), por lo que C&lt;sysseek&gt; devuelve verdadero o falso en caso de fallo, sin embargo, usted puede determinar fácilmente la nueva posición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$/x</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$/x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 8   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 8   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some programmers choose to use an explicit conversion so as to 
leave nothing to doubt:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos programadores eligen usar una conversión explícita para que no haya ninguna duda:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item write</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item write</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%x    an unsigned integer, in hexadecimal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%x    un entero sin signo, en hexadecimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perldebtut&gt;, L&lt;perldebug&gt; and L&lt;perldebguts&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;perldebtut&gt;, L&lt;perldebug&gt; y L&lt;perldebguts&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When searching for single-character delimiters, escaped delimiters
and C&lt;\\&gt; are skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Durante la búsqueda de caracteres delimitadores individuales, los delimitadores escapados y los C&lt;\\&gt; son omitidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace mostly serves to separate tokens, unlike
languages like Python where it is an important part of the syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco sirve para separar los elementos, a diferencia de lenguajes como Python donde es una parte importante de la sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless (open($input, $filename)) {
            print STDERR &quot;Can't open $filename: $!\n&quot;;
            return;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050313Z" changeid="explorer">
        <seg>unless (open($input, $filename)) {
            print STDERR &quot;No puedo abrir $archivo: $!\n&quot;;
            return;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052307Z" changeid="explorer">
        <seg>return (wantarray ? (undef, $errmsg) : undef) if $lo_hizo_estallar;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;x&quot; is the repetition operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;x&quot; es el operador de repetición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the bracket form is used and N is not an integer, it
is treated as a reference to a named buffer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa la forma con corchetes y N no es un número entero, es tratado como una referencia a una memoria intermedia nominada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to single quoted
strings except that backslashes have no special meaning, with C&lt;\\&gt;
being treated as two backslashes and not one as they would in every
other quoting construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es similar a las cadenas con comillas simples, excepto que las barras invertidas no tienen ningún significado especial, siendo entonces que C&lt;\\&gt; es tratado como dos barras invertidas y no una como lo harían en cualquier otra construcción entrecomillada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>green chile</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chile verde</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of loading of
modules does not risk altering your namespace.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma de cargar módulos no tiene el riesgo de alterar el espacio de nombres propio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variable substitution inside strings is limited to
scalar variables, arrays, and array or hash slices.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sustitución de variables dentro de cadenas se limita a variables escalares, arrays y porciones de array y hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that programs that do not also use C&lt;flock&gt;
may modify files locked with C&lt;flock&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que los programas que no usen C&lt;flock&gt; pueden modificar archivos bloqueados con C&lt;flock&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>11 blksz  POSIX::      3..9 only      @_    subroutine args</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>11 blksz  POSIX::      3..9 solo      @_    args. subrutina</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;&lt; &gt;&gt;                   while  ( ) { }, until ( ) { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;&lt; &gt;&gt;                   while  ( ) { }, until ( ) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taints the variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Contamina la variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the numeric (the native 8-bit encoding, like ASCII or EBCDIC,
or Unicode) value of the first character of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor numérico (en la codificación nativa de 8 bits, como ASCII o EBCDIC, o Unicode) del primer carácter de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, C&lt;$year&gt; is C&lt;123&gt; in year 2023.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, $anno es C&lt;123&gt; para el año 2023.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5120delta	Perl changes in version 5.12.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5120delta	Cambios en la versión 5.12.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dump</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item dump</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto&gt;-&amp;NAME form is highly magical, and substitutes a call to the
named subroutine for the currently running subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-&amp;NOMBRE es muy mágica, y sustituye a una llamada a una subrutina con nombre desde la actual subrutina que se está ejecutando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@values = values %ENV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@values = values %ENV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 4) = 2   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 4) = 2   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More details can be found in L&lt;PerlIO::encoding&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Más detalles se pueden encontrar en L&lt;PerlIO::encoding&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>later version, or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>versión posterior, o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the input string is longer than needed, extra characters are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena de entrada es más larga de lo necesario, los caracteres sobrantes se ignoran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {$FooPack::b &lt;=&gt; $FooPack::a} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {$FooPack::b &lt;=&gt; $FooPack::a} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$port,$proto) = getserv*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($name,$aliases,$port,$proto) = getserv*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open my $oldout, &quot;&gt;&amp;STDOUT&quot;     or die &quot;Can't dup STDOUT: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open my $oldout, &quot;&gt;&amp;STDOUT&quot;     or die &quot;No puedo duplicar STDOUT: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>200) { print; }	# print $_ 100 times</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>200) { print; }	# imprime $_ 100 veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$line = &lt;&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$linea = &lt;&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlvar		Perl predefined variables</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlvar		Variables predefinidas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item If C&lt;use bytes&gt; is in effect:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174258Z" changeid="explorer">
        <seg>=item Si C&lt;use bytes&gt; está activo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%*s&gt;', 6, &quot;a&quot;;   # prints &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%*s&gt;', 6, &quot;a&quot;;   # imprime &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$elem *= 2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$elemento *= 2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise documented, it returns C&lt;1&gt; for true and C&lt;''&gt; for false, or
the undefined value if the file doesn't exist.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004413Z" changeid="explorer">
        <seg>Mientras no se diga lo contrario, se devuelve C&lt;1&gt; para verdadero y C&lt;''&gt; para falso, o el valor indefinido si el archivo no existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$kid = waitpid(-1, WNOHANG);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$hijo = waitpid(-1, WNOHANG);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These days, it's considered cleaner to call the
internal function directly as C&lt;glob($foo)&gt;, which is probably the right
way to have done it in the first place.)  For example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estos días, se considera más limpio llamar a la función interna directamente como C&lt;glob($foo)&gt;, que es probablemente la forma correcta de haberlo hecho desde el principio) Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is seldom what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es muy raro que quiera hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also discussion of list operators in L&lt;Terms and List Operators (Leftward)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T190611Z" changeid="explorer">
        <seg>Véase también la discusión de los Operadores de lista en L&lt;Términos y Operadores de listas (por la izquierda)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over 10</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=over 10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;$x&quot;;      # CASE 2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;$x&quot;;      # CASO 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want it to match the
minimum number of times possible, follow the quantifier with a &quot;?&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea que coincida con el mínimo número de veces posible, siga el cuantificador con un &quot;?&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying VERSION as a literal of the form v5.6.1 should generally be
avoided, because it leads to misleading error messages under earlier
versions of Perl (that is, prior to 5.6.0) that do not support this
syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Especificando VERSIÓN como un literal de la forma v5.6.1, debe, generalmente, evitarse, porque lleva a crear mensajes de error equívocos en las versiones anteriores de Perl (esto es, anteriores a 5.6.0) que no admiten esta sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Searches a string for a pattern, and if found, replaces that pattern
with the replacement text and returns the number of substitutions
made.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Busca un patrón en una cadena, y si se encuentra, sustituye este patrón con el texto de reemplazo y devuelve el número de sustituciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;print&gt; is more efficient and less
error prone.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;print&gt; es más eficiente y menos propenso a errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash subscripts are similar, only instead of square brackets curly brackets
are used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234515Z" changeid="explorer">
        <seg>Los índices en los Hash son similares, pero en lugar de usar corchetes se usan llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-b  File is a block special file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004735Z" changeid="explorer">
        <seg>-b  Archivo es un archivo especial por bloques.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example to test whether Nagle's algorithm is turned on on a socket:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un ejemplo para comprobar si el algoritmo de Nagle está activado en un socket:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options are as described in C&lt;qr//&gt;; in addition, the following match
process modifiers are available:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las opciones son como se describe en C&lt;qr//&gt;; y, además, los siguientes modificadores de coincidencia están disponibles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options are as with m// with the addition of the following replacement
specific options:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las opciones son como las de m// con la adición de las opciones de reemplazo específicas siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
string cannot be cleanly converted to a numeric, Perl will give the warning
B&lt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena no se puede convertir de una forma limpia a numérico, Perl mostrará la advertencia B&lt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with Perl 5.9.2, integer and floating-point formats, along with
the C&lt;p&gt; and C&lt;P&gt; formats and C&lt;()&gt; groups, may all be followed by the 
C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt; endianness modifiers to respectively enforce big-
or little-endian byte-order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de Perl 5.9.2, los formatos enteros y de punto flotante, junto con los formatos C&lt;p&gt; y C&lt;P&gt; y los grupos C&lt;()&gt;, podrán ser seguidos por los modificadores de ordenación de bytes C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt;, para forzar, respectivamente, el orden de bytes big-endian o little-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;$@&gt; 
is a global variable and C&lt;eval&gt; may be used within object implementations,
be careful that analyzing the error object doesn't replace the reference in
the global variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que C&lt;$@&gt; es una variable global y C&lt;eval&gt; puede ser usado dentro de las implementaciones de objetos, tenga el cuidado que al analizar el objeto error no sustituya la referencia en la variable global.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's equivalent to || except for the very low precedence.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es el equivalente de &quot;||&quot; excepto por tener una precedencia muy baja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\A  Match only at beginning of string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225721Z" changeid="explorer">
        <seg>\A  Coincide solo con el comienzo de la cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $count = 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $cuenta = 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several I/O operators you should know about.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay varios operadores de E/S que debe conocer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcheat - Perl 5 Cheat Sheet</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlcheat - Chuleta de Perl 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the last element of LIST does
not end in a newline, it appends the same file/line number text as C&lt;die&gt;
does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el último elemento de LISTA no termina en un salto de línea, se añade el archivo/número de línea de texto igual como lo hace C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You
can say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nicholas Clark &lt;nick@ccl4.org&gt;, collating wisdom supplied by Slaven Rezic
and Tim Bunce.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nicholas Clark &lt;nick@ccl4.org&gt;, recopilando la sabiduría proporcionada por Slaven Rezic y Tim Bunce.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#o&gt;',  12;   # prints &quot;&lt;014&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#o&gt;',  12;   # imprime &quot;&lt;014&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\E&gt;) are useful when interpolating strings into
regular expressions, because by default an interpolated variable will be
considered a mini-regular expression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192941Z" changeid="explorer">
        <seg>C&lt;\E&gt;) son útiles cuando se interpolan cadenas en expresiones regulares, porque por defecto una variable interpolada será considerada una mini expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;die&gt; raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170653Z" changeid="explorer">
        <seg>C&lt;die&gt; lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only question is whether
it saves you more time than it took to build the linked list in the
first place.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La única pregunta es si ahorra más tiempo que en lo que se tardó en construir la lista enlazada, al principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>status for next file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para el siguiente archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># expand variables in $_, but dynamics only, using</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># expandir variables en $_, pero solo dinámicamente, usando</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are package globals.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Son variables globales del paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shmctl ID,CMD,ARG
X&lt;shmctl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200602Z" changeid="explorer">
        <seg>=item shmctl ID,CMD,ARG
X&lt;shmctl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Scalars begin with a $variables-&gt;{'scalar'}-&gt;{'sigil'}\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T212630Z" changeid="zipf">
        <seg>print &quot;Los escalares empiezan por $variables-&gt;{'scalar'}-&gt;{'sigil'}\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, C&lt;use integer; ~0&gt; is C&lt;-1&gt; on two's-complement
machines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, C&lt;use integer; ~0&gt; es C&lt;-1&gt; en las máquinas con complemento a dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For date and time processing look at the many related modules on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para el procesado de fechas y tiempos mire en los módulos relaccionados en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item state TYPE EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item state TIPO EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar in $a</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T030455Z" changeid="explorer">
        <seg>$a =~ s/foo/bar/g;        # reemplaza todas las coincidencias de foo por bar en $a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The patterns used in Perl pattern matching evolved from those supplied in
the Version 8 regex routines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los patrones usados en el sistema de coincidencias de Perl evolucionaron desde los suministrados por las rutinas I&lt;regex&gt; versión 8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for my $elem (@elements) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for my $elemento (@elementos) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>*?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise any object destructors that need to
be called are called before the real exit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Igualmente cualquier destructor de objetos que necesite ser llamado es llamado antes de la salida real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por desgracia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a digest string exactly like the crypt(3) function in the C
library (assuming that you actually have a version there that has not
been extirpated as a potential munition).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea una cadena resumen exactamente igual que la función crypt(3) de la biblioteca C (asumiendo que realmente tenga una versión de la que no haya sido extirpada por ser considerada un arma potencial).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$is_directory  =  S_ISDIR($mode);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$es_directorio =  S_ISDIR($modo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can refer to
identifiers in other packages than the current one by prefixing the identifier
with the package name and a double colon, as in C&lt;$SomePack::var&gt;
or C&lt;ThatPack::INPUT_HANDLE&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacer referencia a los identificadores de otros paquetes distintos del actual anteponiendo el identificador con el nombre del paquete y un dos puntos doble, como en C&lt;$AlgunPaquete::var&gt; o C&lt;EstePaquete::CONTROLADOR_ENTRADA&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example that makes sure that whoever runs this program knows
their password:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo que se asegura que quien corra el programa conoce su contraseña:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some systems the $quota
field may be $change or $age, fields that have to do with password
aging.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas el campo $cuota puede ser $cambio o $edad, campos que tienen que ver con la caducidad de la contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although Perl 
automatically converts strings into numbers as needed, this automatic
conversion assumes base 10.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque Perl convierte automáticamente las cadenas en números según sea necesario, esta conversión automática asume que es en base 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is exactly equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Eso es exactamente equivalente a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 4   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 4   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a precompiled pattern is embedded in a larger pattern then the effect
of 'msixp' will be propagated appropriately.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si un patrón precompilado se incrusta en un patrón más grande entonces los efectos de 'msixp' serán propagados apropiadamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S  An unsigned short value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S  Un valor de un corto sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close ARGV  if eof();		# reset $.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close ARGV  if eof();		# resetea $.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backslashed characters are either replaced with corresponding
literal strings (as with C&lt;\{&gt;), or else they generate special nodes
in the finite automaton (as with C&lt;\b&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los caracteres escapados con contrabarra son sustituidos por sus correspondientes cadenas de texto literales (como en C&lt;\{&gt;), o sino generan nodos especiales en el autómata finito (como en C&lt;\b&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current plan is for code freezes
as follows</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El plan actual es que el código quede congelado de la siguiente manera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($_ = $ARGV[0], /^-/) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($_ = $ARGV[0], /^-/) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thank you, Perl Monks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Gracias, Perl Monks.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>+?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't be afraid to use loop labels--they're there to enhance
readability as well as to allow multilevel loop breaks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se asuste de usar etiquetas de bucles -están para aumentar la legibilidad así como permitir rupturas de bucles multiniveles-.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the particular test case a C&lt;system(&quot;perl -e 0&quot;)&gt; flushes the
stdout pipe of another child process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el caso particular del test C&lt;system(&quot;perl -e 0&quot;)&gt; vacía la tubería de salida estándar de otro proceso hijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases perfection has been
sacrificed in the goal of getting the general idea across.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224543Z" changeid="explorer">
        <seg>En algunos casos se ha sacrificado la precisión para transmitir la idea general.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPTVAL might either be a packed string or an integer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>OPCIÓN_VALOR podría ser una cadena empaquetada o un entero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or warn $!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or warn $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider making your
code run cleanly with C&lt;use strict&gt; and C&lt;use warnings&gt; (or B&lt;-w&gt;) in
effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere hacer su código limpio utilizando C&lt;use strict&gt; y C&lt;use warnings&gt; (o B&lt;-w&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
is now fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto ha sido arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NaN != NaN
returns true, as does NaN != anything else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NaN != NaN devuelve verdadero, como con NaN != con cualquier otra cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 2) = 2   ==          8 00010000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 2) = 2   ==          8 00010000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some other more substantive style issues to think about:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay otras cuestiones de estilo que sí que hay que recordar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Access and Printing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193135Z" changeid="explorer">
        <seg>=head2 Acceso e impresión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $f implicitly closed here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># $f cerrado aquí implícitamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that some system calls can legitimately return C&lt;-1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que algunas llamadas al sistema legítimamente pueden devolver C&lt;-1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (fileno(THIS) == fileno(THAT)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (fileno(THIS) == fileno(THAT)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If using crypt() on a Unicode string (which I&lt;potentially&gt; has
characters with codepoints above 255), Perl tries to make sense
of the situation by trying to downgrade (a copy of the string)
the string back to an eight-bit byte string before calling crypt()
(on that copy).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usa crypt() en una cadena Unicode (que I&lt;potencialmente&gt; tiene caracteres con codificación superior al 255), Perl intenta hacer sentido a la situación intentando hacer una degradación (una copia de la cadena) a una cadena de bytes antes de llamar a crypt() (sobre esa copia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Special Literals
X&lt;special literal&gt; X&lt;__END__&gt; X&lt;__DATA__&gt; X&lt;END&gt; X&lt;DATA&gt;
X&lt;end&gt; X&lt;data&gt; X&lt;^D&gt; X&lt;^Z&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035526Z" changeid="explorer">
        <seg>=head3 Literales especiales
X&lt;special literal&gt; X&lt;__END__&gt; X&lt;__DATA__&gt; X&lt;END&gt; X&lt;DATA&gt;
X&lt;end&gt; X&lt;data&gt; X&lt;^D&gt; X&lt;^Z&gt; X&lt;literal especial&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The text copied gets delimiter-independent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El texto copiado es independiente de los delimitadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 2) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 2) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the construct is a here-doc, the ending delimiter is a line
that has a terminating string as the content.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la construcción es un documento incrustado, el delimitador final es una línea que tiene como contenido una cadena de terminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;DB_File&gt; for other flock() examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;DB_File&gt; para otros ejemplos de flock().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The regression test ext/threads/shared/t/wait.t fails on early RedHat 9
and HP-UX 10.20 due to bugs in their threading implementations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El test de regresión ext/threads/shared/t/wait.t falla en los primeros RedHat 9 y HP-UX 10.20 debido a errores en las implementaciones de los hilos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item threads::shared</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item threads::shared</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NEXTKEY this, lastkey</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NEXTKEY este, últimaclave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	terms and list operators (leftward)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T190256Z" changeid="explorer">
        <seg>izquierda	términos y operadores de listas (por la izquierda)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl regexps also support backreferences, lookaheads, and all kinds of
other complex details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225510Z" changeid="explorer">
        <seg>Las expresiones regulares de Perl también ofrecen referencias a capturas previas, inspección hacia adelante, y muchas otras funcionalidades complejas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sysread FILEHANDLE,SCALAR,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204239Z" changeid="explorer">
        <seg>=item sysread GESTOR_ARCHIVO,ESCALAR,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's
how it works: the first time &lt;&gt; is evaluated, the @ARGV array is
checked, and if it is empty, C&lt;$ARGV[0]&gt; is set to &quot;-&quot;, which when opened
gives you standard input.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He aquí cómo funciona: la primera vez que &lt;&gt; es evaluado, el array @ARGV es comprobado, y si está vacío, C&lt;$ARGV[0]&gt; es configurado a &quot;-&quot;, que cuando sea abierto le ofrecerá a usted la entrada estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>go_outside() and play() unless $is_raining;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vete_fuera() and juega() unless $este_lloviendo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$key = getc(STDIN);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$tecla = getc(STDIN);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shadow password
files are supported only if your vendor has implemented them in the
intuitive fashion that calling the regular C library routines gets the
shadow versions if you're running under privilege or if there exists
the shadow(3) functions as found in System V (this includes Solaris
and Linux.)  Those systems that implement a proprietary shadow password
facility are unlikely to be supported.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Archivos de contraseñas shadow sólo están soportados si el proveedor los ha implementado con la intuitiva moda de que llamando a las rutinas regulares de la biblioteca C se obtiene las versiones shadow si está corriendo con bajos privilegios o si existe la función shadow(3) tal como se encuentra en System V (esto incluye Solaris y Linux). Los sistemas que implementen un sistema de contraseñas shadow propietario es impropable que sean soportados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>char   cc[2];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>char   cc[2];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call your subroutines as if they were
functions or list operators to avoid excessive ampersands and parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llame a sus subrutinas como si fueran funciones u operadores de lista para evitar el excesivo número de ligaduras (&amp;&amp;) y paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Cephes::Fraction	fractions via the Cephes library</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::Cephes::Fraction   fracciones vía la biblioteca Cephes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8.2
contains an improved implementation which is both source and binary
compatible with both 5.8.0 and 5.8.1, and remains robust against the form of
attack which prompted the change for 5.8.1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5.8.2 contiene una implementación mejorada que es a la vez compatible a nivel de código fuente y binario con 5.8.0 y 5.8.1, y se mantiene robusto contra la forma de ataque que provocó el cambio de 5.8.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any backslashed sequences including C&lt;\\&gt; are treated at the stage
to L&lt;/&quot;parsing regular expressions&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier secuencia de barras invertidas, incluyendo C&lt;\\&gt; son tratadas en la fase L&lt;/&quot;analizando expresiones regulares&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;1: '&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;1: '&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names that start with a
letter or underscore may also contain digits and underscores.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres que empiezan por una letra o el símbolo de subrayado pueden incluir también dígitos y subrayados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print;          # prints contents of $_ by default</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T213456Z" changeid="explorer">
        <seg>print;    # imprime el contenido de $_ de manera predeterminada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item hex</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item hex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U  A Unicode character number.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>U  Un número de un carácter Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pops and returns the last value of the array, shortening the array by
one element.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Extrae y devuelve el último valor del array, acortando el array en un elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have
to make &quot;/hurd/pfinet&quot; the translator for &quot;/servers/socket/2&quot;, giving
it the right arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tiene que hacer &quot;/hurd/pfinet&quot; el traductor para &quot;/servers/socket/2&quot;, dándole los argumentos correctos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the only problem was that the program exited non-zero, C&lt;$!&gt;
will be set to C&lt;0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el único problema fue que el programa salió distinto de cero, C&lt;$!&gt; se establecerá a C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the word C&lt;while&gt; is replaced by the word C&lt;until&gt;, the sense of the
test is reversed, but the conditional is still tested before the first
iteration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la palabra C&lt;while&gt; se reemplaza por la palabra C&lt;until&gt;, el sentido del test se invierte, pero la condición es comprobada siempre antes de la primera iteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/x&gt; modifier enables
whitespace formatting, a simple C&lt;#&gt; will suffice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el modificador C&lt;/x&gt; permite formateo con espacio en blanco, un simple C&lt;#&gt; será suficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDOUT &quot;stdout 1\n&quot;;  # this works for</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print STDOUT &quot;stdout 1\n&quot;;  # esto funciona</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ans = &lt;STDIN&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ans = &lt;STDIN&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;use&gt; takes effect at compile time, it doesn't respect the
ordinary flow control of the code being compiled.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que C&lt;use&gt; entra en vigor en tiempo de compilación, no respeta el control de flujo de operaciones del código compilado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr{}{}	  Transliteration	  no (but see below)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr{}{}    Transliteración	  no (pero vea abajo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=cut back to the compiler, nuff of this pod stuff!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=cut devuelta al compilador, ¡lejos de este material pod!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, some special instructions for building Perl with Sun Studio on Linux.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, algunas instrucciones especiales para la construcción de Perl con Sun Studio en Linux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ARGV[1] =~ tr/A-Z/a-z/;	# canonicalize to lower case</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ARGV[1] =~ tr/A-Z/a-z/;	# transforma a minúsculas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line numbers (C&lt;$.&gt;)
continue as though the input were one big happy file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los números de línea (C&lt;$.&gt;) continuarán como si la entrada fuese un único archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$i = 0;  $j = 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$i = 0;  $j = 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C, Perl does a certain amount of expression evaluation at
compile time whenever it determines that all arguments to an
operator are static and have no side effects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que C, Perl hace una cierta cantidad de evaluación de expresiones en tiempo de compilación cuando determina que todos los argumentos a un operador son estáticos y no tienen efectos secundarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kirrily &quot;Skud&quot; Robert &lt;skud@cpan.org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232659Z" changeid="explorer">
        <seg>Kirrily &quot;Skud&quot; Robert &lt;skud@cpan.org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See also L&lt;Integer Arithmetic&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver también L&lt;Aritmética entera&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># put commas in the right places in an integer</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># pone comas en los lugares adecuados en un entero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 PODs: Embedded Documentation
X&lt;POD&gt; X&lt;documentation&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043040Z" changeid="explorer">
        <seg>=head2 POD: Documentación embebida
X&lt;POD&gt; X&lt;documentación&gt; X&lt;documentación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the initial value specified isn't part of a magical increment
sequence (that is, a non-empty string matching &quot;/^[a-zA-Z]*[0-9]*\z/&quot;),
only the initial value will be returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el valor inicial especificado no es parte de una secuencia mágica de incremento (es decir, una cadena no vacía coincidente con &quot;/^[a-zA-Z]*[0-9]*\z/&quot;), sólo se devolverá el valor inicial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example: [a-z]
                    matches &quot;a&quot; or &quot;b&quot; or &quot;c&quot; ... or &quot;z&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223336Z" changeid="explorer">
        <seg>Ejemplo: [a-z]
                    coincide con &quot;a&quot; o &quot;b&quot; o &quot;c&quot; ... o &quot;z&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Escape sequences</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Secuencias de Escape</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the following will only
return an alpha:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que lo siguiente sólo devolverá un alfa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also useful when writing C&lt;lex&gt;-like scanners, when you have
several patterns that you want to match against consequent substrings
of your string, see the previous reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También es útil cuando se escriben escáneres C&lt;lex&gt;, cuando tiene varios patrones que desea hacer coincidir contra subcadenas de su cadena; véase la referencia anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shifts the first value of the array off and returns it, shortening the
array by 1 and moving everything down.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Extrae el primer valor del array y lo devuelve, acortando el array en uno y moviendo todos los demás hacia arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, most networking protocols expect
and prefer a CR+LF (C&lt;&quot;\015\012&quot;&gt; or C&lt;&quot;\cM\cJ&quot;&gt;) for line terminators,
and although they often accept just C&lt;&quot;\012&quot;&gt;, they seldom tolerate just
C&lt;&quot;\015&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, la mayoría de protocolos de red esperan y prefieren un CR+LF (C&lt;&quot;\015\012&quot;&gt; o C&lt;&quot;\cM\cJ&quot;&gt;) como terminadores de línea, y aunque a menudo aceptan sólo C&lt;&quot;\012&quot;&gt;, rara vez tolerarán sólo un C&lt;&quot;\015&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== != &lt;=&gt; eq ne cmp ~~  for equals foreach (ALWAYS)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== != &lt;=&gt; eq ne cmp ~~  for es igual a foreach (SIEMPRE)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;Quote-Like Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop/&quot;Operadores entrecomillados&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
statements are simply written in the script in a straightforward
fashion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224723Z" changeid="explorer">
        <seg>Estas instrucciones se escriben directamente en el script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsyn&gt; for alternative strategies.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsyn&gt; para estrategias alternativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Text after __DATA__ may be read via the filehandle C&lt;PACKNAME::DATA&gt;,
where C&lt;PACKNAME&gt; is the package that was current when the __DATA__
token was encountered.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T003642Z" changeid="explorer">
        <seg>El texto después de __DATA__ se puede leer a través del gestor de archivo C&lt;PAQUETE::DATA&gt;, donde C&lt;PAQUETE&gt; es el paquete que estaba en curso cuando se encontró el símbolo __DATA__.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is caused by the fact that a block by itself acts as a loop that
executes once, see L&lt;&quot;Basic BLOCKs&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto funciona así por el hecho de que un bloque, por sí mismo, actúa como un bucle que se ejecuta una sola vez. Ver L&lt;&quot;BLOQUES básicos&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double values _and_ if Perl has been compiled to support those.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dobles __y__ si Perl ha sido compilado para soportarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlembed&gt;, L&lt;perlxstut&gt;, L&lt;perlxs&gt;, L&lt;perlcall&gt;,
L&lt;perlguts&gt;, and L&lt;xsubpp&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;perlembed&gt;, L&lt;perlxstut&gt;, L&lt;perlxs&gt;, L&lt;perlcall&gt;, L&lt;perlguts&gt; y L&lt;xsubpp&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $s is now &quot;The black cat jumped from the green tree&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># $s es ahora &quot;El gato negro saltó desde el árbol verde&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always check the return codes of system calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre compruebe los valores devueltos por las llamadas al sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;alias&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;alias&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can even set them to pipe commands.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso se puede configurar para entubar a comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To query options at another level the
protocol number of the appropriate protocol controlling the option
should be supplied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para consultar opciones en otro nivel se debe indicar el apropiado número de protocolo que controle a esa opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4 uid    4 month-1    4 hasargs      $|    autoflush</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>4 uid    4 mes-1      4 hasargs      $|    autoflush</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this file
is found, it will be loaded in place of any file ending in a &quot;F&lt;.pm&gt;&quot;
extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si este archivo es encontrado, se cargará en lugar de cualquier archivo que termine en una extensión &quot;F&lt;.pm&gt;&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Works just like index() except that it returns the position of the I&lt;last&gt;
occurrence of SUBSTR in STR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Funciona igual que index() excepto que devuelve la posición de la I&lt;última&gt; ocurrencia de SUBCADENA en CADENA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the perlfunc(1) entry on C&lt;umask&gt; for more
on this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver la entrada perlfunc(1) para C&lt;umask&gt; para más información sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also do</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002725Z" changeid="explorer">
        <seg>También puede hacer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># ...		# other switches</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ...		# otras opciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also means that C&lt;$foo[1]&gt;
is a part of @foo, not a part of $foo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También significa que C&lt;$foo[1]&gt; es parte de @foo, no parte de $foo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># only on ASCII and ASCII-derived systems such as ISO Latin 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># solo en sistemas ASCII y derivados, como ISO Latin 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;Standard Version&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Versión Estándar&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map { get_a_key_for($_) =&gt; $_ } @array;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map { una_clave_para($_) =&gt; $_ } @array;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is whoever is named in the copyright or
copyrights for the package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es el que se nombra en el derecho de autor o derechos de autor para el paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>flock($fh, LOCK_EX) or die &quot;Cannot lock mailbox - $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>flock($fh, LOCK_EX) or die &quot;No puedo bloquear el buzón - $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX qw( setlocale localeconv )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use POSIX qw( setlocale localeconv )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That way you're safe from the shell
expanding wildcards or splitting up words with whitespace in them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esta forma estará protegido de la expansión de los comodines del shell o de la división en palabras con un espacio en blanco dentro de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4_294_967_296       # underscore for legibility</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>4_294_967_296       # guión bajo para legibilidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt;&quot;foo&quot;, &lt;&lt;&quot;bar&quot;; # you can stack them</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt;&quot;foo&quot;, &lt;&lt;&quot;bar&quot;; # puede apilarles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces the output 'h:i:t:h:e:r:e'.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce la salida 'h:o:l:a:p:o:r:a:q:u:i'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you can add new rows.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora puede agregar nuevas filas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means
that the C&lt;~&gt; and C&lt;~~&gt; tokens treat the entire PICTURE as a single line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que los tokens C&lt;~&gt; y C&lt;~~&gt; tratan al CUADRO entero como una única línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $mbox $msg,&quot;\n\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $mbox $msg,&quot;\n\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the integer portion of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la parte entera de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chr NUMBER
X&lt;chr&gt; X&lt;character&gt; X&lt;ASCII&gt; X&lt;Unicode&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170235Z" changeid="explorer">
        <seg>=item chr NÚMERO
X&lt;chr&gt; X&lt;character&gt; X&lt;ASCII&gt; X&lt;Unicode&gt; X&lt;carácter&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space before the opening curly of a multi-line BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio antes de llave de apertura de un BLOQUE multilínea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {uc($a) cmp uc($b)} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {uc($a) cmp uc($b)} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 The &quot;Artistic License&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 La &quot;Licencia Artística&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getprotobyname NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getprotobyname NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since
Perl 5.8.1 the ordering is different even between different runs of
Perl for security reasons (see L&lt;perlsec/&quot;Algorithmic Complexity
Attacks&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde Perl 5.8.1 la ordenación es diferente incluso entre diferentes ejecuciones de Perl por razones de seguridad (ver L&lt;perlsec/&quot;Ataques por Complejidad Algorítmica&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open   (FH, $path)          or  return undef;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open   (FH, $ruta)          or  return undef;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned depends on the
type of thing the reference is a reference to.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto depende del tipo de cosa que la referencia indique como referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a case additional elements $evaltext and
C&lt;$is_require&gt; are set: C&lt;$is_require&gt; is true if the frame is created by a
C&lt;require&gt; or C&lt;use&gt; statement, $evaltext contains the text of the
C&lt;eval EXPR&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012307Z" changeid="explorer">
        <seg>En tal caso, se añaden los nuevos elementos $evaltext y C&lt;$is_require&gt;: C&lt;$is_require&gt; es verdadero si el marco es creado por una instrucción C&lt;require&gt; o C&lt;use&gt;, $evaltext contiene el texto de la instrucción C&lt;eval EXPR&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$first = &lt;$handle&gt;
            or return ();     # Automatically closed here.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050439Z" changeid="explorer">
        <seg>$first = &lt;$handle&gt;
            or return ();     # Cerrado aquí automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the LIST is prepended whole, not one element at a time, so the
prepended elements stay in the same order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la LISTA se antepone en su conjunto, no un elemento a la vez, por lo que los elementos añadidos se mantienen en el mismo orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;$_&gt; is an alias to the list value, so it can be used to
modify the elements of the LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;$_&gt; es un alias al valor de la lista, por lo que puede ser usado para modificar los elementos de la LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But if you're not, you should as always feel perfectly
free to write for your own system's idiosyncrasies (sometimes called
&quot;features&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Pero si no, puede siempre sentirse libre de escribir sus propias idiosincrasias del sistema (algunas veces llamadas &quot;features&quot; -características-).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is a contextually
polymorphic language whose scalars can be strings, numbers, or
references (which includes objects).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl es un lenguaje contextualmente polimórfico según el contexto, cuyos escalares pueden ser cadenas, números o referencias (las cuales incluyen a los objetos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means that C&lt;caller(N)&gt;
might not return information about the call frame you expect it to, for
C&lt;&lt; N &gt; 1 &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que C&lt;caller(N)&gt; quizás no devuelva información sobre el marco de llamada que espera, para C&lt;&lt; N &gt; 1 &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If TEMPLATE requires more arguments that pack() is given, pack()
assumes additional C&lt;&quot;&quot;&gt; arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si PLANTILLA requiere más argumentos de los que se pasan a pack(), éste asume argumentos adicionales iguales a C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl B&lt;borrows syntax&gt; and concepts from many languages: awk, sed, C,
Bourne Shell, Smalltalk, Lisp and even English.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl B&lt;toma prestada la sintaxis&gt; y conceptos de muchos lenguajes: awk, sed, C, Bourne Shell, Smalltalk, Lisp e incluso el Inglés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no equivalent operator to force an expression to
be interpolated in list context because in practice, this is never
needed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay un operador equivalente que fuerce a una expresión a ser interpolada en contexto de lista, ya que en la práctica, esto nunca es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or even just</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o incluso sólo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsec&gt; for a clean and safe example of a manual fork() and exec()
to emulate backticks safely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase L&lt;perlsec&gt; para un ejemplo seguro y limpio de un fork() y exec() manual para emular comillas invertidas de forma segura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlko		Perl for Korean (in EUC-KR)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlko		Perl para Coreano (en EUC-KR)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare with L&lt;/require&gt;, which can do a similar check at run time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compare con L&lt;/require&gt;, que puede hacer un control similar en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the output is empty and C&lt;$@&gt; contains an object reference that has a
C&lt;PROPAGATE&gt; method, that method will be called with additional file
and line number parameters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la salida está vacía y C&lt;$@&gt; contiene una referencia a un objeto que tiene un método C&lt;PROPAGATE&gt;, éste método será llamado con los parámetros adicionales del archivo y número de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perllocale&gt; for
discussion of additional considerations that apply when C&lt;use locale&gt;
is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perllocale&gt; para la discusión de consideraciones adicionales que se aplican cuando el C&lt;use locale&gt; está en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 CONTACT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 CONTACTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The EXPR can be arbitrarily complicated provided its
final operation is an element or slice of an aggregate:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La EXPR puede ser tan arbitrariamente complicada con tal de que el final de la operación sea un elemento o una porción de un agregado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$biz = &quot;$foo&quot; ^ &quot;$bar&quot;;	# both ops explicitly stringy</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$biz = &quot;$foo&quot; ^ &quot;$bar&quot;;	# ambas op. explícitamente como literales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function
implementing the C&lt;\U&gt; escape in double-quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la función interna del escapado C&lt;\U&gt; en las cadenas doblemente entrecomilladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sqrt</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sqrt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt;EOF;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt;EOF;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I didn't dare yet
to try enabling it and see what problems occur.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No me atrevía aún a activarlo y ver qué problemas pueden ocurrir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/x</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/Extended Patterns&gt; below for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225423Z" changeid="explorer">
        <seg>Véase más abajo L&lt;/Patrones extendidos&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getnetent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getnetent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># poor man's grep</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un grep para pobres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;binmode&gt;, C&lt;close&gt;, C&lt;closedir&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;die&gt;, C&lt;eof&gt;,
C&lt;fileno&gt;, C&lt;flock&gt;, C&lt;format&gt;, C&lt;getc&gt;, C&lt;print&gt;, C&lt;printf&gt;, C&lt;read&gt;,
C&lt;readdir&gt;, C&lt;rewinddir&gt;, C&lt;say&gt;, C&lt;seek&gt;, C&lt;seekdir&gt;, C&lt;select&gt;, C&lt;syscall&gt;,
C&lt;sysread&gt;, C&lt;sysseek&gt;, C&lt;syswrite&gt;, C&lt;tell&gt;, C&lt;telldir&gt;, C&lt;truncate&gt;,
C&lt;warn&gt;, C&lt;write&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;binmode&gt;, C&lt;close&gt;, C&lt;closedir&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;die&gt;, C&lt;eof&gt;, C&lt;fileno&gt;, C&lt;flock&gt;, C&lt;format&gt;, C&lt;getc&gt;, C&lt;print&gt;, C&lt;printf&gt;, C&lt;read&gt;, C&lt;readdir&gt;, C&lt;rewinddir&gt;, C&lt;seek&gt;, C&lt;seekdir&gt;, C&lt;select&gt;, C&lt;syscall&gt;, C&lt;sysread&gt;, C&lt;sysseek&gt;, C&lt;syswrite&gt;, C&lt;tell&gt;, C&lt;telldir&gt;, C&lt;truncate&gt;, C&lt;warn&gt;, C&lt;write&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to Hannu Napari &lt;Hannu.Napari@hut.fi&gt; for the IRIX</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004537Z" changeid="explorer">
        <seg>Gracias a Hannu Napari &lt;Hannu.Napari@hut.fi&gt; por la información</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\l		lowercase next char</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003106Z" changeid="explorer">
        <seg>\l		siguiente car. en minúscula</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es equivalente a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$width = 2**$w;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ancho = 2**$w;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are more pack codes or if the repeat count of a field or a group
is larger than what the remainder of the input string allows, the result
is not well defined: the repeat count may be decreased, or
C&lt;unpack()&gt; may produce empty strings or zeros, or it may raise an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay más códigos de empaquetado o si el número de repeticiones de un campo o un grupo es más grande que lo que el resto de la cadena de entrada permite, el resultado no está bien definido: el número de repeticiones puede ser disminuido, o C&lt;unpack()&gt; puede producir cadenas vacías o ceros, o puede provocar una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=cut back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=cut regreso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read that documentation using the C&lt;perldoc&gt;
command or whatever method you're using to read this document.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224554Z" changeid="explorer">
        <seg>Puede consultar la documentación mediante el comando C&lt;perldoc&gt; o cualquier otro método que use para leer este documento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;exec&gt; function executes a system command I&lt;and never returns&gt;;
use C&lt;system&gt; instead of C&lt;exec&gt; if you want it to return.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función C&lt;exec&gt; ejecuta un comando del sistema I&lt;y nunca regresa&gt;; use C&lt;system&gt; en lugar de C&lt;exec&gt; si quiere que regrese.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The equivalent numeric
version should be used instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se debe usar en su lugar la versión equivalente numérica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>arrayref  ${$$foo[1]}[2] aka $foo-&gt;[1]-&gt;[2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>anónimo  ${$$foo[1]}[2] igual que $foo-&gt;[1]-&gt;[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlvmesa		Perl notes for VM/ESA</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlvmesa		Notas para VM/ESA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 4) = 8   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 4) = 8   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your platform doesn't
support NaNs then NaN is just a string with numeric value 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su plataforma no es compatible con NaN entonces NaN es sólo una cadena con un valor numérico 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FILEHANDLE, &quot;&lt;&amp;=&quot;, $fd)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FILEHANDLE, &quot;&lt;&amp;=&quot;, $fd)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dbmopen(%NS_Hist, &quot;$ENV{HOME}/.netscape/history.db&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dbmopen(%NS_Hist, &quot;$ENV{HOME}/.netscape/history.db&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5005delta	Perl changes in version 5.005</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5005delta	Cambios en la versión 5.005</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl595delta	Perl changes in version 5.9.5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl595delta	Cambios en la versión 5.9.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three forms of hooks: subroutine
references, array references and blessed objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay tres formas de enganches: referencias a subrutinas, referencias a arrays y objetos bendecidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $file (sort keys(%seen)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $archivo (sort keys(%visto)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$herstraddr     = inet_ntoa($iaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$herstraddr     = inet_ntoa($iaddr);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Writing subroutines</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T004059Z" changeid="zipf">
        <seg>=head2 Programación de subrutinas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print OUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print OUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the platform-specific
release notes for more details about your particular environment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase las notas específicas de la plataforma para obtener más detalles acerca de su entorno particular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
package in which the variable is entered is determined at the point
of the declaration, not at the point of use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El paquete en el que se introduce la variable se determina en el punto de la declaración, no en el momento de ser usada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if
you were to declare the subroutine as C&lt;sub myname ($)&gt;, then
C&lt;myname&gt; would function as a unary operator, so either C&lt;or&gt; or
C&lt;||&gt; would work.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si declara la subrutina como C&lt;sub minombre ($)&gt;, entonces C&lt;minombre&gt; funcionará como un operador unario, así que servirán tanto C&lt;or&gt; como C&lt;||&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
there is a C&lt;continue&gt; BLOCK attached to a BLOCK (typically in a C&lt;while&gt; or
C&lt;foreach&gt;), it is always executed just before the conditional is about to
be evaluated again, just like the third part of a C&lt;for&gt; loop in C.  Thus
it can be used to increment a loop variable, even when the loop has been
continued via the C&lt;next&gt; statement (which is similar to the C C&lt;continue&gt;
statement).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si existe un BLOQUE C&lt;continue&gt; adjunto a un BLOQUE (típicamente en un C&lt;while&gt; o C&lt;foreach&gt;), siempre es ejecutado justo antes de que la condicional sea de nuevo evaluada, igual que la tercera parte de un bucle C&lt;for&gt; en C. Esto puede ser utilizado para incrementar una variable de bucle, incluso cuando el bucle ha sido interrumpido por la sentencia C&lt;next&gt; (que es similar a la sentencia C&lt;continue&gt; del C).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All this is experimental.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo esto es experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tries to minimally patch
the uconfig.sh using your *current* Perl so that your microperl has
the correct basic types and sizes and byteorder.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto intenta parchear mínimamente el uconfig.sh utilizando su *actual* Perl para que su microperl tenga los tipos y tamaños básicos y orden de los bytes correcto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>longlongsize='8';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>longlongsize='8';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cd ~/config/lib; ln -s perl5/5.8.6/BePC-beos/CORE/libperl.so .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>cd ~/config/lib; ln -s perl5/5.8.6/BePC-beos/CORE/libperl.so .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of
C&lt;O_TRUNC&gt; with C&lt;O_RDONLY&gt; is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento de C&lt;O_TRUNC&gt; con C&lt;O_RDONLY&gt; no está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings that match
parenthesized parts of a regular expression are saved under names
containing only digits after the C&lt;$&gt; (see L&lt;perlop&gt; and L&lt;perlre&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las cadenas que coinciden con las partes encerradas entre paréntesis de una expresión regular se guardan con nombres que contienen sólo dígitos después del C&lt;$&gt; (véase L&lt;perlre&gt; y L&lt;perlop&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, modifying an
element of a list returned by grep (for example, in a C&lt;foreach&gt;, C&lt;map&gt;
or another C&lt;grep&gt;) actually modifies the element in the original list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, modificar un elemento de la lista devuelto por grep (por ejemplo, en un C&lt;foreach&gt;, C&lt;map&gt; u otro C&lt;grep&gt;) modifica el elemento en la lista original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regexp-like quote.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entrecomillado de expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;File is %s, size is %s, perm %04o, mtime %s\n&quot;,
           $filename, $sb-&gt;size, $sb-&gt;mode &amp; 07777,
           scalar localtime $sb-&gt;mtime;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051902Z" changeid="explorer">
        <seg>printf &quot;Archivo es %s, tamaño es %s, perm %04o, mtime %s\n&quot;,
           $archivo, $sb-&gt;size, $sb-&gt;mode &amp; 07777,
           scalar localtime $sb-&gt;mtime;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;my&gt; X&lt;local&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;my&gt; X&lt;local&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For numeric conversions, you can specify the size to interpret the
number as using C&lt;l&gt;, C&lt;h&gt;, C&lt;V&gt;, C&lt;q&gt;, C&lt;L&gt;, or C&lt;ll&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para conversiones numéricas, se puede especificar el tamaño del número a interpretar usando C&lt;l&gt;, C&lt;h&gt;, C&lt;V&gt;, C&lt;q&gt;, C&lt;L&gt;, o C&lt;ll&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '%3$d %d %1$d', 1, 2, 3;  # prints &quot;3 1 1&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '%3$d %d %1$d', 1, 2, 3;  # imprime &quot;3 1 1&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replace C&lt;/path/to/flock/server/headers&gt; with the path to the directory
containing the C&lt;flock.h&gt; header.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Reemplace C&lt;/ruta/a/cabeceras/servidor/flock&gt; con la ruta al directorio que contiene la cabecera C&lt;flock.h&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the access and modification times on each file of a list of
files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia los tiempos de acceso y modificación de cada archivo de una lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last if /fred/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last if /pedro/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Saying
C&lt;-exp($foo)&gt; still works as expected, however: only single letters
following a minus are interpreted as file tests.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Decir C&lt;-exp($foo)&gt; sigue funcionando como se espera que lo haga: sólo letras sueltas, por detrás de un menos, son interpretadas como test de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest thing to build is an array of arrays (sometimes imprecisely
called a list of lists).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo más sencillo es crear un array de array (a veces, de forma imprecisa, es llamado una lista de listas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $patterns = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $patrones   = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In versions of Perl prior to 5.004 the default seed was just the
current C&lt;time&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En las versiones de Perl anteriores a 5.004 la semilla por defecto era sólo el valor actual de C&lt;time&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub foo { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub foo { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your compilation platform is not 32-bit
little-endian (like x86), you might want to try</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su plataforma de compilación no es de 32 bits little-endian (como x86), es posible que quiera probar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a^b == (a+1)^(b+1)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a^b == (a+1)^(b+1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item splice ARRAY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item splice ARRAY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want
to call the underlying C&lt;getppid()&gt;, you may use the CPAN module
C&lt;Linux::Pid&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere llamar a la subyacente C&lt;getppid()&gt;, puede usar el módulo de CPAN C&lt;Linux::Pid&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the cost of some space and
considerable speed, they avoid the normal pitfalls associated with
limited-precision representations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A costa de algún espacio y velocidad, evitan los peligros asociados a la limitada precisión de las representaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>p  A pointer to a null-terminated string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>p  Un puntero a una cadena terminada en nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scope
of the package declaration is from the declaration itself through the end
of the enclosing block, file, or eval (the same as the C&lt;my&gt; operator).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El alcance de la declaración del paquete es desde la misma declaración hasta el final del bloque que lo engloba, un archivo o eval (lo mismo que el operador C&lt;my&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shift</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item shift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Building 'cc -n32' is the default.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002527Z" changeid="explorer">
        <seg>(Compilar 'cc -n32' está por defecto)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if the specified Perl version is greater than or equal to
5.11.0, strictures are enabled lexically as with C&lt;use strict&gt; (except
that the F&lt;strict.pm&gt; file is not actually loaded).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, si la versión especificada de Perl es mayor o igual a 5.11.0, el modo de trabajo estricto quedará activado léxicamente como con C&lt;use strict&gt; (excepto que el archivo F&lt;strict.pm&gt;, realmente, no se cargará).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can gain you a measure of efficiency if
you know the hash is going to get big.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacerle ganar más eficiencia si sabe que el hash va a tener un gran tamaño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(foo|bar|baz)       matches any of the alternatives specified</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121727Z" changeid="zipf">
        <seg>(foo|bar|baz)       cualquiera de las alternativas especificadas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, '|-', &quot;tr&quot;, '[a-z]', '[A-Z]');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, '|-', &quot;tr&quot;, '[a-z]', '[A-Z]');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may embed this Package's interpreter within
an executable of yours (by linking); this shall be construed as a mere
form of aggregation, provided that the complete Standard Version of the
interpreter is so embedded.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede integrar el intérprete de este Paquete dentro de un ejecutable suyo (mediante montaje o linkado); esto se entenderá como una mera forma de agregación, siempre que la Versión Estándar completa del intérprete esté empotrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't
have a filehandle named &quot;log&quot;, for instance.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se puede tener un gestor de archivo llamado &quot;log&quot;, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($image, $max_x * $x + $y, 8) = 3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($imagen, $max_x * $x + $y, 8) = 3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or you can see this document by entering &quot;perldoc perlartistic&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>O puede ver este documento mediante la introducción de &quot;perldoc perlartistic&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On many Unix systems, fdopen() is known to fail when file descriptors
exceed a certain value, typically 255.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En muchos sistemas Unix, fdopen() se conoce que falla cuando los descriptores de archivo exceden un valor determinado, por lo general 255.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 ) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>10 ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, in the source to be cross compiled:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Luego, en el código fuente para ser compilado de forma cruzada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the curly brackets are I&lt;required&gt;--no
dangling statements allowed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013317Z" changeid="explorer">
        <seg>Esto significa que las llaves son I&lt;necesarias&gt;: no se permiten instrucciones sueltas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The perl5 development team are implementing changes to help address this
problem, which should go live in early 2004.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El equipo de desarrollo de perl5 está implementando cambios para ayudar a resolver este problema, que debería aparecer a principios de 2004.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying the target
string also resets the search position.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Modificando la cadena objetivo también restablece la posición de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl also defines a consistent extension syntax for features not
found in standard tools like B&lt;awk&gt; and B&lt;lex&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl también define una coherente sintaxis extendida de características no encontradas en las herramientas estándar como B&lt;awk&gt; y B&lt;lex&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>embeddable and extensible</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>integrable y ampliable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub read_myfile_munged {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub leer_miarchivo {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if successful, or false if there is
an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tiene éxito, o falso si hay un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POSITION before the beginning of the string
or after its end is treated as if it were the beginning or the end,
respectively.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>POSICIÓN antes del comienzo del string o después de su final es tratado como si estuviera al principio o al final, respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%-6s&gt;', 12;   # prints &quot;&lt;12    &gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%-6s&gt;', 12;   # imprime &quot;&lt;12    &gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The epoch was at 00:00 January 1, 1970 GMT.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(El epoch fue a las 00:00 GMT del 1 de enero de 1970)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The terminating string may be either an identifier (a word), or some
quoted text.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La cadena de terminación puede ser un identificador (una palabra), o algún texto entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pack(&quot;a/W2&quot;, ord(&quot;a&quot;) ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pack(&quot;a/W2&quot;, ord(&quot;a&quot;) ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,15, 2) = 2   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,15, 2) = 2   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one may need to use the template C&lt;c x![d] d c[2]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>puede tener que usar la plantilla C&lt;c x![d] d c[2]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$verbose &amp;&amp; print &quot;Starting analysis\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$locuaz &amp;&amp; print &quot;Empezando análisis\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IRWXG S_IRGRP S_IWGRP S_IXGRP</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_IRWXG S_IRGRP S_IWGRP S_IXGRP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1_000_000) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1_000_000) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Match a minimal number of characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Busca el mínimo número de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to read LENGTH bytes of data into variable SCALAR from the
specified FILEHANDLE, using the read(2).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204303Z" changeid="explorer">
        <seg>Intenta leer LONGITUD bytes de datos en la variable ESCALAR desde el GESTOR_ARCHIVO especificado, utilizando read(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should instead use a simple test for size:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilize en su lugar una comprobación de tamaño:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $Config{longlongsize}, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $Config{longlongsize}, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;&quot;switch&quot;&gt; feature is enabled, C&lt;continue&gt; is also a
function that exits the current C&lt;when&gt; (or C&lt;default&gt;) block and
falls through to the next one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T014942Z" changeid="explorer">
        <seg>Si la característica C&lt;&quot;switch&quot;&gt; está habilitada, C&lt;continue&gt; es también una función que termina el bloque C&lt;when&gt; (o C&lt;default&gt;) y cae al siguiente caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context,
returns the elements removed from the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, devuelve los elementos retirados del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unshift ARRAY,LIST
X&lt;unshift&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210346Z" changeid="explorer">
        <seg>=item unshift ARRAY,LISTA
X&lt;unshift&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ip_address = inet_ntoa($packed_ip);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ip_address = inet_ntoa($packed_ip);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We try not to do this more than we have to.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tratamos de no hacer esto no más de lo necesario).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the list of operators in
the next section for information on comparison and boolean logic operators,
which are commonly used in conditional statements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225116Z" changeid="explorer">
        <seg>Consulte la lista de operadores de la siguiente sección para obtener información sobre los operadores lógicos booleanos y de comparación que se suelen usar en instrucciones condicionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even C&lt;&lt; &lt;$x &gt; &gt;&gt; (note the extra space)
is treated as C&lt;glob(&quot;$x &quot;)&gt;, not C&lt;readline($x)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010919Z" changeid="explorer">
        <seg>Incluso C&lt;&lt; &lt;$x &gt; &gt;&gt; (note el espacio extra) es tratado como C&lt;glob(&quot;$x &quot;)&gt;, no como C&lt;readline($x)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TIEHASH classname, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TIEHASH clase, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space around most operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio alrededor de la mayoría de operadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$_\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$_\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces the list value</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce la lista de valores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our $bar;      # emits warning but has no other effect</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>our $bar;      # emite una advertencia pero no tiene otro efecto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>format STDOUT =</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>format STDOUT =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Breaks the binding between a variable and a package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Rompe el enlace entre una variable y un paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\S        [3]  Match a non-whitespace character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223658Z" changeid="explorer">
        <seg>\S	 [3]  Coincide con un carácter que no es un espacio en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-r  File is readable by effective uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004457Z" changeid="explorer">
        <seg>-r  Archivo es legible por el uid/gid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(getpwuid($&lt;))[7] // die &quot;You're homeless!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(getpwuid($&lt;))[7] // die &quot;¡Eres un sin techo!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $/;  # slurp!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local $/;  # ¡sorber!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;&quot;	qq{}	      Literal		  yes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;&quot;	qq{}	      Literal		  sí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encodes to a character in character mode</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Codifica a un carácter en modo de caracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/pack&gt; for more examples and notes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/pack&gt; para más ejemplos y notas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the differences being that it generates a real list at compile time, and
in scalar context it returns the last element in the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>siendo diferente en que genera una lista real en tiempo de compilación, y en contexto escalar devuelve el último elemento de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a yet-more-powerful import facility, see L&lt;/use&gt; and L&lt;perlmod&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una más-que-poderosa facilidad de importación, ver L&lt;/use&gt; y L&lt;perlmod&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item delete EXPR
X&lt;delete&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170450Z" changeid="explorer">
        <seg>=item delete EXPR
X&lt;delete&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;if&gt; executes the statement once I&lt;if&gt; and only if the condition is
true.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013027Z" changeid="explorer">
        <seg>C&lt;if&gt; ejecuta la instrucción una vez I&lt;si&gt; y sólo si la condición es verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use Module</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item use Módule</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$b&gt; will now work as expected when either $a or $b is C&lt;undef&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$b&gt; ahora funcionará como se espera cuando $a o $b sean C&lt;undef&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5121delta	Perl changes in version 5.12.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5121delta	Cambios en la versión 5.12.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which enables a switch feature that is closely based on the
Perl 6 proposal.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>que activa la característica conmutador, que se basa estrechamente en la propuesta en Perl 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of C&lt;ioctl&gt; (and C&lt;fcntl&gt;) is as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto de C&lt;ioctl&gt; (y C&lt;fcntl&gt;) es como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To refer
to the current contents of a buffer later on, within the same pattern,
use \1 for the first, \2 for the second, and so on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para hacer referencia a los actuales contenidos de una memoria de captura, en el mismo patrón, use \1 para la primera, \2 para la segunda, y así sucesivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset	    if eof();		# reset ?pat?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>reset	    if eof();		# resetea ?patrón?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;Operator associativity&gt; defines what happens if a sequence of the
same operators is used one after another: whether the evaluator will
evaluate the left operations first or the right.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T010301Z" changeid="explorer">
        <seg>I&lt;Asociatividad de operadores&gt; define qué sucede si una secuencia de los mismos operadores es usada una detrás de otra: si el evaluador evaluará primero las operaciones a la izquierda o las de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As it happens, using C&lt;@array&gt; where Perl
expects to find a scalar value (&quot;in scalar context&quot;) will give you the number
of elements in the array:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224859Z" changeid="explorer">
        <seg>Si utiliza C&lt;@array&gt; donde Perl espera encontrar un valor escalar (&quot;en contexto escalar&quot;), obtendrá el número de elementos del array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, put this as the first line of your script:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224641Z" changeid="explorer">
        <seg>Como alternativa, puede colocar al principio del script la siguiente línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function msgctl(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC msgctl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($b =~ /=(\d+)/)[0] &lt;=&gt; ($a =~ /=(\d+)/)[0]
            ||</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051339Z" changeid="explorer">
        <seg>($b =~ /=(\d+)/)[0] &lt;=&gt; ($a =~ /=(\d+)/)[0]
            ||</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A declaration can be put anywhere a statement can, but has no effect on
the execution of the primary sequence of statements--declarations all
take effect at compile time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012227Z" changeid="explorer">
        <seg>Una declaración puede ponerse en cualquier sitio, como si fuera una instrucción, pero no tiene efecto en la ejecución de la secuencia de instrucciones principal: todas las declaraciones toman efecto en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's no place
to declare a scalar variable to be of type &quot;string&quot;, type &quot;number&quot;,
type &quot;reference&quot;, or anything else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay ninguna forma de declarar que una variable escalar sea de tipo &quot;cadena&quot;, tipo &quot;número&quot;, tipo &quot;referencia&quot; o de cualquier otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># this is where that last takes me</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Aquí es donde lleva el 'last'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	&amp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Leading whitespace is not stripped,
unlike oct().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacios en blanco aledaños, no son eliminados, a diferencia de oct().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef @ARRAY;   # forget @ARRAY ever existed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef @ARRAY;   # hacer que @ARRAY nunca existió</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces the output 'h:i: :t:h:e:r:e'.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce la salida 'h:o:l:a: :p:o:r: :a:q:u:i'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-blocking wait is available on machines supporting either the
waitpid(2) or wait4(2) syscalls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espera no bloqueanto está disponible en máquinas que soporten las llamadas del sistema, tanto waitpid(2) como wait4(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(this may not work on some bizarre filesystems).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(esto quizás no funcione en algunos sistemas de archivos extraños).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 9, 2) = 2   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 9, 2) = 2   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,14, 2) = 2   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,14, 2) = 2   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmodstyle	Perl modules: how to write modules with style</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmodstyle	Módulos Perl: cómo escribir módulos con estilo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(There is a Perl script called B&lt;h2ph&gt; that comes with the Perl kit that
may help you in this, but it's nontrivial.)  SCALAR will be read and/or
written depending on the FUNCTION; a C pointer to the string value of SCALAR
will be passed as the third argument of the actual C&lt;ioctl&gt; call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Existe un script Perl llamado B&lt;h2ph&gt; que viene con el kit Perl que puede ayudarle en esto, pero no es nada trivial). ESCALAR será leído o escrito dependiendo de la FUNCIÓN; un puntero C al valor de la cadena ESCALAR será pasado como tercer argumento de la actual llamada C&lt;ioctl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We've already seen how to print to standard output using C&lt;print()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225351Z" changeid="explorer">
        <seg>Ya hemos visto la manera de imprimir en la salida estándar mediante C&lt;print()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most interesting range is from '@' to '_'
(0x40 through 0x5F), resulting in a control character from 0x00
through 0x1F.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El rango más interesante es desde '@' a '_' (0x40 a 0x5F), resultando en un carácter de control desde 0x00 a 0x1F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Installation and Configuration Improvements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Mejoras en la instalación y configuración</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T195317Z" changeid="explorer">
        <seg>8;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutine references are the simplest case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Referencias a subrutinas son el caso más simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must yourself do any alignment or padding by inserting, for example,
enough C&lt;&quot;x&quot;&gt;es while packing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe hacer cualquier alineamiento o rellenado, insertando, por ejemplo, suficientes C&lt;&quot;x&quot;&gt;, mientras desempaqueta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;Freely Available&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Libre Disponibilidad&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will call this syntactic construct a BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llamaremos a esta construcción sintáctica un BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item undef</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item undef</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Assertions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Aserciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\g{name}  [5]  Named backreference</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224609Z" changeid="explorer">
        <seg>\g{name}  [5]  Contrareferencia nominal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of 5.005, C&lt;$&amp;&gt; is not so costly as the
other two.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de 5.005, C&lt;$&amp;&gt; no es tan costoso como los otros dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$days{'Feb'}	# the 'Feb' value from hash %days</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$dias{'Feb'}	# el valor 'Feb' del hash %dias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort { $a cmp $b } find_records @key;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort { $a cmp $b } busca_registros @claves;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A (file)glob evaluates its (embedded) argument only when it is
starting a new list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una expansión evalúa sus argumentos (incorporados) sólo cuando está iniciando una nueva lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>??</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>??</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Works just like L&lt;localtime&gt; but the returned values are
localized for the standard Greenwich time zone.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Funciona igual que L&lt;localtime&gt; pero los valores devueltos son localizados por la zona horaria estándar de Greenwich.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lstat EXPR
X&lt;lstat&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191329Z" changeid="explorer">
        <seg>=item lstat EXPR
X&lt;lstat&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the absence of parentheses, the precedence of list operators such as
C&lt;print&gt;, C&lt;sort&gt;, or C&lt;chmod&gt; is either very high or very low depending on
whether you are looking at the left side or the right side of the operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En ausencia de paréntesis, la precedencia de los operadores de lista como C&lt;print&gt;, C&lt;sort&gt;, o C&lt;chmod&gt; es, o muy alta o muy baja, dependiendo de si usted está mirando al lado izquierdo o al lado derecho del operador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>details).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>detalles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%o    an unsigned integer, in octal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%o    un entero sin signo, en octal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($word = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($palabra = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For &quot;g&quot; and &quot;G&quot;, this specifies the maximum number of digits to show,
including thoe prior to the decimal point and those after it; for 
example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para &quot;g&quot; y &quot;G&quot;, especifica el número máximo de dígitos para mostrar, incluyendo los anteriores del punto decimal y los posteriores a él, por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators return the
length of the list that would have been returned in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven la longitud de la lista que se hubiera devuelto en contexto lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that, due to
the implementation of C&lt;use filetest 'access'&gt;, the C&lt;_&gt; special
filehandle won't cache the results of the file tests when this pragma is
in effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note también que, debido a la implementación de C&lt;use filetest 'access'&gt;, el gestor de archivo especial C&lt;_&gt; no almacenará los resultados de los test de archivo mientras este pragma esté activo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should C&lt;use Socket&gt; first
to get the proper definitions imported.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe usar C&lt;use Socket&gt; primero para obtener las apropiadas definiciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;until&gt; does the opposite, it repeats the statement I&lt;until&gt; the
condition is true (or while the condition is false):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013136Z" changeid="explorer">
        <seg>C&lt;until&gt; hace lo opuesto, repite la instrucción I&lt;hasta&gt; que la condición sea verdadera (o mientras la condición sea falsa):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also differs in that code evaluated with C&lt;do FILENAME&gt;
cannot see lexicals in the enclosing scope; C&lt;eval STRING&gt; does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También difiere en que el código evaluado con C&lt;do NOMBREARCHIVO&gt; no puede ver a las variables léxicas en el ámbito en que se ejecuta; C&lt;eval STRING&gt; sí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because this will be very wrong:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no esto quedaría muy mal:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	=~ !~</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	=~ !~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;cond_wait&gt; has a new two argument form.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;cond_wait&gt; tiene una nueva forma de dos argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpreter initialization is more complete when -DMULTIPLICITY is off.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El Intérprete de inicialización es más completo cuando -DMULTIPLICITY está desactivado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>until EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>until EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &quot;/&quot; is the delimiter then the initial C&lt;m&gt; is optional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si &quot;/&quot; es el delimitador entonces la inicial C&lt;m&gt; es opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+	   Match 1 or more times</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>+	   Coincide con 1 o más veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,11, 1) = 1   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,11, 1) = 1   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a .= &quot;\n&quot;;     # same as $a = $a . &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055555Z" changeid="explorer">
        <seg>$a .= &quot;\n&quot;;     # igual que $a = $a . &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$uid   = getpwnam($name);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$uid     = getpwnam($nombre);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function returns an undefined value,
it's an admission that it couldn't give you an honest answer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando una función devuelve un valor indefinido, se asume que no puede dar una respuesta honrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item import LIST
X&lt;import&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173915Z" changeid="explorer">
        <seg>=item import LISTA
X&lt;import&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chop( LIST )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chop( LISTA )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, C&lt;$myarray[-1]&gt; would have been 
5000, and C&lt;$myarray[-2]&gt; would have been 500.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En nuestro ejemplo, C&lt;$miarray[-1]&gt; habría sido 5000, y C&lt;$miarray[-2]&gt; habría sido 500.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*x&gt;', 6, 1;    # prints &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*x&gt;', 6, 1;    # imprime &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That doesn't mean you should go out of your way to avoid backticks
when they're the right way to get something done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Eso no significa que deba evitar las comillas invertidas cuando sea la forma correcta de hacer algo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator is
bistable, like a flip-flop, and emulates the line-range (comma)
operator of B&lt;sed&gt;, B&lt;awk&gt;, and various editors.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador es biestable, como un flip-flop, y emula el operador rango-de-línea de B&lt;sed&gt;, B&lt;awk&gt;, y diversos editores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, use C&lt;\034&gt; or C&lt;\x1c&gt; at the end of quoted constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En su lugar, utilice C&lt;\034&gt; o C&lt;\x1c&gt; al final de la construcción entrecomillada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may be able to evaluate
multiple commands in a single line by separating them with the command
separator character, if your shell supports that (e.g. C&lt;;&gt; on many Unix
shells; C&lt;&amp;&gt; on the Windows NT C&lt;cmd&gt; shell).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Quizás sea capaz de evaluar múltiples comandos en una sola línea, separándoles con el carácter separador de comandos, si el shell lo soporta (por ejemplo, C&lt;;&gt; en muchos shell Unix; C&lt;&amp;&gt; en el shell C&lt;cmd&gt; de Windows NT).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.14&gt; will not do what
you want in scalar context because each of the operands are evaluated
using their integer representation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3,14&gt; no harán lo que quiere hacer en contexto escalar porque cada uno de los operandos son evaluados utilizando su representación entera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6 rdev   6 weekday    6 evaltext     $@    eval error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>6 rdev   6 día semana 6 evaltext     $@    eval error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>oct() and hex() in glorious 64 bit</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>oct() y hex() en el glorioso mundo de los 64 bits</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltodo		Perl things to do</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perltodo		Cosas por hacer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-p  File is a named pipe (FIFO), or Filehandle is a pipe.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004710Z" changeid="explorer">
        <seg>-p  Archivo es una tubería con nombre (FIFO), o el gestor de archivo es una tubería.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item formline PICTURE,LIST
X&lt;formline&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173435Z" changeid="explorer">
        <seg>=item formline CUADRO,LISTA
X&lt;formline&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item values ARRAY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item values ARRAY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str = &quot;widget&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$str = &quot;widget&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failed 2/229 test scripts, 99.13% okay.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Failed 2/229 test scripts, 99.13% okay.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you know the exact length in bits, it can be used in place of the C&lt;*&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si conoce la longitud exacta en bits, puede ser utilizada en lugar de la C&lt;*&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, unpacks the C&lt;$_&gt; string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es omitido, desempaqueta la cadena C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's best to assume traditional behavior if you're writing
portable programs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es mejor asumir el comportamiento tradicional si está escribiendo programas portables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, references to variables related to
output will refer to this output channel.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En segundo lugar, las referencias a variables relacionadas con la salida se referirán a este canal de salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># foo eq &quot;AB\0\0CD&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># foo es &quot;AB\0\0CD&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $animal = &quot;camel&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025616Z" changeid="explorer">
        <seg>my $animal    = &quot;camello&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If in doubt about
this behaviour, the left operand can be quoted explicitly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de duda acerca de este comportamiento, el operando de la izquierda puede ser entrecomillado de forma explícita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can switch into a
package in more than one place, since this only determines which default 
symbol table the compiler uses for the rest of that block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede cambiar en un paquete en más de un lugar, ya que esto sólo determina qué tabla de símbolos por defecto será utilizada por el compilador para el resto de ese bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\E		end case modification</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003202Z" changeid="explorer">
        <seg>\E		fin modificación del tamaño de caja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is because, as mentioned below, the regex
compilation may be done at execution time, and C&lt;\N{...}&gt; is a compile-time
construct.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto se debe a que, como se menciona más abajo, la compilación de expresiones regulares se puede hacer en tiempo de ejecución, y C&lt;\N{...}&gt; es una construcción en tiempo de compilación).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $logfile $logmessage;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T222046Z" changeid="zipf">
        <seg>print $registro $mensaje_registro;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl587delta	Perl changes in version 5.8.7</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl587delta	Cambios en la versión 5.8.7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you are using Perls older than 5.8.0, Perl will be using
the standard C libraries' fdopen() to implement the &quot;=&quot; functionality.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si está usando Perls más viejos que v5.8.0, Perl usará las bibliotecas estándar C de fdopen() para ejecutar la funcionalidad de &quot;=&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an uncaught exception results in interpreter exit, the exit code is
determined from the values of C&lt;$!&gt; and C&lt;$?&gt; with this pseudocode:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171114Z" changeid="explorer">
        <seg>Si se produce una excepción no detectada en la salida del intérprete, el código de salida se determina a partir de los valores de C&lt;$!&gt; y C&lt;$?&gt; con este pseudocódigo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $ref-&gt;[$x][$y]{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $ref-&gt;[$x][$y]{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically all the declarations are put at
the beginning or the end of the script.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Típicamente, todas las declaraciones se ponen al comienzo o al final del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#.5o&gt;', 012;      # prints &quot;&lt;00012&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#.5o&gt;', 012;      # imprime &quot;&lt;00012&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't start caesar: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo iniciar caesar: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reads from the filehandle whose typeglob is contained in EXPR (or from
*ARGV if EXPR is not provided).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lee del gestor de archivo cuyo typeglob esté contenido en EXPR (o desde *ARGV si se omite EXPR).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a run-time error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un error en tiempo de ejecución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;r is a reference to a hash.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;r es una referencia a un hash.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previous steps were performed during the compilation of Perl code,
but this one happens at run time, although it may be optimized to
be calculated at compile time if appropriate.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pasos previos se realizaron durante la compilación de código Perl, pero éste sucede en tiempo de ejecución, aunque puede ser optimizado para ser valorado en tiempo de compilación, si procede.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current package has a subroutine named C&lt;ToLower&gt;, it will be used to
change the case (See L&lt;perlunicode/User-Defined Case Mappings&gt;.)
Otherwise Unicode semantics are used for the case change.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174825Z" changeid="explorer">
        <seg>Si el paquete actual tiene un subrutina denominada C&lt;ToLower&gt;, será utilizada para cambiar el tamaño de caja (ver L&lt;perlunicode/Mapeos de caja definidos por el usuario&gt;). De lo contrario se utiliza semántica Unicode para el cambio de tamaño de caja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>start of the innermost ()-group.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>inicio del grupo () más interno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows programmers to be B&lt;lazy&gt; and to
code in a style with which they are comfortable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Permite a los programadores ser B&lt;perezosos&gt; y codificar en el estilo en que se encuentran más cómodos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For systems from the Microsoft family this means that if your binary
data contains C&lt;\cZ&gt;, the I/O subsystem will regard it as the end of
the file, unless you use binmode().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para los sistemas de la familia Microsoft esto significa que si sus datos binarios contienenC&lt;\cZ&gt;, el subsistema I/O lo considerarán como el fin del archivo, a menos que use binmode().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item bind SOCKET,NAME
X&lt;bind&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165628Z" changeid="explorer">
        <seg>=item bind SOCKET,NOMBRE
X&lt;bind&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you add or delete a hash's elements
while iterating over it, entries may be skipped or duplicated--so don't do
that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si añade o borra un elemento de un hash mientras está iterando sobre él, puede encontrarse con entradas desaparecidas o duplicadas, así que no lo haga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># __DIE__ hooks may modify error messages</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># llamadas __DIE__ pueden modificar los mensajes de error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match 0 or 1 time, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide 0 o 1 veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such literals are accepted by both C&lt;require&gt; and C&lt;use&gt; for
doing a version check.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos literales son aceptadas por ambas C&lt;require&gt; y C&lt;use&gt; para hacer una comprobación de versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the time, the longest possible text that does not include
spaces between components and which contains matching braces or
brackets.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de las veces, el texto más largo posible que no incluya espacios entre los componentes y que contenga un juego de llaves o corchetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators return the
last value in the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven el último valor de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar(@whatever) == $#whatever - $[ + 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>scalar(@loquesea) == $#loquesea - $[ + 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = @b || @c;		# this is wrong</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@a = @b || @c;		# esto es un error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type-casting operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operador de Forzado de tipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may find it helpful to use letter case to indicate the scope
or nature of a variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede encontrar útil usar el tamaño de caja de las letras para indicar el ámbito o naturaleza de una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/c&gt; modifier is specified, the SEARCHLIST character set
is complemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se especifica el modificador C&lt;/c&gt;, el conjunto de caracteres LISTA_BÚSQUEDA es complementado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that the final match
did not update C&lt;pos&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También tenga en cuenta que la última coincidencia no actualizó C&lt;pos&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:encoding&gt; layer sometimes needs to be called in
mid-stream, and it doesn't flush the stream.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La capa C&lt;:encoding&gt; algunas veces necesita ser llamada en mitad del flujo de datos y no lo vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A character range may be specified with a hyphen, so C&lt;tr/A-J/0-9/&gt;
does the same replacement as C&lt;tr/ACEGIBDFHJ/0246813579/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un intervalo de caracteres se puede especificar con un guión, por lo que C&lt;tr/A-J/0-9/&gt; es la sustitución de C&lt;tr/ACEGIBDFHJ/0246813579/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From this we can determine that Perl is different
things to different people, but that lots of people think it's at least
worth writing about.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224632Z" changeid="explorer">
        <seg>Esto refleja el hecho de que, aunque Perl tiene muchos públicos distintos, muchas personas piensan que merece la pena escribir sobre este lenguaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= += -= *= etc.  ?     zero or one          /g global</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043428Z" changeid="explorer">
        <seg>= += -= *= etc.  ?     cero o más           /g global</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wanted to keep track of subscripts, you might do this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193838Z" changeid="explorer">
        <seg>Si quisiera hacer un seguimiento de los subíndices, podría hacer lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;=  greater than or equal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&gt;=  mayor o igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (%a_hash)   { print &quot;has hash members\n&quot;   }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (%a_hash)   { print &quot;el hash tiene miembros\n&quot;   }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;We have no bananas&quot; unless $bananas;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235734Z" changeid="zipf">
        <seg>print &quot;No quedan plátanos&quot; unless $platanos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After C&lt;each&gt; has returned all entries from the hash or array, the next
call to C&lt;each&gt; returns the empty list in list context and C&lt;undef&gt; in
scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Después de C&lt;each&gt; haya devuelto todas las entradas del hash o del array, la siguiente llamada a C&lt;each&gt; devuelve la lista vacía en contexto lista y C&lt;undef&gt; en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treat string as single line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Trata a la cadena como una sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#etc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that if you put literal backslashes (those not inside
interpolated variables) between C&lt;\Q&gt; and C&lt;\E&gt;, double-quotish
backslash interpolation may lead to confusing results.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si pone contrabarras literales (no dentro delas variables interpoladas) entre C&lt;\Q&gt; y C&lt;\E&gt;, una interpolación con doble escapado de contrabarras puede llevar a resultados confusos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># do something</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># hacer algo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item no MODULE VERSION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item no MÓDULO VERSIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dir    = (getpwnam(&quot;daemon&quot;))[7];  # likewise, but with list</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$dir      = (getpwnam(&quot;daemon&quot;))[7]; # lo mismo, pero con una lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though it looks like they're the same method calls (uid),
they aren't, because a C&lt;File::stat&gt; object is different from
a C&lt;User::pwent&gt; object.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso aunque parezcan los mismos métodos (uid), no lo son, porque un objeto C&lt;File::stat&gt; es diferente de un objeto C&lt;User::pwent&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Double quotes indicate that the text will be interpolated using exactly
the same rules as normal double quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las dobles comillas indican que el texto será interpolado usando exactamente las mismas reglas que las cadenas con dobles comillas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get lower-case greek letters, use this instead:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener las letras minúsculas griegas, utilice en su lugar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you read this file _as_is_, just ignore the funny characters you
see.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si lees este archivo _tal_como_es_, ignora los caracteres curiosos que veas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%i    a synonym for %d</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%i    un sinónimo para %d</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Compound Statements
X&lt;statement, compound&gt; X&lt;block&gt; X&lt;bracket, curly&gt; X&lt;curly bracket&gt; X&lt;brace&gt;
X&lt;{&gt; X&lt;}&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt; X&lt;until&gt; X&lt;foreach&gt; X&lt;for&gt; X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013240Z" changeid="explorer">
        <seg>=head2 Instrucciones compuestas
X&lt;statement, compound&gt; X&lt;block&gt; X&lt;bracket, curly&gt; X&lt;curly bracket&gt; X&lt;brace&gt;
X&lt;{&gt; X&lt;}&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt; X&lt;until&gt; X&lt;foreach&gt; X&lt;for&gt; X&lt;continue&gt; X&lt;instrucción, compuesta&gt; X&lt;bloque&gt; X&lt;llave&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Leading white space is ignored without warning, as too are any trailing 
non-digits, such as a decimal point (C&lt;oct&gt; only handles non-negative
integers, not negative integers or floating point).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco que le rodea es ignorado sin avisar, como también cualquier otro carácter que no sea un dígito, como un punto decimal (C&lt;oct&gt; sólo maneja números enteros no negativos, no enteros negativos o en punto flotante).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-k  File has sticky bit set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-k  Archivo tiene puesto el bit sticky.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This string is true in boolean context and C&lt;0&gt;
in numeric context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta cadena es verdadero en contexto booleano y C&lt;0&gt; en contexto numérico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Detached threads aren't supported on Windows yet, as they may lead to 
memory access violation problems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hilos independientes todavía no son compatibles con Windows, ya que pueden provocar problemas de violación de acceso a memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perluts		Perl notes for UTS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perluts		Notas para UTS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $x ( 3, 7, 9 ) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $x ( 3, 7, 9 ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hash code has been refactored to reduce source duplication.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El código hash ha sido reprogramado para reducir la duplicación de código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;FOO&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;FOO&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILENO this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FILENO este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignore the warning.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004832Z" changeid="explorer">
        <seg>No haga caso de la advertencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is exactly equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es exáctamente equivalente a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ones = (5) x @ones;	# set all elements to 5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@unos = (5) x @unos;	# pone todos los elementos a 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir($foo) * 20;	# (chdir $foo) * 20</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir($foo) * 20;	# (chdir $foo) * 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl progname.pl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl nombre_programa.pl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The form C&lt;while/if BLOCK BLOCK&gt;, available in Perl 4, is no longer
available.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;while/if BLOQUE BLOQUE&gt;, existente en Perl 4, ya no está disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the sake
of portability it is a good idea to always use it when appropriate,
and to never use it when it isn't appropriate.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una mejor portabilidad es una buena idea siempre usarlo cuando sea apropiado, y nunca usarlo cuando no sea apropiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example in C&lt;\x{...}&gt;, regardless of the C&lt;/x&gt; modifier, there can be no
spaces.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, en C&lt;\x{...}&gt;, independientemente del modificador C&lt;/x&gt;, no puede tener espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions obsoleted in perl5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones obsoletas en perl5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned values are copies of the original keys in the hash, so
modifying them will not affect the original hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores devueltos son copias de las claves originales en el hash, así que modificarlas no afectará al hash original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a Unix-like system, these documentation files will usually also be
available as manpages for use with the F&lt;man&gt; program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En un sistema de la familia Unix, esta documentación estará también, por lo general, disponible como páginas de manual para su uso con el programa F&lt;man&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly for the C&lt;:encoding&gt; pragma:
in that case pretty much any characters can be read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, para el pragma C&lt;:encoding&gt;: en este caso casi todos los caracteres se pueden leer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following table, a C&lt;{}&gt; represents
any pair of delimiters you choose.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la siguiente tabla, un C&lt;{}&gt; representa cualquier par de delimitadores que usted elija.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return wantarray ? @a : &quot;@a&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052539Z" changeid="explorer">
        <seg>return wantarray ? @a : &quot;@a&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&lt;&quot; returns true if the left argument is numerically less than
the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&lt;&quot; devuelve verdadero si el argumento de la izquierda es numéricamente menor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Truth and Falsehood
X&lt;truth&gt; X&lt;falsehood&gt; X&lt;true&gt; X&lt;false&gt; X&lt;!&gt; X&lt;not&gt; X&lt;negation&gt; X&lt;0&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040949Z" changeid="explorer">
        <seg>=head2 Verdad y Falsedad
X&lt;truth&gt; X&lt;falsehood&gt; X&lt;true&gt; X&lt;false&gt; X&lt;!&gt; X&lt;not&gt; X&lt;negation&gt; X&lt;0&gt; X&lt;verdad&gt; X&lt;falsedad&gt; X&lt;verdadero&gt; X&lt;falso&gt; X&lt;negación&gt; X&lt;no&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use NDBM_File;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use NDBM_File;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl will still very
probably be part of the &quot;default install&quot;, and in any case the latest
version will be in the ports system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl seguirá, probablemente, formando parte de la &quot;instalación por defecto&quot; y en cualquier caso la último versión será adaptada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\L		lowercase till \E (think vi)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\L		minúscula hasta \E (como en vi)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12652</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12652</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlre - Perl regular expressions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlre - Expresiones regulares en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No idea
how to fix this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No tengo idea de cómo solucionar este problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting a hash element to the undefined value does
not remove its key, but deleting it does; see L&lt;/exists&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Poner un elemento hash al valor indefinido no elimina su clave, pero eliminándolo sí que lo hace; véase L&lt;/exists&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 2) = 2   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 2) = 2   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ...;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ...;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;axyz&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># &quot;axyz&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str = 'ABC';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$str = 'ABC';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of subroutine call is deprecated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma de llamada de subrutina ha sido depreciada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unlink LIST
X&lt;unlink&gt; X&lt;delete&gt; X&lt;remove&gt; X&lt;rm&gt; X&lt;del&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210151Z" changeid="explorer">
        <seg>=item unlink LISTA
X&lt;unlink&gt; X&lt;delete&gt; X&lt;remove&gt; X&lt;rm&gt; X&lt;del&gt; X&lt;elimina&gt; X&lt;borra&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it's exactly the same as C&lt;||&gt;, except that it
tests the left hand side's definedness instead of its truth.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De hecho, es exactamente lo mismo que C&lt;||&gt;, excepto que comprueba la definición del lado izquierdo en lugar de su estado de verdad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
returns log of C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, devuelve el logaritmo de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can avoid this
problem by using C&lt;pipe&gt; instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede evitar este problema mediante el uso, en su lugar, de C&lt;pipe&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Hashes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232610Z" changeid="explorer">
        <seg>=item Hashes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An C&lt;eof&gt; without an argument uses the last file read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;eof&gt; sin argumento usa el último archivo leído.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;++&quot; and &quot;--&quot; work as in C.  That is, if placed before a variable,
they increment or decrement the variable by one before returning the
value, and if placed after, increment or decrement after returning the
value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;++&quot; y &quot;--&quot; funcionan como en C. Es decir, si son colocados antes de una variable, incrementan o decrementan la variable por uno antes de devolver el valor, y colocados después, incrementan o decrementan después de haber devuelto el valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Long lines broken after an operator (except C&lt;and&gt; and C&lt;or&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dividir líneas largas después de un operador (excepto C&lt;and&gt; y C&lt;or&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read the documentation for the C&lt;filetest&gt; pragma for more
information.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información, lea la documentación del pragma C&lt;filetest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LOCK_NB is bitwise-or'ed with
LOCK_SH or LOCK_EX then C&lt;flock&gt; returns immediately rather than blocking
waiting for the lock; check the return status to see if you got it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LOCK_NB se combina a nivel de bit con 'or' con LOCK_SH o LOCK_EX entonces C&lt;flock&gt; regresa inmediatamente en vez de esperar por el bloqueo; compruebe el valor de estado devuelto para ver si lo ha conseguido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If CMD is IPC_STAT or
GETALL, then ARG must be a variable that will hold the returned
semid_ds structure or semaphore value array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si CMD es IPC_STAT o GETALL, entonces ARG debe ser una variable que contendrá la estructura semid_ds devuelta o el array de semáforos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you had the entire header of a normal Unix email message in $header,
you could split it up into fields and their values this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted tuviera el encabezado completo de un mensaje de correo electrónico Unix normal en $encabezado, puede dividirlo en sus campos y valores de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example under C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver ejemplo en C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in doubt, use C&lt;*FH&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de duda, use C&lt;*FH&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent examples:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplos equivalentes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 4) = 4   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 4) = 4   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also using &quot;+&lt;&quot;
works for symmetry, but you really should consider writing something
to the temporary file first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También usando &quot;+&lt;&quot; trabaja de forma simétrica, pero debe considerar, realmente, en primer lugar, escribir algo en el archivo temporal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;exec&gt; will not call your C&lt;END&gt; blocks, nor will it invoke
C&lt;DESTROY&gt; methods on your objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;exec&gt; no llamará a sus bloques C&lt;END&gt;, ni llamará a ningún método C&lt;DESTROY&gt; de sus objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GETC this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>GETC este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlrun		Perl execution and options</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlrun		Ejecución y opciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = kill 1, $child1, $child2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = kill 1, $child1, $child2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BUILD AND INSTALL</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 CONSTRUCCIÓN E INSTALACIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use Module VERSION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item use Módulo VERSIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results follow ASCII semantics.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174525Z" changeid="explorer">
        <seg>Los resultados siguen la semántica ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that splitting an EXPR that evaluates to the
empty string always returns the empty list, regardless of the LIMIT
specified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que la división de una EXPR que evalúe a una cadena vacía siempre devuelve una lista vacía, sin importar el LÍMITE especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because each operand is evaluated in integer form, C&lt;2.18 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que cada operando es evaluado en forma de número entero, C&lt;2,18 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto-&amp;NAME&gt; form is quite different from the other forms of
C&lt;goto&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto-&amp;NOMBRE&gt; es muy diferente de las otras formas de C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to the following Perl-like pseudo code:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es equivalente al siguiente pseudo código Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid statements like:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012110Z" changeid="explorer">
        <seg>Evite instrucciones como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $num = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232654Z" changeid="explorer">
        <seg>my $num = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declares the compilation unit as being in the given namespace.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Declara que la compilación está en el espacio de nombres indicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@whatever = ();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@loquesea  = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub fp_equal {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub fp_igual {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates the directory specified by FILENAME, with permissions
specified by MASK (as modified by C&lt;umask&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea el directorio especificado por el nombre de ARCHIVO, con permisos especificados por la MÁSCARA (y modificada por C&lt;umask&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hostname is $2\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T031204Z" changeid="explorer">
        <seg>print &quot;El nombre del servidor es $2\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names that start with a digit may contain only more digits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres que comienzan con un dígito, solo pueden contener más dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Perl is configured to use ithreads, it will use re-entrant library calls
in preference to non-re-entrant versions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando Perl está configurado para usar ithreads, usará llamadas de biblioteca reentrantes preferentemente sobre versiones no-reentrantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-W  File is writable by real uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004551Z" changeid="explorer">
        <seg>-W  Archivo es escribible por el uid/gid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix unpack U to be the reverse of pack U</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>arreglo de unpack(&quot;U&quot;) para que sea el inverso de pack(&quot;U&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack('(sl)&lt;', -42, 4711);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack('(sl)&lt;', -42, 4711);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $substring = 'quick.*?fox';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T193102Z" changeid="explorer">
        <seg>my $subcadena = 'rápido.*?zorro';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double d;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>double d;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lstat</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item lstat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space after each comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio después de cada coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;.&quot; concatenates two strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;.&quot; concatena dos cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So how come you can write these:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que ¿cómo entonces puede escribir lo siguiente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that the interpolation code needs to make a decision on
where the interpolated scalar ends.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta también que el código de interpolación tiene que tomar una decisión sobre dónde termina el escalar interpolado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 8, 2) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 8, 2) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qx/STRING/
X&lt;qx&gt; X&lt;`&gt; X&lt;``&gt; X&lt;backtick&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010238Z" changeid="explorer">
        <seg>=item qx/CADENA/
X&lt;qx&gt; X&lt;`&gt; X&lt;``&gt; X&lt;backtick&gt; X&lt;comilla invertida&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*s&gt;',  7, &quot;string&quot;;   # prints &quot;&lt;string&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*s&gt;',  7, &quot;cadena&quot;;   # imprime &quot;&lt;cadena&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @INC, \&amp;my_sub;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @INC, \&amp;mi_sub;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.23E-10             # a very small number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>.23E-10             # un número muy pequeño</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Scalar values
X&lt;scalar&gt; X&lt;number&gt; X&lt;string&gt; X&lt;reference&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035219Z" changeid="explorer">
        <seg>=head2 Valores escalares
X&lt;scalar&gt; X&lt;number&gt; X&lt;string&gt; X&lt;reference&gt; X&lt;escalar&gt; X&lt;número&gt; X&lt;cadena&gt; X&lt;referencia&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 4) = 8   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 4) = 8   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the PATTERN evaluates to the empty string, the last
I&lt;successfully&gt; matched regular expression is used instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el PATRÓN se evalúa como la cadena vacía, es usada en su lugar la última I&lt;exitosa&gt; expresión regular coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$i = $i ++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$i = $i ++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Named Unary Operators
X&lt;operator, named unary&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234848Z" changeid="explorer">
        <seg>=head2 Operadores unarios con nombre
X&lt;operator, named unary&gt; X&lt;operador, unario con nombre&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5114delta	Perl changes in version 5.11.4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5114delta	Cambios en la versión 5.11.4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If OFFSET is negative then it starts that far from the end of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el DESPLAZAMIENTO es negativo, se cuenta la posición desde el final del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;use strict 'refs'&gt; forbids such practice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;use strict 'refs'&gt; prohíbe tal práctica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behaviour is determined by the following table: the first row
that applies determines the match behaviour (which is thus mostly
determined by the type of the right operand).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento está determinado por la siguiente tabla: la primera fila que se pueda aplicar determina el comportamiento de la coincidencia (que principalmente está determinado por el tipo del operando derecho).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>modulo (%) preserving 64-bit integers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>módulo (%) preserva los enteros de 64 bits</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $i ( 1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $i ( 1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X DIRHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211143Z" changeid="explorer">
        <seg>=item -X GESTOR_DIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$parent = $ISA[0];                  # one element from the array</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$padre    = $ISA[0];                 # un elemento desde el array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlport&gt; for notes on the
portability of C&lt;select&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también L&lt;perlport&gt; para las notas sobre la portabilidad de C&lt;select&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;!=&quot; returns true if the left argument is numerically not equal
to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;!=&quot; devuelve verdadero si el argumento de la izquierda es numéricamente distinto que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlink(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlink(&quot;alfa&quot;, &quot;beta&quot;, &quot;gamma&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* / % x                 SYNTAX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>* / % x                 SINTAXIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{bar}  # with bar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{bar}  # por bar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, typing in your own password to whoever asks you
for it is unwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Naturalmente es muy imprudente dar la propia contraseña a cualquiera que lo pregunte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $foo = 20;          # no warning about duplicate my $foo,
                           # but hey, you asked for it!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052618Z" changeid="explorer">
        <seg>my $foo = 20;          # no avisa de un my $foo duplicado,
                           # pero bueno, ¡tú lo has querido!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll have to negotiate C&lt;$|&gt;
on your own, though.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque, tendrá que negociar también con C&lt;$|&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line-noise lowercase line-noise lowercase UPPERCASE line-noise</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>línea-ruidosa minúsculas línea-ruidosa minúsculas MAYÚSCULAS línea-ruidosa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item utime LIST
X&lt;utime&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210739Z" changeid="explorer">
        <seg>=item utime LISTA
X&lt;utime&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># using m//gc with \G</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># usando m//gc con \G</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.8.1 release and
the 5.8.2 release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe las diferencias entre la versión 5.8.1 y la versión 5.8.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SHIFT this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SHIFT este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, those variables will never be reinitialized, contrary to
lexical variables that are reinitialized each time their enclosing block
is entered.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, estas variables no se reinicializan, a diferencia de las variables léxicas que se reinicializan cada vez que entran en un bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All variables and arrays beginning with one of
those letters are reset to their pristine state.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todas las variables y arrays que comiencen con una de esas letras son restablecidas a su estado prístino.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;glob&gt; splits its arguments on whitespace and treats
each segment as separate pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que C&lt;glob&gt; divide sus argumentos por los espacios en blanco y trata a cada segmento como patrones independientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>statements;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>instrucciones;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that this does not always work for quoting Perl code:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nótese, sin embargo, que esto no siempre funciona para entrecomillar código Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close ARGV if eof;  # Not eof()!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close ARGV if eof;  # ¡No eof()!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = [ somefunc($i) ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$i] = [ algunafuncion($i) ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets FILEHANDLE's system position in bytes using 
lseek(2).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204346Z" changeid="explorer">
        <seg>Establece la posición del GESTOR_ARCHIVO en bytes usando lseek(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec '/bin/echo', 'Your arguments are: ', @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec '/bin/echo', 'Tus argumentos son: ', @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These differ in their precedence relationship with a
following comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Difieren en su relación de precedencia cuando son seguidos por una coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do case-insensitive pattern matching.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace coincidencia de patrones sin importar si son mayúsculas o minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elsif ($?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>elsif ($?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO) or die &quot;Can't open $FOO: $!&quot;;	# FOO or bust!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO) or die &quot;No puedo abrir $FOO: $!&quot;;	# ¡FOO o quieto!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is only one scalar argument, the argument
is checked for shell metacharacters, and if there are any, the
entire argument is passed to the system's command shell for parsing
(this is C&lt;/bin/sh -c&gt; on Unix platforms, but varies on other
platforms).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sólo hay un argumento escalar, se comprueba si el argumento tiene metacaracteres, y si hay alguno, el argumento entero es pasado al shell de comandos para que sea interpretado (suele ser C&lt;/bin/sh -c&gt; en plataformas Unix, pero varía en otras plataformas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This might
as well break the build, though.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto, sin embargo, también podría romper la compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, a list of
values is returned, one per line of output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, se devuelve una lista de valores, uno por cada línea de la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And now some examples as a list operator:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y ahora algunos ejemplos como un operadores de lista:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;\t [ @$aref ],\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052825Z" changeid="explorer">
        <seg>print &quot;\t [ @$aref ],\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;seek&gt; doesn't change the position,
but it I&lt;does&gt; clear the end-of-file condition on the handle, so that the
next C&lt;&lt; &lt;FILE&gt; &gt;&gt; makes Perl try again to read something.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;seek&gt; no cambia la posición, pero I&lt;borra&gt; la condición de final de archivo en el gestor de archivo, para que el próximo C&lt;&lt; &lt;FILE&gt; &gt;&gt; haga que Perl intente de nuevo leer algo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Fetching user and group info
X&lt;user&gt; X&lt;group&gt; X&lt;password&gt; X&lt;uid&gt; X&lt;gid&gt;  X&lt;passwd&gt; X&lt;/etc/passwd&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202358Z" changeid="explorer">
        <seg>=item Obteniendo información de usuarios y grupos
X&lt;user&gt; X&lt;group&gt; X&lt;password&gt; X&lt;uid&gt; X&lt;gid&gt; X&lt;passwd&gt; X&lt;/etc/passwd&gt; X&lt;usuario&gt; X&lt;grupo&gt; X&lt;contraseña&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>le  less than or equal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>le  menor o igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>uopt: Warning: Perl_yylex: this procedure not optimized because it</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004821Z" changeid="explorer">
        <seg>uopt: Warning: Perl_yylex: this procedure not optimized because it</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @nums = @caps = ();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @numeros = @mayusculas = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can be
used to capture the results of parts of the regexp match for later use.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225501Z" changeid="explorer">
        <seg>se pueden usar para capturar los resultados de partes de una expresión regular a fin de usarlos posteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Portability
X&lt;portability&gt; X&lt;Unix&gt; X&lt;portable&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165322Z" changeid="explorer">
        <seg>=head2 Portabilidad
X&lt;portability&gt; X&lt;Unix&gt; X&lt;portable&gt; X&lt;portabilidad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;suidperl&gt;
is neither built nor installed by default, and has been deprecated since
perl 5.8.0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;suidperl&gt; no es construido ni instalado por defecto, y es obsoleto desde perl 5.8.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't use a
string literal (or other read-only string) as an argument to C&lt;syscall&gt;
because Perl has to assume that any string pointer might be written
through.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se puede utilizar una cadena literal (u otras cadenas de sólo lectura) como un argumento a C&lt;syscall&gt; porque Perl tiene que asumir que cualquier puntero de cadena puede ser escrita a través de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of characters sent,
or the undefined value on error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de caracteres enviados, o el valor indefinido en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item substr EXPR,OFFSET,LENGTH,REPLACEMENT
X&lt;substr&gt; X&lt;substring&gt; X&lt;mid&gt; X&lt;left&gt; X&lt;right&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201824Z" changeid="explorer">
        <seg>=item substr EXPR,DESPLAZAMIENTO,LONGITUD,REEMPLAZO
X&lt;substr&gt; X&lt;substring&gt; X&lt;mid&gt; X&lt;left&gt; X&lt;right&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;endgrent&gt;, C&lt;endhostent&gt;, C&lt;endnetent&gt;, C&lt;endpwent&gt;, C&lt;getgrent&gt;,
C&lt;getgrgid&gt;, C&lt;getgrnam&gt;, C&lt;getlogin&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;,
C&lt;getpwuid&gt;, C&lt;setgrent&gt;, C&lt;setpwent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202400Z" changeid="explorer">
        <seg>C&lt;endgrent&gt;, C&lt;endhostent&gt;, C&lt;endnetent&gt;, C&lt;endpwent&gt;, C&lt;getgrent&gt;,
C&lt;getgrgid&gt;, C&lt;getgrnam&gt;, C&lt;getlogin&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;,
C&lt;getpwuid&gt;, C&lt;setgrent&gt;, C&lt;setpwent&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a += 1;        # same as $a = $a + 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a += 1;        # igual que $a = $a + 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If DIRHANDLE is an undefined
scalar variable (or array or hash element), the variable is assigned a
reference to a new anonymous dirhandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si GESTOR_DIR es una variable escalar indefinida (o array o elemento hash), a la variable se le asigna una referencia a un nuevo gestor de directorio anónimo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, &quot;&lt;:encoding(UTF-8)&quot;, &quot;filename&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $fh, &quot;&lt;:encoding(UTF-8)&quot;, &quot;archivo&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the rule for zero-length
matches is modified somewhat, in that contents to the left of C&lt;\G&gt; is
not counted when determining the length of the match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuanto que la norma para las coincidencias de tamaño cero ha sido modificada en cierta medida, en que los contenidos a la izquierda de C&lt;\G&gt; no son tenidos en cuenta cuando se determina la longitud de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @transformed = map {; ... } @input; # ; disambiguates</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @transformado = map {; ... } @entrada; # ; desambigüedad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not want to call the package's C&lt;import&gt; method (for instance,
to stop your namespace from being altered), explicitly supply the empty list:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no desea llamar al método C&lt;import&gt; del paquete (por ejemplo, para impedir que su espacio de nombres sea alterado), indique, de manera explícita, una lista vacía:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $key, '=', $ENV{$key}, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $key, '=', $ENV{$key}, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The difference is that C
does not offer named loops combined with loop control.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(La diferencia con C es que no ofrece bucles nominales combinados con control de bucles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor, as determined by the
value of $^F.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soportan la bandera cerrar-en-ejecución sobre archivos, la bandera será puesta para el nuevo descriptor de archivo abierto, determinado por el valor de $^F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlutil		utilities packaged with the Perl distribution</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlutil		utilidades empaquetadas con la distribución Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo, 94,  1) = 1;      # 'PerlPerlPerl'
                                   # 'l' is &quot;\x6c&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052430Z" changeid="explorer">
        <seg>vec($foo, 94,  1) = 1;      # 'PerlPerlPerl'
                                   # 'l' es &quot;\x6c&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$in_body   = /^$/ ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$en_cuerpo   = /^$/ ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Typeglobs and Filehandles
X&lt;typeglob&gt; X&lt;filehandle&gt; X&lt;*&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035940Z" changeid="explorer">
        <seg>=head2 Typeglobs y controladores de archivo
X&lt;typeglob&gt; X&lt;filehandle&gt; X&lt;*&gt; X&lt;controlador de archivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>echo hi there</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>echo Hola, qué tal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there's an error, returns the undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay un error, devuelve el valor indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 9, 1) = 1   ==        512 00000000010000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 9, 1) = 1   ==        512 00000000010000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a simpleminded Pascal comment stripper</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># elimina ingenuamente comentarios Pascal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;@INC&quot;			locations of perl libraries</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011826Z" changeid="explorer">
        <seg>&quot;@INC&quot;			posiciones de las bibliotecas perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several special variables also refer back to portions of the previous
match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Varias variables especiales también se refieren a porciones de la coincidencia anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltru64		Perl notes for Tru64</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perltru64		Notas para Tru64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your system supports
only the older DBM functions, you may make only one C&lt;dbmopen&gt; call in your
program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su sistema sólo soporta las viejas funciones DBM, sólo puede realizar una llamada C&lt;dbmopen&gt; en su programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, it'll need
to be executable first, so C&lt;chmod 755 script.pl&gt; (under Unix).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224647Z" changeid="explorer">
        <seg>Por supuesto, antes deberá marcarlo como ejecutable con el comando C&lt;chmod 755 script.pl&gt; (en Unix).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, C&lt;&quot;$foo XXX '@arr'&quot;&gt; becomes:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, C&lt;&quot;$foo XXX '@arr'&quot;&gt; se convierte en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>IO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>list ops         ()    capture</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>op. lista        ()    captura</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rand EXPR
X&lt;rand&gt; X&lt;random&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194331Z" changeid="explorer">
        <seg>=item rand EXPR
X&lt;rand&gt; X&lt;random&gt; X&lt;aleatorio&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item my TYPE EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item my TYPE EXPR : ATRIBUTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supplying a count to the I&lt;length-item&gt; format letter is only useful with
C&lt;A&gt;, C&lt;a&gt;, or C&lt;Z&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192320Z" changeid="explorer">
        <seg>Indicando un contador al formato I&lt;longitud-item&gt; solo es útil para C&lt;A&gt;, C&lt;a&gt;, o C&lt;Z&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq6		Regexes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq6		Expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For threaded builds for modules calling certain re-entrant system calls,
binary compatibility was accidentally lost between 5.8.0 and 5.8.1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se perdió, accidentalmente, la compatibilidad binaria entre 5.8.0 y 5.8.1, en la construcción de módulos en paralelo, al llamar a ciertas llamadas del sistema reentrantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although in early versions of Perl,
an undefined scalar could become defined when first used in a
place expecting a defined value, this no longer happens except for
rare cases of autovivification as explained in L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque en las versiones anteriores de Perl, un escalar no definido podía llegar a ser definido la primera vez que se usaba en cualquier lugar que esperase un valor definido, esto no va a ocurrir más, excepto en los raros casos de &quot;autovivificación&quot; que se explican en L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exceeds size threshold; to optimize this procedure, use -Olimit option</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004826Z" changeid="explorer">
        <seg>exceeds size threshold; to optimize this procedure, use -Olimit option</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($x = 4; $x &lt;= 8; $x++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053014Z" changeid="explorer">
        <seg>for ($x = 4; $x &lt;= 8; $x++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Symbol table entries can be named with an initial '*',
but you don't really care about that yet (if ever :-).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las entradas de la tabla de símbolos pueden nombrarse empezando por '*', aunque no hace falta que se preocupe por esto ahora (y quizá nunca deba hacerlo :-).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function causes an immediate core dump.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función provoca un volcado inmediato del núcleo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it's possible to confuse Perl into thinking C&lt;//&gt; (the empty
regex) is really C&lt;//&gt; (the defined-or operator).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que es posible confundir a Perl haciéndolo creer que C&lt;//&gt; (la expresión regular vacía) es en realidad C&lt;//&gt; (el operador definido-o).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing, but much more efficiently;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, pero mucho más eficiente;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;\g{-1}&gt; refers to the last buffer, C&lt;\g{-2}&gt; refers to the
buffer before that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, C&lt;\g{-1}&gt; se refiere a la última memoria de captura, y C&lt;\g{-2}&gt; se refiere a la memoria intermedia anterior a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset 'a-z';    # reset lower case variables</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>reset 'a-z';    # reinicia las variables con minúsculas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (-s $file &gt; 5 + 100 * 2**16) {  }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (-s $archivo &gt; 5 + 100 * 2**16) {  }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bracketing construct C&lt;( ... )&gt; creates capture buffers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La construcción de paréntesis C&lt;( ... )&gt; crea memorias de captura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;rmdir&gt; instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilice C&lt;rmdir&gt; en su lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>jJfFdDpP   (The &quot;big end&quot; touches the construct.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>jJfFdDpP   (El &quot;big end&quot; toca la construcción).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9 mtime               9 bitmask      @ARGV command line args</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>9 mtime               9 bitmask      @ARGV args. línea comandos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They're more readable than the C-style operators, but have
different precedence to C&lt;&amp;&amp;&gt; and friends.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225248Z" changeid="explorer">
        <seg>Ofrecen más legibilidad que los operadores tipo C correspondientes, como C&lt;&amp;&amp;&gt;, pero su precedencia es distinta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the two digests
match the password is correct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los dos I&lt;digest&gt; coinciden, la contraseña es correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $var;           $$variable_name  perl.com</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $var;           $$variable       perl.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This construct is very flexible and powerful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta construcción es muy flexible y poderosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $Config{intsize},      &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $Config{intsize},      &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print pop(@keys), '=', pop(@values), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print pop(@keys), '=', pop(@values), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is one of the
requirements of C&lt;use strict;&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T230806Z" changeid="explorer">
        <seg>(Éste es uno de los requisitos de C&lt;use strict;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 ino    1 minute     1 filename     $0    program name</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004120Z" changeid="explorer">
        <seg>1 ino    1 minuto     1 nom. archivo $0    nombre programa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Installing the built perl on DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Instalando el perl compilado en DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0xdead_beef         # more hex</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0xdead_beef         # más hex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* unless the delimiter is ''.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>* excepto si el delimitador es ''.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Complex not as efficient as POSIX, but
POSIX can't work with complex numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::Complex no es tan eficiente como POSIX, pero POSIX no puede trabajar con números complejos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This file contains instructions how to build Perl under BeOS and lists
known problems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este archivo contiene instrucciones de cómo construir Perl para BeOS y listas de problemas conocidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default sprintf
will format the next unused argument in the list, but this allows you
to take the arguments out of order:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto sprintf formateará el siguiente argumento no utilizado en la lista, pero esto le permite tomar los argumentos fuera de orden:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;`STRING`&quot;&gt; and L&lt;/exec&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop/&quot;`STRING`&quot;&gt; y L&lt;/exec&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perllinux		Perl notes for Linux</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perllinux		Notas para Linux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your C&lt;umask&gt; were C&lt;0027&gt; (group can't
write; others can't read, write, or execute), then passing
C&lt;sysopen&gt; C&lt;0666&gt; would create a file with mode C&lt;0640&gt; (C&lt;0666 &amp;~
027&gt; is C&lt;0640&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su C&lt;umask&gt; fuera C&lt;0027&gt; (el grupo no puede escribir, los otros no pueden leer, escribir o ejecutar), entonces pasando a C&lt;sysopen&gt; C&lt;0666&gt; creará un archivo con el modo C&lt;0640&gt; (C&lt;0666 &amp;~ 027&gt; es C&lt;0640&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$on_a_tty = -t STDIN &amp;&amp; -t STDOUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$en_un_tty = -t STDIN &amp;&amp; -t STDOUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the left part is delimited by bracketing punctuations (that is C&lt;()&gt;,
C&lt;[]&gt;, C&lt;{}&gt;, or C&lt;&lt; &lt;&gt; &gt;&gt;), the right part needs another pair of
delimiters such as C&lt;s(){}&gt; and C&lt;tr[]//&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la parte izquierda está delimitada por signos de puntuación emparejados (es decir, C&lt;()&gt;, C&lt;[]&gt;, C&lt;{}&gt;, o C&lt;&lt; &lt;&gt; &gt;&gt;), la parte derecha necesita otro par de delimitadores, como en C&lt;s(){}&gt; y C&lt;tr[]//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raises an exception if truncate isn't implemented
on your system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lanza una excepción si truncate no está implementada en el sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict;        DON'T</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use strict;        NO HACER</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The string specified with C&lt;=~&gt; must
be scalar variable, an array element, a hash element, or an assignment
to one of those, i.e., an lvalue.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203614Z" changeid="explorer">
        <seg>(La cadena especificada con C&lt;=~&gt; debe ser una variable escalar, un elemento de un array, un elemento de un hash, o una asignación a una de éstos, es decir, un I&lt;ivalor&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qq/STRING/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item qq/STRING/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is quite safe and will not
produce an endless loop, since C&lt;__WARN__&gt; hooks are not called from
inside one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que esto es bastante seguro y no producirá un bucle sin fin, puesto que los enganches C&lt;__WARN__&gt; no son llamados desde el interior de uno mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod 0644, $_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod 0644, $_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the latter will alternate between returning a filename and
returning false.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ya que este último alternará entre devolver un nombre de archivo y devolver falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will not automatically invoke the overload method with X as an argument;
instead the table above is consulted as normal, and based in the type of X,
overloading may or may not be invoked.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no invocará automáticamente el método sobrecargado con X como argumento; en su lugar, será consultada la tabla anterior, y en base al tipo de X, la sobrecarga será o no invocada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our $bar;      # declares $Foo::bar for rest of lexical scope</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>our $bar;      # declara $Foo::bar para el resto del ámbito léxico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imports some semantics into the current package from the named module,
generally by aliasing certain subroutine or variable names into your
package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Importa semántica en el paquete actual desde el módulo que se indica, generalmente por medio de alias de ciertas subrutinas o nombres de variables en su paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hash or array element can be true only if it's defined, and defined if
it exists, but the reverse doesn't necessarily hold true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un elemento de un hash o de un array puede ser verdadero sólo si está definido, y definido y existe, pero lo inverso no es necesariamente cierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, grep returns aliases into the original list, much as a for
loop's index variable aliases the list elements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Semejantemente, grep devuelve alias de la lista original, como los alias de los elementos de la lista de las variables de los bucles for.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not a C float&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es flotante en C&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it has no repeat count or uses a '*', the number
of available items is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no tiene contador de repeticiones o utiliza un '*', se utiliza el número de elementos disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unlike normal C&lt;open&gt;, the first
argument is I&lt;not&gt; a filehandle, even though it looks like one).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(A diferencia de un C&lt;open&gt; normal, el primer argumento I&lt;no&gt; es un gestor, aunque lo parezca).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;EXPR&gt; following the modifier is referred to as the &quot;condition&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La C&lt;EXPR&gt; siguiente al modificador es referida como la &quot;condición&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, S&lt;C&lt;split(' ')&gt;&gt; can
be used to emulate B&lt;awk&gt;'s default behavior, whereas S&lt;C&lt;split(/ /)&gt;&gt;
will give you as many initial null fields (empty string) as there are leading spaces.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto, S&lt;C&lt;split(' ')&gt;&gt; puede ser utilizado para emular el comportamiento por defecto de B&lt;awk&gt;, mientras que S&lt;C&lt;split(/ /)&gt;&gt; le dará tantos campos nulos iniciales (cadenas vacías) como espacios haya allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You
can truncate an array down to nothing by assigning the null list
() to it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede truncarse un array para dejarlo vacío asignándole la lista nula ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@args = (&quot;command&quot;, &quot;arg1&quot;, &quot;arg2&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@args = (&quot;comando&quot;, &quot;arg1&quot;, &quot;arg2&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prepends list to the front of the
array, and returns the new number of elements in the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Antepone LISTA al principio del array, y devuelve el número de elementos en el array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shortening an array this way destroys intervening values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Acortar un array de esta forma destruye los valores involucrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ALL_CAPS_HERE   constants only (beware clashes with perl vars!)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$TODO_MAYUSCULAS    Sólo constantes (¡cuidado con variables perl!)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Known Problems with Perl on Hurd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Problemas conocidos de Perl sobre Hurd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL while (EXPR) BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA while (EXPR) BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this is
I&lt;NOT&gt; true in C&lt;eval{}&gt;, C&lt;sub{}&gt;, or contrary to popular belief
C&lt;do{}&gt; blocks, which do I&lt;NOT&gt; count as loops.)  The C&lt;continue&gt;
block is optional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Note que esto I&lt;NO&gt; es verdad en C&lt;eval{}&gt;, C&lt;sub{}&gt;, y contrariamente a la creencia popular, bloques C&lt;do{}&gt;, que I&lt;NO&gt; cuentan como bucles). El bloque C&lt;continue&gt; es opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = tr/*/*/;		# count the stars in $_</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = tr/*/*/;		# cuenta los asteriscos en $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, while searching
for closing C&lt;]&gt; paired with the opening C&lt;[&gt;, combinations of C&lt;\\&gt;, C&lt;\]&gt;,
and C&lt;\[&gt; are all skipped, and nested C&lt;[&gt; and C&lt;]&gt; are skipped as well.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, mientras se busca el C&lt;]&gt; de cierre  emparejado con el de apertura C&lt;[&gt;, combinaciones de C&lt;\\&gt;, C&lt;\]&gt; y C&lt;\[&gt; son todos omitidos, y anidados de C&lt;[&gt; y C&lt;]&gt; se pasan también por alto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may omit the mode in these forms when that mode is
C&lt;&lt; '&lt;' &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede omitir el modo en estos formatos cuando el modo sea C&lt;&lt; '&lt;' &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hersockaddr    = getpeername(SOCK);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$hersockaddr    = getpeername(SOCK);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt; and C&lt;V&gt; accept the C&lt;!&gt; modifier to
represent signed 16-/32-bit integers in big-/little-endian order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt; y C&lt;V&gt; aceptan el modificador C&lt;!&gt; para representar enteros de 16-/32-bit con signo en distinta ordenación de bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$setbits = unpack(&quot;%32b*&quot;, $selectmask);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bitspuestos = unpack(&quot;%32b*&quot;, $mascara);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;a &quot; . $b . &quot; -&gt; {c}&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054412Z" changeid="explorer">
        <seg>&quot;a &quot; . $b . &quot; -&gt; {c}&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Demands a version of Perl specified by VERSION, or demands some semantics
specified by EXPR or by C&lt;$_&gt; if EXPR is not supplied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Exige una versión de Perl especificada por VERSIÓN, o exige una semántica especificada por EXPR, o por C&lt;$_&gt; si EXPR se omite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore a C&lt;/&gt; terminates a C&lt;qq//&gt; construct, while a C&lt;]&gt; terminates
C&lt;qq[]&gt; and C&lt;qq]]&gt; constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto, una C&lt;/&gt; termina una construcción C&lt;qq//&gt;, mientras que un C&lt;]&gt; termina las construcciones C&lt;qq[]&gt; y C&lt;qq]]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although not for the faint of heart, Perl does support a C&lt;goto&gt;
statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013534Z" changeid="explorer">
        <seg>Aunque no sea muy querido, Perl soporta la instrucción C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># prints +15241578780673678515622620750190521</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># imprime +15241578780673678515622620750190521</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is just a selected list of some of the more notable changes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es sólo una selección de algunos de los cambios más notables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the BSD 4.2 version of C&lt;setpgrp&gt; does not
accept any arguments, so only C&lt;setpgrp(0,0)&gt; is portable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que la versión de BSD 4.2 de C&lt;setpgrp&gt; no acepta ningún argumento, por lo que sólo C&lt;setpgrp(0,0)&gt; es portátil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the POSIX version of C&lt;getpgrp&gt;
does not accept a PID argument, so only C&lt;PID==0&gt; is truly portable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la versión POSIX de C&lt;getpgrp&gt; no acepta un argumento PID, por lo que sólo C&lt;PID==0&gt; es verdaderamente portable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\e		escape (think troff)  (ESC)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\e		escape (como en troff)(ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>||  or</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232644Z" changeid="explorer">
        <seg>||  or</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die unless $@ =~ /Expected exception/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die unless $@ =~ /Expected exception/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,28, 1) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,28, 1) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item no VERSION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item no VERSIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( /$pattern/ ) { }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234725Z" changeid="explorer">
        <seg>if ( /$patron/ ) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The documentation for the special code blocks (BEGIN, CHECK, INIT, END)
has been improved.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La documentación de los bloques especiales (BEGIN, CHECK, INIT, FIN) ha sido mejorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We see this as the
lesser of two evils.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vemos esto como el menor de dos males.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt;ABC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt;ABC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The precedence is a little lower
than || and &amp;&amp;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La precedencia es un poco menor que || y &amp;&amp;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::BigInteger	uses an external C library</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::BigInteger         usa una biblioteca C externa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The L&lt;File::stat&gt; module provides a convenient, by-name access mechanism:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo &lt;File::stat&gt; proporciona un conveniente mecanismo de acceso por nombre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\b  Match a word boundary</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225642Z" changeid="explorer">
        <seg>\b  Coincide con un límite de palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some
systems, a value of 0 indicates that there are processes still running.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas, un valor de 0 indica que hay procesos en funcionamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,}   Match at least n times</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n,}   Coincide al menos n veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ?PATTERN?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item ?PATRÓN?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 4) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 4) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;a &quot; . $b -&gt; {c};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054416Z" changeid="explorer">
        <seg>&quot;a &quot; . $b -&gt; {c};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given($foo) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>given($foo) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$line = &lt;$fh&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$linea = &lt;$fh&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do 'stat.pl';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do 'stat.pl';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last two would be the
$0 and the $s variables in the (presumably) non-existent package
C&lt;who&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La última sería una variable $0 en un (presumiblemente) inexistente paquete C&lt;quien&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If a curly bracket occurs in any other context, it is treated
as a regular character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si aparece una llave en cualquier otro contexto, es tratada como un carácter normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item redo</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item redo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfaq4&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase L&lt;perlfaq4&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For string conversions, specifying a precision truncates the string
to fit the specified width:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las conversiones de cadena, especificando una precisión trunca la cadena a la anchura especificada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bar	# NOT a comment, this slash / terminated m//!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>bar	# ¡NO es un comentario, esta barra / termina m//!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$@%&amp;* dereference     $$foo{bar}     aka $foo-&gt;{bar}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234011Z" changeid="explorer">
        <seg>$@%&amp;* desreferencia  $$foo{bar}     igual que $foo-&gt;{bar}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;state&gt; declares a lexically scoped variable, just like C&lt;my&gt; does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;state&gt; declara una variable de ámbito léxico, como lo hace C&lt;my&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Semaphore trouble: $!\n&quot; unless semop($semid, $semop);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;Problema son semáforo: $!\n&quot; unless semop($semid, $semop);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-c  File is a character special file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004741Z" changeid="explorer">
        <seg>-c  Archivo es un archivo especial de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if successful,
or false if there is an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tiene éxito, o falso si hay un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return (pop(@foo),pop(@foo))[0];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return (pop(@foo),pop(@foo))[0];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$output = `cmd 2&gt;/dev/null`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$salida = `comando 2&gt;/dev/null`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Double Quotes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Dobles comillas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BITS therefore specifies the number of bits
that are reserved for each element in the bit vector.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BITS, por tanto, especifica el número de bits que son reservados para cada elemento en el vector de bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All data in Perl is a scalar, an array of scalars, or a hash of
scalars.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo dato en Perl es un escalar, un array de escalares o un hash de escalares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sysseek() bypasses normal buffered IO, so mixing this with reads (other
than C&lt;sysread&gt;, for example C&lt;&lt; &lt;&gt; &gt;&gt; or read()) C&lt;print&gt;, C&lt;write&gt;,
C&lt;seek&gt;, C&lt;tell&gt;, or C&lt;eof&gt; may cause confusion.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sysseek() omite E/S buffer normal, por lo que mezclar esto con lecturas (que no sean C&lt;sysread&gt;, por ejemplo, C&lt;&lt; &lt;&gt; &gt;&gt; o read()) C&lt;print&gt;, C&lt;write&gt;, C&lt;seek&gt;, C&lt;tell&gt;, o C&lt;eof&gt; puede causar confusión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo,  2, 16) = 0x5065; # 'PerlPe'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($foo,  2, 16) = 0x5065; # 'PerlPe'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make switching optimization and debugging levels during Perl builds
easier via the OPTIMIZE environment variable</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>realizar la optimización de conexión y los niveles de depuración durante la compilación de Perl es más fácil usando la variable de entorno OPTIMIZE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Declaration and Access of Arrays of Arrays</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Declaración y acceso de los array de array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$shell_info = qx'ps $$';            # that's the new shell's $$</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$shell_info = qx'ps $$';            # es el $$ del nuevo shell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It bypasses
buffered IO, so mixing this with other kinds of reads, C&lt;print&gt;,
C&lt;write&gt;, C&lt;seek&gt;, C&lt;tell&gt;, or C&lt;eof&gt; can cause confusion because the
perlio or stdio layers usually buffers data.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Omite E/S con buffer, por lo que mezclar esto con otros tipos de lecturas, C&lt;print&gt;, C&lt;write&gt;, C&lt;seek&gt;, C&lt;tell&gt;, o C&lt;eof&gt; puede causar confusión porque las capas Perlio o stdio por lo general usan búferes de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.  Null-fill or truncate to absolute position specified by the value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050454Z" changeid="explorer">
        <seg>.  Relleno con nulos o truncado a una posición absoluta especificada por el valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item return EXPR
X&lt;return&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194632Z" changeid="explorer">
        <seg>=item return EXPR
X&lt;return&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It formats (see L&lt;perlform&gt;) a list of values according to the
contents of PICTURE, placing the output into the format output
accumulator, C&lt;$^A&gt; (or C&lt;$ACCUMULATOR&gt; in English).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Formatea (ver L&lt;perlform&gt;) una lista de valores de acuerdo a los contenidos de CUADRO, colocando la salida en el acumulador de salida de format, C&lt;$^A&gt; (o C&lt;$ACCUMULATOR&gt; en English).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this to break up
your regular expression into (slightly) more readable parts.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar esto para romper la expresión regular en partes (un poco) más legibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eof ()</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eof ()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that it's more efficient and concise, keeps track of the current
filename for error messages, searches the @INC directories, and updates
C&lt;%INC&gt; if the file is found.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>excepto que es más eficiente y conciso, mantiene el nombre del archivo en los mensajes de error, busca en los directorios @INC y actualiza C&lt;%INC&gt; si el archivo es encontrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Extended Patterns</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Patrones extendidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also use Perl's four-argument
version of select() leaving the first three arguments undefined, or you
might be able to use the C&lt;syscall&gt; interface to access setitimer(2) if
your system supports it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede también usar la versión de select() de cuatro argumentos, dejando los tres primeros indefinidos, o puede usar la interfaz C&lt;syscall&gt; para acceder a setitimer(2) si su sistema lo soporta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Preamble</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Preámbulo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;not&quot; returns the logical negation of the expression to its right.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unario &quot;not&quot; devuelve la negación lógica de la expresión a su derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The collected standard output of the command is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo lo que salga por la salida estándar del comando se devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Jarkko Hietaniemi &lt;jhi@iki.fi&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005413Z" changeid="explorer">
        <seg>Jarkko Hietaniemi &lt;jhi@iki.fi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 4) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 4) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the permissions of a list of files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia los permisos de una lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>myfunc(&lt;&lt; &quot;THIS&quot;, 23, &lt;&lt;'THAT');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>myfunc(&lt;&lt; &quot;ESTE&quot;, 23, &lt;&lt;'ESE');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both failures are not really specific to the Hurd, as indicated by the
test suite output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ambos fallos realmente no son específicos a Hurd, como se indica en la salida de los test.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>support for Unicode, internationalization, and localization</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>soporte para Unicode, la internacionalización y localización</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$perl_info  = qx(ps $$);            # that's Perl's $$</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$perl_info  = qx(ps $$);            # es el $$ de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\*/	# Match the closing delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\*/	# Busca el delimitador de cierre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>refers to the collection of files distributed by the
Copyright Holder, and derivatives of that collection of files created
through textual modification.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>se refiere a la colección de archivos distribuidos por el Titular del Copyright, y derivados de esa colección de archivos creados mediante la modificación del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, a reasonably
portable way to find out the home directory might be:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto, un forma razonablemente portátil para averiguar el directorio principal podría ser:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(INPUT, 'foo')          # get sort's results</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(INPUT, 'foo')          # obtener los resultado de sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is similar to pre-extending
an array by assigning a larger number to $#array.)  If you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto es similar a pre-extender un array asignándole un gran número a $#array). Si dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$can_chown_giveaway = not sysconf(_PC_CHOWN_RESTRICTED);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$can_chown_giveaway = not sysconf(_PC_CHOWN_RESTRICTED);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lock THING
X&lt;lock&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T190718Z" changeid="explorer">
        <seg>=item lock COSA
X&lt;lock&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Quantifiers can be used to specify how many of the previous thing you
want to match on, where &quot;thing&quot; means either a literal character, one
of the metacharacters listed above, or a group of characters or
metacharacters in parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225437Z" changeid="explorer">
        <seg>Los cuantificadores se utilizan para especificar cuántas coincidencias de lo anterior (un carácter literal, uno de los metacaracteres antes especificados o un grupo de caracteres o metacaracteres entre paréntesis) se desea detectar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(ARGV, $ARGV);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(ARGV, $ARGV);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each result bit is based on the least-significant bit of the corresponding
input character, i.e., on C&lt;ord($char)%2&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada bit resultante se basa en el bit menos significativo del correspondiente carácter de la entrada, es decir, en C&lt;ord($carácter)%2&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If instead you want to sort the array @key with the comparison routine
C&lt;find_records()&gt; then you can use:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si, en cambio, quiere ordenar el array @claves con la rutina de comparación C&lt;busca_registros()&gt; entonces puede usar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># process argument list of files along with any includes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># procesa la lista de archivos pasados como argumentos junto con cualquier archivo a incluir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.8.2 release and
the 5.8.3 release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe las diferencias entre la versión 5.8.2 y la versión 5.8.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Digest::MD5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Digest::MD5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use sort 'stable';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use sort 'stable';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^([^ ]*) *([^ ]*)/$2 $1/;     # intercambia las dos primeras palabras</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if C&lt;die&gt; won't do what you want (say, in a CGI script,
where you want to format a suitable error message (but there are
modules that can help with that problem)) always check
the return value from opening a file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso si C&lt;die&gt; no hace lo que usted quiere (por ejemplo, en un script CGI, en la que desea dar formato a un mensaje de error apropiado (aunque existen módulos que pueden ayudar con ese problema)) controle siempre el valor de retorno de la apertura de un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@keys = keys %ENV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@keys = keys %ENV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IRWXU S_IRUSR S_IWUSR S_IXUSR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_IRWXU S_IRUSR S_IWUSR S_IXUSR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as the first line of the handler (see L&lt;perlvar/$^S&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>como primera línea del gestor (ver L&lt;perlvar/$^S&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub lock {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub lock {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;a4&quot;,&quot;abcd&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;a4&quot;,&quot;abcd&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For documentation of C&lt;\N{name}&gt;, see L&lt;charnames&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para documentación sobre C&lt;\N{nombre}&gt;, véase L&lt;charnames&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last Updated: Fri, 29 Oct 1999 22:50:30 +0200</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Last Updated: Fri, 29 Oct 1999 22:50:30 +0200</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tied VARIABLE
X&lt;tied&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T205919Z" changeid="explorer">
        <seg>=item tied VARIABLE
X&lt;tied&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to stack multiple here-docs in a row:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es posible apilar múltiples documentos incrustados en una fila:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%+ d&gt;', 12;   # prints &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%+ d&gt;', 12;   # imprime &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval $x;        # CASE 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval $x;        # CASO 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($Config{use64bitint} eq &quot;define&quot; || $Config{longsize} &gt;= 8) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($Config{use64bitint} eq &quot;define&quot; || $Config{longsize} &gt;= 8) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The repeat count for C&lt;u&gt; is interpreted as the maximal number of bytes
to encode per line of output, with 0, 1 and 2 replaced by 45.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de repeticiones para C&lt;u&gt; se interpreta como el número máximo de bytes para codificar por línea de salida, con 0, 1 y 2 sustituidos por 45.&lt;/u&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L  An unsigned long value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>L  Un valor de un largo sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;overload&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;sobrecarga&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new utility, C&lt;prove&gt;, makes it easy to run an individual regression test
at the command line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una nueva utilidad, C&lt;prove&gt;, hace que sea fácil ejecutar una prueba de regresión individual en la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print '-' x 80;		# print row of dashes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print '-' x 80;		# imprime una fila de guiones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$minutes = $2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$minutos = $2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pop(@a)             splice(@a,-1)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pop(@a)             splice(@a,-1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub myname;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub minombre;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(On other statements the loop modifiers test the conditional
first.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012017Z" changeid="explorer">
        <seg>(En otras instrucciones los modificadores de bucle comprueban primero la condición).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LISTs do automatic interpolation of sublists.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LISTAs hacen una interpolación automática de las sublistas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function semget(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC semget(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using substr() on a UTF8 string could cause subsequent accesses on that
string to return garbage.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando substr() en una cadena UTF8 podría causar que los subsecuentes accesos a dicha cadena devuelvan basura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>default {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $key (sort(keys %ENV)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $key (sort(keys %ENV)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hexdigit = ('a','b','c','d','e','f')[$digit-10];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$digitohex = ('a','b','c','d','e','f')[$digito-10];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regarding precedence, the filetest operators, like C&lt;-f&gt;, C&lt;-M&gt;, etc. are
treated like named unary operators, but they don't follow this functional
parenthesis rule.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En cuanto a la precedencia, los operadores test de archivos, como C&lt;-f&gt;, C&lt;-M&gt;, etc, son tratados como operadores unarios con nombre, pero no siguen esta regla funcional de los paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be understood as being roughly
equivalent to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser entendida como equivalente a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%B    like %b, but using an upper-case &quot;B&quot; with the # flag</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%B    como %b, pero usando una letra &quot;B&quot; mayúscula con la bandera #</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item join EXPR,LIST
X&lt;join&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174111Z" changeid="explorer">
        <seg>=item join EXPR,LISTA
X&lt;join&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It tells
the regular expression parser to ignore most whitespace that is neither
backslashed nor within a character class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Él indica al analizador de expresiones regulares que ignore la mayoría de los espacios en blanco que no estén escapados con barras invertidas ni que estén dentro de una clase de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each &quot;..&quot; operator
maintains its own boolean state, even across calls to a subroutine
that contains it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada operador &quot;..&quot; mantiene su estado booleano propio, incluso a través de llamadas a la subrutina que lo contenga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[3]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[3]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item format parameter index</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item índice de parámetro de formato</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Overview</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 General</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perluniprops	Index of Unicode Version 5.2.0 properties in Perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perluniprops	Índice de las propiedades de Unicode versión 5.2.0 en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use C&lt;while&gt; in a post-condition:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T224606Z" changeid="zipf">
        <seg>También puede usar C&lt;while&gt; en una condición posterior:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the packed sockaddr address of other end of the SOCKET connection.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la dirección sockect empaquetada del otro final de la conexión SOCKET.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following escape sequences are available in constructs that interpolate,
but not in transliterations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las siguientes secuencias de escape están disponibles en construcciones que interpolan, pero no en transliteraciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, that wouldn't even compile.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De hecho, esto ni siquiera compilaría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note
that the delimiter may be longer than one character.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tenga en cuenta que el delimitador puede ser más largo que un carácter).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@animals[1..$#animals];         # gives all except the first element</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T214003Z" changeid="explorer">
        <seg>@animales[1..$#animales];  # devuelve todos excepto el primero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So will C&lt;next&gt;, but since it will execute a C&lt;continue&gt;
block, it may be more entertaining.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También C&lt;next&gt;, pero como ejecutará un bloque C&lt;continue&gt;, quizás se convierta en algo divertido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>are exempt from warnings (because they care about truth rather than
definedness).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>están exentos de esos avisos (porque tienen en cuenta el valor de verdad en vez de ver si está definido).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>goto((&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>goto((&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also
L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, and C&lt;IPC::SysV::Semaphore&gt;
documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, y C&lt;IPC::Semaphore&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 HISTORY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 HISTORIA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;threads::shared&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;threads::shared&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Testing Perl on DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Comprobando Perl en DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>de tal manera que serán definidas ${^PREMATCH}, ${^MATCH} y ${^POSTMATCH}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any additional arguments are passed to the C&lt;new&gt;
method of the class (meaning C&lt;TIESCALAR&gt;, C&lt;TIEHANDLE&gt;, C&lt;TIEARRAY&gt;,
or C&lt;TIEHASH&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualesquiera argumentos adicionales son pasados al método C&lt;new&gt; de la clase (es decir, C&lt;TIESCALAR&gt;, C&lt;TIEHANDLE&gt;, C&lt;TIEARRAY&gt;, o C&lt;TIEHASH&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, en</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$file =~ s#^(\s)#./$1#;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$archivo =~ s#^(\s)#./$1#;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;when&gt; executes the statement I&lt;when&gt; C&lt;$_&gt; smart matches C&lt;EXPR&gt;, and
then either C&lt;break&gt;s out if it's enclosed in a C&lt;given&gt; scope or skips
to the C&lt;next&gt; element when it lies directly inside a C&lt;for&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013046Z" changeid="explorer">
        <seg>C&lt;when&gt; ejecuta la instrucción I&lt;cuando&gt; C&lt;$_&gt; coincide inteligentemente con C&lt;EXPR&gt;, y después, o bien C&lt;salta&gt; fuera si está encerrada en un ámbito C&lt;given&gt; o salta al C&lt;siguiente&gt; elemento cuando reside dentro de un bucle C&lt;for&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operating and filesystems do not get
this right, so Perl automatically removes all trailing slashes to keep
everyone happy.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos sistemas operativos y de sistemas de archivos no interpretan esto de forma correcta, por lo que Perl automáticamente elimina todas las barras inclinadas finales para tener a todo el mundo feliz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s	Treat string as single line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s	Trata la cadena como una única línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically
used as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Típicamente se usa como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the arguments are omitted,
it defaults to C&lt;0,0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los argumentos son omitidos, el valor predeterminado es C&lt;0,0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
the range operator is changed to C&lt;...&gt;, it will also print the
&quot;Baz&quot; line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el operador se cambia a C&lt;...&gt;, también se imprimirá la línea &quot;Baz&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($curpos = tell(FILE); $_ = &lt;FILE&gt;;
             $curpos = tell(FILE)) {
            # search for some stuff and put it into files</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051322Z" changeid="explorer">
        <seg>for ($curpos = tell(FILE); $_ = &lt;FILE&gt;;
             $curpos = tell(FILE)) {
            # buscar por algo y ponerlo en los archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless (EXPR) BLOCK else BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless (EXPR) BLOQUE else BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello, world\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233902Z" changeid="zipf">
        <seg>print &quot;Hola a todos\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item hex EXPR
X&lt;hex&gt; X&lt;hexadecimal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173911Z" changeid="explorer">
        <seg>=item hex EXPR
X&lt;hex&gt; X&lt;hexadecimal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>may be closer to the conjectural I&lt;intention&gt; of the writer of C&lt;&quot;\Q\t\E&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>puede conjeturar que puede estar muy cerca de la I&lt;intención&gt; de quien escribió C&lt;&quot;\Q\t\E&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># now process $line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ahora, procesa $linea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns I&lt;e&gt; (the natural logarithm base) to the power of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve I&lt;e&gt; (la base natural del logaritmo) a la potencia de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay una línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This 'integer' is _at_least_ 32 bits wide.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Este 'entero' es _al_menos_, de 32 bit de ancho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the current priority for a process, a process group, or a user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la prioridad actual de un proceso, un grupo de procesos o un usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior is undefined if LENGTH is greater than the length of the
file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento no está definido si LONGITUD es mayor que la longitud del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\g{-1}    [5]  The number may be negative indicating a relative previous
                    buffer and may optionally be wrapped in curly brackets for
                    safer parsing.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224543Z" changeid="explorer">
        <seg>\g{-1}    [5]  El número puede ser negativo, indicando la posición relativa de
                    un buffer anterior y puede, opcionalmente, estar rodeado por
                    llaves, para una mejor interpretación de la exp. reg.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's too
long and an explicit count is provided, C&lt;Z&gt; packs only C&lt;$count-1&gt; bytes,
followed by a null byte.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si es demasiado largo y se indica un contador explícito, C&lt;Z&gt; empaqueta solo C&lt;$contador-1&gt; bytes, seguido por un byte nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item time
X&lt;time&gt; X&lt;epoch&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T205923Z" changeid="explorer">
        <seg>=item time
X&lt;time&gt; X&lt;epoch&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>c  A signed char (8-bit) value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>c  Un valor de un carácter con signo (8 bit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filehandles STDIN, STDOUT, and STDERR are predefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los gestores de archivo STDIN, STDOUT y STDERR están predefinidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.5g&gt;', 100.01; # prints &quot;&lt;100.01&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.5g&gt;', 100.01; # imprime &quot;&lt;100.01&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first delimiter is not an opening punctuation, three delimiters must
be same such as C&lt;s!!!&gt; and C&lt;tr)))&gt;, in which case the second delimiter
terminates the left part and starts the right part at once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el primer delimitador no es un carácter de puntuación de apertura, los tres delimitadores deben ser el mismo, como C&lt;s!!!&gt; y C&lt;tr)))&gt;, en cuyo caso el segundo delimitador termina la parte izquierda y, a la vez, comienza la parte derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc/&quot;Using open() for IPC&quot;&gt;
for more examples of this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc/&quot;Usando open() por IPC&quot;&gt; para más ejemplos de sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot currently get the precision from a specified number,
but it is intended that this will be possible in the future, for
example using C&lt;.*2$&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Actualmente, no se puede conseguir la precisión de un número determinado, pero es intención de que esto será posible en el futuro, por ejemplo, con C&lt;.*2$&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$who = &quot;Larry&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$quien = &quot;Larry&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is the output (split into several lines):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí está la salida (dividido en varias líneas):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>give non-standard executables non-standard names, and clearly
document the differences in manual pages (or equivalent), together with
instructions on where to get the Standard Version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dar nombres no estándares a los ejecutables no estándares, y claramente documentar las diferencias en páginas del manual (o equivalente), junto con instrucciones sobre dónde obtener la Versión Estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backslash interpolation also happens at
compile time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La interpolación de contrabarras también sucede en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't get the UTF-8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No obtiene los bytes UTF-8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some frequently seen examples:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos ejemplos que suelen encontrarse frecuentemente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As more readable alternatives to C&lt;&amp;&amp;&gt; and C&lt;||&gt; when used for
control flow, Perl provides the C&lt;and&gt; and C&lt;or&gt; operators (see below).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como alternativas más legibles a C&lt;&amp;&amp;&gt; y C&lt;||&gt; cuando se usan para control de flujo, Perl proporciona los operadores C&lt;and&gt; y C&lt;or&gt; (véase más adelante).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perltie&gt; and L&lt;AnyDBM_File&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;perltie&gt; y L&lt;AnyDBM_File&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bits;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bits;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item for</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232634Z" changeid="explorer">
        <seg>=item for</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0377                # octal (only numbers, begins with 0)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0377                # octal (solo números, comenzando con 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be aware that the optimizer might have optimized call frames away before
C&lt;caller&gt; had a chance to get the information.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuidado con el optimizador, que puede optimizar marcos de llamada antes de que C&lt;caller&gt; tenga la oportunidad de obtener la información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array of an array is just a regular old array @AoA that you can
get at with two subscripts, like C&lt;$AoA[3][2]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un array de un array es justo un array @AoA normal sobre la que se puede aplicar dos subíndices, como C&lt;$AoA[3][2]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the next directory entry for a directory opened by C&lt;opendir&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la siguiente entrada de directorio de un directorio abierto con C&lt;opendir&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($quote = &lt;&lt;'FINIS') =~ s/^\s+//gm;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($quote = &lt;&lt;'FINIS') =~ s/^\s+//gm;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\X        [4]  Match Unicode &quot;eXtended grapheme cluster&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223832Z" changeid="explorer">
        <seg>\X	 [4]  Coincide con una &quot;agrupación de grafemas eXtendida&quot; Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about the portability of these functions, see
L&lt;perlport&gt; and other available platform-specific documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información sobre la portabilidad de estas funciones, ver L&lt;perlport&gt; y cualquier otra documentación específica de la plataforma que esté disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid using C&lt;grep()&gt; (or C&lt;map()&gt;) or `backticks` in a void context, that is,
when you just throw away their return values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evite usar C&lt;grep()&gt; (o C&lt;map()&gt;) o `acentos graves` en contexto nulos, es decir, cuando usted no va usar los valores de retorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, as of Perl 5.10.0 you may use named capture buffers and named
backreferences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, a partir de Perl 5.10.0 puede utilizar el capturas nominadas y contrareferencias nominadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX qw(strftime);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use POSIX qw(strftime);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Perl program consists of a sequence of declarations and statements
which run from the top to the bottom.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012150Z" changeid="explorer">
        <seg>Un programa Perl consiste en una secuencia de declaraciones e instrucciones que se ejecutan de arriba hacia abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't do that either.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco haga esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C&lt;if&gt;, C&lt;unless&gt; can be followed
by C&lt;else&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como C&lt;if&gt;, C&lt;unless&gt; puede ser seguido por C&lt;else&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item CGI</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item CGI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl
5.8.1 the ordering is different even between different runs of Perl
for security reasons (see L&lt;perlsec/&quot;Algorithmic Complexity Attacks&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde Perl 5.8.1 la ordenación es diferente incluso entre diferentes ejecuciones de Perl por razones de seguridad (ver L&lt;perlsec/&quot;Ataques por Complejidad Algorítmica&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># as a sort subroutine (including other package's subroutines)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># como una subrutina para sort (incluyendo subrutinas de otros paquetes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators borrowed from
C keep the same precedence relationship with each other, even where
C's precedence is slightly screwy.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los operadores tomados del C mantienen la misma relación de precedencia entre sí, incluso donde la precedencia de C está ligeramente chiflada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will automatically accept all the defaults and
in particular /usr/local/ as installation directory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto, automáticamente, aceptará todos los valores predeterminados y, en particular, /usr/local/ como directorio de instalación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context,
returns the caller's package name if there I&lt;is&gt; a caller (that is, if
we're in a subroutine or C&lt;eval&gt; or C&lt;require&gt;) and the undefined value
otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el nombre del paquete del llamante si aquel I&lt;es&gt; un llamante, es decir, si estamos en una subrutina, C&lt;eval&gt; o C&lt;require&gt;, y el valor indefinido en otro caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlunicode 	Perl Unicode support</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlunicode 	Soporte Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec {'/bin/csh'} '-sh';  # pretend it's a login shell</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec {'/bin/csh'} '-sh';  # finge que es un shell de login</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item each ARRAY
X&lt;array, iterator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171532Z" changeid="explorer">
        <seg>=item each ARRAY
X&lt;array, iterator&gt; X&lt;array, iterador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;long doubles by default\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;long doubles por defecto\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can read this document in the following formats:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede leer este documento en los siguientes formatos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the availability and the exact meaning of these fields
in your system, please consult your getpwnam(3) documentation and your
F&lt;pwd.h&gt; file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la disponibilidad y el significado exacto de estos campos en su sistema, por favor consulte la documentación de su getpwnam(3) y su archivo F&lt;pwd.h&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Testing for exact floating-point equality or inequality is not a
good idea.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011231Z" changeid="explorer">
        <seg>No es una buena idea comprobar la igualdad o la desigualdad exacta de números en punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is pretty much useful only to find out whether
Perl's internal hashing algorithm is performing poorly on your data
set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil solamente para conocer si el algoritmo interno de los hashes está teniendo un bajo rendimiento sobre un conjunto de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;Named Unary Operators&gt; for more discussion of this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;Operadores unarios con nombre&gt; para una discusión más sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;-X&gt;, C&lt;binmode&gt;, C&lt;chmod&gt;, C&lt;chown&gt;, C&lt;chroot&gt;, C&lt;crypt&gt;,
C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;dump&gt;, C&lt;endgrent&gt;, C&lt;endhostent&gt;,
C&lt;endnetent&gt;, C&lt;endprotoent&gt;, C&lt;endpwent&gt;, C&lt;endservent&gt;, C&lt;exec&gt;,
C&lt;fcntl&gt;, C&lt;flock&gt;, C&lt;fork&gt;, C&lt;getgrent&gt;, C&lt;getgrgid&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getlogin&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getppid&gt;, C&lt;getpgrp&gt;, C&lt;getpriority&gt;, C&lt;getprotobynumber&gt;,
C&lt;getprotoent&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;, C&lt;getpwuid&gt;,
C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;getsockopt&gt;, C&lt;glob&gt;, C&lt;ioctl&gt;,
C&lt;kill&gt;, C&lt;link&gt;, C&lt;lstat&gt;, C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;,
C&lt;msgsnd&gt;, C&lt;open&gt;, C&lt;pipe&gt;, C&lt;readlink&gt;, C&lt;rename&gt;, C&lt;select&gt;, C&lt;semctl&gt;,
C&lt;semget&gt;, C&lt;semop&gt;, C&lt;setgrent&gt;, C&lt;sethostent&gt;, C&lt;setnetent&gt;,
C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;setprotoent&gt;, C&lt;setpwent&gt;,
C&lt;setservent&gt;, C&lt;setsockopt&gt;, C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;,
C&lt;shmwrite&gt;, C&lt;socket&gt;, C&lt;socketpair&gt;,
C&lt;stat&gt;, C&lt;symlink&gt;, C&lt;syscall&gt;, C&lt;sysopen&gt;, C&lt;system&gt;,
C&lt;times&gt;, C&lt;truncate&gt;, C&lt;umask&gt;, C&lt;unlink&gt;,
C&lt;utime&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165331Z" changeid="explorer">
        <seg>C&lt;-X&gt;, C&lt;binmode&gt;, C&lt;chmod&gt;, C&lt;chown&gt;, C&lt;chroot&gt;, C&lt;crypt&gt;,
C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;dump&gt;, C&lt;endgrent&gt;, C&lt;endhostent&gt;,
C&lt;endnetent&gt;, C&lt;endprotoent&gt;, C&lt;endpwent&gt;, C&lt;endservent&gt;, C&lt;exec&gt;,
C&lt;fcntl&gt;, C&lt;flock&gt;, C&lt;fork&gt;, C&lt;getgrent&gt;, C&lt;getgrgid&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getlogin&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getppid&gt;, C&lt;getpgrp&gt;, C&lt;getpriority&gt;, C&lt;getprotobynumber&gt;,
C&lt;getprotoent&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;, C&lt;getpwuid&gt;,
C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;getsockopt&gt;, C&lt;glob&gt;, C&lt;ioctl&gt;,
C&lt;kill&gt;, C&lt;link&gt;, C&lt;lstat&gt;, C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;,
C&lt;msgsnd&gt;, C&lt;open&gt;, C&lt;pipe&gt;, C&lt;readlink&gt;, C&lt;rename&gt;, C&lt;select&gt;, C&lt;semctl&gt;,
C&lt;semget&gt;, C&lt;semop&gt;, C&lt;setgrent&gt;, C&lt;sethostent&gt;, C&lt;setnetent&gt;,
C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;setprotoent&gt;, C&lt;setpwent&gt;,
C&lt;setservent&gt;, C&lt;setsockopt&gt;, C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;,
C&lt;shmwrite&gt;, C&lt;socket&gt;, C&lt;socketpair&gt;,
C&lt;stat&gt;, C&lt;symlink&gt;, C&lt;syscall&gt;, C&lt;sysopen&gt;, C&lt;system&gt;,
C&lt;times&gt;, C&lt;truncate&gt;, C&lt;umask&gt;, C&lt;unlink&gt;,
C&lt;utime&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exp</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This emulates the C&lt;syswrite&gt; function (or vice versa):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto emula la función C&lt;syswrite&gt; (o viceversa):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Hash Randomisation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Aleatorización Hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not a decimal number&quot; unless /^-?\d+\.?\d*$/;     # rejects .2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es número real&quot;    unless /^-?\d+\.?\d*$/;     # rechaza .2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc&gt; for more examples of
forking and reaping moribund children.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;perlipc&gt; para más ejemplos de fork y borrado de hijos moribundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add DEL to [:cntrl:]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadir DEL a [:cntrl:]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, if you want only one
of the elements, it's trivial:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193218Z" changeid="explorer">
        <seg>Bueno, si desea sólo uno de los elementos, es trivial:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it cannot be
used by itself to fetch single characters without waiting for the user
to hit enter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, esto no puede ser usado para extraer caracteres sueltos sin esperar a que el usuario pulse la tecla de I&lt;Enter&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that
you must fully qualify the sub's name, as unqualified C&lt;INC&gt; is always forced
into package C&lt;main&gt;.)  Here is a typical code layout:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tenga en cuenta que debe cualificar completamente el nombre de la subrutina, así como un no cualificado C&lt;INC&gt; está siempre forzado en el paquete C&lt;main&gt;). Este es un diseño de código típico:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boolean contexts,
such as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contextos booleanos, como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;i9pl&quot;, gmtime);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;i9pl&quot;, gmtime);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print($foo), exit;	# Or this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print($foo), exit;	# O esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chomp( LIST )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chomp( LISTA )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl 5.8.0 sets C&lt;$^X&gt; where possible to a full path by asking the operating
system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl 5.8.0 pone C&lt;$^X&gt; hasta donde sea posible a todo el camino completo preguntando al sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns C&lt;1&gt; for success, C&lt;0&gt; otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve C&lt;1&gt; en caso de éxito; de otra manera, C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ord EXPR
X&lt;ord&gt; X&lt;encoding&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191933Z" changeid="explorer">
        <seg>=item ord EXPR
X&lt;ord&gt; X&lt;encoding&gt; X&lt;codificación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$other  = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$otro   = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, C&lt;*FH&gt; must be used to create new symbol table entries;
C&lt;*foo{THING}&gt; cannot.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005613Z" changeid="explorer">
        <seg>En otras palabras, C&lt;*FH&gt; debe ser usado para crear nuevas entradas de en la tabla de símbolos; C&lt;*foo{COSA}&gt;, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is much more efficient than C&lt;s/.$//s&gt; because it neither
scans nor copies the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más eficiente que C&lt;s/.$//s&gt; porque ni escanea ni copia el string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;File contains: &quot;, &lt;HANDLE&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El archivo contiene: &quot;, &lt;HANDLE&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$max;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232640Z" changeid="explorer">
        <seg>$max;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They were v-strings from Perl 5.6.0 to
Perl 5.8.0, but that caused more confusion and breakage than good.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fueron v-strings desde Perl 5.6.0 a Perl 5.8.0, pero causó más confusión y problemas, que bienes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you actually want to test if at least one of C&lt;$a&gt; and
C&lt;$b&gt; is defined, use C&lt;defined($a // $b)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si realmente desea probar si al menos uno de los dos, C&lt;$a&gt; o C&lt;$b&gt;, están definidos, use C&lt;defined($a // $b)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of tell() for the standard streams like the STDIN
depends on the operating system: it may return -1 or something else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de retorno de tell() para los flujos estándares como STDIN depende del sistema operativo: puede devolver -1 o algo más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#      $foo = pack(&quot;WWWW&quot;,193,194,195,196);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#      $foo = pack(&quot;WWWW&quot;,193,194,195,196);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't want it to test the right operand until the
next evaluation, as in B&lt;sed&gt;, just use three dots (&quot;...&quot;) instead of
two.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no quiere poner a prueba el operando derecho hasta la próxima evaluación, al igual que en B&lt;sed&gt;, sólo tiene que utilizar tres puntos (&quot;...&quot;) en lugar de dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item syswrite FILEHANDLE,SCALAR,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211848Z" changeid="explorer">
        <seg>=item syswrite GESTOR_ARCHIVO,ESCALAR,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;IMPORTANT&gt;: Without patch 2401, a kernel bug in Irix 6.2 will cause
your machine to panic and crash when running threaded perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004443Z" changeid="explorer">
        <seg>B&lt;IMPORTANTE&gt;: Sin el parche 2401, un error del kernel en Irix 6.2 causará que su máquina entre en pánico y casque cuando ejecute perl enhebrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list assignment in scalar
context will translate that into the number of elements (here, the
number of times the pattern matched) and assign that to $count.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La lista de asignación en contexto escalar se traducirá en el número de elementos (en este caso, el número de veces que el patrón coincide) y los asigna a $cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.7.2 release and the
5.7.3 release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe las diferencias entre la versión 5.7.2 y la versión 5.7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\s        [3]  Match a whitespace character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223630Z" changeid="explorer">
        <seg>\s	 [3]  Coincide con un carácter espacio en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Use C&lt;defined($pid)&gt; to determine whether the open was successful.)
The filehandle behaves normally for the parent, but I/O to that
filehandle is piped from/to the STDOUT/STDIN of the child process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Use C&lt;defined($pid)&gt; para determinar si open() se ha realizado correctamente). El gestor de archivo se comporta normalmente para el padre, pero la E/S del gestor de archivo se entuba desde/hacia el STDOUT/STDIN del proceso hijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;sysseek&gt; instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use en su lugar C&lt;sysseek&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%E    like %e, but using an upper-case &quot;E&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%E    como %e, pero usando una letra &quot;E&quot; mayúscula</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a += 2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a += 2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the C&lt;eval{}&gt; form as an exception trap in libraries does have some
issues.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar la forma C&lt;eval{}&gt; como una trampa de excepciones en bibliotecas puede tener algunos problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;signal.h&gt; is now always included.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;signal.h&gt; ahora es siempre incluido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It used to do so in Perl 4, but we
had to break this to make sure destructors were called when expected.)
X&lt;$#&gt; X&lt;array, length&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Así solía hacerse en Perl 4, aunque aunque tuvimos que cambiarlo para asegurar que los destructores eran llamados cuando se esperaba hacerlo).
X&lt;$#&gt; X&lt;array, length&gt; X&lt;array, longitud&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does the opposite of a C&lt;shift&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El opuesto de un C&lt;shift&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item kill SIGNAL, LIST
X&lt;kill&gt; X&lt;signal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174146Z" changeid="explorer">
        <seg>=item kill SEÑAL, LISTA
X&lt;kill&gt; X&lt;signal&gt; X&lt;señal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will
often point out exactly where the trouble is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A menudo, mostrará dónde está el problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the final value specified is not in the sequence that the magical
increment would produce, the sequence goes until the next value would
be longer than the final value specified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el valor final especificado no está en la secuencia que el incremento mágico produciría, la secuencia continúa hasta el siguiente valor que sería más largo que el valor final fijado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these cases, whitespaces
and comments are allowed between both parts, though the comment must follow
at least one whitespace; otherwise a character expected as the start of
the comment may be regarded as the starting delimiter of the right part.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estos casos, los espacios en blanco y los comentarios están permitidos entre ambas partes, aunque el comentario debe estar precedido, por lo menos, de un espacio en blanco; de lo contrario, un carácter esperado como inicio del comentario puede ser considerado como el delimitador de inicio de la parte derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item order of arguments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item orden de los argumentos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perltoot&gt; and L&lt;perlobj&gt; for more about the blessing (and blessings)
of objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perltoot&gt; y L&lt;perlobj&gt; para saber más sobre bautizos (y bautizar) de objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@args = ( &quot;echo surprise&quot; );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@args = ( &quot;echo sorpresa&quot; );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># sort numerically descending</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ordenación numérica descendente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But generally, a block is delimited by curly brackets, also known as braces.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero generalmente, un bloque está delimitado por llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport/&quot;Supported Platforms&quot;&gt;
for a listing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport/&quot;Plataformas soportadas&quot;&gt; para ver un listado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@files = glob($files[$i]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@archivos = glob($archivos[$i]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This makes learning Perl easier
for C folks.)  With very few exceptions, these all operate on scalar
values only, not array values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto hace el aprendizaje de Perl más fácil para la gente de C). Con pocas excepciones, todas éstas operan solamente en valores escalares, no en valores de array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't readlink $sym: $!&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo enlazar simbólicamente con $sym: $!&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item return</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item return</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;grep&gt;, C&lt;join&gt;, C&lt;map&gt;, C&lt;qw//&gt;, C&lt;reverse&gt;, C&lt;sort&gt;, C&lt;unpack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;grep&gt;, C&lt;join&gt;, C&lt;map&gt;, C&lt;qw/STRING/&gt;, C&lt;reverse&gt;, C&lt;sort&gt;, C&lt;unpack&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$me = myname $0 		or die &quot;can't get myname&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$me = minombre $0 		or die &quot;no puedo obtener minombre&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#       ensure the leading &quot;0&quot; for any octal,
           prefix non-zero hexadecimal with &quot;0x&quot; or &quot;0X&quot;,
           prefix non-zero binary with &quot;0b&quot; or &quot;0B&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051738Z" changeid="explorer">
        <seg>#       garantiza el &quot;0&quot; inicial para todos los octales,
           prefija hexadecimales no ceros con &quot;0x&quot; o &quot;0X&quot;,
           prefija binarios no cero con &quot;0b&quot; o &quot;0B&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the length of the input string is not even, it behaves as if padded by
a null character at the end.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la longitud de la cadena de entrada no es par, se comporta como si estuviera rellenada con un carácter nulo al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlqnx		Perl notes for QNX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlqnx		Notas para QNX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the pattern
evaluates to the empty string, the last successfully executed regular
expression is used instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el patrón se evalúa a la cadena vacía, se utiliza en su lugar la última expresión regular ejecutada con éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note also that
each C&lt;use&gt; statement creates a C&lt;require&gt; frame inside an C&lt;eval EXPR&gt;
frame.)  $subroutine may also be C&lt;(unknown)&gt; if this particular
subroutine happens to have been deleted from the symbol table.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012339Z" changeid="explorer">
        <seg>(Note también que cada instrucción C&lt;use&gt; crea un marco C&lt;require&gt; dentro de un marco C&lt;eval EXPR&gt;).  $subrutina puede ser también C&lt;(unknown)&gt; (desconocida) si esta subrutina en particular parece haber sido borrada de la tabla de símbolos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no such thing as an unvarying, physical
newline character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe tal cosa como un invariable o físico, carácter de nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not try to use Perl's malloc, this will lead into very mysterious
errors (especially with -Duse64bitall).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004025Z" changeid="explorer">
        <seg>No intente usar el malloc de Perl, esto le conducirá a errores muy misteriosos (especialmente con -Duse64bitall)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 2) = 1   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 2) = 1   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is described in more detail below
and in L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ésto se describe con mayor detalle más abajo y en L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $foo eq &quot;Perl&quot; eq &quot;\x50\x65\x72\x6C&quot;, 32 bits</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># $foo eq &quot;Perl&quot; eq &quot;\x50\x65\x72\x6C&quot;, 32 bits</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want the pattern compiled only once the first time
the variable is interpolated, use the C&lt;/o&gt; option.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea que el patrón sea compilado solo la primera vez que la variable sea interpola, utilice la opción C&lt;/o&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $packed = getsockopt($socket, $tcp, TCP_NODELAY)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $packed = getsockopt($socket, $tcp, TCP_NODELAY)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hash    =&gt;  {
                     description =&gt; &quot;key/value pairs&quot;,
                     sigil =&gt; '%',
                    },</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055529Z" changeid="explorer">
        <seg>hash    =&gt;  {
                     description =&gt; &quot;pares clave/valor&quot;,
                     sigil =&gt; '%',
                    },</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failed Test                  Stat Wstat Total Fail  Failed  List of Failed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055015Z" changeid="explorer">
        <seg>Test erróneos                Stat Wstat Total Fallo Falló   Lista de fallados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt; `EOC`; # execute command and get results</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt; `EOC`; # ejecuta comando y obtén resultados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$Some_Caps_Here  package-wide global/static</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$Algunas_Mayusculas Ámbito de paquete/estática</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They may appear to sleep longer than that,
however, because your process might not be scheduled right away in a
busy multitasking system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, quizás puedan parecer dormir más de lo indicado, debido a que su proceso no puede ser planificado de forma inmediata en un sistema multitarea ocupado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12756</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12756</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar or list context propagates downward into the 2nd
or 3rd argument, whichever is selected.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Contexto escalar o lista es propagado hacia adelante, en el segundo o tercer argumento, cualquiera que sea el seleccionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading in the whole file at one time is called slurping.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235621Z" changeid="zipf">
        <seg>La lectura de un archivo completo se suele llamar &quot;slurping&quot; (succión).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a_or_b ? $a : $b) = $c;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054051Z" changeid="explorer">
        <seg>($a_o_b ? $a : $b) = $c;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't have write access to the DBM file, you can only read hash
variables, not set them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no tiene permiso de escritura al archivo DBM, sólo podrá leer las variables hash, pero no asignarlas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;.IX foo\n&quot;    if /\bfoo\b/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;.IX foo\n&quot;    if /\bfoo\b/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Regexp Quote-Like Operators
X&lt;operator, regexp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003334Z" changeid="explorer">
        <seg>=head2 Operadores Regexp entrecomillados
X&lt;operator, regexp&gt; X&lt;operador, regexp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C&lt;ioctl&gt;, it maps a C&lt;0&gt; return from the system call into
C&lt;&quot;0 but true&quot;&gt; in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como C&lt;ioctl&gt;, mapea un C&lt;0&gt; devuelto de la llamada del sistema en un C&lt;&quot;0 but true&quot;&gt; (&quot;0 pero cierto&quot;) en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The auto-decrement operator is not magical.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador de auto decremento no es mágico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length of OPSTRING 
implies the number of semaphore operations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La longitud de OPSTRING implica el número de operaciones de semáforos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a list reference that does I&lt;NOT&gt; interpolate, see L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para hacer referencia a una lista que &lt;NO&gt; interpole, véase L&lt;perlref&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.                   a single character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055609Z" changeid="explorer">
        <seg>.                   un solo carácter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlglossary	Perl Glossary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlglossary	Glosario Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%U    a synonym for %lu</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%U    un sinónimo para %lu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This entered computer lingo via the paper &quot;On Holy Wars and a Plea for
Peace&quot; by Danny Cohen, USC/ISI IEN 137, April 1, 1980.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto entró en la jerga informática a través del documento &quot;On Holy Wars and a Plea for Peace&quot; (De las Guerras Santas y un llamamiento por la Paz), de Danny Cohen, USC/ISI IEN 137, 1 de abril de 1980.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first pass is finding the end of the quoted construct, where
the information about the delimiters is used in parsing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer paso es encontrar el final de la construcción entrecomillada, donde la información sobre los delimitadores se utiliza en el análisis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>into the next variable in the parameter list</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>en la siguiente variable en la lista de parámetros</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Alphabetical Listing of Perl Functions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015652Z" changeid="explorer">
        <seg>=head2 Lista de funciones de Perl en orden alfabético</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>introduce the -t option for gentler taint checking</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>introducir la opción -t para un control de seguridad aceitoso más suave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the constructor from the C&lt;IO::Handle&gt; package (or one of its
subclasses, such as C&lt;IO::File&gt; or C&lt;IO::Socket&gt;), you can generate anonymous
filehandles that have the scope of whatever variables hold references to
them, and automatically close whenever and however you leave that scope:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilizando el constructor del paquete C&lt;IO::Handle&gt; (o una de sus subclases, como C&lt;IO::File&gt; o C&lt;IO::Socket&gt;), puede generar gestores de archivo anónimos que tienen el ámbito de cualquiera de las variables que contengan referencias a ellas, y se cierran automáticamente cuando salgan del ámbito de aplicación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getc FILEHANDLE
X&lt;getc&gt; X&lt;getchar&gt; X&lt;character&gt; X&lt;file, read&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211559Z" changeid="explorer">
        <seg>=item getc GESTOR_ARCHIVO
X&lt;getc&gt; X&lt;getchar&gt; X&lt;character&gt; X&lt;file, read&gt; X&lt;archivo, lectura&gt; X&lt;carácter&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise it returns false (specifically, the empty string).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, devuelve falso (en concreto, la cadena vacía).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Semicolon omitted in &quot;short&quot; one-line BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Punto y coma omitido en BLOQUE &quot;pequeño&quot; de una sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's equivalent to &amp;&amp; except for the very low
precedence.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es el equivalente de &quot;&amp;&amp;&quot; excepto por tener una precedencia muy baja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print @AoA;		# WRONG</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193252Z" changeid="explorer">
        <seg>print @AoA;		# MAL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Perl variable types</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233922Z" changeid="zipf">
        <seg>=head2 Tipos de variables de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takis Psarogiannakopoulos
Universirty of Cambridge
Centre for Mathematical Sciences
Department of Pure Mathematics
Wilberforce road
Cambridge CB3 0WB , UK
email &lt;takis@XFree86.Org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040316Z" changeid="explorer">
        <seg>Takis Psarogiannakopoulos
Universidad de Cambridge
Centro para las Ciencias Matemáticas
Departamento de Matemáticas Puras
Wilberforce road
Cambridge CB3 0WB , UK
email &lt;takis@XFree86.Org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require 5.6.1;      # ditto</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require 5.6.1;      # ídem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For BeOS specifics problems feel free to mail to:
Ingo Weinhold &lt;bonefish@cs.tu-berlin.de&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para información específica de problemas BeOS no dude en enviar un correo a: Ingo Weinhold &lt;bonefish@cs.tu-berlin.de&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dealing with bugs and bug reports
is unglamorous work; not something ideally suited to volunteer labour,
but that is all that we have.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tratar con errores e informes de errores es un trabajo poco atractivo; no es algo ideal para un trabajo voluntario, pero eso es todo lo que tenemos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, splits the C&lt;$_&gt; string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es omitido, divide la cadena C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldelta		Perl changes since previous version</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldelta		Cambios desde la versión anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is often more readable to use the C&lt;&lt; =&gt; &gt;&gt; operator between key/value
pairs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A menudo es más legible usar el operador C&lt;&lt; =&gt; &gt;&gt; entre los pares clave / valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!/usr/bin/perl -wl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#!/usr/bin/perl -wl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Range Operators
X&lt;operator, range&gt; X&lt;range&gt; X&lt;..&gt; X&lt;...&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001023Z" changeid="explorer">
        <seg>=head2 Operadores de rango
X&lt;operator, range&gt; X&lt;range&gt; X&lt;..&gt; X&lt;...&gt; X&lt;operador, rango&gt; X&lt;rango&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># blank line between header and body</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># línea en blanco entre cabecera y cuerpo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may be other
reasons you can't actually read, write, or execute the file: for
example network filesystem access controls, ACLs (access control lists),
read-only filesystems, and unrecognized executable formats.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede haber otras razones por las que no pueda leer, escribir o ejecutar un archivo: por ejemplo, controles de acceso a sistemas de archivos en red, ACL (listas de control de acceso), sistemas de archivos de solo lectura, y formatos irreconocibles de ejecutables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting from a C&lt;tied&gt; hash
or array may not necessarily return anything; it depends on the implementation
of the C&lt;tied&gt; package's DELETE method, which may do whatever it pleases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Borrando de un hash o array C&lt;enlazado&gt; no necesariamente devolverá algo; depende de la implementación del método DELETE en el paquete C&lt;enlazado&gt;, que puede hacer lo que quiera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(($foo &amp; 255) + 1, &quot;\n&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(($foo &amp; 255) + 1, &quot;\n&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$pattern = &quot;foobar&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234632Z" changeid="explorer">
        <seg>$patron = &quot;foobar&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n}+   Match exactly n times and give nothing back (redundant)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n}+   Coincide exactamente n veces y no devuelve nada (redundante)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match at least n times, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide al menos n veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the commas on the right of the sort are evaluated before the sort,
but the commas on the left are evaluated after.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>las comas a la derecha de sort son evaluadas antes que el sort, pero las comas a la izquierda se evalúan después.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are traditionally valued 1, 2, 8 and 4, but
you can use the symbolic names if you import them from the Fcntl module,
either individually, or as a group using the ':flock' tag.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas constantes tienen, tradicionalmente, los valores 1, 2, 8 y 4, pero puede usar los nombres simbólicos si los importa con el módulo Fcntl, tanto de forma indivual o como un grupo usando la marca ':flock'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Unicode keys with tied hashes should now work correctly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando claves Unicode con hashes enlazados ahora debería funcionar correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $z      = substr $s, -4, 2;     # tr</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $z      = substr $s, -5, 2;     # ve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, including instructions for other platforms such as
Windows and Mac OS, read L&lt;perlrun&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224657Z" changeid="explorer">
        <seg>Para obtener más información e instrucciones para otras plataformas, como Windows y Mac OS, lea L&lt;perlrun&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closing any piped filehandle causes the parent process to wait for the
child to finish, and returns the status value in C&lt;$?&gt; and
C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cerrando cualquier gestor de archivo entubado hace que el proceso padre espere que el hijo termine, y devuelva el valor de estado en C&lt;$?&gt; y en C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>man perldgux</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>man perldgux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no string is specified
via the C&lt;=~&gt; or C&lt;!~&gt; operator, the $_ string is searched.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se especifica una cadena vía los operadores C&lt;=~&gt; o C&lt;!~&gt;, se busca en la cadena $_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 4) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 4) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item opendir DIRHANDLE,EXPR
X&lt;opendir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191916Z" changeid="explorer">
        <seg>=item opendir GESTOR_DIR,EXPR
X&lt;opendir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir ($foo) * 20;	# (chdir $foo) * 20</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir ($foo) * 20;	# (chdir $foo) * 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>refers to such a Package if it has not been
modified, or has been modified in accordance with the wishes of the
Copyright Holder as specified below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>se refiere a un paquete, si no ha sido modificado o ha sido modificado de conformidad con los deseos del propietario del Titular del Copyright tal como se especifica a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@counts = ( scalar @a, scalar @b, scalar @c );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contadores = ( scalar @a, scalar @b, scalar @c );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204516Z" changeid="explorer">
        <seg>Véase L&lt;perlipc&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$~ = 'Something';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$~ = 'Algo';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to refer to a named capture buffer by absolute and relative number as well.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es posible hacer referencia a una memoria de captura nominada tanto por su número absoluto como relativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a 4-byte integer
0x12345678 (305419896 decimal) would be ordered natively (arranged in and
handled by the CPU registers) into bytes as</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, un entero de 4 bytes 0x12345678 (305419896 en decimal) se ordenaría nativamente (dispuesto en y manejado por los registros de la CPU) en bytes como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::FixedPrecision	calculate with a fixed precision</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::FixedPrecision     calcula con una precisión fija</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a, $b, @rest) = split;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a, $b, @resto) = split;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$header =~ s/\n(?=\s)//g;  # fix continuation lines</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$encabezado =~ s/\n(?=\s)//g;  # arregla la continuación de líneas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub prompt { print &quot;yes?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub prompt { print &quot;¿si?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the input string is longer than needed, remaining characters are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena de entrada es más larga de lo necesario, los caracteres sobrantes se ignoran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $variables = {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232613Z" changeid="explorer">
        <seg>my $variables = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The require function will look for the &quot;F&lt;Foo::Bar&gt;&quot; file in the @INC array and
will complain about not finding &quot;F&lt;Foo::Bar&gt;&quot; there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función require buscará por el archivo &quot;F&lt;Foo::Bar&gt;&quot; en los directorios especificados por el array C&lt;@INC&gt; y se quejará de que no lo encuentra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item state EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item state EXPR : ATRIBS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to these
changes, lots of work took place in integrating threads, PerlIO, and
Unicode; general code cleanup; and last but not least porting to
non-Unix lands such as Win32, VMS, Cygwin, DJGPP, VOS, MacOS Classic,
and EBCDIC.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de estos cambios, mucho trabajo se llevó a cabo en la integración de I&lt;threads&gt;, PerlIO, y Unicode; limpieza general del código, y por último, pero no menos importante, portar a los no-Unix, tales como Win32, VMS, Cygwin, DJGPP, VOS, Mac OS Classic, y EBCDIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't bother.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181236Z" changeid="zipf">
        <seg>No es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;You&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Usted&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># guarantee stability, regardless of algorithm</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># garantiza estabilidad, sin importar el algoritmo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$_&gt; is lexical in the scope where the C&lt;map&gt; appears (because it has
been declared with C&lt;my $_&gt;), then, in addition to being locally aliased to
the list elements, C&lt;$_&gt; keeps being lexical inside the block; that is, it
can't be seen from the outside, avoiding any potential side-effects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$_&gt; es léxico en el ámbito cuando el C&lt;map&gt; aparece (porque se ha declarado con C&lt;my $_&gt;), entonces, además de ser un alias local a los elementos de la lista, C&lt;$_&gt; sigue siendo léxico dentro del bloque, es decir, no puede ser visto desde el exterior, evitando cualquier potencial efecto secundario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last update: 2004-12-16</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Última actualización: 2004-12-16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$days		# the simple scalar value &quot;days&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$dias		# el valor escalar único llamado &quot;dias&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
the current implementation, no temporary array is created when the
range operator is used as the expression in C&lt;foreach&gt; loops, but older
versions of Perl might burn a lot of memory when you write something
like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la implementación actual, no se crea ningún array temporal cuando el operador rango es usado como expresión en los bucles C&lt;foreach&gt;, pero versiones anteriores de Perl pueden quemar una gran cantidad de memoria cuando se escribe algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first element of the
list must be the numerical mode, which should probably be an octal
number, and which definitely should I&lt;not&gt; be a string of octal digits:
C&lt;0644&gt; is okay, but C&lt;&quot;0644&quot;&gt; is not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer elemento de la lista debe ser un modo numérico, que normalmente estará en octal, y que, definitivamente, I&lt;no&gt; debe ser una cadena de dígitos en octal: C&lt;0644&gt; es correcto, C&lt;&quot;0644&quot;&gt; no lo es.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is just like the C&lt;/pattern/&gt; search, except that it matches only
once between calls to the reset() operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es igual que la búsqueda C&lt;/patrón/&gt;, salvo que coincide una sola vez entre llamadas al operador reset().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod&gt; for details on this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod&gt; para detalles sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the current arguably broken state of C&lt;__DIE__&gt; hooks, you
may wish not to trigger any C&lt;__DIE__&gt; hooks that user code may have installed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido al posible mal estado de la llamada C&lt;__DIE__&gt;, quizás deseé no activar ninguna de las llamadas C&lt;__DIE__&gt; que el código de usuario puede haber instalado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See C&lt;sprintf&gt;
for an explanation of the format argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver C&lt;sprintf&gt; para una explicación del argumento formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The defaults
are there for lazy systems programmers writing one-shot programs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores por defecto son para los programadores de sistemas perezosos escribiendo programas pequeños.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(':', split(/\W/, 'hi there!', -1)), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(':', split(/\W/, 'hola aqui!', -1)), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string which is (possibly) interpolated and then executed as a
system command with C&lt;/bin/sh&gt; or its equivalent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una cadena que es (posiblemente) interpolada y luego ejecutada como un comando del sistema con C&lt;/bin/sh&gt; o su equivalente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may alter the usual smart match semantics.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esta manera se altera la semántica normal de la coincidencia inteligente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltie		Perl objects hidden behind simple variables</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perltie		Objetos Perl detrás de variables sencillas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = (($foo,$bar) = f());           # set $x to f()'s return count</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035826Z" changeid="explorer">
        <seg>$x = (($foo,$bar) = f());           # pone $x al número de valores devueltos por f()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $animals[1];              # prints &quot;llama&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121217Z" changeid="zipf">
        <seg>print $animales[1];  # imprime &quot;llama&quot; en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 10.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>b) the &quot;Artistic License&quot; which comes with this Kit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>b) la &quot;Licencia Artística&quot; que viene con este equipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item printf FORMAT, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item printf FORMATO, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Yada Yada Operator
X&lt;...&gt; X&lt;... operator&gt; X&lt;yada yada operator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001507Z" changeid="explorer">
        <seg>=head2 Operador blablablá
X&lt;...&gt; X&lt;... operator&gt; X&lt;yada yada operator&gt; X&lt;operador blablablá&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a C&lt;bless&gt; is often the last thing in a constructor,
it returns the reference for convenience.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como un C&lt;bless&gt; a menudo es la última cosa de un constructor, devuelve la referencia por conveniencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A
potential problem caught by C&lt;use strict;&gt; will cause your code to stop
immediately when it is encountered, while C&lt;use warnings;&gt; will merely
give a warning (like the command-line switch B&lt;-w&gt;) and let your code run.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224714Z" changeid="explorer">
        <seg>Un posible problema detectado por C&lt;use strict;&gt; hará que el código se detenga inmediatamente, mientras que C&lt;use warnings;&gt; (al igual que el modificador de línea de comandos B&lt;-w&gt;) sólo mostrará una advertencia y dejará que el código se ejecute.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mung $first or die &quot;mung failed&quot;;  # Or here.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>mung $primero or die &quot;mung falló&quot;;  # O aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no parentheses, it returns a list of all
the matched strings, as if there were parentheses around the whole
pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay paréntesis, devuelve una lista de todas las cadenas coincidentes, como si hubiera paréntesis alrededor de todo el patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pack and unpack can operate in two modes: character mode (C&lt;C0&gt; mode) where
the packed string is processed per character, and UTF-8 mode (C&lt;U0&gt; mode)
where the packed string is processed in its UTF-8-encoded Unicode form on
a byte-by-byte basis.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pack y unpack pueden funcionar de dos modos: modo de caracteres (modo C&lt;C0&gt;) donde la cadena empaquetada es procesada por cada carácter, y el modo UTF-8 (modo C&lt;U0&gt;) donde la cadena empaquetada es procesada en su formato codificado en UTF-8, byte a byte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PUSH this, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>PUSH este, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with value &gt;= 4252.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004828Z" changeid="explorer">
        <seg>with value &gt;= 4252.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%2s&gt;', &quot;long&quot;;   # prints &quot;&lt;long&gt;&quot; (does not truncate)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%2s&gt;', &quot;long&quot;;   # imprime &quot;&lt;long&gt;&quot; (no lo trunca)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class implementing a hash should have the following methods:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una clase que implementa un hash debe tener los siguientes métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, it doesn't think the C&lt;...&gt; is the yada yada
because it's expecting an expression instead of a statement:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012723Z" changeid="explorer">
        <seg>En ese caso, Perl no cree que el C&lt;...&gt; es el blablablá porque está esperando una expresión en lugar de una instrucción:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The I&lt;length-item&gt; is not returned explicitly from C&lt;unpack&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La I&lt;longitud-item&gt; no se devuelve de forma explícita desde C&lt;unpack&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, that's because the rule is that on adjacent brackets only (whether
square or curly), you are free to omit the pointer dereferencing arrow.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bueno, eso es porque la regla dice que sólo en los corchetes o llaves adyacentes, es libre de omitir la flecha de referencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = [ split ' ', scalar(&lt;&gt;) ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$i] = [ split ' ', scalar(&lt;&gt;) ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whatever happens in the RE engine might be better discussed in L&lt;perlre&gt;,
but for the sake of continuity, we shall do so here.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pase lo que pase en el motor de RE podría estar mejor explicado en L&lt;perlre&gt;, pero en aras de la continuidad, lo haremos aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can always switch mode mid-format with an explicit 
C&lt;C0&gt; or C&lt;U0&gt; in the format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre puede cambiar de modo con un explícito C&lt;C0&gt; o C&lt;U0&gt; en mitad del formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;eof()&gt;
with empty parentheses is different.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar C&lt;eof()&gt; con paréntesis vacíos es diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means the following
behavior holds:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que el siguiente comportamiento cumple que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since changing a slice changes the original array or hash that it's
slicing, a C&lt;foreach&gt; construct will alter some--or even all--of the
values of the array or hash.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234939Z" changeid="explorer">
        <seg>Debido a que alterar una porción altera al array o hash original, una construcción C&lt;foreach&gt; alterará algunos -o incluso todos- los valores del array o hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a[$i] = $y         splice(@a,$i,1,$y)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a[$i] = $y         splice(@a,$i,1,$y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the output is empty and C&lt;$@&gt; already contains a value (typically from a
previous eval) that value is reused after appending C&lt;&quot;\t...propagated&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la LISTA está vacía y C&lt;$@&gt; ya contiene un valor (típicamente de un eval() anterior) este valor es reutilizado después de añadirle C&lt;&quot;\t...propagated&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Respects current LC_CTYPE locale.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174902Z" changeid="explorer">
        <seg>Respeta la actual configuración regional LC_CTYPE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;last&gt; command is like the C&lt;break&gt; statement in C (as used in
loops); it immediately exits the loop in question.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012519Z" changeid="explorer">
        <seg>El comando C&lt;last&gt; es como la instrucción C&lt;break&gt; del C (usada en bucles); inmediatamente sale del bucle en cuestión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;IPC::Open2&gt;, L&lt;IPC::Open3&gt;, and L&lt;perlipc/&quot;Bidirectional Communication&quot;&gt;
for examples of such things.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;IPC::Open2&gt;, L&lt;IPC::Open3&gt;, y L&lt;perlipc/&quot;Comunicación Bidireccional&quot;&gt; para ejemplos de estas cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is yet another way to print your environment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay otra forma de imprimir su entorno:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = 'pq';  print $x,&quot;\n&quot;;    # prints 5pq9</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = 'pq';  print $x,&quot;\n&quot;;    # imprime 5pq9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;$f&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;$f&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are upgrading from an earlier release such as 5.6.1, first read
the L&lt;perl58delta&gt;, which describes differences between 5.6.0 and
5.8.0, and the L&lt;perl581delta&gt;, which describes differences between
5.8.0 and 5.8.1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está actualizando desde una versión anterior como la 5.6.1, primero lea L&lt;perl58delta&gt;, que describe las diferencias entre 5.6.0 y 5.8.0, y L&lt;perl581delta&gt;, que describe las diferencias entre 5.8.0 y 5.8.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;&gt; 8;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&gt;&gt; 8;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just what is in the packed string depends on LEVEL and OPTNAME;
consult getsockopt(2) for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo que exactamente esté en la cadena empaquetada depende de NIVEL y OPCIÓN; consulte getsockopt(2) para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It means &quot;use the standard size for a Perl
integer or floating-point number&quot;, which is the default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa &quot;usar el tamaño estándar de un entero Perl o punto de número de coma flotante&quot;, que es el predeterminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practical hint: you almost never need to use C&lt;eof&gt; in Perl, because the
input operators typically return C&lt;undef&gt; when they run out of data, or if
there was an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Truco práctico: casi nunca necesita usar C&lt;eof&gt; en Perl, porque los operadores de entrada normalmente devuelven C&lt;undef&gt; cuando no hay más datos, o si ocurrió un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlop/&quot;Regexp Quote-Like Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop/&quot;Operadores Regexp entrecomillados&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-z  File has zero size (is empty).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004620Z" changeid="explorer">
        <seg>-z  Archivo tiene tamaño cero (está vacío).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prints the value of LIST to STDERR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Imprime el valor de LISTA a STDERR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Gestores de archivo se deben pasar como comodines o referencias a comodines para que sean reconocidos; las palabras sueltas se consideran como nombres de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, C&lt;our&gt; has the same
scoping rules as C&lt;my&gt;, but does not necessarily create a
variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, C&lt;our&gt; tiene el alcance de las mismas reglas que C&lt;my&gt;, pero no crea necesariamente una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no shell metacharacters in the argument,
it is split into words and passed directly to C&lt;execvp&gt;, which is
more efficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay metacaracteres shell en el argumento, es dividido en palabras y pasadas directamente a C&lt;execvp&gt;, que es más eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And the tables used by hashes (sometimes called
&quot;associative arrays&quot;) grow as necessary to prevent degraded
performance.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y las tablas utilizadas por los hashes (a veces llamadas &quot;matrices asociativas&quot;) crecen lo que sea necesario para evitar que el rendimiento se degrade.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;open&gt; pragma can be used to
establish default I/O layers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El pragma C&lt;open&gt; puede ser usado para establecer las capas I/O por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use sigtrap&gt; and even C&lt;use diagnostics&gt; pragmas
may also prove useful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El pragma C&lt;use sigtrap&gt; e incluso el C&lt;use diagnostics&gt; pueden ser también muy útiles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to its precedence, you should
probably avoid using this for assignment, only for control flow.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a su precedencia, probablemente debería evitar el uso de este operador para hacer asignaciones, sólo para control de flujo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>()	Grouping</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>()	Agrupación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes various features of Irix that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002306Z" changeid="explorer">
        <seg>Este documentos describe varias características de Irix que afectarán a cómo Perl versión 5 (de ahora en adelante sólo Perl) es compilado y/o ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Tie::Hash</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Tie::Hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means, for example, that C&lt;-f($file).&quot;.bak&quot;&gt; is
equivalent to C&lt;-f &quot;$file.bak&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234937Z" changeid="explorer">
        <seg>Esto significa, por ejemplo, que C&lt;-f($archivo).&quot;.bak&quot;&gt; es equivalente a C&lt;-f &quot;$file.bak&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Irix cc versions, e.g. 7.3.1.1m (try cc -version) have been known
to have issues (coredumps) when compiling perl.c.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003056Z" changeid="explorer">
        <seg>Algunas versiones de cc de Irix, por ejemplo, la 7.3.1.1m (pruebe cc -version) se sabe que tienen problemas (coredumps) al compilar perl.c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -Dcc='cc -n32'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002335Z" changeid="explorer">
        <seg>sh Configure -Dcc='cc -n32'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting from the beginning of the template to pack(), each pair
of characters is converted to 1 character of output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir del comienzo de la plantilla a pack(), cada par de caracteres se convierte en un carácter en la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is due to bugs in Haiku's network stack implementation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se debe a errores en la implementación de la pila del sistema de red de Haiku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;pack&gt;, C&lt;read&gt;, C&lt;syscall&gt;, C&lt;sysread&gt;, C&lt;syswrite&gt;, C&lt;unpack&gt;, C&lt;vec&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;pack&gt;, C&lt;read&gt;, C&lt;syscall&gt;, C&lt;sysread&gt;, C&lt;syswrite&gt;, C&lt;unpack&gt;, C&lt;vec&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;$+&gt; X&lt;$^N&gt; X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;$+&gt; X&lt;$^N&gt; X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcheat		Perl cheat sheet</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlcheat		Chuleta Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>login( $username =&gt; $password );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>login( $usuario =&gt; $contraseña );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the terminating string is quoted, the type of quotes used determine
the treatment of the text.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena de terminación está entrecomillada, el tipo de comillas usadas determinan el tratamiento del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>m/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The precedence of &quot;and&quot;
and &quot;or&quot; is much lower, however, so that you can safely use them after a
list operator without the need for parentheses:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, la precedencia de &quot;and&quot; y &quot;or&quot; es mucho menor, de modo que usted puede usarlos con seguridad después de un operador de lista sin necesidad de paréntesis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You are not allowed to C&lt;open&gt; to a command
that pipes both in I&lt;and&gt; out, but see L&lt;IPC::Open2&gt;, L&lt;IPC::Open3&gt;,
and L&lt;perlipc/&quot;Bidirectional Communication with Another Process&quot;&gt;
for alternatives.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(No se le permite hacer un C&lt;open&gt; a un comando que entube tanto en la entrada I&lt;como&gt; en la salida, pero véase L&lt;IPC::Open2&gt;, L&lt;IPC::Open3&gt;, y L&lt;perlipc/&quot;Comunicación bidireccional con otro proceso&quot;&gt; para alternativas sobre esto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item last LABEL
X&lt;last&gt; X&lt;break&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174200Z" changeid="explorer">
        <seg>=item last ETIQUETA
X&lt;last&gt; X&lt;break&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make install</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make install</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@array[ 4 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach (@array[ 4 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setpriority WHICH,WHO,PRIORITY
X&lt;setpriority&gt; X&lt;priority&gt; X&lt;nice&gt; X&lt;renice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200518Z" changeid="explorer">
        <seg>=item setpriority CUÁL,QUIÉN,PRIORIDAD
X&lt;setpriority&gt; X&lt;priority&gt; X&lt;nice&gt; X&lt;renice&gt; X&lt;prioridad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most programs won't even call srand() at all, except those that
need a cryptographically-strong starting point rather than the
generally acceptable default, which is based on time of day,
process ID, and memory allocation, or the F&lt;/dev/urandom&gt; device
if available.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de los programas ni siquiera llaman a srand(), excepto los que necesitan un fuerte punto de partida criptográfico en lugar del valor por defecto, que se basa en la hora del día, el ID del proceso, la asignación de memoria, o el dispositivo F&lt;/dev/urandom&gt; si está disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;feature&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;feature&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, if the left operand is enclosed in
parentheses or is a list formed by C&lt;qw/STRING/&gt;, it repeats the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, si el operando de la izquierda se encierra entre paréntesis o es una lista formada por C&lt;qw/CADENA/&gt;, repite la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $hash{A}{B}[$ix])        { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $hash{A}{B}[$i])           { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at bzzzt line 201.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at bzzzt line 201.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,12, 2) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,12, 2) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>jJfFdDpP   (The &quot;little end&quot; touches the construct.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>jJfFdDpP   (El &quot;little end&quot; toca la construcción).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The collected standard
output of the command is returned; standard error is unaffected.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo lo que salga por la salida estándar del comando se devuelve; la salida estándar de error no se verá afectada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may therefore need to use multiple formlines to implement a single
record format, just like the C&lt;format&gt; compiler.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede por eso necesitar usar múltiples formlines para implementar un único registro format, como lo hace el propio compilador de C&lt;format&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Quote and Quote-like Operators
X&lt;operator, quote&gt; X&lt;operator, quote-like&gt; X&lt;q&gt; X&lt;qq&gt; X&lt;qx&gt; X&lt;qw&gt; X&lt;m&gt;
X&lt;qr&gt; X&lt;s&gt; X&lt;tr&gt; X&lt;'&gt; X&lt;''&gt; X&lt;&quot;&gt; X&lt;&quot;&quot;&gt; X&lt;//&gt; X&lt;`&gt; X&lt;``&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;
X&lt;escape sequence&gt; X&lt;escape&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185057Z" changeid="explorer">
        <seg>=head2 Comillas y Operadores de comillas
X&lt;operator, quote&gt; X&lt;operator, quote-like&gt; X&lt;q&gt; X&lt;qq&gt; X&lt;qx&gt; X&lt;qw&gt; X&lt;m&gt;
X&lt;qr&gt; X&lt;s&gt; X&lt;tr&gt; X&lt;'&gt; X&lt;''&gt; X&lt;&quot;&gt; X&lt;&quot;&quot;&gt; X&lt;//&gt; X&lt;`&gt; X&lt;``&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;
X&lt;escape sequence&gt; X&lt;escape&gt; X&lt;escapado&gt; X&lt;operador, comilla&gt; X&lt;operador, entrecomillado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that doesn't work (some I/O implementations are particularly
cantankerous), you might need something like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si eso no funciona (algunas implementaciones de E/S son particularmente irritables), puede que tenga que hacer algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other rules are likely to contradict the user's
expectations much less frequently than this first one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las demás normas es probable que contradigan las expectativas del usuario con mucha menos frecuencia que ésta primera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./configure.gnu --prefix=/boot/home/config</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>./configure.gnu --prefix=/boot/home/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following rules apply:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se aplica las siguientes reglas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%-8s %s\n&quot;, $user, $home;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%-8s %s\n&quot;, $user, $home;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE&gt;: Failed matches in Perl do not reset the match variables,
which makes it easier to write code that tests for a series of more
specific cases and remembers the best match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;NOTA&gt;: Coincidencias fallidas en perl no reinicializan las variables de coincidencia, lo que facilita escribir código que haga comprobaciones para una serie específica de casos y recuerde la mejor coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int(rand(10))</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>int(rand(10))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows for computed C&lt;goto&gt;s per FORTRAN, but isn't
necessarily recommended if you're optimizing for maintainability:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto permite crear C&lt;goto&gt; calculados como en FORTRAN, pero no está necesariamente recomendado si usted está optimizando, durante el mantenimiento:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== -1) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== -1) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;x$where a$howmuch&quot;, $what);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;x$donde a$cuanto&quot;, $que);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All list elements are numeric, and come straight out of the C `struct
tm'.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todos los elementos de la lista son numéricos y derivan de la 'struct tm' del C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub backwards { $b cmp $a }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub al_reves { $b cmp $a }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot;, &quot;judy&quot;, ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot;, &quot;judy&quot;, ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other values are true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todos los demás valores son verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getgrent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getgrent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likely candidates are: &quot;op/stat&quot;, &quot;lib/io_pipe&quot;,
&quot;lib/io_sock&quot;, &quot;lib/io_udp&quot; and &quot;lib/time&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los candidatos probables son: &quot;op/stat&quot;, &quot;lib/io_pipe&quot;, &quot;lib/io_sock&quot;, &quot;lib/io_udp&quot; y &quot;lib/hora&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The conditions can be any Perl expression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181953Z" changeid="zipf">
        <seg>Una condición puede ser cualquier expresión Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to the control flow of your Perl program
X&lt;control flow&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201736Z" changeid="explorer">
        <seg>=item Identificadores relativos al control de flujo de tu programa Perl
X&lt;control flow&gt; X&lt;control de flujo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir '/usr/spool/news' or die &quot;Can't cd to spool: $!\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir '/usr/spool/news' or die &quot;No puedo entrar en spool/: $!\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unlink</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item unlink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array indices start with 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los índices de array empiezan por 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the only form of quoting in perl where there is no need
to worry about escaping content, something that code generators
can and do make good use of.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la única forma de entrecomillar en Perl donde no es necesario preocuparse por el escapado del contenido, algo que los generadores de código pueden y hacen buen uso de él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the name of a file; an existing file NEWNAME will be
clobbered.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia el nombre de un archivo; un archivo existente que se llame NOMBRE_NUEVO será sobreescrito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;Permissions are %04o\n&quot;, S_IMODE($mode), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Permisos son %04o\n&quot;, S_IMODE($modo), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also import the symbolic C&lt;S_I*&gt; constants from the C&lt;Fcntl&gt;
module:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede importar las constantes simbólicas C&lt;S_I*&gt; desde el módulo Fcntl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array   Regex     array grep               grep /$b/, @$a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Array       Regex      grep array                       grep /$b/, @$a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$passwd,$gid,$members) = getgr*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($name,$passwd,$gid,$members) = getgr*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\1&gt; in the replacement of C&lt;s'''&gt; does not work as C&lt;$1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;\1&gt; en el reemplazo de C&lt;s'''&gt; no funciona como C&lt;$1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 4) = 2   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 4) = 2   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(At one point C&lt;$0&gt; did
also, but now it returns the name of the program.)  C&lt;$`&gt; returns
everything before the matched string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Hace un tiempo, C&lt;$0&gt; también lo hacía, pero ahora devuelve el nombre del programa).  C&lt;$`&gt; devuelve todo lo anterior a la cadena coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The STDIN filehandle used by the command is inherited from Perl's STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El gestor de archivo STDIN utilizado por el comando se hereda del STDIN de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both OFFSET and LENGTH are omitted, removes everything.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ambos DESPLAZAMIENTO y LONGITUD se omiten, quita todo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># short 12, zero fill to position 4, long 34</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un 12 short, relleno con ceros a la posición 4, un 34 long</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in C, the scalar assignment operator produces a valid lvalue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203531Z" changeid="explorer">
        <seg>A diferencia de C, el operador de asignación escalar produce un I&lt;ivalor&gt; válido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlreguts		Perl regular expression engine internals</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlreguts		Interiores del motor de expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
largely eliminates the need for typeglobs when opening filehandles
that must be passed around, as in the following example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto elimina en gran medida la necesidad de typeglobs al abrir gestores de archivo que deberían ser traspasados, como en el ejemplo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILENAME is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite NOMBRE_DIRECTORIO, utiliza C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $x = &quot;foo&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232627Z" changeid="explorer">
        <seg>my $x = &quot;foo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;a3/A A*&quot;, &quot;007 Bond  J &quot;)       gives (&quot; Bond&quot;, &quot;J&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;a3/A A*&quot;, &quot;007 Bond  J &quot;)       da (&quot; Bond&quot;, &quot;J&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next step is interpolation in the text obtained, which is now
delimiter-independent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El siguiente paso es la interpolación del texto obtenido, que ahora es independiente del delimitador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of bytes
actually written, or C&lt;undef&gt; if there was an error (in this case the
errno variable C&lt;$!&gt; is also set).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de bytes realmente escritos, o C&lt;undef&gt; si hubo un error (en este caso, también se establece la variable C&lt;$!&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LOOP: {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BUCLE: {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mac OS, all variants of Unix, and Stream_LF files on VMS use a single
character to end each line in the external representation of text (even
though that single character is CARRIAGE RETURN on Mac OS and LINE FEED
on Unix and most VMS files).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mac OS, todas las variantes de Unix y los archivos Stream_LF sobre VMS usan un único carácter al final de cada línea en la representación externa del texto (incluso si el carácter único es un RETORNO DE CARRO en Mac OS y un AVANCE DE LÍNEA en Unix y la mayor parte de los archivos VMS).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is designed to give you several
ways to do anything, so consider picking the most readable one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl está diseñado para darle varias opciones para hacer cualquier cosa, así que elija la más legible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it has no direct equivalent in C, Perl's C&lt;//&gt; operator is related
to its C-style or.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A pesar de que no tiene equivalente directo en C, el operador Perl C&lt;//&gt; está relacionado con el operador or del C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that I I&lt;couldn't&gt; say just:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que yo I&lt;no puedo&gt; decir simplemente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the sine of EXPR (expressed in radians).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el seno de EXPR (expresado en radianes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes a block is delimited by the file containing it (in the case
of a required file, or the program as a whole), and sometimes a block
is delimited by the extent of a string (in the case of an eval).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas veces un bloque está delimitado por el archivo que lo contiene (en el caso de un archivo requerido, o el programa entero) y otras veces un bloque está delimitado por la extensión de una cadena (en el caso de un C&lt;eval&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($i++ &lt; 2) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($i++ &lt; 2) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the C&lt;use&gt; function, of which C&lt;no&gt; is the opposite.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver la función C&lt;use&gt;, de la cuál C&lt;no&gt; es lo opuesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>object-oriented programming</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>programación orientada a objetos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may make and give away verbatim copies of the source form of the
Standard Version of this Package without restriction, provided that you
duplicate all of the original copyright notices and associated disclaimers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede hacer y regalar copias literales del contenido original de la Versión Estándar de este Paquete sin restricciones, siempre que se dupliquen todos los avisos de copyright y las renuncias asociadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a mailbox appender for BSD systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es un agregador de correo para sistemas BSD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl593delta	Perl changes in version 5.9.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl593delta	Cambios en la versión 5.9.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single-quoted, literal string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un entrecomillado simple, una cadena de caracteres literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$some_dir/$_\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$algun_dir/$_\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;defined&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;formline&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;,
C&lt;reset&gt;, C&lt;scalar&gt;, C&lt;state&gt;, C&lt;undef&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;defined&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;formline&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;, C&lt;reset&gt;, C&lt;scalar&gt;, C&lt;undef&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, it comes back as a single (potentially
multi-line) string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, se devuelve como una sola cadena (potencialmente multi-línea).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl
has no way of checking whether the value passed to C&lt;unpack()&gt;
corresponds to a valid memory location, passing a pointer value that's
not known to be valid is likely to have disastrous consequences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que Perl no tiene manera de comprobar si el valor pasado a C&lt;unpack()&gt; corresponde a una ubicación de memoria válida, pasando un valor de puntero que no se sabe de su validez, puede tener consecuencias desastrosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Otherwise, if C&lt;use locale&gt; is in effect</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174844Z" changeid="explorer">
        <seg>=item De lo contrario, si C&lt;use locale&gt; está activo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;-s/a/b/&gt; does not do a negated substitution.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;-s/a/b/&gt; no realiza una substitución negada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/this/&lt;&lt;E . 'that'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054239Z" changeid="explorer">
        <seg>s/este/&lt;&lt;E . 'ese'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, using C&lt;unlink&gt; on directories is
not supported on many operating systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por último, con C&lt;unlink&gt; en directorios no está soportado en muchos sistemas operativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically used as
follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Típicamente se usa como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the $comment field is unsupported,
it is an empty scalar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el campo $comentario no está soportado, es un escalar vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the case where some patterns want to be case
sensitive and some do not:  The case insensitive ones merely need to
include C&lt;(?i)&gt; at the front of the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234620Z" changeid="explorer">
        <seg>Considere el caso de que algunos patrones quieren ser sensible a las mayúsculas y otros no: para el caso de los patrones insensibles sólo necesita incluir C&lt;(?i)&gt; por delante del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you set up a loop of piped processes, deadlock can occur
unless you are very careful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si se establece un circuito de procesos entubados, puede producirse un bloqueo mortal a menos que sea muy cuidadoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;!~&quot; is just like &quot;=~&quot; except the return value is negated in
the logical sense.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;!~&quot; es justo como &quot;=~&quot; excepto que el valor de retorno es negado, en el sentido lógico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># insert dashes just before last line of last file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># inserta guiones justo antes de la última línea del último archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You see, assigning a named array like that to a scalar just counts the
number of elements in @tmp, which probably isn't what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ya ve, asignando un array como este a un escalar sólo contaría el número de elementos en @tmp, que probablemente no es lo que quiere.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item require EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item require EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EOF this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EOF este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my (@AoA, $i);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my (@AoA, $i);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exists may also be called on array elements, but its behavior is much less
obvious, and is strongly tied to the use of L&lt;/delete&gt; on arrays.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exists() también pueden ser llamado sobre elementos de array, pero su comportamiento es mucho menos evidente, y está fuertemente ligada a la utilización de L&lt;/delete&gt; en los arreglos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is in
practice difficult to do, as it's unclear how to escape which characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es en la práctica es difícil de hacer, como que no está claro cómo escapar qué caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -V:byteorder</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ perl -V:byteorder</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require 'syscall.ph';        # may need to run h2ph</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require 'syscall.ph';        # puede necesitar ejecutar h2ph</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\N        [7]  Any character but \n (experimental).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224852Z" changeid="explorer">
        <seg>\N        [7]  Cualquier carácter excepto \n (experimental)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Writable\n&quot; if -w _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Escribible\n&quot; if -w _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify a precision (for numeric conversions) or a maximum
width (for string conversions) by specifying a C&lt;.&gt; followed by a number.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede especificar una precisión (para las conversiones numéricas) o una anchura máxima (para las conversiones de cadena) mediante la especificación de un C&lt;.&gt; seguido de un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no filehandle (previous item),
then this subroutine is expected to generate one line of source code per
call, writing the line into C&lt;$_&gt; and returning 1, then returning 0 at
end of file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay un gestor de archivo (punto anterior), entonces esta subrutina se espera que genere una línea de código fuente por llamada, escribiendo en la línea C &amp;lt;$ _&amp;gt; y devolver 1, a continuación, volver 0 al final del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The various named unary operators are treated as functions with one
argument, with optional parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los distintos operadores unarios con nombre son tratados como funciones con un argumento, con paréntesis opcionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrun&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlrun&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it
exits the current subroutine (losing any changes set by local()) and
immediately calls in its place the named subroutine using the current
value of @_.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En cambio, sale de la subrutina actual (perdiendo cualquier cambio hecho por local()) e inmediatamente llama a la subrutina indicada pasandole el valor actual de @_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/   division</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235212Z" changeid="zipf">
        <seg>/   división</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;/e&gt; will cause the
replacement portion to be treated as a full-fledged Perl expression
and evaluated right then and there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;/e&gt; hará que la parte de reemplazo sea tratada como una verdadera expresión Perl y evaluada ahí y en ese mismo momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;O_RDONLY&gt; X&lt;O_RDWR&gt; X&lt;O_WRONLY&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;O_RDONLY&gt; X&lt;O_RDWR&gt; X&lt;O_WRONLY&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item m
X&lt;/m&gt; X&lt;regex, multiline&gt; X&lt;regexp, multiline&gt; X&lt;regular expression, multiline&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222635Z" changeid="explorer">
        <seg>=item m
X&lt;/m&gt; X&lt;regex, multiline&gt; X&lt;regexp, multiline&gt; X&lt;regular expression, multiline&gt; X&lt;regex, multilínea&gt; X&lt;expresión regular, multilínea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Setgid\n&quot; if -g _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Setgid\n&quot; if -g _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a four-element list giving the user and system times, in
seconds, for this process and the children of this process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una lista de cuatro elementos, dando los tiempos de usuario y sistema, en segundos, para este proceso y los hijos de este proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>../lib/sort.t                   0   138   119   72  60.50%  48-119</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055026Z" changeid="explorer">
        <seg>../lib/sort.t                   0   138   119   72  60.50%  48-119</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The End</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fin

=head1 Nota del traductor

Esta traducción C&lt;no&gt; es un documento legal. La expresión de la legalidad de la Licencia Artística reside únicamente en el texto original en inglés de perlartistic.pod.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can see whether Perl has been compiled with PerlIO or not by
running C&lt;perl -V&gt; and looking for C&lt;useperlio=&gt; line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Podrá saber si Perl se ha elaborado con PerlIO o no mediante la ejecución de C&lt;perl -V&gt; y buscando por la línea C&lt;useperlio=&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If too many strange characters (&gt;30%)
are found, it's a C&lt;-B&gt; file; otherwise it's a C&lt;-T&gt; file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T014654Z" changeid="explorer">
        <seg>Si se encuentran demasiados caracteres extraños (E&lt;gt&gt;30%), es un archivo C&lt;-B&gt;; de lo contrario es un archivo C&lt;-T&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If ARRAY is omitted, shifts the
C&lt;@_&gt; array within the lexical scope of subroutines and formats, and the
C&lt;@ARGV&gt; array outside a subroutine and also within the lexical scopes
established by the C&lt;eval STRING&gt;, C&lt;BEGIN {}&gt;, C&lt;INIT {}&gt;, C&lt;CHECK {}&gt;,
C&lt;UNITCHECK {}&gt; and C&lt;END {}&gt; constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ARRAY se omite, desplaza el array C&lt;@_&gt; en el ámbito léxico de subrutinas y formatos, y el array C&lt;@ARGV&gt; fuera de una subrutina y también dentro de los ámbitos léxicos establecidos por construcciones como C&lt;eval CADENA&gt;, C&lt;BEGIN {}&gt;, C&lt;INIT {}&gt;, C&lt;CHECK {}&gt;, C&lt;UNITCHECK {}&gt; y C &lt;END {}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-l  File is a symbolic link.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004651Z" changeid="explorer">
        <seg>-l  Archivo es un enlace simbólico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9, 'a' ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>9, 'a' ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ @{ $lrr-&gt;[$_] } [ $y_lo ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053110Z" changeid="explorer">
        <seg>[ @{ $lrr-&gt;[$_] } [ $y_lo ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are known as
&quot;barewords&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T003834Z" changeid="explorer">
        <seg>Estos son conocidos como &quot;I&lt;barewords&gt;&quot; (palabras sueltas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dump LABEL
X&lt;dump&gt; X&lt;core&gt; X&lt;undump&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171508Z" changeid="explorer">
        <seg>=item dump ETIQUETA
X&lt;dump&gt; X&lt;core&gt; X&lt;undump&gt; X&lt;volcado&gt; X&lt;núcleo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that pod translators should look at only paragraphs beginning
with a pod directive (it makes parsing easier), whereas the compiler
actually knows to look for pod escapes even in the middle of a
paragraph.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que los traductores pod suelen mirar sólo en los párrafos que comiencen por una directiva pod (hace el parseo más fácil), mientras que el compilador realmente sabe mirar por las secuencias pod incluso en el medio de un párrafo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If non-empty braces are the only wildcard characters used in the
C&lt;glob&gt;, no filenames are matched, but potentially many strings
are returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los únicos caracteres comodín en C&lt;glob&gt; son llaves, no se coincidirá con ningún archivo, pero, potencialmente, se devuelven muchas cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get status info for a symbolic link
instead of the target file behind the link, use the C&lt;lstat&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener información de estado de un enlace simbólico en lugar del archivo de destino tras el enlace, utilice la función C&lt;lstat&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 4) = 8   ==          8 00010000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 4) = 8   ==          8 00010000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rename any non-standard executables so the names do not conflict with
standard executables, which must also be provided, and provide a
separate manual page for each non-standard executable that clearly
documents how it differs from the Standard Version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>cambie el nombre de cualquier ejecutable no estándar para que los nombres no entren en conflicto con los ejecutables estándar, que también se debe proporcionar, y proporcionar una página de manual por separado por cada ejecutable no estándar que documente claramente en qué se diferencia de la versión estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative to using substr() as an lvalue is to specify the
replacement string as the 4th argument.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203421Z" changeid="explorer">
        <seg>Una alternativa al uso substr() como un I&lt;ivalor&gt; es especificar la cadena de reemplazo como el cuarto argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, si dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that the block is automatically broken out of by a
successful C&lt;when&gt; or an explicit C&lt;break&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>excepto que el bloque es, automáticamente, parado, por un C&lt;when&gt; con éxito o un explícito C&lt;break&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The documentation has been revised in places to produce more standard manpages.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La documentación ha sido revisada en diversos lugares para producir páginas de manual más estándares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is called an &quot;array slice&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T001749Z" changeid="zipf">
        <seg>Esto se denomina una &quot;porción de array&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*s&gt;',  3, &quot;string&quot;;   # prints &quot;&lt;str&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*s&gt;',  3, &quot;cadena&quot;;   # imprime &quot;&lt;cad&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item oct EXPR
X&lt;oct&gt; X&lt;octal&gt; X&lt;hex&gt; X&lt;hexadecimal&gt; X&lt;binary&gt; X&lt;bin&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191552Z" changeid="explorer">
        <seg>=item oct EXPR
X&lt;oct&gt; X&lt;octal&gt; X&lt;hex&gt; X&lt;hexadecimal&gt; X&lt;binary&gt; X&lt;bin&gt; X&lt;binario&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On success, it returns the number of files
it successfully deleted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de éxito, devuelve el número de archivos que se han eliminado correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than
requiring you to put parentheses around every function call and
declare every variable, you can often leave such explicit elements off
and Perl will figure out what you meant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En vez de obligarle a poner paréntesis en todas las llamadas de función y declarar cada variable, puede, a menudo, dejar algunos elementos de forma explícita, y Perl intentará adivinar lo que quiere decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Road goes ever on and on,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El camino sigue y sigue,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;perl&gt;	S&lt;[ B&lt;-sTtuUWX&gt; ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;perl&gt;	S&lt;[ B&lt;-sTtuUWX&gt; ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example you could write:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, puede escribir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$oldfh = select(STDERR); $| = 1; select($oldfh);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$oldfh = select(STDERR); $| = 1; select($oldfh);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requires require a 64-bit MIPS CPU (R8000, R10000, ...)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002610Z" changeid="explorer">
        <seg>Esto requiere una CPU MIPS de 64-bit (R8000, R10000, ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$n_encontrados = select($rout=$rin, $wout=$win, $eout=$ein, undef);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>quotemeta (and C&lt;\Q&gt; ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192847Z" changeid="explorer">
        <seg>quotemeta (y C&lt;\Q&gt; ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item q/STRING/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item q/STRING/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Otherwise:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175145Z" changeid="explorer">
        <seg>=item Delo contrario:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return the positive square root of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la raíz cuadrada positiva de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Package names are sometimes an exception to this rule.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres de los paquetes son, en alguna ocasión, una excepción a esta regla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same template may generally also be used in unpack().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La misma plantilla puede ser usada, generalmente, con unpack().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
can be done using the C&lt;O_TRUNC&gt; flag.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se puede hacer con el uso de la bandera C&lt;O_TRUNC&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>kill 9, @goners;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>kill 9, @finalizadores;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blank lines between chunks that do different things.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Líneas en blanco entre bloques que hacen cosas diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And so do these:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así como estos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$s = q{ if($a eq &quot;}&quot;) ... }; # WRONG</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$s = q{ if($a eq &quot;}&quot;) ... }; # MAL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if there were a C&lt;continue&gt; block on the above code, it would
get executed only on lines discarded by the regex (since redo skips the
continue block).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que si existiese un bloque C&lt;continue&gt; en este código, sería ejecutado sólo en las líneas descartadas por la expresión regular (debido a que C&lt;redo&gt; salta el bloque C&lt;continue&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Language-Specific</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Idiomas específicos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%b    an unsigned integer, in binary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%b    un entero sin signo, en binario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $aref ( @AoA ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052822Z" changeid="explorer">
        <seg>for $aref ( @AoA ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values to be compared are always passed by reference and should not
be modified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores a ser comparados siempre se pasan por referencia y no deben ser modificados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most important Perl parsing rule is the first one discussed
below: when processing a quoted construct, Perl first finds the end
of that construct, then interprets its contents.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La más importante regla de análisis de Perl es la primera que se explica a continuación: cuando se procesa una construcción entrecomillada, Perl primero encuentra al final de esa construcción; a continuación, interpreta su contenido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the C&lt;local $SIG{__DIE__}&gt; construct for this purpose,
as this example shows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar la construcción C&lt;local $SIG{__DIE__}&gt; para este propósito, como muestra este ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make perl executable and create a symlink for libperl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace a perl ejecutable y crea un enlace simbólico para libperl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to build a Perl with flock() support, you have to install this
package first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere construir un Perl con soporte de flock(), tiene que instalar este paquete en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's how to do one operation using a loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194641Z" changeid="explorer">
        <seg>Aquí está cómo hacer una operación con un bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ucfirst EXPR
X&lt;ucfirst&gt; X&lt;uppercase&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210103Z" changeid="explorer">
        <seg>=item ucfirst EXPR
X&lt;ucfirst&gt; X&lt;uppercase&gt; X&lt;mayúscula&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So your build will fail if you choose the defaults.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que su compilación producirá un error si usted elige los valores predeterminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 4) = 4   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 4) = 4   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters special to the
RE engine (such as C&lt;|&gt;) generate corresponding nodes or groups of
nodes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Caracteres especiales al motor de RE (como C&lt;|&gt;) generan sus correspondientes nodos o grupos de nodos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack('sx2l', 12, 34);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack('sx2l', 12, 34);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 32  ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 32  ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function C&lt;again&gt; is provided to resolve problems where modules in different
directories wish to use FindBin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se proporciona, C&lt;de nuevo&gt;, una función para resolver los problemas donde módulos en diferentes directorios desean utilizar FindBin.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl
uses the same mechanism to produce $1, $2, etc, so you also pay a
price for each pattern that contains capturing parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl utiliza el mismo mecanismo para producir $1, $2, etc, por lo que también paga un precio para cada patrón que contiene paréntesis de captura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlguts		Perl internal functions for those doing extensions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlguts		Funciones internas para los que hacen extensiones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That same loop could be replaced with a slice operation:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194731Z" changeid="explorer">
        <seg>Ese mismo bucle podría ser sustituido por una operación de corte:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print sort backwards @harry;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print sort al_reves @harry;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-A  Same for access time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-A  Lo mismo, para el tiempo de acceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A I&lt;stable&gt; sort
preserves the input order of elements that compare equal.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Un sort I&lt;estable&gt; preserva el orden de los elementos de entrada que sean iguales en la comparación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;use locale&gt; is in effect,
and POSIX::setlocale() has been called, the character used for the decimal
separator in formatted floating-point numbers is affected by the LC_NUMERIC
locale.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;use locale&gt; está activo, y POSIX::setlocale() ha sido llamada, el carácter utilizado para el separador decimal en números formateados en punto flotante se ve afectado por la configuración regional de LC_NUMERIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using such
a module, see the module's documentation for details of the syntax that
it defines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está usando un módulo así, mire la documentación del módulo para ver los detalles de la sintaxis que define.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specify position as byte offset in the internal
                   representation of the packed string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050653Z" changeid="explorer">
        <seg>Especifica una posición como desplazamiento de byte en la
                   representación interna de la cadena empaquetada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are still reading this and you are itching to try out microperl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si aún sigue leyendo esto y está ansioso por probar microperl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if successful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tuvo éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0 dev    0 second     0 package      $_    default variable</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0 dev    0 segundo    0 paquete      $_    variable por def.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item our TYPE EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item our TIPO EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or to force an anon hash constructor use C&lt;+{&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o para forzar a un constructor de un hash anónimo use C&lt;+{&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto-LABEL&gt; form finds the statement labeled with LABEL and
resumes execution there.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012509Z" changeid="explorer">
        <seg>La forma C&lt;goto-ETIQUETA&gt; busca la instrucción etiquetada con ETIQUETA y continua la ejecución desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlboot		Perl OO tutorial for beginners</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlboot		Seminario de POO Perl para novatos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Configuration and Building</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Configuración y construcción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die $@ unless $@ eq &quot;Alarm!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die $@ unless $@ eq &quot;¡Alarma!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;-lnet&gt; is needed on net server systems only and if the compiler doesn't
add it automatically (Be's R5 gcc does, Oliver Tappe's gcc 2.95.3 does not).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;-lnet&gt; es necesario en los sistemas net server solo si el compilador no lo agrega de forma automática (El gcc de Be R5 así lo hace; el gcc de Oliver Tappe 2.95.3, no).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 16  ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 16  ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.1f&gt;', 1;  # prints &quot;&lt;1.0&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.1f&gt;', 1;  # imprime &quot;&lt;1.0&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However Perl also uses \10, \11, etc. as aliases for \010,
\011, etc.  (Recall that 0 means octal, so \011 is the character at
number 9 in your coded character set; which would be the 10th character,
a horizontal tab under ASCII.)  Perl resolves this
ambiguity by interpreting \10 as a backreference only if at least 10
left parentheses have opened before it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, Perl también utiliza \10, \11, etc como alias de \010, \011, etc. (Hay que recordar que 0 significa octal, por lo que \011 es el carácter número 9 en su conjunto de codificación de caracteres, lo que sería el décimo carácter, un tabulador horizontal en ASCII). Perl resuelve esta ambigüedad mediante la interpretación de \10 como una contrareferencia sólo si, antes, por lo menos, se han abierto 10 paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = &lt;&lt;'EOL';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = &lt;&lt;'EOL';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*   multiplication</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235210Z" changeid="zipf">
        <seg>*   multiplicación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($key,$val) = each %HIST) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (($key,$val) = each %HIST) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl - The Perl language interpreter</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl - El intérprete del lenguaje Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/use&gt;, L&lt;perlmod&gt;, and L&lt;Exporter&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/use&gt;, L&lt;perlmod&gt; y L&lt;Exporter&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 2) = 1   ==         64 00000010000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 2) = 1   ==         64 00000010000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl was ported to Mac OS by Matthias Neeracher
E&lt;lt&gt;neeracher@mac.comE&lt;gt&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl fue adaptado a Mac OS por Matthias Neeracher E&lt;lt&gt;neeracher@mac.comE&lt;gt&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the PATTERN contains parentheses, additional list elements are
created from each matching substring in the delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el PATRÓN contiene paréntesis, se crean elementos de lista adicionales por cada subcadena coincidente con el delimitador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/d&gt; modifier is used, the REPLACEMENTLIST is always interpreted
exactly as specified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se usa el modificador C&lt;/d&gt;, la LISTA_REEMPLAZO siempre es interpretada exactamente como esté especificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when($foo)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when($foo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If @foo doesn't otherwise exist, then it's obviously a
character class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si @foo no existe, entonces es obvio que es una clase carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@foo,@bar,&amp;SomeSub,%glarch)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(@foo,@bar,&amp;AlgunaSub,%glarch)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Begun in 1993 (see L&lt;perlhist&gt;), Perl version 5 is nearly a complete
rewrite that provides the following additional benefits:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Iniciado en 1993 (véase L&lt;perlhist&gt;), la versión de Perl 5 es casi una reescritura completa que proporciona los beneficios adicionales siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item read FILEHANDLE,SCALAR,LENGTH,OFFSET
X&lt;read&gt; X&lt;file, read&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194413Z" changeid="explorer">
        <seg>=item read GESTOR_ARCHIVO,ESCALAR,LONGITUD,DESPLAZAMIENTO
X&lt;read&gt; X&lt;file, read&gt; X&lt;archivo, leer&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@days{'a','c'}	# same as ($days{'a'},$days{'c'})</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@dias{'a','c'}	# igual que ($dias{'a'},$dias{'c'})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While C&lt;use integer&gt; provides integer-only arithmetic, there is no
analogous mechanism to provide automatic rounding or truncation to a
certain number of decimal places.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras que C&lt;use integer&gt; sólo proporciona aritmética de enteros, no existe un mecanismo análogo para proporcionar redondeo automático o truncamiento a un determinado número de decimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select undef, undef, undef, 0.25;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select undef, undef, undef, 0.25;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omitting the C&lt;continue&gt; section is equivalent to using an
empty one, logically enough, so C&lt;next&gt; goes directly back
to check the condition at the top of the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La omisión de la sección C&lt;continue&gt; es equivalente a usar un bloque vacío, como es lógico, por lo que C&lt;next&gt; va directamente a comprobar la condición en la parte superior del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @backwards = reverse @numbers;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T001800Z" changeid="zipf">
        <seg>my @orden_inverso = reverse @numeros;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes turning off possible CRLF
translation and marking it as bytes (as opposed to Unicode characters).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto incluye desactivar posibles traducciones CRLF y marcarlas como bytes (como opuesto a los caracteres Unicode).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item On EBCDIC platforms</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174321Z" changeid="explorer">
        <seg>=item En plataformas EBCDIC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is usually a mistake to intermix C&lt;alarm&gt; and C&lt;sleep&gt; calls, because
C&lt;sleep&gt; may be internally implemented on your system with C&lt;alarm&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente es un fallo entremezclar llamadas a C&lt;alarm&gt; y C&lt;sleep&gt;, porque C&lt;sleep&gt; puede ser, internamente, implementado en su sistema con C&lt;alarm&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The call is implemented in terms of either Perl's or your system's native
fread(3) library function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La llamada es implementada en términos de Perl o de la función nativa fread(3) de su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;eq&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;eq&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So C&lt;given(@foo)&gt; is the same as C&lt;given(\@foo)&gt;,
for example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Asi que, por ejemplo, C&lt;given(@foo)&gt; es lo mismo que C&lt;given(\@foo)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then use it like:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235306Z" changeid="zipf">
        <seg>Puede asignar el valor devuelto así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>}}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For portably packed integers, either use the formats C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt;, 
and C&lt;V&gt; or else use the C&lt;&lt; &gt; &gt;&gt; and C&lt;&lt; &lt; &gt;&gt; modifiers described
immediately below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para enteros empaquetados de forma portátil, o bien usar los formatos C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt;, y C&lt;V&gt; o bien los modificadores C&lt;&lt; &gt; &gt;&gt; y C&lt;&lt; &lt; &gt;&gt; descritos inmediatamente abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Details are in L&lt;perlop/Quote and Quote-like Operators&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185113Z" changeid="explorer">
        <seg>Los detalles están en L&lt;perlop/Comillas y Operadores de comillas&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opens the file whose filename is given by EXPR, and associates it with
FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211726Z" changeid="explorer">
        <seg>Abre el archivo cuyo nombre viene dado por EXPR, y lo asocia con GESTOR_ARCHIVO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlink glob &quot;*.bak&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlink glob &quot;*.bak&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the handler's responsibility to deal with the message
as it sees fit (like, for instance, converting it into a C&lt;die&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es responsabilidad del controlador tratar el mensaje como lo considere oportuno (como, por ejemplo, convertirlo en un C&lt;die&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item our TYPE EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item our TIPO EXPR : ATRIBUTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach my $pat (@compiled) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach my $pat (@compilados) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eof</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eof</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To view the differences between the
5.7.0 release and the 5.7.1 release, see L&lt;perl571delta&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para ver las diferencias entre la versión 5.7.0 y la versión 5.7.1, véase L&lt;perl571delta&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open my $fh, &quot;@_&quot;
             or die &quot;Can't open '@_': $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043112Z" changeid="explorer">
        <seg>open my $fh, &quot;@_&quot;
             or die &quot;No puedo abrir '@_': $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;!=&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;!=&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO) ? 'hi mom' : die &quot;Can't open $FOO: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054547Z" changeid="explorer">
        <seg>open(FOO) ? 'hola mamá' : die &quot;No puedo abrir $FOO: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to scoping</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Palabras clave relacionadas con el ámbito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using &quot;or&quot; for assignment is unlikely to do what you want; see below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es poco probable que quiera usar &quot;or&quot; para hacer asignaciones; véase más adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It still
counts as scalar context for functions that care whether or not
they're being called in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, también cuenta como contexto escalar para las funciones a las que les interesa saber si han sido llamadas en contexto lista o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A positive OFFSET greater than the length of SCALAR
results in the string being padded to the required size with C&lt;&quot;\0&quot;&gt;
bytes before the result of the read is appended.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DESPLAZAMIENTO positivo mayor que la longitud de ESCALAR resulta en un cadena rellenada al tamaño requerido con bytes C&lt;&quot;\0&quot;&gt; antes de que el resultado de la lectura sea añadido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># example: '# line 42 &quot;new_filename.plx&quot;'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ejemplo: '# line 42 &quot;nuevo_archivo.plx&quot;'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughout this document you'll see references to other parts of the
Perl documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224550Z" changeid="explorer">
        <seg>En este documento se incluyen referencias a otras partes de la documentación de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;~&gt; X&lt;negation, binary&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;~&gt; X&lt;negation, binary&gt; X&lt;negación, binario&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldebtut		Perl debugging tutorial</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldebtut		Seminario de depuración</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pack TEMPLATE,LIST
X&lt;pack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191948Z" changeid="explorer">
        <seg>=item pack PLANTILLA,LISTA
X&lt;pack&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means
that if you're in the C&lt;main&gt; package and type</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que si usted está en el paquete C&lt;main&gt; y escribe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instead of having to write these:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>en lugar de tener que escribir lo siguiente?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=over</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Yow!&quot; if $zippy;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235719Z" changeid="zipf">
        <seg>print &quot;¡Caramba!&quot; if $zippy;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Quantifiers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Cuantificadores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 1) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 1) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$herhostname    = gethostbyaddr($iaddr, AF_INET);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$herhostname    = gethostbyaddr($iaddr, AF_INET);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot include a literal C&lt;$&gt; or C&lt;@&gt; within a C&lt;\Q&gt; sequence.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede incluir un literal C&lt;$&gt; o C&lt;@&gt; dentro de una secuencia C&lt;\Q&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As well as grouping, parentheses serve a second purpose.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120836Z" changeid="zipf">
        <seg>Además de para agrupar, los paréntesis también</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or &quot;quads&quot; (typically 64-bit integers)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o &quot;quads&quot; (generalmente enteros de 64-bit)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as though the argument to C&lt;given&gt; were an element of the hash
C&lt;%foo&gt;, interpreting the braces as hash-element syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>como si el argumento a C&lt;given&gt; fuera un elemento del hash C&lt;%foo&gt;, interpretando las llaves como la sintaxis de un elemento de un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE,
using the format associated with that file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211051Z" changeid="explorer">
        <seg>Escribe un registro formateado (posiblemente de varias líneas) al GESTOR_ARCHIVO especificado, utilizando el formato asociado con ese archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;echo $temp&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;echo $temporal&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C  An unsigned char (octet) value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C  Un valor de un carácter sin signo (octeto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\V        [3]  Not vertical whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224936Z" changeid="explorer">
        <seg>\V        [3]  No espacio en blanco vertical</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If POSITION is omitted, starts searching from the
beginning of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite POSICIÓN, comienza a buscar desde el comienzo del string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note:  Many folks tend to overuse C&lt;defined&gt;, and then are surprised to
discover that the number C&lt;0&gt; and C&lt;&quot;&quot;&gt; (the zero-length string) are, in fact,
defined values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota: mucha gente tiende a sobrevalorar C&lt;defined&gt; y, para su sorpresa, descubren que el número C&lt;0&gt; y C&lt;&quot;&quot;&gt; (la cadena de longitud cero) son, de hecho, valores definidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;.&gt; X&lt;/s&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;.&gt; X&lt;/s&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the two-argument (and one-argument) form of the call, the mode and
filename should be concatenated (in that order), possibly separated by
spaces.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la forme de dos argumentos (y un argumento) de la llamada, el modo y el nombre del archivo debe ser concatenados (en ese orden), opcionalmente separados por espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;m//&gt;, C&lt;pos&gt;, C&lt;quotemeta&gt;, C&lt;s///&gt;, C&lt;split&gt;, C&lt;study&gt;, C&lt;qr//&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;m//&gt;, C&lt;pos&gt;, C&lt;quotemeta&gt;, C&lt;s///&gt;, C&lt;split&gt;, C&lt;study&gt;, C&lt;qr//&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item local EXPR
X&lt;local&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175427Z" changeid="explorer">
        <seg>=item local EXPR
X&lt;local&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates the BLOCK or EXPR for each element of LIST (locally setting
C&lt;$_&gt; to each element) and returns the list value consisting of those
elements for which the expression evaluated to true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa el BLOQUE o EXPRE para cada elemento de LISTA (poniendo localmente C&lt;$_&gt; a cada elemento) y devuelve un valor de lista consistente en los elementos por los que la expresión evaluada es verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;do BLOCK&gt; does I&lt;not&gt; count as a loop, so the loop control statements
C&lt;next&gt;, C&lt;last&gt;, or C&lt;redo&gt; cannot be used to leave or restart the block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012028Z" changeid="explorer">
        <seg>C&lt;do BLOQUE&gt; I&lt;no&gt; cuenta como un bucle, así que las instrucciones de control de bucle C&lt;next&gt;, C&lt;last&gt;, o C&lt;redo&gt; no pueden ser usadas para dejar o reiniciar el bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$scalar = delete @hash{qw(foo bar)};     # $scalar is 22</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$scalar = delete @hash{qw(foo bar)};     # $scalar es 22</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eq  equality</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120435Z" changeid="zipf">
        <seg>eq  igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;/p&gt; X&lt;p modifier&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;/p&gt; X&lt;p modificador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value may be given to C&lt;seekdir&gt; to access a particular location in a
directory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor puede ser indicado a C&lt;seekdir&gt; para acceder a un lugar determinado en un directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 2) = 2   ==        128 00000001000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 2) = 2   ==        128 00000001000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gt  greater than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>gt  mayor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>},</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232143Z" changeid="explorer">
        <seg>},</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only things you need to declare in Perl are report formats and
subroutines (and sometimes not even subroutines).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los únicos elementos que necesita declarar en Perl son los informes y las subrutinas (y algunas veces ni siquiera las subrutinas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can only use the yada yada to stand in for a complete statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012655Z" changeid="explorer">
        <seg>Sólo se puede utilizar el blablablá en lugar de una instrucción completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This would be clearer to the casual reader:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto será más claro para el lector casual:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else { # in body
            # do something else</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053705Z" changeid="explorer">
        <seg>} else { # en cuerpo
            # sino hacer otra cosa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Time::HiRes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Time::HiRes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrebackslash/Misc&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225320Z" changeid="explorer">
        <seg>Véase L&lt;perlrebackslash/Miscelánea&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;j p \n&quot; ^ &quot; a h&quot;;        	# prints &quot;JAPH\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;j p \n&quot; ^ &quot; a h&quot;;        	# imprime &quot;JAPH\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>are also always exempt from such warnings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>están también exentos de tales avisos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, gives C&lt;exp($_)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, devuelve C&lt;exp($_)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\d+/sprintf(&quot;%5d&quot;,$&amp;)/e;	# yields 'abc  246xyz'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/\d+/sprintf(&quot;%5d&quot;,$&amp;)/e;	# queda como 'abc  246xyz'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfreebsd 	Perl notes for FreeBSD</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfreebsd 	Notas para FreeBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting C&lt;O_CREAT|O_EXCL&gt; prevents the file from
being opened if it is a symbolic link.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estableciendo C&lt;O_CREAT|O_EXCL&gt; impide que el archivo sea abierto si es un enlace simbólico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Unix permission C&lt;rwxr-x---&gt; is represented as three sets of three
bits, or three octal digits: C&lt;0750&gt; (the leading 0 indicates octal
and isn't one of the digits).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los permisos Unix C&lt;rwxr-x---&gt; son representados como tres conjuntos de tres bits, o tres dígitos octales: C&lt;0750&gt; (el 0 precedente indica que es octal, y que no es uno de los dígitos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># or for GMT formatted appropriately for your locale:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># o para GMT formateado a su región:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;fred&quot;, &quot;barney&quot;, &quot;pebbles&quot;, &quot;bambam&quot;, &quot;dino&quot;, ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;pedro&quot;, &quot;pablo&quot;, &quot;pebbles&quot;, &quot;bambam&quot;, &quot;dino&quot;, ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exceptions to this rule are C&lt;wait&gt;,
C&lt;waitpid&gt;, and C&lt;syscall&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Excepciones a esta regla son C&lt;wait&gt;, C&lt;waitpid&gt; y C&lt;syscall&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?:               *     zero or more         /x ign.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>?:               *     cero o más           /x ign.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This works on machines only for which the device number is negative
under NFS.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto funciona solo en máquinas en las cuales el número de dispositivo es negativo para NFS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($str == 0 &amp;&amp; $str ne &quot;0&quot;)  {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($str == 0 &amp;&amp; $str ne &quot;0&quot;)  {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;&gt; 8;    # child exit status</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171152Z" changeid="explorer">
        <seg>&gt;&gt; 8;    # estado de salida del hijo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Threaded Perl on DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Perl con I&lt;threads&gt; en DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line up corresponding things vertically, especially if it'd be too long
to fit on one line anyway.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alineé elementos correspondientes verticalmente, especialmente si es demasiado largo el espacio que ocupan como para entrar en una sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given integer
operands C&lt;$a&gt; and C&lt;$b&gt;: If C&lt;$b&gt; is positive, then C&lt;$a % $b&gt; is
C&lt;$a&gt; minus the largest multiple of C&lt;$b&gt; less than or equal to
C&lt;$a&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dados los operandos enteros C&lt;$a&gt; y C&lt;$b&gt;: si C&lt;$b&gt; es positivo, entonces C&lt;$a % $b&gt; es C&lt;$a&gt; menos el mayor múltiplo de C&lt;$b&gt; menor o igual a C&lt;$a&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This keyword is enabled by the C&lt;&quot;switch&quot;&gt; feature: see L&lt;feature&gt;
for more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165839Z" changeid="explorer">
        <seg>Este identificador se activa con la característica C&lt;&quot;switch&quot;&gt;: vea L&lt;feature&gt; para más información</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you specify C&lt;&lt; '&lt;&amp;=X' &gt;&gt;, where C&lt;X&gt; is a file descriptor number
or a filehandle, then Perl will do an equivalent of C's C&lt;fdopen&gt; of
that file descriptor (and not call C&lt;dup(2)&gt;); this is more
parsimonious of file descriptors.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si especifica C&lt;&lt; '&lt;&amp;=X' &gt;&gt;, donde C&lt;X&gt; es un número de descriptor de archivo o un gestor de archivo, entonces Perl hará un equivalente de C de C&lt;fdopen&gt; de ese descriptor de archivo (y no llamar a C&lt;dup(2)&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\R        [4]  Linebreak</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225002Z" changeid="explorer">
        <seg>\R        [4]  Ruptura de línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SCALAR this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SCALAR este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>crypt() is a one-way hash function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>crypt() es una función hash de un sólo sentido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of the last command in the
sequence of commands indicated by BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor del último comando en la secuencia de comandos indicada por BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;gmtime&gt;, C&lt;localtime&gt;, C&lt;time&gt;, C&lt;times&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;gmtime&gt;, C&lt;localtime&gt;, C&lt;time&gt;, C&lt;times&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to run a threaded Perl on OpenBSD
3.7 or higher, you will need to upgrade to at least Perl 5.8.7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere correr un Perl con hilos sobre OpenBSD 3.7 o superior, necesitará actualizar Perl al menos a la versión 5.8.7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlunitut		Perl Unicode tutorial</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlunitut		Seminario Unicode en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some programmers may prefer to think of filehandles as objects with
methods, preferring to write the last example as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos programadores prefieren pensar en gestores de archivo como objetos con métodos, prefiriendo escribir el último ejemplo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No interpolation is performed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se realiza ninguna interpolación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VERSION must be a
&quot;strict&quot; style version number as defined by the L&lt;version&gt; module: a positive
decimal number (integer or decimal-fraction) without exponentiation or else a
dotted-decimal v-string with a leading 'v' character and at least three
components.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VERSIÓN debe ser un número de versión al estilo &quot;estricto&quot;, según lo define el módulo L&lt;version&gt;: un número decimal positivo (entero o decimal) sin exponentes o una v-cadena con una 'v' precedente con al menos tres componentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such discretionary locks are more flexible, but offer
fewer guarantees.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tales bloqueos discrecionalmente son más flexibles, pero ofrecen pocas garantías.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl586delta	Perl changes in version 5.8.6</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl586delta	Cambios en la versión 5.8.6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string is broken into chunks described by the TEMPLATE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La cadena se rompe en trozos descritos por la PLANTILLA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can intermix C&lt;m//g&gt; matches with C&lt;m/\G.../g&gt;, where C&lt;\G&gt; is a
zero-width assertion that matches the exact position where the previous
C&lt;m//g&gt;, if any, left off.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede entremezclar coincidencias C&lt;m//g&gt; con C&lt;m/\\G.../g&gt;, donde C&lt;\G&gt; es una aserción de ancho cero que coincide con la posición exacta en que la anterior C&lt;m//g&gt;, si existía, se detuvo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @old;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@nuevo = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @viejo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$line .= &lt;ARGV&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$linea .= &lt;ARGV&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo =  150  |  105;	# yields 255  (0x96 | 0x69 is 0xFF)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo =  150  |  105;	# produce 255  (0x96 | 0x69 es 0xFF)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, reads until end-of-file
is reached and returns a list of lines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, lee hasta el final de archivo y devuelve una lista de líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11410</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11410</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, uses
C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;IPC::SysV&gt;
and C&lt;IPC::SysV::Msg&gt; documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también la documentación C&lt;IPC::SysV&gt; y C&lt;IPC::SysV::Msg&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;\G&gt; without C&lt;/g&gt; on a target string that has not previously had a
C&lt;/g&gt; match applied to it is the same as using the C&lt;\A&gt; assertion to match
the beginning of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando C&lt;\G&gt; sin C&lt;/g&gt; en una cadena objetivo que no haya tenido anteriormente aplicada una coincidencia C&lt;/g&gt; es lo mismo que usar la aserción C&lt;\A&gt; para que coincida con el principio de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Perl closes
the comment as soon as it sees a C&lt;)&gt;, so there is no way to put a literal
C&lt;)&gt; in the comment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que Perl cierra el comentario tan pronto como vea un C&lt;)&gt;, por lo que no hay manera de poner un C&lt;)&gt; literal en el comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parsing of the bracketed character class construct, C&lt;[...]&gt;, is
rather different than the rule used for the rest of the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El análisis de la construcción clase de caracteres, entre corchetes, C&lt;[...]&gt;, es bastante diferente a la regla utilizada para el resto del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>spicy tomato</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tomate especiado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If I&lt;both&gt;
arguments pass the test, then the argument is treated
as boolean.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si I&lt;ambos&gt; argumentos pasan el test, entonces el argumento es tratado como un booleano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default VERSION method, inherited from
the UNIVERSAL class, croaks if the given version is larger than the
value of the variable C&lt;$Module::VERSION&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El método VERSIÓN por defecto, heredado de la clase UNIVERSAL, croa si la versión dada es mayor que el valor de la variable C&lt;$Módulo::VERSIÓN&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transliteration operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador de transliteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item wait
X&lt;wait&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210844Z" changeid="explorer">
        <seg>=item wait
X&lt;wait&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Statement Modifiers
X&lt;statement modifier&gt; X&lt;modifier&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt;
X&lt;until&gt; X&lt;when&gt; X&lt;foreach&gt; X&lt;for&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013011Z" changeid="explorer">
        <seg>=head2 Modificadores de instrucciones
X&lt;statement modifier&gt; X&lt;modifier&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt;
X&lt;until&gt; X&lt;when&gt; X&lt;foreach&gt; X&lt;for&gt; X&lt;modificador de instrucción&gt; X&lt;modificador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pattern C&lt;/PATTERN/&gt; may be replaced with an expression to specify
patterns that vary at runtime.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El patrón C&lt;/PATRÓN/&gt; puede ser sustituido por una expresión para especificar patrones que varían en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's how a C programmer might code up a particular algorithm in Perl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo de cómo un programador de C codificaría un determinado algoritmo en Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Unicode::Normalize</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Unicode::Normalize</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shmread ID,VAR,POS,SIZE
X&lt;shmread&gt;
X&lt;shmwrite&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200631Z" changeid="explorer">
        <seg>=item shmread ID,VAR,POSICIÓN,TAMAÑO
X&lt;shmread&gt; X&lt;shmwrite&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11405</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11405</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you meant the empty regex, just
use parentheses or spaces to disambiguate, or even prefix the empty
regex with an C&lt;m&gt; (so C&lt;//&gt; becomes C&lt;m//&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted quiere decir la expresión regular vacía, sólo tiene que utilizar paréntesis o espacios para eliminar la ambigüedad, o incluso el prefijar con una C&lt;m&gt; (así que C&lt;//&gt; se convierte en C&lt;m//&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc/&quot;UDP: Message Passing&quot;&gt; for examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc/&quot;UDP: Paso de mensajes&quot;&gt; para ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If PATTERN is also omitted,
splits on whitespace (after skipping any leading whitespace).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si PATRÓN es también omitido, se divide por el espacio en blanco(después de saltarse cualquier espacio en blanco precedente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The pseudo code above doesn't work because it treats
&lt;ARGV&gt; as non-magical.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(El pseudo código anterior no funciona porque trata a &lt;ARGV&gt; como no-mágico).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>179231</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>179231</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\W        [3]  Match a non-&quot;word&quot; character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223624Z" changeid="explorer">
        <seg>\W	 [3]  Coincide con un carácter que no es de &quot;palabra&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you chomp a list, each element is chomped, and the total number of
characters removed is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si recorta una lista, cada elemento es recortado y se devuelve el número total de caracteres eliminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ucfirst</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item ucfirst</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Math::Complex;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Math::Complex;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also useful for applications emulating C&lt;tail -f&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto también es útil para aplicaciones que emulen C&lt;tail -f&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-number v-strings like C&lt;v65.66&gt; and C&lt;65.66.67&gt; continue to
be v-strings always.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>V-strings multi números como C&lt;v65.66&gt; y C&lt;65.66.67&gt; siguen siendo v-strings.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%+10.6d&gt;', 1;   # prints &quot;&lt;   +000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%+10.6d&gt;', 1;   # imprime &quot;&lt;   +000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die 'foo';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die 'foo';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl also has its own built-in variables whose names don't follow
these rules.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl también tiene su propias variables incorporadas cuyos nombres no siguen estas reglas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;pop&gt;, C&lt;push&gt;, C&lt;shift&gt;, C&lt;splice&gt;, C&lt;unshift&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;pop&gt;, C&lt;push&gt;, C&lt;shift&gt;, C&lt;splice&gt;, C&lt;unshift&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because
print takes a LIST, anything in the LIST is evaluated in list
context, and any subroutine that you call will have one or more of
its expressions evaluated in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que print toma una LISTA, cualquier cosa en la LISTA se evalúa en contexto de lista, y cualquier subrutina que llame tendrá una o más de sus expresiones evaluadas en contexto de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this behaviour is
sometimes undesirable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, este comportamiento es a veces indeseable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You can set C&lt;$/&gt; to use
a different line terminator.)  The command is executed each time the
pseudo-literal is evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Puede configurar C&lt;$/&gt; para utilizar un terminador de línea diferente). El comando es ejecutado cada vez que el pseudo-literal es evaluado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub my_sub {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub mi_sub {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you haven't used regular expressions before, a quick-start
introduction is available in L&lt;perlrequick&gt;, and a longer tutorial
introduction is available in L&lt;perlretut&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no ha utilizado expresiones regulares antes, una introducción rápida está disponible en L&lt;perlrequick&gt;, y un cursillo de introducción mayor está disponible en L&lt;perlretut&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now we can use the subroutine just as any other built-in function:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T004124Z" changeid="zipf">
        <seg>Ahora podemos usar la subrutina como cualquier función integrada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(uc($bar),$baz);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(uc($bar),$baz);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See setpriority(2).)  Raises an exception when used on a machine
that doesn't implement setpriority(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver setpriority(2)). Lanza una excepción cuando se utiliza en una máquina que no implementa setpriority(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (EXPR) BLOCK else BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (EXPR) BLOQUE else BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be avoided if you always use 
O_NONBLOCK on the socket.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto puede evitarse si siempre utiliza O_NONBLOCK en el socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator is also handy for inverting a hash, although there are some
caveats.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este operador también es útil para invertir un hash, aunque existen algunas salvedades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SCALAR is of length zero, you can only use an OFFSET of 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ESCALAR es de longitud cero, sólo se puede utilizar un DESPLAZAMIENTO de 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;cat -n '$file'|&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, &quot;cat -n '$archivo'|&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable holds
the undefined value (C&lt;undef&gt;) until it has been assigned a defined
value, which is anything other than C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una variable almacena el valor indefinido (C&lt;undef&gt;) hasta que se le asigna un valor definido, que es cualquier otra cosa distinta de C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also gain some minuscule measure of efficiency by pre-extending
an array that is going to get big.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También se puede ganar una minúscula cantidad de eficiencia pre-extendiendo un array que va a hacerse grande.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These last until their block is exited, but may be passed back.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos últimos duran hasta que se sale de su bloque, pero puede ser traspasado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will only affect people who have a threaded perl 5.8.1, and compiled
modules which use these calls, and now attempt to run the compiled modules
with 5.8.2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto sólo afectará a las personas que tienen un perl 5.8.1 multihilo, y los módulos compilados que utilizan estas llamadas, y ahora intenta ejecutar los módulos compilados con 5.8.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6 rdev     the device identifier (special files only)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>6 rdev     identificador del dispositivo (solo archivos especiales)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlthrtut&gt; and L&lt;threads&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;perlthrtut&gt; y L&lt;threads&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = 'a';   print $x,&quot;\n&quot;;    # prints 1a4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = 'a';   print $x,&quot;\n&quot;;    # imprime 1a4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;Bitwise String Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185827Z" changeid="explorer">
        <seg>Ver L&lt;perlop/&quot;Operadores de bit en cadenas&quot;&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printing to a closed pipe or socket will generate a SIGPIPE signal.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Imprimir a una tubería o socket cerrados generará una señal SIGPIPE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item File::Spec</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item File::Spec</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item POSIX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item POSIX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are some cases where Perl can't immediately tell the difference
between an expression and a statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012714Z" changeid="explorer">
        <seg>Hay algunos casos donde Perl no puede decir, de forma inmediata, la diferencia entre una expresión y una instrucción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore C&lt;&lt;&lt;EOF&gt; is
terminated by C&lt;EOF&gt; immediately followed by C&lt;&quot;\n&quot;&gt; and starting
from the first column of the terminating line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto C&lt;&lt;&lt;EOF&gt; es terminado por un C&lt;EOF&gt; inmediatamente seguido por un C&lt;&quot;\n&quot;&gt; y empezando en la primera columna de la línea de terminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ref_to_AoA-&gt;[2]-&gt;[2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ref_to_AoA-&gt;[2]-&gt;[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of prior m//g)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>de la anterior m//g)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>i.e., as if C&lt;&lt; $@ = eval { $@-&gt;PROPAGATE(__FILE__, __LINE__) }; &gt;&gt;
were called.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es decir, como si se ejecutara C&lt;&lt; $@ = eval { $@-&gt;PROPAGATE(__FILE__, __LINE__) }; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Boolean value telling whether EXPR has a value other than
the undefined value C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve un valor Booleano indicando si EXPR tiene un valor que no sea el valor indefinido C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $log, &quot;&gt;&gt;&quot;, &quot;my.log&quot;)     or die &quot;Can't open my.log: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T031032Z" changeid="explorer">
        <seg>open(my $registro, &quot;&gt;&gt;&quot;, &quot;mi.registro&quot;) or die &quot;No se puede abrir mi.registro: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo, 93,  1) = 1;      # 'PerlPerlPer'  . &quot;\x2c&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052421Z" changeid="explorer">
        <seg>vec($foo, 93,  1) = 1;      # 'PerlPerlPer'  . &quot;\x2c&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;&lt; =&gt; &gt;&gt; doesn't quote compound identifiers, that contain
double colons.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;&lt; =&gt; &gt;&gt; no entrecomilla identificadores compuestos, que contengan dos dobles puntos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now weaken references to read only values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora puede debilitar referencias para leer solo valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Currency		for currency calculations</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::Currency           para cálculos monetarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 2) = 2   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 2) = 2   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is provided as a more readable version of C&lt;if (!I&lt;condition&gt;)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225130Z" changeid="explorer">
        <seg>Esto se proporciona como una versión más legible de C&lt;if  (!I&lt;condición&gt;)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (my $ev_err = $@) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (my $ev_err = $@) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDERR &quot;stderr 1\n&quot;;  # subprocesses too</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print STDERR &quot;stderr 1\n&quot;;  # también para subprocesos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The file must return true as the last statement to indicate
successful execution of any initialization code, so it's customary to
end such a file with C&lt;1;&gt; unless you're sure it'll return true
otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012644Z" changeid="explorer">
        <seg>El archivo debe devolver verdadero como última instrucción para indicar una ejecución exitosa de cualquier código de inicialización, por lo que es habitual a tal efecto que un archivo termine con un C&lt;1;&gt; a menos que esté seguro de que devolverá cierto, de otra manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the Fcntl module or your fcntl(2)
manpage to learn what functions are available on your system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el módulo Fcntl o la página de manual fcntl(2) para aprender qué funciones están disponibles en su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hash randomisation introduced with 5.8.1 has been amended.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La asignación al azar hash introducido con 5.8.1 ha sido modificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;feature&gt; and L&lt;perlsyn/&quot;Switch statements&quot;&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011956Z" changeid="explorer">
        <seg>Ver L&lt;feature&gt; y L&lt;perlsyn/&quot;Instrucciones Switch&quot;&gt;.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're planning to filetest the return values out of a C&lt;readdir&gt;, you'd
better prepend the directory in question.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está planeando hacer test de archivos de los valores retornados por un C&lt;readdir&gt;, más le vale anteponer el directorio en cuestión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2254 Pthread library fixes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004316Z" changeid="explorer">
        <seg>2254 Pthread arreglos en biblioteca</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state is passed in as C&lt;$_[1]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El estado es pasado en C&lt;$_[1]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is omitted, assumes the file
last read.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204742Z" changeid="explorer">
        <seg>Si GESTOR_ARCHIVO se omite, se asume que es el último archivo leído.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Perl emulates the
system call by remembering the status values of processes that have
exited but have not been harvested by the Perl script yet.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Perl emula la llamada al sistema, recordando los valores de estado de los procesos que han salido, pero que todavía no han sido recolectadas por el script Perl).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12056</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12056</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># This is a comment</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Esto es un comentario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	&amp;&amp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	&amp;&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlsub/&quot;Private Variables via my()&quot;&gt; for details, and L&lt;fields&gt;,
L&lt;attributes&gt;, and L&lt;Attribute::Handlers&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub/&quot;Variables privadas vía my()&quot;&gt; para más detalles, y L&lt;fields&gt;, L&lt;attributes&gt;, y L&lt;Attribute::Handlers&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2/10850 subtests failed, 99.98% okay.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2/10850 subtests failed, 99.98% okay.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Num     numish[4] numeric equality         $a == $b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Número      numeral[4] igualdad numérica                $a == $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function calls the
underlying operating system's C&lt;open&gt; function with the parameters
FILENAME, MODE, PERMS.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función llama a la función subyacente del sistema operativo C&lt;open&gt; con los parámetros ARCHIVO, MODO, PERMISOS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can import symbolic mode constants (C&lt;S_IF*&gt;) and functions
(C&lt;S_IS*&gt;) from the Fcntl module:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede importar constantes simbólicas (C&lt;S_IF*&gt;) y funciones (C&lt;S_IS*&gt;) desde el módulo Fcntl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec &quot;sort $outfile | uniq&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec &quot;sort $salida | uniq&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-O  File is owned by real uid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004605Z" changeid="explorer">
        <seg>-O  Archivo es propiedad del uid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># scalar context</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># contexto escalar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/chomp&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/chomp&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$hints&gt; and C&lt;$bitmask&gt; contain pragmatic hints that the caller was
compiled with.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$hints&gt; y C&lt;$bitmask&gt; contienen detalles para los cuales caller fue compilado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>document the new taint behaviour of exec LIST and system LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>documentar el comportamiento del nuevo comportamiento de I&lt;taint&gt; de exec LISTA y system LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$whoami = $ENV{&quot;USER&quot;};             # one element from the hash</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$quiensoy = $ENV{&quot;USER&quot;};            # un elemento desde el hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want all items in C&lt;@ARGV&gt; to be interpreted as file names, you
can use the module C&lt;ARGV::readonly&gt; from CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea que todos los elementos de C&lt;@ARGV&gt; deban ser interpretados como nombres de archivo, puede utilizar el módulo C&lt;ARGV::readonly&gt; de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can omit the EXPR, in which case nothing is
undefined, but you still get an undefined value that you could, for
instance, return from a subroutine, assign to a variable, or pass as a
parameter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede omitir la EXPR, en tal caso, nada queda indefinido, pero aún obtiene un valor indefinido que podría, por ejemplo, devolver de una subrutina, asignar a una variable, o pasar como un parámetro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, putting
a C&lt;use&gt; inside the false branch of a conditional doesn't prevent it
from being processed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, poniendo un C&lt;use&gt; dentro de la rama falsa de un condicional no impide que sea procesado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$search = 'while (&lt;&gt;) { study;';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$buscar = 'while (&lt;&gt;) { study;';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($package, $filename, $line) = caller;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($paquete, $nombre_archivo, $linea) = caller;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $bar;    # prints 20, as it refers to $Foo::bar</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $bar;    # pinta 20, porque se refiere a $Foo::bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This change should only affect platform
maintainers writing configuration hints files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este cambio sólo debe afectar a los mantenedores de la plataforma al escribir sugerencias en los archivos de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsolaris 	Perl notes for Solaris</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsolaris 	Notas para Solaris</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$newAoA[$x - $startx][$y - $starty] = $AoA[$x][$y];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053011Z" changeid="explorer">
        <seg>$newAoA[$x - $startx][$y - $starty] = $AoA[$x][$y];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notably, the
ctime field is non-portable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, el campo ctime no es portátil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless ( condition ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002940Z" changeid="zipf">
        <seg>unless ( condición ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1404</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004230Z" changeid="explorer">
        <seg>1404</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
external interface is unchanged, and aside from the bug fixes described
above, there should be no change in behaviour.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El interfaz externo no se ha modificado, y aparte de la corrección de errores descritos anteriormente, no debería haber ningún cambio en el comportamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right	not</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>derecha	not</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-pna&gt; ] [ B&lt;-F&gt;I&lt;pattern&gt; ] [ B&lt;-l&gt;[I&lt;octal&gt;] ] [ B&lt;-0&gt;[I&lt;octal/hexadecimal&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-pna&gt; ] [ B&lt;-F&gt;I&lt;patrón&gt; ] [ B&lt;-l&gt;[I&lt;octal&gt;] ] [ B&lt;-0&gt;[I&lt;octal/hexadecimal&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$wday&gt; is the day of the week, with 0 indicating Sunday and 3 indicating
Wednesday.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$sdia&gt; es el día de la semana, con 0 indicando domingo y 3 indicando miércoles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltrap		Perl traps for the unwary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perltrap		Trampas para los incautos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%-10.6x&gt;', 1;   # prints &quot;&lt;000001    &gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%-10.6x&gt;', 1;   # imprime &quot;&lt;000001    &gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More precisely: the subtests
using datagram sockets fail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Precisando más: las subpruebas usando sockets de datagramas fallan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In searching for C&lt;/\bfoo\b/&gt;, only locations in C&lt;$_&gt; that contain C&lt;f&gt;
will be looked at, because C&lt;f&gt; is rarer than C&lt;o&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la búsqueda de C&lt;/\bfoo\b/&gt;, los únicos lugares que serán examinados de C&lt;$_&gt; serán los que contengan una C&lt;f&gt;, debido a que C&lt;f&gt; es más rara que una C&lt;o&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlform		Perl formats</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlform		Formatos Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, if something strange has gone wrong with your program and you're
not sure where you should look for help, try the B&lt;-w&gt; switch first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, si ha ocurrido algo extraño en su programa y no está seguro de dónde debe buscar ayuda, intente primero usar la opción B&lt;-w&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used on numbers, the bitwise operators (&quot;&amp;&quot;, &quot;|&quot;, &quot;^&quot;, &quot;~&quot;, &quot;&lt;&lt;&quot;,
and &quot;&gt;&gt;&quot;) always produce integral results.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usado en números, los operadores binarios (&quot;&amp;&quot;, &quot;|&quot;, &quot;^&quot;, &quot;~&quot;, &quot;&lt;&lt;&quot;, y &quot;&gt;&gt;&quot;) siempre producen resultados enteros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now it's time to print your data structure out.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193154Z" changeid="explorer">
        <seg>Ahora es el momento de imprimir la estructura de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($arrayref, $filename) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($arrayref, $archivo) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is not what you want, use C&lt;\Q&gt; to
interpolate a variable literally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no es esto lo que quiere, use C&lt;\Q&gt; para interpolar una variable literalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 AUTHOR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T232605Z" changeid="zipf">
        <seg>=head1 AUTOR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%days		# (key1, val1, key2, val2 ...)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%dias		# (clave1, valor1, clave2, valor2 ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/(\w+)/\u\L$1/g;   # &quot;titlecase&quot; words</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/(\w+)/\u\L$1/g;   # capitaliza las palabras</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since C&lt;SIGINT&gt; and C&lt;SIGQUIT&gt; are ignored during the execution of
C&lt;system&gt;, if you expect your program to terminate on receipt of these
signals you will need to arrange to do so yourself based on the return
value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puesto que C&lt;SIGINT&gt; y C&lt;SIGQUIT&gt; son ignoradas durante la ejecución de C&lt;system&gt;, si espera que su programa termine a la recepción de estas señales tendrá que disponer lo necesario para hacerlo usted mismo en función del valor de retorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing in reversed order</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, en orden inverso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This last example splits $foo into the first two words and the
remainder of the line, and assigns those three fields to $F1, $F2, and
$Etc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este último ejemplo divide $foo en las dos primeras palabras y el resto de la línea, y asigna los tres campos a $F1, $F2, y $Etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$time = stat($file)[8];  # OOPS, FORGOT PARENTHESES</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004227Z" changeid="explorer">
        <seg>$acceso = stat($archivo)[8];  # ¡OOPS!, OLVIDÓ LOS PARÉNTESIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're running Perl on a system that distinguishes between text
files and binary files, then you should check out L&lt;/binmode&gt; for tips
for dealing with this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está usando Perl en un sistema que distingue entre archivos de texto y archivos binarios, entonces debería consultar L&lt;/binmode&gt; para ver sugerencias para tratar con esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open() or die $!;  `$userinput`     use.perl.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open() or die $!;  `$userinput`     use.perl.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a simple example to illustrate the difference between
the two range operators:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He aquí un ejemplo sencillo para ilustrar la diferencia entre los dos operadores rango:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all other regards, &quot;...&quot; behaves just like &quot;..&quot; does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En todos los demás aspectos, &quot;...&quot; se comporta como &quot;..&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RE engine scans the string from left to right and
converts it to a finite automaton.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El motor de RE explora la cadena de izquierda a derecha y lo convierte en un autómata finito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open($fh, '&gt;', \$variable) || ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open($fh, '&gt;', \$variable) || ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say '$foo is the string &quot;foo&quot;';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>say '$foo es la cadena &quot;foo&quot;';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#X&gt;',  12;   # prints &quot;&lt;0XC&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#X&gt;',  12;   # imprime &quot;&lt;0XC&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/d&gt; modifier is specified, any characters
specified by SEARCHLIST not found in REPLACEMENTLIST are deleted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se especifica el modificador C&lt;/d&gt;, cualquier carácter especificado por LISTA_BÚSQUEDA que no sea encontrado en la LISTA_REEMPLAZO es eliminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># now case-insensitively</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ahora, independiente del tamaño de caja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARRAY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ARRAY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See C&lt;getpriority(2)&gt;.)  Will raise a fatal exception if used on a
machine that doesn't implement getpriority(2).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015228Z" changeid="explorer">
        <seg>(Ver L&lt;getpriority&gt;). Lanzará una excepción fatal si se usa en una máquina que no implemente getpriority(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, you may need to set C&lt;$|&gt; ($AUTOFLUSH
in English) or call the C&lt;autoflush()&gt; method of C&lt;IO::Handle&gt; on any
open handles to avoid lost output.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T172805Z" changeid="explorer">
        <seg>Para estar seguros, puede necesitar poner C&lt;$|&gt; ($AUTOFLUSH en el módulo English) o llamar el método C&lt;autoflush()&gt; de C&lt;IO::Handle&gt; en cualquiera de los gestores de archivo abiertos para evitar la pérdida de datos en la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$Config{longlongsize}&gt; is undefined on systems without 
long long support.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$Config{longlongsize}&gt; es indefinido en sistemas sin soporte de long largo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>H  A hex string (high nybble first).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>H  Una cadena hexadecimal (primero el nibble alto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While none of the built-in data types have any arbitrary size limits
(apart from memory size), there are still a few arbitrary limits:  a
given variable name may not be longer than 251 characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque ninguno de los tipos integrados de datos tiene límites de tamaño (aparte del tamaño de la memoria), todavía hay unos pocos límites arbitrarios: un determinado nombre de variable no podrá ser superior a 251 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>split(' ', q/STRING/);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>split(' ', q/CADENA/);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;&lt; &lt;=&gt; &gt;&gt; returns C&lt;undef&gt; when either operand is C&lt;NaN&gt;
(not-a-number), and because C&lt;sort&gt; raises an exception unless the
result of a comparison is defined, when sorting with a comparison function
like C&lt;&lt; $a &lt;=&gt; $b &gt;&gt;, be careful about lists that might contain a C&lt;NaN&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que C&lt;&lt; &lt;=&gt; &gt;&gt; devuelve C&lt;undef&gt; cuando alguno de los operandos es C&lt;NaN&gt; (I&lt;not-a-number&gt;, no es un número), y porque C&lt;sort&gt; lanza una excepción a menos que el resultado de la comparación esté definido, al ordenar con una función de comparación como C&lt;&lt; $a &lt;=&gt; $b &gt;&gt;, tenga cuidado acerca de las listas que pueden contener un C&lt;NaN&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getpwuid($num);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$name  = getpwuid($num);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But benchmarks indicated that for some inputs, on some platforms,
the original quicksort was faster.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero los benchmarks indicaron que, para algunas entradas, en algunas plataformas, el quicksort original era más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if your forked child inherits system file descriptors like
STDIN and STDOUT that are actually connected by a pipe or socket, even
if you exit, then the remote server (such as, say, a CGI script or a
backgrounded job launched from a remote shell) won't think you're done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que si su hijo hereda los descriptores de archivo del sistema como STDIN y STDOUT que estén conectados a un pipe o a un socket, incluso si usted sale del programa, el servidor remoto (por ejemplo, un script CGI o un proceso lanzado en segundo plano desde un shell remoto) no se dará cuenta de que se ha ido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;\l&gt; X&lt;\u&gt; X&lt;\L&gt; X&lt;\U&gt; X&lt;\E&gt; X&lt;\Q&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;\l&gt; X&lt;\u&gt; X&lt;\L&gt; X&lt;\U&gt; X&lt;\E&gt; X&lt;\Q&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport&gt;, 
your port's specific documentation, or your system-specific local manpages
for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport&gt;, la documentación específica de su adaptación Perl, o sus páginas de manual locales para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should reopen those to F&lt;/dev/null&gt; if it's any issue.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Deberá reabrirlos a F&lt;/dev/null&gt; si eso es un problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3];            # array slice</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3];            # porción array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002620Z" changeid="explorer">
        <seg>También puede usar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (ref($r) eq &quot;HASH&quot;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (ref($r) eq &quot;HASH&quot;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allow building perl with -DUSE_UTF8_SCRIPTS which makes UTF-8
the default script encoding (not the default since that would
break all scripts having legacy eight-bit data in them)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>permitir la construcción de perl con -DUSE_UTF8_SCRIPTS que hace que sea la codificación UTF-8 la de por defecto en el codificado de los script (no está por defecto ya que rompería todos los script que tiene un legado de ocho bits de datos dentro de si)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a comprehensive date and time representation look at the
L&lt;DateTime&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una completa y actualizada representación del tiempo mire el módulo L&lt;DateTime&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If srand() is not called explicitly, it is called implicitly at the
first use of the C&lt;rand&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si srand() no se llama de forma explícita, es llamada implícitamente en el primer uso del operador C&lt;rand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlintro -- a brief introduction and overview of Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T225748Z" changeid="zipf">
        <seg>perlintro -- Breve introducción y descripción general de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If MODE is C&lt;&lt; '&gt;' &gt;&gt;, the file is truncated and
opened for output, being created if necessary.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si MODO es C&lt;&lt; '&gt;' &gt;&gt;, el archivo es truncado y abierto para salida, siendo creado si es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>200) { print; } # print 2nd hundred lines, short for
                               #   if ($.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053520Z" changeid="explorer">
        <seg>200) { print; } # imprime las segundas cien líneas, resumen de
                               #   if ($.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;s2&quot;,1,2);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;s2&quot;,1,2);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Scalars</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Escalares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmacosx		Perl notes for Mac OS X</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmacosx		Notas para Mac OS X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$atime,$mtime,$ctime,$blksize,$blocks)
           = stat($filename);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051833Z" changeid="explorer">
        <seg>$atime,$mtime,$ctime,$blksize,$blocks)
           = stat($archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are
responsible for ensuring that the string is not a temporary value, as that
could potentially get deallocated before you got around to using the packed
result.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted es responsable de asegurarse que la cadena no es un valor temporal, ya que podría quedar desasignado antes de poder usar el resultado empaquetado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We are grateful to the Debian project for their input in this area.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estamos muy agradecidos con el proyecto Debian por sus aportaciones en este ámbito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mode remains in effect until the next 
mode change, or until the end of the C&lt;()&gt; group it (directly) applies to.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este modo permanece activo hasta el cambio del modo siguiente, o hasta el final del grupo C&lt;()&gt; en que se aplicó directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no elements in the
array, returns the undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay elementos en el array, devuelve el valor undef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>d  A double-precision float in native format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>d  Un flotante en doble precisión en formato nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The auto-increment operator has a little extra builtin magic to it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador de auto incremento tiene un poco más de magia en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're
dealing with just matrices, it's often easiest to use simple assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está tratando con matrices justo, a menudo es más fácil usar una asignación simple:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a struct utmp (BSDish)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># una struct utmp (del BSD)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just &quot;outdent&quot; it a little to make it more visible:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo &quot;desángrelo&quot; un poco para hacerlo más visible:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[\000-\177];		# delete 8th bit</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[\000-\177];		# borra el octavo bit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my($bits);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my($bits);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behavior in list context depends on the particular
operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento en contexto de lista depende del propio operador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
is intended as a &quot;bootstrap&quot; guide for those who are new to the
language, and provides just enough information for you to be able to
read other peoples' Perl and understand roughly what it's doing, or
write your own simple scripts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224536Z" changeid="explorer">
        <seg>Es una guía de iniciación para los nuevos usuarios del lenguaje que proporciona la información necesaria para poder leer el código Perl de otras personas y comprender a grandes rasgos su funcionamiento, o para escribir scripts sencillos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the right side is a method name or a simple scalar
variable containing either the method name or a subroutine reference,
and the left side must be either an object (a blessed reference)
or a class name (that is, a package name).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, el lado derecho es un nombre de método o una variable escalar simple conteniendo ya sea el nombre del método o una referencia a una subrutina, y el lado izquierdo debe ser un objeto (una referencia bendecida) o un nombre de clase (es decir, un nombre de paquete).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die unless $@ eq &quot;alarm\n&quot;;   # propagate unexpected errors</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die unless $@ eq &quot;alarma\n&quot;;   # propagar errores inesperados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before any operation that may do a fork, but this may not be
supported on some platforms (see L&lt;perlport&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Empezando con v5.6.0, Perl intentará vaciar todos los archivos abiertos para la salida antes de cualquier operación que pueda hacer un fork, pero esto quizás no esté soportado en algunas plataformas (véase L &lt;perlport&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, you don't need the temporary array to have a name at all:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por supuesto, no necesita el array temporal para nada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#10.6x&gt;', 1;   # prints &quot;&lt;  0x000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#10.6x&gt;', 1;   # imprime &quot;&lt;  0x000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;P&gt; format packs a pointer to a structure of the size indicated
by the length.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El formato C&lt;P&gt; empaqueta un puntero a una estructura del tamaño indicado por la longitud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub Foo::INC {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub Foo::INC {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\r		return                (CR)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\r		retorno               (CR)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;x&gt; and C&lt;X&gt; accept the C&lt;!&gt; modifier to act as alignment commands: they
jump forward or back to the closest position aligned at a multiple of C&lt;count&gt;
characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;x&gt; y C&lt;X&gt; aceptan el modificar C&lt;!&gt; para actuar como comando de alineamiento: saltan hacia adelante o atrás a la posición más cercana alineada a un múltiplo de C&lt;contador&gt; caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item binmode FILEHANDLE, LAYER
X&lt;binmode&gt; X&lt;binary&gt; X&lt;text&gt; X&lt;DOS&gt; X&lt;Windows&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211153Z" changeid="explorer">
        <seg>=item binmode GESTOR_ARCHIVO, CAPA
X&lt;binmode&gt; X&lt;binary&gt; X&lt;text&gt; X&lt;DOS&gt; X&lt;Windows&gt; X&lt;binario&gt; X&lt;texto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most well known of these is C&lt;%ENV&gt; which contains environment
variables.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T234425Z" changeid="explorer">
        <seg>El más conocido es C&lt;%ENV&gt;, que contiene variables de entorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {$b cmp $a} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {$b cmp $a} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make split()'s unused captures to be undef, not ''</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hacer que las capturas no utilizadas de split() sean indefinidas, no ''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a  A string with arbitrary binary data, will be null padded.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a  Una cadena con datos binarios arbitrarios, serán rellenados con nulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As C&lt;\c&gt; is skipped at this step, C&lt;@&gt; of C&lt;\c@&gt; in RE is possibly
treated as an array symbol (for example C&lt;@foo&gt;),
even though the same text in C&lt;qq//&gt; gives interpolation of C&lt;\c@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como C&lt;\c&gt; es omitido en este paso, C&lt;@&gt; de C&lt;\c@&gt; en RE es posiblemente tratado como un símbolo de array (por ejemplo C&lt;@foo&gt;), incluso aunque el mismo texto en C&lt;qq//&gt; sí da la interpolación de C&lt;\c@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To view
the differences between the 5.7.1 release and the 5.7.2 release,
see L&lt;perl572delta&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para ver las diferencias entre la versión 5.7.1 y la versión 5.7.2, véase L&lt;perl572delta&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are Perl's functions (including things that look like
functions, like some keywords and named operators)
arranged by category.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí están las funciones Perl (incluyen cosas que parecen funciones, como algunas palabras clave y operadores con nombre) agrupados por categoría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until the block exits, elements locally deleted
temporarily no longer exist.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hasta que un bloque termine, los elementos locales suprimidos, temporalmente, ya no existen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item umask</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item umask</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus arrays and hashes lose their
identity in a LIST--the list</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, los arrays y hashes pierden su identidad en una LISTA: la lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>( (?i) blah ) \s+ \1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234831Z" changeid="explorer">
        <seg>( (?i) bla ) \s+ \1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because you're assigning to
an @array, so you need parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es así porque está asignando a un @array, por lo que necesita usar paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do various useful things to lists:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T002003Z" changeid="zipf">
        <seg>Puede hacer varias cosas útiles con las listas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If MODE is C&lt;&lt;&lt; '&gt;&gt;' &gt;&gt;&gt;,
the file is opened for appending, again being created if necessary.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si MODO es C&lt;&lt;&lt; '&gt;&gt;' &gt;&gt;&gt;, el archivo se abre en modo añadir, y de nuevo, será creado si es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-i&gt;[I&lt;extension&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-i&gt;[I&lt;extensión&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called in
scalar context, returns only the key (not the value) in a hash, or the index
in an array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se le llama en contexto escalar, sólo devuelve la clave (no el valor) del hash, o el índice del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX &quot;:sys_wait_h&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use POSIX &quot;:sys_wait_h&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/continue&gt; for an illustration of how C&lt;last&gt;, C&lt;next&gt;, and
C&lt;redo&gt; work.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/continue&gt; para una ilustración de cómo funcionan C&lt;last&gt;, C&lt;next&gt; y C&lt;redo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readlink EXPR
X&lt;readlink&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194433Z" changeid="explorer">
        <seg>=item readlink EXPR
X&lt;readlink&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($variable) {		# trim whitespace in $variable, cheap</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ($variable) {		# recorta el espacio en blanco en $variable, de forma más simple</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot; ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot; ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;unpack&gt;, an internal stack of integer arguments unpacked so far is
used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para C&lt;unpack&gt;, se usa una pila interna de argumentos enteros desempaquetados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Requirements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Requisitos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13575</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13575</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a C&lt;&lt; while (&lt;&gt;) &gt;&gt; loop, C&lt;eof&gt; or C&lt;eof(ARGV)&gt; can be used to
detect the end of each file, C&lt;eof()&gt; will detect the end of only the
last file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En un bucle C&lt;&lt; while (&lt;&gt;) &gt;&gt;, C&lt;eof&gt; o C&lt;eof(ARGV)&gt; pueden usarse para detectar el fin de un archivo; C&lt;eof()&gt; sólo detectará el final del último archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SUBNAME or BLOCK is omitted, C&lt;sort&gt;s in standard string comparison
order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si NOMBRE_SUB O BLOQUE se omite, se ordena siguiendo una comparación estándar de cadenas de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a % 2) ? ($a += 10) : ($a += 2)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054124Z" changeid="explorer">
        <seg>($a % 2) ? ($a += 10) : ($a += 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first block or so of the
file is examined for odd characters such as strange control codes or
characters with the high bit set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer bloque (aprox.) del archivo, es examinado para buscar caracteres extraños como códigos de control o caracteres con el bit alto puesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But alternative
hashing schemes (like MD5), higher level security schemes (like C2),
and implementations on non-Unix platforms may produce different
strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero esquemas alternativos de cálculo de hash (como MD5), esquemas de seguridad de alto nivel (como C2) e implementaciones en plataformas no UNIX pueden producir cadenas diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One should
conscientiously choose between the I&lt;magic&gt; and 3-arguments form
of open():</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Uno debe elegir escrupulosamente entre la I&lt;magia&gt; y la forma de 3 argumentos de open():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments should
be integers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los argumentos deben ser números enteros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override the width by putting
a number here, or get the width from the next argument (with C&lt;*&gt;)
or from a specified argument (e.g., with C&lt;*2$&gt;):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede reemplazar el ancho al anteponer un número, u obteniendo la anchura del siguiente argumento (con C&lt;*&gt;) o de un argumento determinado (por ejemplo, con C&lt;*2$&gt;):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the file is
successfully compiled, C&lt;do&gt; returns the value of the last expression
evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el archivo se compila bien, C&lt;do&gt; devuelve el valor de la última expresión evaluada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true for success, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero en caso de éxito, o falso en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,}+  Match at least n times and give nothing back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n,}+  Coincide al menos n veces y no devuelve nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;&lt; $file\0&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, &quot;&lt; $archivo\0&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$oct_perm_str = sprintf &quot;%o&quot;, $perms;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$oct_perm_str = sprintf &quot;%o&quot;, $permisos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular,
characters C&lt;&quot;0&quot;&gt; and C&lt;&quot;1&quot;&gt; generate nybbles 0 and 1, as do bytes
C&lt;&quot;\0&quot;&gt; and C&lt;&quot;\1&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, los caracteres C&lt;&quot;0&quot;&gt; y C&lt;&quot;1&quot;&gt; generan los nibles 0 y 1, como los bytes C&lt;&quot;\0&quot;&gt; y C&lt;&quot;\1&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the C&lt;m&gt;
you can use any pair of non-whitespace characters
as delimiters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con la C&lt;m&gt; puede usar cualquier par de caracteres no-blancos como delimitadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rounded = sprintf(&quot;%.3f&quot;, $number);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$redondeo = sprintf(&quot;%.3f&quot;, $numero);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the exception is outside of all enclosing C&lt;eval&gt;s, then the uncaught
exception prints LIST to C&lt;STDERR&gt; and exits with a non-zero value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170937Z" changeid="explorer">
        <seg>Si la excepción está fuera de un C&lt;eval&gt;, entonces la excepción no capturada imprime LISTA al C&lt;STDERR&gt; y sale con un valor no nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Boolean logic</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Lógica Booleana</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's cleaner, safer, and faster.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más limpio, seguro y rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5004delta	Perl changes in version 5.004</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5004delta	Cambios en la versión 5.004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the B&lt;-i&gt; switch in L&lt;perlrun&gt; for a
better approach.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver la opción B&lt;-i&gt; en L&lt;perlrun&gt; para una mejor aproximación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use the C&lt;use warnings&gt; pragma or Perl's B&lt;-w&gt; command-line 
option, you may see warnings
about useless uses of constants or functions in &quot;void context&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T000519Z" changeid="explorer">
        <seg>Cuando se utiliza el pragma C&lt;use warnings&gt; o la opción de Perl en la línea de órdenes B&lt;-w&gt;, pueden mostrarse avisos sobre el uso inútil de constantes o funciones en contexto vacío (&quot;I&lt;void&gt;&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This strategy
is so successful that Perl programmers often do not suspect the
ambivalence of what they write.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta estrategia es tan exitosa que los programadores de Perl a menudo no sospechan de la ambivalencia de lo que escriben.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} until $line  eq &quot;.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} until $linea  eq &quot;.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If ARRAY is omitted, pops the C&lt;@ARGV&gt; array in the
main program, but the C&lt;@_&gt; array in subroutines, just like C&lt;shift&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192655Z" changeid="explorer">
        <seg>Si ARRAY se omite, se extrae desde el array C&lt;@ARGV&gt; en el programa principal, y del array C&lt;@_&gt; en subrutinas, igual que C&lt;shift&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VALUE is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite VALOR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, when a LIST is
evaluated, each element of the list is evaluated in list context, and
the resulting list value is interpolated into LIST just as if each
individual element were a member of LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, cuando una LISTA se evalúa, cada elemento de la lista se evalúa en contexto lista, y el valor de la lista resultante se interpola en la LISTA como si cada elemento individual fuera un miembro de LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type prefix of a typeglob is a C&lt;*&gt;, because
it represents all types.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El prefijo de un tipo de typeglob es una C&lt;*&gt;, porque representa todos los tipos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} $x_lo ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053113Z" changeid="explorer">
        <seg>} $x_lo ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>11 blksize  preferred block size for file system I/O</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>11 blksize  tamaño preferido del bloque de E/S para el sistema de archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AUTHOR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>AUTOR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is the same as this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es lo mismo que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hours = $1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$horas = $1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to connect to a remote socket, just like connect(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intenta conectarse a un socket remoto, al igual que connect(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a &lt;FILEHANDLE&gt; is used in a context that is looking for
a list, a list comprising all input lines is returned, one line per
list element.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T212041Z" changeid="explorer">
        <seg>Si un &lt;GESTOR_ARCHIVO&gt; es utilizado en un contexto en el que está esperando una lista, es devuelta una lista que contenga todas las líneas de entrada, una línea por cada elemento de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = ('cc', '-E', $bar);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = ('cc', '-E', $bar);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/hex&gt; and L&lt;perlfunc/oct&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T002328Z" changeid="explorer">
        <seg>Véase L&lt;perlfunc/hex&gt; y L&lt;perlfunc/oct&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get multiple values from an array:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T223516Z" changeid="zipf">
        <seg>Para obtener varios elementos de un array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, return 1 for each valid line, and 0 after all lines have been
returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De nuevo, devuelve 1 para cada línea válida y 0 después de que todas las líneas han sido devueltas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can actually chop anything that's an lvalue, including an assignment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede recortar cualquier cosa que sea un lvalue (valor a la izquierda), incluyendo una asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @greek_small =  (&quot;\N{alpha}&quot; ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @griegas_minusculas =  (&quot;\N{alpha}&quot; ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function semop(2) for semaphore operations
such as signalling and waiting.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC semop(2) para operaciones de semáforo como señalización y espera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $foo = '';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $foo = '';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\t		tab                   (HT, TAB)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\t		tab                   (HT, TAB)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello, world&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233532Z" changeid="zipf">
        <seg>print &quot;Hola a todos&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not use tell() (or other buffered I/O operations) on a filehandle
that has been manipulated by sysread(), syswrite() or sysseek().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No utilice tell() (u otras operaciones de E/S con buffer) en un gestor de archivo que ha sido manipulado por sysread(), syswrite() o sysseek().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $perm = (stat $fh)[2] &amp; 07777;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $permisos = (stat $fh)[2] &amp; 07777;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1: 'oo', pos=4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1: 'oo', pos=4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getservent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getservent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words,
the C&lt;foreach&gt; loop index variable is an implicit alias for each item
in the list that you're looping over.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, la variable índice del bucle C&lt;foreach&gt; es implícitamente un alias de cada elemento de la lista sobre la que está iterando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>enhanced debugger and interactive Perl environment,
with integrated editor support</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>depurador mejorado y entorno Perl interactivo, con soporte de un editor integrado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub foo { defined &amp;$bar ? &amp;$bar(@_) : die &quot;No bar&quot;; }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043804Z" changeid="explorer">
        <seg>sub foo { defined &amp;$bar ? &amp;$bar(@_) : die &quot;No bar&quot;; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However,
you may distribute this Package in aggregate with other (possibly
commercial) programs as part of a larger (possibly commercial) software
distribution provided that you do not advertise this Package as a
product of your own.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, usted puede distribuir este Paquete en conjunto con otros programas (posiblemente comerciales) como parte de una mayor (posiblemente comercial) distribución de software siempre y cuando no haga publicidad de este Paquete como si fuera un producto suyo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allow installing extra modules or bundles when building Perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>permitir la instalación de módulos extra o empaquetados cuando se compila Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(To convert strings that might start with either C&lt;0&gt;, C&lt;0x&gt;, or C&lt;0b&gt;, see
L&lt;/oct&gt;.)  If EXPR is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para convertir strings que pueden comenzar con C&lt;0&gt;, C&lt;0x&gt; o C&lt;0b&gt;, ver L&lt;/oct&gt;.)  Si se omite EXPR, usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
are the semantics that lockf(3) implements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas son las semánticas que lockf(3) implementa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0x34 0x12 0x78 0x56</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0x34 0x12 0x78 0x56</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some
operators return the first value in the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven el primer valor de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the file descriptor for a filehandle, or undefined if the
filehandle is not open.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el descriptor de archivo para un gestor, o indefinido si el gestor no está abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless defined($value = readlink $sym);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless defined($valor = readlink $sym);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/y/) { say '$foo contains a y' }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/y/) { say '$foo contiene una y' }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.macos - Perl under Mac OS (Classic)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.macos - Perl bajo Mac OS (Classic)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;W4&quot;,65,66,67,68);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;W4&quot;,65,66,67,68);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value
gives the real filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211412Z" changeid="explorer">
        <seg>GESTOR_ARCHIVO puede ser una expresión cuyo valor da el gestor real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Network socket support is disabled for BeOS R5 net server.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Soporte para socket está desactivado para BeOS R5 net server.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Backticks</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Comillas invertidas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When assigning to a list, if LIMIT is omitted, or zero, Perl supplies
a LIMIT one larger than the number of variables in the list, to avoid
unnecessary work.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al asignar a una lista, si LÍMITE es omitido, o cero, Perl proporciona un LÍMITE uno mayor que el número de variables en la lista, para evitar trabajo innecesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>78/75813 subtests failed, 99.90% okay.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005055Z" changeid="explorer">
        <seg>78/75813 subtests fallaron, 99.90% bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open STDERR, &quot;&gt;&amp;STDOUT&quot;     or die &quot;Can't dup STDOUT: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open STDERR, &quot;&gt;&amp;STDOUT&quot;     or die &quot;No puedo duplicar STDOUT: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;open&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;open&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getgrnam NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getgrnam NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus ((),(),()) is equivalent to ().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que ((),(),()) es equivalente a ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,10, 2) = 2   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,10, 2) = 2   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop&gt; for more details on unary operators and the comma operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop&gt; para más detalles en operadores unarios y el operador coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shmwrite ID,STRING,POS,SIZE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item shmwrite ID,CADENA,POSICIÓN,TAMAÑO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170025Z" changeid="explorer">
        <seg>$wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the outcome may be determined by voting based
on heuristic estimators, the result is not strictly predictable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que el resultado puede ser determinado por votación basada en estimadores heurísticos, el resultado no es estrictamente predecible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 About Compiler Versions of Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003014Z" changeid="explorer">
        <seg>=head2 Sobre las versiones del compilador de Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Updated Modules And Pragmata</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Módulos y Pragmata actualizados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0         1         2         3
                       unpack(&quot;V&quot;,$_) 01234567890123456789012345678901</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052533Z" changeid="explorer">
        <seg>0         1         2         3
                       unpack(&quot;V&quot;,$_) 01234567890123456789012345678901</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also use C&lt;defined(&amp;func)&gt; to check whether subroutine C&lt;&amp;func&gt;
has ever been defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar también C&lt;defined(&amp;func)&gt; para comprobar si la subrutina C&lt;&amp;func&gt; ha sido definida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$utmp_template = &quot;Z8 Z8 Z16 L&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$utmp_template = &quot;Z8 Z8 Z16 L&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>uc($a)  cmp  uc($b)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>uc($a)  cmp  uc($b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>seek(FILE, $curpos, 0);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>seek(FILE, $curpos, 0);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's
because while we have a nice synonym for single elements via the
pointer arrow for dereferencing, no such convenience exists for slices.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194606Z" changeid="explorer">
        <seg>Eso es porque mientras que nosotros tenemos un sinónimo sencillo para los elementos individuales a través de la flecha puntero de desreferencia, no existe tal conveniencia para las porciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash    Hash      hash keys identical (every key is found in both hashes)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hash        Hash       claves hash identicas (cada clave está en ambos hash)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item More complex regular expressions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233428Z" changeid="zipf">
        <seg>=item Expresiones regulares más complejas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$abbr[$mon] $mday&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$abbr[$mes] $mdia&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;state&gt; variables are enabled only when the C&lt;use feature &quot;state&quot;&gt; pragma 
is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;state&gt; variables sólo se activan cuando el pragma C&lt;use feature &quot;state&quot;&gt; está en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dec_perms = (stat(&quot;filename&quot;))[2] &amp; 07777;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$dec_perms = (stat(&quot;archivo&quot;))[2] &amp; 07777;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of using C&lt;given()&gt;, you can use a C&lt;foreach()&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En lugar de usar C&lt;given()&gt;, puede usar un bucle C&lt;foreach()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could just make a direct assignment
if you knew where you wanted to put it:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacer una asignación directa si sabe dónde quiere ponerlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(print $foo), exit;	# This is what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(print $foo), exit;	# Esto es lo que quiere hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$abc    = 1 when /^abc/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$abc    = 1 when /^abc/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>document the coderef-in-@INC feature</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>documentar la característica &quot;referencia a código&quot; en @INC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special case, specifying a PATTERN of space (S&lt;C&lt;' '&gt;&gt;) will split on
white space just as C&lt;split&gt; with no arguments does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como caso especial, especificando un PATRÓN de un espacio (S&lt;C&lt;' '&gt;&gt;) dividirá en espacios en blanco al igual que lo hace C&lt;split&gt; sin argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>accompany the distribution with the machine-readable source of the
Package with your modifications.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>acompañar a la distribución con el código fuente, legible por la máquina, del Paquete con sus modificaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only those places
that contain this &quot;rarest&quot; character are examined.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo estos lugares que contienen este &quot;carácter&quot; más raro son examinados).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can use sophisticated pattern matching techniques to
scan large amounts of data quickly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl puede utilizar sofisticadas técnicas de concordancia de patrones para escanear grandes cantidades de datos, rápidamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;/ucfirst&gt; for that.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210050Z" changeid="explorer">
        <seg>Ver L&lt;/ucfirst&gt; para eso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@EXPORT = qw( foo bar baz );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@EXPORT = qw( foo bar baz );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo,  9,  8) = 0x65;   # 'PerlPerlPe'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($foo,  9,  8) = 0x65;   # 'PerlPerlPe'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = @foo;                # $foo gets 3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = @foo;                # $foo vale 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also be aware that setting C&lt;@DB::args&gt; is I&lt;best effort&gt;, intended for
debugging or generating backtraces, and should not be relied upon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También tenga en cuenta que fijar C&lt;@DB::args&gt; es I&lt;el mejor esfuerzo&gt;, destinado a la depuración o la generación de seguimientos, y no debería ser invocado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 4   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 4   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: Any files opened at the time of the dump will I&lt;not&gt;
be open any more when the program is reincarnated, with possible
resulting confusion by Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;ATENCIÓN&gt;: Cualquier archivo abierto en el momento del volcado I&lt;no&gt; será abierto mas que cuando el programa sea reencarnado, con una muy posible confusión por parte de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copy the miniperl executable from the native build done earlier to
replace the cross compiled miniperl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Copie el ejecutable miniperl desde la construcción nativa hecha antes, para reemplazar el miniperl compilado de forma cruzada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item split /PATTERN/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item split /PATRÓN/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(($a % 2) ? ($a += 10) : $a) += 2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054118Z" changeid="explorer">
        <seg>(($a % 2) ? ($a += 10) : $a) += 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># alter $@ on nefarious repugnancy only</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># altera $@ solo en una infame repugnancia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The granularity for such extension or truncation is one or more
bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La granularidad para dicha extensión o truncamiento es de uno o más bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;defined(...)&gt;, C&lt;exists(...)&gt;, or C&lt;eof(...)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;defined(...)&gt;, C&lt;exists(...)&gt;, o C&lt;eof(...)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the process id of the parent process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el identificador de proceso del proceso padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a tied hash
is evaluated in scalar context, a fatal error will result, since this
bucket usage information is currently not available for tied hashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si un hash enlazado (tie) es evaluado en contexto escalar, resultará en un error fatal, debido a que la información de cajones no está, actualmente, disponible para los hashes enlazados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you call it again after this, it will assume you are processing another
@ARGV list, and if you haven't set @ARGV, will read input from STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si lo llama de nuevo, después, asumirá que está procesando otra lista @ARGV, y si no ha configurado @ARGV, leerá la entrada desde STDIN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 4) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 4) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most systems the epoch is 00:00:00 UTC, January 1, 1970;
a prominent exception being Mac OS Classic which uses 00:00:00, January 1,
1904 in the current local time zone for its epoch.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de los sistemas el I&lt;epoch&gt; son las 00:00:00 UTC, del 1 de enero de 1970; una prominente excepción es el Mac OS Classic que utiliza las 00:00:00, del 1 de enero de 1904 en la actual zona horaria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns undefined if there is an
error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve indefinido si hay un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item String comparison</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Comparación de cadenas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SUBNAME is specified, it gives the name of a subroutine
that returns an integer less than, equal to, or greater than C&lt;0&gt;,
depending on how the elements of the list are to be ordered.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se ha especificado NOMBRE_SUB, da el nombre de la subrutina que devuelve un entero menor que, igual que, o mayor que C&lt;0&gt;, dependiendo de cómo los elementos de la lista tienen que ser ordenados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item m/PATTERN/msixpogc
X&lt;m&gt; X&lt;operator, match&gt;
X&lt;regexp, options&gt; X&lt;regexp&gt; X&lt;regex, options&gt; X&lt;regex&gt;
X&lt;/m&gt; X&lt;/s&gt; X&lt;/i&gt; X&lt;/x&gt; X&lt;/p&gt; X&lt;/o&gt; X&lt;/g&gt; X&lt;/c&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003607Z" changeid="explorer">
        <seg>=item m/PATRÓN/msixpogc
X&lt;m&gt; X&lt;operator, match&gt;
X&lt;regexp, options&gt; X&lt;regexp&gt; X&lt;regex, options&gt; X&lt;regex&gt;
X&lt;/m&gt; X&lt;/s&gt; X&lt;/i&gt; X&lt;/x&gt; X&lt;/p&gt; X&lt;/o&gt; X&lt;/g&gt; X&lt;/c&gt; X&lt;operador, coincidencia&gt; X&lt;opciones, regex&gt; X&lt;opciones, regexp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>untie(%HIST);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>untie(%HIST);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sort BLOCK LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sort BLOQUE LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match at least n but not more than m times, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide al menos n pero no más de m veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most systems, this will set the file's access and
modification times to the current time (i.e., equivalent to the example
above) and will work even on files you don't own provided you have write
permission:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de los sistemas, esto hará que los tiempos de acceso y modificación del archivo se establezcan a la hora actual (es decir, equivalente al ejemplo anterior) y funcionará incluso en archivos de los cuales usted no tenga permisos de escritura:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; &gt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; &gt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordinarily you must assign the returned value to a variable, but
there is one situation where an automatic assignment happens.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente debe asignar el valor devuelto a una variable, pero hay una situación en la que sucede una asignación automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\G  Match only at pos() (e.g. at the end-of-match position</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225944Z" changeid="explorer">
        <seg>\G  Coincide solo en pos() (p. ej. en la posición de la última coincidencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item splice ARRAY,OFFSET</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item splice ARRAY,DESPLAZAMIENTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/&quot;I/O Operators&quot;&gt; for more discussion.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase L&lt;/&quot;Operadores E/S&quot;&gt; para más discusiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%+.6d&gt;', 1;     # prints &quot;&lt;+000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%+.6d&gt;', 1;     # imprime &quot;&lt;+000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like C&lt;print&gt;, but implicitly appends a newline.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Igual que C&lt;print&gt;, pero implícitamente añade un carácter de nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;%32W*&quot;,&lt;&gt;) % 65535;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;%32W*&quot;,&lt;&gt;) % 65535;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Quote-Like Operators
X&lt;operator, quote-like&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010108Z" changeid="explorer">
        <seg>=head2 Operadores de entrecomillado
X&lt;operator, quote-like&gt; X&lt;operador, entrecomillado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right	= += -= *= etc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>derecha	= += -= *= etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 32  ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 32  ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The author of Perl has never felt the
need to use this form of C&lt;goto&gt; (in Perl, that is--C is another matter).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El autor de Perl nunca ha sentido la necesidad de usar esta forma de C&lt;goto&gt; (en Perl, desde luego. C es otra historia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To find out whether a given string is a valid non-zero number, it's
sometimes enough to test it against both numeric 0 and also lexical
&quot;0&quot; (although this will cause noises if warnings are on).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para saber si una cadena dada es un número válido distinto de cero, a veces es suficiente con compararlo con el 0 numérico y también con el &quot;0&quot; léxico (aunque esto provocará ruido si los avisos están activados).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item `STRING`</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item `CADENA`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extracts a substring out of EXPR and returns it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Extrae una subcadena de EXPR y la devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pthreads patches information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004548Z" changeid="explorer">
        <seg>de parches en pthreads.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual limit can
be seen in the error message generated by code such as this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El límite real se puede ver en el mensaje de error generado por un código como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$proto) = getproto*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($name,$aliases,$proto) = getproto*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next unless -f $_;  # ignore specials</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next unless -f $_;	# ignora especiales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq1		General Questions About Perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq1		Cuestiones generales sobre Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($logmessage, $priority) = @_;       # common</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110204T165732Z" changeid="zipf">
        <seg>my ($mensaje_registro, $prioridad) = @_; # común</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$count = $string =~ /\d+/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cuenta = $cadena =~ /\d+/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/ftmp-security....File::Temp::_gettemp:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lib/ftmp-security....File::Temp::_gettemp:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;8 - 4&gt; is evaluated first making the
expression C&lt;4 - 2 == 2&gt; and not C&lt;8 - 2 == 6&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;8 - 4&gt; es evaluada primero dejando la expresión C&lt;4 - 2 == 2&gt; y no C&lt;8 - 2 == 6&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ENFMT stands for</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El ENFMT significa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># inefficiently sort by descending numeric compare using</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#  ordenación ineficiente por comparación numérica descendente usando</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to write loops that terminate when a null list
is returned:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto hace que sea fácil escribir bucles que terminan cuando se devuelve una lista vacía:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last if eof();          # needed if we're reading from a terminal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last if eof();          # necesario si estamos leyendo de una terminal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system(@args) == 0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system(@args) == 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print PASSWD &quot;${who}::0:0:Superuser:/:/bin/perl\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print PASSWD &quot;${quien}::0:0:Superusuario:/:/bin/perl\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function allows you to distinguish C&lt;undef&gt; from
other values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función le permite distinguir C&lt;undef&gt; de otros valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to create anonymous filehandles is with the Symbol
module or with the IO::Handle module and its ilk.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otra forma de crear gestores de archivo anónimos es con el módulo Symbol o con el módulo IO::Handle y sus acólitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Defined\n&quot; if defined &amp;subroutine;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Definido\n&quot; if defined &amp;subrutina;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hashes are unordered collections of scalar 
values indexed by their associated string key.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los hashes son colecciones no ordenadas de valores escalares indexadas por sus claves asociadas, que son cadenas de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strange though this may seem, this is the basis for the whole
module import/export system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por extraño que pueda parecer, esta es la base para todo el sistema de importación/exportación en los módulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a number of &quot;magic&quot; scalars with names that look like
punctuation or line noise.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224830Z" changeid="explorer">
        <seg>Hay varios escalares &quot;mágicos&quot; con nombres que recuerdan conjuntos de signos de puntuación (o &quot;ruido de señal&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($zippy) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232631Z" changeid="explorer">
        <seg>if ($zippy) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:-)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T114150Z" changeid="zipf">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binds a network address to a socket, just as bind(2)
does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Enlaza una dirección de red a un socket, como lo hace bind(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rand +(10) * 20;	# rand (10 * 20)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>rand +(10) * 20;	# rand (10 * 20)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LABEL identifies the loop for the loop control
statements C&lt;next&gt;, C&lt;last&gt;, and C&lt;redo&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013400Z" changeid="explorer">
        <seg>La ETIQUETA identifica el bucle para las instrucciones de control de bucle C&lt;next&gt;, C&lt;last&gt; y C&lt;redo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11371</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11371</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item goto LABEL
X&lt;goto&gt; X&lt;jump&gt; X&lt;jmp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173857Z" changeid="explorer">
        <seg>=item goto ETIQUETA
X&lt;goto&gt; X&lt;jump&gt; X&lt;jmp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language is intended to be practical (easy to use, efficient,
complete) rather than beautiful (tiny, elegant, minimal).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224610Z" changeid="explorer">
        <seg>El lenguaje se diseñó para ser práctico (fácil de usar, eficaz, completo), más que estético (reducido, elegante, minimalista).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when world writable?) at lib/ftmp-security.t line 100</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when world writable?) at lib/ftmp-security.t line 100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11375</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11375</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>D  A float of long-double precision in native format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>D  Un flotante en doble-largo precisión en formato nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Symmetrically, C&lt;no VERSION&gt; allows you to specify that you want a version
of Perl older than the specified one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Simétricamente, C&lt;no VERSIÓN&gt; le permite especificar que desea una versión de Perl más vieja que la especificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\r		return          (CR)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002736Z" changeid="explorer">
        <seg>\r		retorno          (CR)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T010646Z" changeid="explorer">
        <seg>if ($.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl 5.8.0 had been released
for BeOS BONE, I suspect, there is a good chance, that it still compiles on
a BONE system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde que Perl 5.8.0 ha sido lanzado para BeOS BONE, sospecho, que es una buena oportunidad, para que todavía se pueda compilar en un sistema BONE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ary1[$i] += $ary2[$j];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ary1[$i] += $ary2[$j];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arranges to have a SIGALRM delivered to this process after the
specified number of wallclock seconds has elapsed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ordena mandar una señal SIGALRM al proceso actual después de que haya pasado el número de segundos especificados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means you usually want to use positive not negative signals.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Eso significa que desea utilizar, generalmente, señales positivas, y no negativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$val = oct($val) if $val =~ /^0/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$val = oct($val) if $val =~ /^0/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;pack&gt;, you write I&lt;length-item&gt;C&lt;/&gt;I&lt;sequence-item&gt;, and the
I&lt;length-item&gt; describes how the length value is packed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para C&lt;pack&gt;, escriba I&lt;longitud-item&gt;C&lt;/&gt;I&lt;secuencia-item&gt;, y la I&lt;longitud-item&gt; indica el valor de la longitud de lo que está empaquetado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, &quot;..&quot; returns a boolean value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, &quot;..&quot; devuelve un valor booleano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#whatever = -1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#loquesea = -1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr/AAA/XYZ/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr/AAA/XYZ/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%e    a floating-point number, in scientific notation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%e    un número en punto flotante, en notación científica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$addrtype,$net) = getnet*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($name,$aliases,$addrtype,$net) = getnet*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod/&quot;Packages&quot;&gt; for more information about packages, modules,
and classes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod/&quot;Paquetes&quot;&gt; para más información sobre paquetes, módulos y clases.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlxs		Perl XS application programming interface</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlxs		Interfaz de programación de aplicaciones XS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may not be used to go into any construct that
requires initialization, such as a subroutine or a C&lt;foreach&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede ser usado en ninguna construcción que requiera inicialización, como una subrutina o un bucle C&lt;foreach&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o	Compile pattern only once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o	Compila el patrón solo una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item On ASCII platforms</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174511Z" changeid="explorer">
        <seg>=item En plataformas ASCII</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A simple Boolean test will not distinguish among
C&lt;undef&gt;, zero, the empty string, and C&lt;&quot;0&quot;&gt;, which are all equally
false.)  Note that since C&lt;undef&gt; is a valid scalar, its presence
doesn't I&lt;necessarily&gt; indicate an exceptional condition: C&lt;pop&gt;
returns C&lt;undef&gt; when its argument is an empty array, I&lt;or&gt; when the
element to return happens to be C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Un simple test Booleano no distinguirá entre C&lt;undef&gt;, cero, el string vacío y C&lt;&quot;0&quot;&gt;, que son todos igualmente falso). Note que como C&lt;undef&gt; es un escalar válido, su presencia no indica I&lt;necesariamente&gt; una condición excepcional: C&lt;pop&gt; devuelve C&lt;undef&gt; cuando su argumento es un array vacío, I&lt;o&gt; cuando el elemento a devolver sea un C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;unshift&gt;, C&lt;push&gt;, and C&lt;pop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también C&lt;unshift&gt;, C&lt;push&gt;, y C&lt;pop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp; 128) ? 'with' : 'without';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052247Z" changeid="explorer">
        <seg>&amp; 128) ? 'con' : 'sin';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keys of a hash are returned in an apparently random order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las claves de un hash son devueltas en un aparente orden aleatorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item goto &amp;NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item goto &amp;NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;keys&gt;, C&lt;values&gt; and C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;keys&gt;, C&lt;values&gt; y C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, use of C&lt;$[&gt; is deprecated.)
So in general you can assume that
X&lt;$[&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T001436Z" changeid="explorer">
        <seg>(En otras palabras, el uso de C&lt;$[&gt; es obsoleto). Por ello, en general, puede asumir que X&lt;$[&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Safety net</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235813Z" changeid="zipf">
        <seg>=head2 Red de seguridad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An C&lt;our&gt; declaration declares a global variable that will be visible
across its entire lexical scope, even across package boundaries.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una declaración C&lt;our&gt; declara una variable global que será visible en todo su ámbito léxico, incluso a través de las fronteras del paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>. 'more '/eg;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054303Z" changeid="explorer">
        <seg>. 'más '/eg;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 New or Changed Diagnostics</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Diagnósticos nuevos y cambiados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$baz = '\n';		# a two-character string</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$baz = '\n';		# una cadena de dos caracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^abc/) { $abc = 1; last SWITCH; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^abc/) { $abc = 1; last SWITCH; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substr($name, 4) = 'dy';         # $name is now 'freddy'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>substr($nombre, 4) = 'ito';       # $nombre es ahora 'pedrito'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>w  A BER compressed integer (not an ASN.1 BER, see perlpacktut for</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>w  Un entero comprimido en BER (no en ASN.1 BER, ver perlpacktut para los</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PATTERN may contain variables, which will be interpolated (and the
pattern recompiled) every time the pattern search is evaluated, except
for when the delimiter is a single quote.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>PATRÓN puede contener variables, que serán interpoladas (y el patrón recompilado) cada vez que el patrón de búsqueda sea evaluado, a excepción de cuando el delimitador sea una comilla simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The module can implement its
C&lt;import&gt; method any way it likes, though most modules just choose to
derive their C&lt;import&gt; method via inheritance from the C&lt;Exporter&gt; class that
is defined in the C&lt;Exporter&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo puede implementar su propio método C&lt;import&gt; de la forma que desee, aunque la mayoría de los módulos sólo eligen derivar su método C&lt;import&gt; vía herencia desde la clase C&lt;Exporter&gt; que se define en el módulo C&lt;Exporter&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Just read in this line: $_&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T003122Z" changeid="zipf">
        <seg>print &quot;Acabo de leer esta línea: $_&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Shift Operators
X&lt;shift operator&gt; X&lt;operator, shift&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;
X&lt;&lt;&lt; &gt;&gt; &gt;&gt;&gt; X&lt;right shift&gt; X&lt;left shift&gt; X&lt;bitwise shift&gt;
X&lt;shl&gt; X&lt;shr&gt; X&lt;shift, right&gt; X&lt;shift, left&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234557Z" changeid="explorer">
        <seg>=head2 Operadores de desplazamiento
X&lt;shift operator&gt; X&lt;operator, shift&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;
X&lt;&lt;&lt; &gt;&gt; &gt;&gt;&gt; X&lt;right shift&gt; X&lt;left shift&gt; X&lt;bitwise shift&gt;
X&lt;shl&gt; X&lt;shr&gt; X&lt;shift, right&gt; X&lt;shift, left&gt; X&lt;operador de desplazamiento&gt; X&lt;operador, desplazamiento&gt; X&lt;desplazamiento derecho&gt; X&lt;desplazamiento izquierdo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl functions affected
by this are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las funciones Perl afectadas por esto son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Commas should separate literal elements of the LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las comas deberían separar elementos literales de la LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(To
avoid this cost while retaining the grouping behaviour, use the
extended regular expression C&lt;(?: ... )&gt; instead.)  But if you never
use C&lt;$&amp;&gt;, C&lt;$`&gt; or C&lt;$'&gt;, then patterns I&lt;without&gt; capturing
parentheses will not be penalized.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para evitar este coste mientras quiera usar el comportamiento de agrupación, use en su lugar la expresión regular extendida C&lt;(?: ... )&gt;). Pero si nunca usa C&lt;$&amp;&gt;, C&lt;$`&gt; o C&lt;$'&gt;, entonces los patrones I&lt;sin&gt; paréntesis de captura no serán penalizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(a.)+/             matches a string in which every odd-numbered letter
                        is a (eg &quot;abacadaf&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055800Z" changeid="explorer">
        <seg>/(a.)+/             cadena en la que cada letra impar es a
                        (ej. &quot;abacadaf&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each semop structure can be generated with
C&lt;pack(&quot;s!3&quot;, $semnum, $semop, $semflag)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada estructura semop se puede generar con C&lt;pack(&quot;s!3&quot;, $semnum, $semop, $semflag)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the selected element is outside the string, the value 0 is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el elemento seleccionado se fuera de la cadena, se devuelve el valor 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next if /barney/; # same effect as &quot;last&quot;, but doesn't document as well</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next if /pablo/; # mismo efecto que &quot;last&quot;, pero no se ve muy claro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;telldir&gt; has the same caveats about possible directory
compaction as the corresponding system library routine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;telldir&gt; también tiene las mismas advertencias sobre la posible compactación del directorio como la correspondiente rutina del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
expression is interpreted as a list of single characters (hyphens
allowed for ranges).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La expresión se interpreta como una lista de caracteres simples (guiones permitidos para indicar rangos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, C&lt;undef&gt; is returned only once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una vez más, C&lt;undef&gt; sólo se devuelve una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;formline&gt; always returns true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;formline&gt; siempre devuelve verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11362</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11362</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, attempting to
use them raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, al tratar de usarlos lanzará una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page describes the syntax of regular expressions in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta página describe la sintaxis de las expresiones regulares en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Identical to the chmod 0755 of the example above.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Idéntico a chmod 0755 del ejemplo anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#ARRAY];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#ARRAY];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each
hash or array has its own internal iterator, accessed by C&lt;each&gt;, C&lt;keys&gt;,
and C&lt;values&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada hash o array tiene su iterador interno, accedido por C&lt;each&gt; , C&lt;keys&gt;, y C&lt;values&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rand(10) * 20;	# (rand 10) * 20</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>rand(10) * 20;	# (rand 10) * 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LDLOADLIBS=-lc make</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LDLOADLIBS=-lc make</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\b		backspace       (BS)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002821Z" changeid="explorer">
        <seg>\b		retroceso        (BS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The port of Perl to to Mac OS was officially removed as of Perl 5.12,
though the last offical production release of MacPerl corresponded to 
Perl 5.6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La versión de Perl para el Mac OS se retiró oficialmente como Perl 5.12, aunque el lanzamiento oficial de la última producción MacPerl correspondió a Perl 5.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef &amp;mysub;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef &amp;mysub;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List assignment in scalar context returns the number of elements
produced by the expression on the right side of the assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lista de asignación en contexto escalar devuelve el número de elementos producidos por la expresión en el lado derecho de la asignación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command is normally used by programs that want to lie to themselves
about what was just input.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comando se usa, normalmente, por los programas que quieren engañarse a sí mismos sobre lo que fue introducido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means C&lt;srand(42)&gt; will usually
produce the same results as C&lt;srand(42.1)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que C&lt;srand(42)&gt; produce los mismos resultados, generalmente, que C&lt;srand(42.1)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A literal of the form C&lt;v1.20.300.4000&gt; is parsed as a string composed
of characters with the specified ordinals.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T003610Z" changeid="explorer">
        <seg>Un literal de la forma C&lt;v1.20.300.4000&gt; es interpretada como una cadena compuesta de caracteres con los ordinales especificados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is better than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es mejor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The old &quot;gnu-0.2&quot;
binary distribution will most certainly have additional problems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La anterior distribución binaria &quot;gnu-0.2&quot; con toda seguridad, tiene problemas adicionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a fairly obvious gotcha included with the line directive:
Debuggers and profilers will only show the last source line to appear
at a particular line number in a given file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existe obviamente un problema con esta directiva: los I&lt;debuggers&gt; y perfiladores sólo mostrarán la última línea del código fuente que aparece en un número de línea en particular de un determinado archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This lets you indirectly pass arguments to
the subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto le permite pasar argumentos indirectamente a la subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; digits&quot;),		redo LOOP if /\G\d+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(&quot; dígitos&quot;),	redo LOOP if /\G\d+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>place your modifications in the Public Domain or otherwise make them
Freely Available, such as by posting said modifications to Usenet or an
equivalent medium, or placing the modifications on a major archive site
such as uunet.uu.net, or by allowing the Copyright Holder to include
your modifications in the Standard Version of the Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>coloque sus modificaciones en el Dominio Público o de otra manera hacerlos de Libre Disposición, o mediante la publicación de dichas modificaciones en Usenet o un medio equivalente, o la colocación de las modificaciones en sitios importantes como uunet.uu.net, o permitiendo que el Titular del Copyright incluya las modificaciones en la Versión Estándar del Paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class implementing a scalar should have the following methods:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una clase que implementa un escalar debe tener los siguientes métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolating it in a list
has no effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Interpolarla en una lista no tiene ningún efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getservbyport PORT,PROTO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getservbyport PUERTO,PROTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close $in or die &quot;$in: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T225729Z" changeid="zipf">
        <seg>close $entrada or die &quot;$entrada: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perljp		Perl for Japanese (in EUC-JP)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perljp		Perl para Japones (en EUC-JP)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/Login: $foo/Login: $bar/; # run-time pattern</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/Login: $foo/Login: $bar/;         # patrón en tiempo de ejecución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**                      &lt; &gt; &lt;= &gt;=  lt gt le ge   pm.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>**                      &lt; &gt; &lt;= &gt;=  lt gt le ge   pm.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**=    +=    *=    &amp;=    &lt;&lt;=    &amp;&amp;=
           -=    /=    |=    &gt;&gt;=    ||=
           .=    %=    ^=           //=
                 x=</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054133Z" changeid="explorer">
        <seg>**=    +=    *=    &amp;=    &lt;&lt;=    &amp;&amp;=
           -=    /=    |=    &gt;&gt;=    ||=
           .=    %=    ^=           //=
                 x=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endprotoent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endprotoent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which lasts until the end of that BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>que durará hasta el final de ese BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=~ !~                                            perldoc.com</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=~ !~                                            perldoc.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># pack little-endian 16- and 32-bit signed integers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># empaqueta 16 y 32-bit enteros con signo, en little-endian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces the output 'h:i :t:h:e:r:e!'.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce la salida 'h:o:l:a :p:o:r :a:q:u:i!'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlipc&gt; for more on signal handling.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc&gt; para más información sobre el manejo de señales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 111631</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 111631</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length of ARRAY increases by the length of
LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La longitud de ARRAY se incrementa por la longitud de LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	-&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	-&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The notation is C&lt;&lt; (?&lt;name&gt;...) &gt;&gt; to declare and C&lt;&lt; \k&lt;name&gt; &gt;&gt;
to reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La notación es C&lt;&lt; (?&lt;nombre&gt;...) &gt;&gt; para declararlo y C&lt;&lt; \k&lt;nombre&gt; &gt;&gt; para referirse a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in short:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T225811Z" changeid="zipf">
        <seg>Se incluye a continuación un resumen:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're trying to do variable interpolation, it's definitely better
to use the glob() function, because the older notation can cause people
to become confused with the indirect filehandle notation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está tratando de hacer interpolación de variables, sin duda es mejor utilizar la función glob(), porque la notación más antigua puede hacer que las personas se confundan con la notación de gestor de archivo indirecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checksumming the compressed output of one or more
rapidly changing operating system status programs is the usual method.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El método usual es la suma de control de la salida comprimida de uno o más programas, rápidamente cambiantes, de estado del sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($starty = $y = 7; $y &lt;= 12; $y++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053009Z" changeid="explorer">
        <seg>for ($starty = $y = 7; $y &lt;= 12; $y++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the builtin is not I&lt;overridable&gt; (such as
C&lt;qw//&gt;) or if its arguments cannot be adequately expressed by a prototype
(such as C&lt;system&gt;), prototype() returns C&lt;undef&gt;, because the builtin
does not really behave like a Perl function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la orden interna no es yo &lt;sobreescribible&gt; (como lo es C&lt;qw//&gt;) o si sus argumentos no pueden ser adecuadamente expresados por un prototipo (como C&lt;system&gt;), prototype() devuelve C&lt;undef&gt;, porque la orden interna en realidad no se comporta como una función de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is
another way to protect your filenames from interpretation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es otra manera de proteger los nombres de archivo de la interpretación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, 1.23 times ten to the
99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, 1.23 por diez elevado a 99 puede ser &quot;1.23e99&quot; o &quot;1.23e099&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may turn it off explicitly for particular
portions of code via the C&lt;no warnings&gt; pragma or the C&lt;$^W&gt; variable
if you must.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede desactivarla explícitamente en partes del código con el pragma C&lt;no warnings&gt; o con la variable C&lt;$^W&gt; si así lo desea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># line 200 &quot;bzzzt&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># line 200 &quot;bzzzt&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taken together, these features go a long way towards
making Perl's regular expressions more readable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En conjunto, estas características hacen un gran labor para conseguir que las expresiones regulares de Perl sean más legibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Punctuation&quot; arrays such as C&lt;@*&gt; are only
interpolated if the name is enclosed in braces C&lt;@{*}&gt;, but special
arrays C&lt;@_&gt;, C&lt;@+&gt;, and C&lt;@-&gt; are interpolated, even without braces.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los arrays de &quot;puntuación&quot; como C&lt;@*&gt; son solo interpolados si el nombre está encerrado entre llaves C&lt;@{*}&gt;, pero los arrays especiales C&lt;@_&gt;, C&lt;@+&gt;, y C&lt;@-&gt; son interpolados, incluso sin llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This always forces interpretation of the
LIST as a multivalued list, even if there is only a single scalar in
the list.)  Example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto siempre fuerza la interpretación de la LISTA como una lista multievaluada, incluso si sólo hay un único escalar en la lista). Ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not              (?:)  no capture       REGEX CHARCLASSES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>not              (?:)  no captura       REGEX CLASE CARÁCTER</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not necessarily all are available on your system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No necesariamente todos están disponibles en su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the delimiter chosen is a single quote, no interpolation is
done on either the PATTERN or the REPLACEMENT.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el delimitador elegido es una comilla simple, no se realiza ninguna interpolación, ni en el PATRÓN ni en el REEMPLAZO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $s = &quot;The black cat climbed the green tree&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $s = &quot;El gato negro subió el árbol verde&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%6s&gt;',  12;   # prints &quot;&lt;    12&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%6s&gt;',  12;   # imprime &quot;&lt;    12&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also no attention is paid to C&lt;\c\&gt; (multichar control char syntax) during
this search.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco se presta atención a C&lt;\c\&gt; (sintaxis multicarácter de control) durante esta búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3 - If a circular reference is found, we fall back to referential equality.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3 - Si se encuentra una referencia circular, regresamos a la igualdad referencial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They work much like quotes in the standard Unix shells:
double-quoted string literals are subject to backslash and variable
substitution; single-quoted strings are not (except for C&lt;\'&gt; and
C&lt;\\&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T001506Z" changeid="explorer">
        <seg>Funcionan de forma muy parecida a las comillas en las líneas de comandos Unix: literales de cadena entre comillas dobles están sujetos a la barra invertida y la sustitución de variables; cadenas entre comillas simples no lo están (a excepción de C&lt;\'&gt; y C&lt;\\&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($dev, $ino, undef, undef, $uid, $gid) = stat($file);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004232Z" changeid="explorer">
        <seg>($dev, $ino, undef, undef, $uid, $gid) = stat($archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($map{'red'}, $map{'blue'}, $map{'green'}) = (0x00f, 0x0f0, 0xf00);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($map{'rojo'}, $map{'azul'}, $map{'verde'}) = (0x00f, 0x0f0, 0xf00);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of the automatic
conversion of scalars, operations that return scalars don't need
to care (and in fact, cannot care) whether their caller is looking
for a string, a number, or a reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que la conversión de escalares es automática, las operaciones que los devuelven no necesitan tener en cuenta (y, de hecho, no pueden hacerlo), si quien ha hecho la petición está esperando una cadena, un número o una referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three principal virtues of a programmer are Laziness,
Impatience, and Hubris.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las tres principales virtudes de un programador son pereza, impaciencia e Hibris (desmesura u orgullo exagerado en uno mismo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In older versions of Perl, programmers
would insert curly brackets to force interpretation as a filename glob:
C&lt;&lt; &lt;${foo}&gt; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En versiones anteriores de Perl, los programadores insertaban llaves para forzar la interpretación como una expansión de nombre de archivo: C&lt;&lt; &lt;$foo{}&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shift(@a)           splice(@a,0,1)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shift(@a)           splice(@a,0,1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chown $uid, $gid, @filenames;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chown $uid, $gid, @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the C&lt;my&gt; variable may be C&lt;undef&gt;, any
previously assigned value, or possibly anything else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de la variable C&lt;my&gt; puede ser C&lt;undef&gt;, cualquier valor anteriormente asignado, o posiblemente, cualquier otra cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@harry  = qw(dog cat x Cain Abel);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@harry  = qw(dog cat x Cain Abel);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't open $FOO: $!&quot; unless open(FOO);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo abrir $FOO: $!&quot; unless open(FOO);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Care should be taken not
to cause line number collisions in code you'd like to debug later.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay que tener cuidado para no causar colisiones de números de línea en el código que pretenda depurar más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; should
be the only Pod code for file names, but as most Pod formatters render it
as italic, Unix and Windows paths with their slashes and backslashes may
be less readable, and better rendered with C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; debe ser el único código Pod para nombres de archivo, pero como la mayoría de los formateadores de Pod lo muestran en cursiva, los caminos Unix y Windows con sus barras y contrabarras pueden hacerlo menos legible, por lo que es mejor mostrarlo con C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;while&gt; and C&lt;until&gt; modifiers have the usual &quot;C&lt;while&gt; loop&quot;
semantics (conditional evaluated first), except when applied to a
C&lt;do&gt;-BLOCK (or to the deprecated C&lt;do&gt;-SUBROUTINE statement), in
which case the block executes once before the conditional is
evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013154Z" changeid="explorer">
        <seg>Los modificadores C&lt;while&gt; y C&lt;until&gt; tienen la usual semántica de los &quot;bucles C&lt;while&gt;&quot; (la condición se evalúa primero), excepto cuando se aplica a un bloque C&lt;do&gt; (o a la obsoleta instrucción subrutina C&lt;do&gt;), en cuyo caso el bloque se ejecuta una vez antes de sea evaluada la condición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another use for typeglobs is to pass filehandles into a function or
to create new filehandles.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otro uso para los typeglobs es pasar gestores de archivo en una función o para crear nuevos gestores de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means that if you want to use variables, you
must use an eval():</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que si quiere usar variables, debe usar eval():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That should probably be written more simply as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto, probablemente, se debe escribir más sencillamente como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wanted to have a $ref_to_AoA variable as a reference to an array,
you'd have to do something like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quería tener una variable $ref_to_AoA como una referencia a un array, tendrá que hacer algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;&quot;Terms and List Operators (Leftward)&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T190421Z" changeid="explorer">
        <seg>Véase también L&lt;&quot;Términos y Operadores de listas (por la izquierda)&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;cmp&quot; returns -1, 0, or 1 depending on whether the left
argument is stringwise less than, equal to, or greater than the right
argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;cmp&quot; devuelve -1, 0, o 1 dependiendo de si el argumento de la izquierda es alfanuméricamente menor, igual o mayor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;Text::Balanced&gt; module (from CPAN, and
starting from Perl 5.8 part of the standard distribution) is able
to do this properly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo C&lt;Text::Balanced&gt; (de CPAN, y a partir de Perl 5.8 parte de la distribución normal) es capaz de hacer esto correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String modifying combinations for
case and quoting such as C&lt;\Q&gt;, C&lt;\U&gt;, and C&lt;\E&gt; are not recognized.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Combinaciones de modificación de caracteres para cambios de tamaño de caja y entrecomillado, como C&lt;\Q&gt;, C&lt;\U&gt;, y C&lt;\E&gt;, no son reconocidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sleep($for_a_while);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sleep($por_un_rato);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Fraction		big, unlimited fractions like 9973 / 12967</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::Fraction           grandes, ilimitadas fracciones como 9973 / 12967</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
behaviour is the same as a C&lt;while&gt; loop conditional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comportamiento es el mismo que en la condición de un bucle C&lt;while&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub ordinal { unpack(&quot;W&quot;,$_[0]); } # same as ord()</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub ordinal { unpack(&quot;W&quot;,$_[0]); } # lo mismo que ord()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11516</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11516</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a side effect, calling values() resets the HASH or ARRAY's internal
iterator,
see L&lt;/each&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como efecto colateral, llamando a values() resetea el iterador interno del HASH o ARRAY (ver L&lt;/each&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus Perl returns true on success and false on failure, yet you can
still easily determine the actual value returned by the operating
system:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, Perl devuelve verdadero en éxito y falso en fallo, por lo que aún podemos determinar el valor actual devuelto por el sistema operativo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,30, 1) = 1   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,30, 1) = 1   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlos390		Perl notes for OS/390</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlos390		Notas para OS/390</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 2) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 2) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, Perl attempts to flush all files opened for
output before the exec, but this may not be supported on some platforms
(see L&lt;perlport&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de la versión v5.6.0, Perl intenta vaciar todos los archivos abiertos para salida antes de ejecutar exec, pero esto puede no estar soportado en algunas plataformas (ver L&lt;perlport&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function
implementing the C&lt;\L&gt; escape in double-quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la función interna que implementa el escapado C&lt;\L&gt; en las cadenas entre comillas dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inclusion of library modules is better done with the
C&lt;use&gt; and C&lt;require&gt; operators, which also do automatic error checking
and raise an exception if there's a problem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La inclusión de bibliotecas de módulos es mejor hacerla con los operadores C&lt;use&gt; y C&lt;require&gt;, que también hacen una comprobación automática de errores y generan una excepción si existe algún problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># open for input, reusing the fileno of $fd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># abrir para lectura, reutilizando el número de descriptor de $fd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sprintf FORMAT, LIST
X&lt;sprintf&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201152Z" changeid="explorer">
        <seg>=item sprintf FORMATO, LISTA
X&lt;sprintf&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl584delta	Perl changes in version 5.8.4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl584delta	Cambios en la versión 5.8.4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (101 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (101 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if
successful, or false if there is an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tiene éxito, o falso si hay un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OUTER: for my $wid (@ary1) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EXTERNO: for my $wid (@array1) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful for matching path names
that contain &quot;/&quot;, to avoid LTS (leaning toothpick syndrome).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es particularmente útil para hacer coincidir los nombres de ruta que contienen &quot;/&quot;, para evitar el &quot;síndrome del palillo de dientes&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbers don't need quotes around them:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233757Z" changeid="zipf">
        <seg>No es necesario escribir los números entre comillas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef *xyz;       # destroys $xyz, @xyz, %xyz, &amp;xyz, etc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef *xyz;       # destruye $xyz, @xyz, %xyz, &amp;xyz, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>flock($fh, LOCK_UN) or die &quot;Cannot unlock mailbox - $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>flock($fh, LOCK_UN) or die &quot;No puedo desbloquear el buzón - $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling binmode() normally flushes any
pending buffered output data (and perhaps pending input data) on the
handle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llamando a binmode(), normalmente vaciará cualquier dato pendiente que esté almacenado en la salida (y quizás datos pendientes a la entrada) del gestor de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, do not assume
anything about the returned string itself, or how many bytes in the
digest matter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, no asuma nada sobre la cadena devuelta, o que cuántos bytes ocupa el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $j ( 0 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052912Z" changeid="explorer">
        <seg>for $j ( 0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item FindBin</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item FindBin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl does, and
this replaces most structured uses of C&lt;goto&gt; in other languages.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl sí, y esto reemplaza a la mayor parte de los usos estructurados de C&lt;goto&gt; en otros lenguajes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print sort @george, 'to', @harry;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print sort @george, 'to', @harry;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not report bugs in microperl; fix the bugs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No informe de errores en microperl; corrija los errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.6x&gt;', 1;       # prints &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.6x&gt;', 1;       # imprime &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;\G&gt; assertion can be used to chain global matches (using
C&lt;m//g&gt;), as described in L&lt;perlop/&quot;Regexp Quote-Like Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La aserción C&lt;\G&gt; puede ser usada para encadenar coincidencias globales (usando C&lt;m//g&gt;), como se describe en L&lt;perlop/&quot;Operadores Regexp Entrecomillados&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll have to put a C&lt;local $_;&gt; before the loop if you want that
to happen.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tendrá que poner un C&lt;local $_;&gt; antes del bucle si quiere que sea así.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, you may need to set
C&lt;$|&gt; ($AUTOFLUSH in English) or call the C&lt;autoflush()&gt; method of
C&lt;IO::Handle&gt; on any open handles to avoid duplicate output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para estar seguros, puede necesitar poner C&lt;$|&gt; ($AUTOFLUSH en English) o llamar el método C&lt;autoflush()&gt; de C&lt;IO::Handle&gt; en cualquiera de los gestores de archivo abiertos para evitar duplicación de salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar value is interpreted as TRUE in the Boolean sense if it is not
the null string or the number 0 (or its string equivalent, &quot;0&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un valor escalar se interpreta como VERDADERO, en el sentido booleano, si no es la cadena nula ni el número 0 (ni su cadena equivalente &quot;0&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%10.6d&gt;', 1;    # prints &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%10.6d&gt;', 1;    # imprime &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EXISTS this, key</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EXISTS este, clave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 8, 1) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 8, 1) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;next&gt; command is like the C&lt;continue&gt; statement in C; it starts
the next iteration of the loop:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;next&gt; es como la instrucción C&lt;continue&gt; en C; comienza la siguiente iteración del bucle:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this
isn't the length of the array; it's the subscript of the last element,
which is a different value since there is ordinarily a 0th element.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, esto no es la longitud del array, sino el subíndice del último elemento, que es un valor distinto ya que, ordinariamente, hay un elemento número 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8 tests and 24 subtests skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>8 tests and 24 subtests skipped.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlreref		Perl regular expressions quick reference</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlreref		Referencia rápida de las expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>space   prefix non-negative number with a space</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>espacio prefija un número no negativo con un espacio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does not protect against
symbolic links in the file's path.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No protege contra enlaces simbólicos en la ruta del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.6x&gt;', 1;      # prints &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.6x&gt;', 1;      # imprime &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo . &quot; XXX '&quot; . (join $&quot;, @arr) . &quot;'&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054409Z" changeid="explorer">
        <seg>$foo . &quot; XXX '&quot; . (join $&quot;, @arr) . &quot;'&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Allen Smith &lt;easmith@beatrice.rutgers.edu&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003828Z" changeid="explorer">
        <seg>(Allen Smith &lt;easmith@beatrice.rutgers.edu&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next OUTER if $wid &gt; $jet;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next EXTERNO if $wid &gt; $jet;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0 dev      device number of filesystem</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0 dev      número de dispositivo del sistema de archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a time synchronization problem, the
NFS server and local machine will have different times.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay un problema de sincronización de tiempos, el servidor NFS y el equipo local tendrán tiempos diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shell wildcards,
pipes, and redirections will be honored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los comodines del intérprete, tuberías y redirecciones serán respetados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print scalar reverse;                       # Hello, world</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print scalar reverse;                       # Hola, mundo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the undefined value if the context is
looking for no value (void context).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor indefinido si el contexto está buscando por ningún valor (contexto void).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIST is omitted, C&lt;unlink&gt; uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LISTA se omite, C&lt;unlink&gt; utiliza C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The undefined version is the value that indicates that there is
no real value for something, such as when there was an error, or
at end of file, or when you refer to an uninitialized variable or
element of an array or hash.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004138Z" changeid="explorer">
        <seg>La versión indefinida es el valor que indica que no existe ningún valor real para algo, como cuando hubo un error, se alcanzó el fin de archivo, o cuando se hace referencia a una variable o un elemento de array o hash no inicializados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;abs&gt;, C&lt;atan2&gt;, C&lt;cos&gt;, C&lt;exp&gt;, C&lt;hex&gt;, C&lt;int&gt;, C&lt;log&gt;, C&lt;oct&gt;, C&lt;rand&gt;,
C&lt;sin&gt;, C&lt;sqrt&gt;, C&lt;srand&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200927Z" changeid="explorer">
        <seg>C&lt;abs&gt;, C&lt;atan2&gt;, C&lt;cos&gt;, C&lt;exp&gt;, C&lt;hex&gt;, C&lt;int&gt;, C&lt;log&gt;, C&lt;oct&gt;, C&lt;rand&gt;,
C&lt;sin&gt;, C&lt;sqrt&gt;, C&lt;srand&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item parsing regular expressions
X&lt;regexp, parse&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010512Z" changeid="explorer">
        <seg>=item analizando expresiones regulares
X&lt;regexp, parse&gt; X&lt;regexp, análisis&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure
that CLASSNAME is a true value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Asegúrese de que NOMBRECLASE es un valor verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return 0 unless @a == @b;  # same len?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return 0 unless @a == @b;  # ¿misma longitud?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp; s//WILMA $1 WILMA/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;&amp; s//WILMA $1 WILMA/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each
regexp tries to match where the previous one leaves off.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada regexp intenta coincidir donde la anterior lo dejó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;die&gt; instead,
which can be trapped by an C&lt;eval&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use en su lugar C&lt;die&gt;, que puede ser atrapado por un C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Language
historians will also note some vestiges of B&lt;csh&gt;, Pascal, and even
BASIC-PLUS.)  Expression syntax corresponds closely to C
expression syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Historiadores del lenguaje notarán algunos vestigios de B&lt;csh&gt;, Pascal, e incluso BASIC-PLUS). La sintaxis de las expresiones corresponden estrechamente con la sintaxis de las expresiones del C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mentioning a subroutine name for exists or defined
does not count as declaring it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mencionar el nombre de una subrutina para saber si existe o está definida no cuenta como si fuera su declaración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item log</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item log</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($user = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($usuario = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval '$x';      # CASE 3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval '$x';      # CASO 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if an initialized scalar variable is used instead the
result is different: C&lt;my $fh='zzz'; open($fh, ...)&gt; is equivalent
to C&lt;open( *{'zzz'}, ...)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T235528Z" changeid="explorer">
        <seg>Tenga en cuenta que si se usa una variable escalar ya inicializada, el resultado es diferente: C&lt;my $fh='zzz'; open($fh, ...)&gt; es equivalente a C&lt;open( *{'zzz'}, ...)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=cut</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=cut</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&lt;&lt;'EOF'&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item C&lt;&lt;&lt;'EOF'&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following
scans a list of files (C&lt;@files&gt;) for a list of words (C&lt;@words&gt;), and prints
out the names of those files that contain a match:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo siguiente examina una lista de archivos (C&lt;@archivos&gt;) por una lista de palabras (C&lt;@palabras&gt;), e imprime los nombres de los archivos que contienen una coincidencia:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tr/SEARCHLIST/REPLACEMENTLIST/cds
X&lt;tr&gt; X&lt;y&gt; X&lt;transliterate&gt; X&lt;/c&gt; X&lt;/d&gt; X&lt;/s&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010353Z" changeid="explorer">
        <seg>=item tr/LISTA_BÚSQUEDA/LISTA_REEMPLAZO/cds
X&lt;tr&gt; X&lt;y&gt; X&lt;transliterate&gt; X&lt;/c&gt; X&lt;/d&gt; X&lt;/s&gt; X&lt;transliterar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
I&lt;really&gt; want to follow an C&lt;exec&gt; with some other statement, you
can use one of these styles to avoid the warning:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012459Z" changeid="explorer">
        <seg>Si I&lt;verdaderamente&gt; quiere continuar un C&lt;exec&gt; con otra instrucción, puede usar algunas de estas formas para evitar el aviso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $tail   = substr $s, -4;        # tree</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $tail   = substr $s, -5;        # verde</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item the replacement of C&lt;s///&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item el reemplazo de C&lt;s///&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no changes incompatible with 5.8.2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay cambios incompatibles con 5.8.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For three or more arguments if MODE is C&lt;'|-'&gt;, the filename is
interpreted as a command to which output is to be piped, and if MODE
is C&lt;'-|'&gt;, the filename is interpreted as a command that pipes
output to us.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para tres o más argumentos, cuando MODO es C&lt;'|-'&gt;, el nombre del archivo se interpreta como un comando cuya salida va a ser entubada, y si MODO es &lt;'-|'&gt;, el nombre del archivo es interpretado como un comando que entuba la salida hacia nosotros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;long doubles\n&quot; if $Config{d_longdbl} eq &quot;define&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;long doubles\n&quot; if $Config{d_longdbl} eq &quot;define&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># short 12, two zero bytes padding, long 34</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un 12 short, dos bytes cero de relleno, un 34 long</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item my TYPE EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item my TIPO EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,23, 1) = 1   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,23, 1) = 1   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C-style Logical Defined-Or
X&lt;//&gt; X&lt;operator, logical, defined-or&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235624Z" changeid="explorer">
        <seg>=head2 Defined-Or lógico al estilo del C
X&lt;//&gt; X&lt;operator, logical, defined-or&gt; X&lt;operador, lógico, defined-or&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = $ok ? @b : @c;  # get an array</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053849Z" changeid="explorer">
        <seg>@a = $ok ? @b : @c;  # obtiene un array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print v102.111.111;       # prints &quot;foo&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print v102.111.111;       # imprime &quot;foo&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to write:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto le permite escribir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using this operator can lead to programs that are difficult to port,
because the shell commands called vary between systems, and may in
fact not be present at all.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando este operador puede dar lugar a programas que son difíciles de portar, porque el shell de comandos varían entre sistemas, y de hecho no pueden estar presentes en todos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[aeiou]             matches a single character in the given set</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121720Z" changeid="zipf">
        <seg>[aeiou]             un solo carácter del conjunto especificado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other functions do not, except accidentally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otras funciones no, excepto accidentalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful to check that a child process is still
alive (even if only as a zombie) and hasn't changed its UID.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para comprobar que un proceso hijo aún está vivo (aunque sólo sea como un zombie) y no ha cambiado su UID.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This usage is vaguely deprecated, which means it just might possibly
be removed in some distant future version of Perl, perhaps somewhere
around the year 2168.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este uso es vagamente obsoleto, lo cual significa que es muy posible que se podría eliminar en una futura lejana versión de Perl, tal vez en algún momento alrededor del año 2168.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of Perl
5.10, it even has a case/switch statement (spelled C&lt;given&gt;/C&lt;when&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225105Z" changeid="explorer">
        <seg>En Perl 5.10, incluso ofrece una instrucción case/switch (llamada C&lt;given&gt;/C&lt;when&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removes the elements designated by OFFSET and LENGTH from an array, and
replaces them with the elements of LIST, if any.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elimina los elementos designados por DESPLAZAMIENTO y LONGITUD de un array, y los sustituye por los elementos de LISTA, si los hubiere.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>l  A signed long (32-bit) value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>l  Un valor de un largo con signo (32 bit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlxstut		Perl XS tutorial</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlxstut		Seminario sobre XS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getnetbyname NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getnetbyname NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>update to Unicode 3.1.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>actualización a Unicode 3.1.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next if /^\s*#/;  # skip comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next if /^\s*#/;  # salta los comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># bytes because the U at the start of the format caused a switch to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># porque la U al principio del formato causó un cambio a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\cK		control char          (example: VT)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\cK		car. control          (ejemplo: VT)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;/&gt; is
equivalent to C&lt;\/&gt; inside a regular expression, this does not
matter unless the delimiter happens to be character special to the
RE engine, such as in C&lt;s*foo*bar*&gt;, C&lt;m[foo]&gt;, or C&lt;?foo?&gt;; or an
alphanumeric char, as in:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que C&lt;/&gt; es equivalente a C&lt;\/&gt; dentro de una expresión regular, esto no importará a menos que el delimitador pase a ser un carácter especial para el motor de RE, como en C&lt;s*foo*bar*&gt;, C&lt;m[foo]&gt;, o C&lt;?foo?&gt;; o un carácter alfanumérico, como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl588delta	Perl changes in version 5.8.8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl588delta	Cambios en la versión 5.8.8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[^aeiou]            matches a single character outside the given set</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T221909Z" changeid="zipf">
        <seg>[^aeiou]            un solo carácter no perteneciente al conjunto especificado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; =&gt; &gt;&gt; operator is helpful in documenting the correspondence
between keys and values in hashes, and other paired elements in lists.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador C&lt;&lt; =&gt; &gt;&gt;  es útil para documentar la correspondencia entre claves y valores de hashes, y otros elementos vinculados en listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is supported, it
usually encodes the disk quota.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está soportada, usualmente codifica la cuota de disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A categorized list of modules is
also available from CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225603Z" changeid="explorer">
        <seg>En CPAN también está disponible una lista de módulos clasificados por categorías.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>++     Match 1 or more times and give nothing back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>++     Coincide 1 o más veces y no devuelve nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intent is to propagate
bug fixes out to stable releases more rapidly and make upgrading stable
releases less of an upheaval.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La intención es propagar la corrección de errores a versiones estables con mayor rapidez y hacer esas actualizaciones menos problemáticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To signal the semaphore, replace C&lt;-1&gt; with C&lt;1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para señalizar el el semáforo, reemplace C&lt;-1&gt; con C&lt;1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not an integer&quot;       unless /^[+-]?\d+$/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es un entero&quot;      unless /^[+-]?\d+$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregation of this Package with a commercial distribution is always
permitted provided that the use of this Package is embedded; that is,
when no overt attempt is made to make this Package's interfaces visible
to the end user of the commercial distribution.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La agregación de este Paquete con una distribución comercial siempre está permitida siempre que el uso de este Paquete esté integrado; es decir, cuando no se haga un evidente intento de hacer las interfaces del Paquete visibles para el usuario final de la distribución comercial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, if any element of LIST is NOT an
lvalue, any attempt to modify that element will fail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recíprocamente, si cualquier elemento de LISTA NO es un I&lt;lvalue&gt;, cualquier intento de modificar este elemento fallará (provocará un error).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use feature &quot;switch&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use feature &quot;switch&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $end    = substr $s, 14;        # climbed the green tree</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $end    = substr $s, 14;        # subió el árbol verde</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12180</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12180</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (101 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (101 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$$x++;          # CASE 6</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$$x++;          # CASO 6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line \s+ (\d+)   \s*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>line \s+ (\d+)   \s*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rand (10) * 20;	# (rand 10) * 20</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>rand (10) * 20;	# (rand 10) * 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $fh;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return $fh;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In a script passed to Perl via B&lt;-e&gt; switches, each
B&lt;-e&gt; is counted as one line.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En un script pasado a Perl a través de opciones B&lt;-e&gt;, cada B&lt;-e&gt; cuenta como una sola línea).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regex   Array     array grep               grep /$a/, @$b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Regex       Array      grep array                       grep /$a/, @$b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 2) = 1   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 2) = 1   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>j   A Perl internal signed integer value (IV).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>j   Un valor Perl interno entero con signo (IV).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They I&lt;are&gt; reserved with respect to labels and filehandles,
however, which don't have an initial special character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sí I&lt;están&gt; reservadas, sin embargo, para las etiquetas y gestores de archivo, ya que éstos no tienen un carácter especial al comienzo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>g	Match globally, i.e., find all occurrences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>g	Coincidencia global, es decir, busca todas las ocurrencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;require $class&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;require $clase&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/(\$\w+)/$1/eeg;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/(\$\w+)/$1/eeg;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash    CodeRef   sub truth for each key[1] !grep { !$b-&gt;($_) } keys %$a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hash        RefCódigo  sub verdad por cada clave[1]     !grep { !$b-&gt;($_) } keys %$a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.5s&gt;', &quot;truncated&quot;;   # prints &quot;&lt;trunc&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.5s&gt;', &quot;truncado&quot;;   # imprime &quot;&lt;trunc&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for LIST</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the VERSION argument is present between Module and LIST, then the
C&lt;use&gt; will call the VERSION method in class Module with the given
version as an argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el argumento VERSIÓN está presente entre el Módulo y la LISTA, entonces C&lt;use&gt; llamará al método VERSIÓN en la clase Módulo con la versión dada como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlreftut&gt;, L&lt;perlref&gt;, L&lt;perldsc&gt;, and L&lt;perllol&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;perlreftut&gt;, L&lt;perlref&gt;, L&lt;perldsc&gt; y L&lt;perllol&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$'&gt; returns everything
after the matched string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$'&gt; devuelve todo lo posterior a la cadena coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\f		form feed       (FF)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002753Z" changeid="explorer">
        <seg>\f		avance de página (FF)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exists &amp;sub();  # Error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exists &amp;sub();  # Error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
defined version is just a string of length zero, such as C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La versión definida es sólo una cadena de longitud cero, tal como C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically it would be the first 
declaration in a file included by C&lt;require&gt; or C&lt;use&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente será la primera declaración en un archivo incluido por medio de un C&lt;require&gt; o C&lt;use&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read all about them in L&lt;perlrequick&gt;,
L&lt;perlretut&gt;, and L&lt;perlre&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225512Z" changeid="explorer">
        <seg>Encontrará más información en L&lt;perlrequick&gt;, L&lt;perlretut&gt; y L&lt;perlre&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forcing big- or little-endian byte-order on floating-point values for
data exchange can work only if all platforms use the same
binary representation such as IEEE floating-point.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Forzar una ordenación de bytes en valores de punto flotante para el intercambio de datos sólo puede funcionar si todas las plataformas utilizan la misma representación binaria de punto flotante IEEE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@ary) { s/foo/bar/ }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@array) { s/foo/bar/ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failed 3/811 test scripts, 99.63% okay.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005044Z" changeid="explorer">
        <seg>Fallaron 3/811 de las pruebas, 99,63% bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eight (the high bit) is set on each byte except the last.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192159Z" changeid="explorer">
        <seg>octavo (el bit más alto) es puesto en cada byte excepto el último.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all of these examples, Perl
will assume you meant defined-or.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En todos estos ejemplos, Perl asumirá que significaba definido-o.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return list's length always matches that of
the argument list: deleting non-existent elements returns the undefined value
in their corresponding positions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La longitud de la lista devuelta siempre coincide con el de la lista de argumentos: eliminar elementos no existentes devuelve el valor indefinido en sus posiciones correspondientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another useful shortcut is that, if you use a literal array
or hash as the argument to C&lt;given&gt;, it is turned into a
reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otro método abreviado útil es que, si usa un array o hash literal, como el argumento a C&lt;given&gt;, se convierte en una referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sentence =~ s{$substring}{big bad wolf};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012552Z" changeid="explorer">
        <seg>$instruccion =~ s{$subcadena}{gran lobo malo};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;foreach&gt; loop iterates over a normal list value and sets the
variable VAR to be each element of the list in turn.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bucle C&lt;foreach&gt; itera sobre los valores de una lista normal y pone la variable VAR a cada uno de los elementos de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>v  An unsigned short (16-bit) in &quot;VAX&quot; (little-endian) order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>v  Un corto sin signo (16 bit) en orden &quot;VAX&quot; (little-endian).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl56delta 	Perl changes in version 5.6</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl56delta 	Cambios en la versión 5.6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;AnyDBM_File&gt; for a more general description of the pros and
cons of the various dbm approaches, as well as L&lt;DB_File&gt; for a particularly
rich implementation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;AnyDBM_File&gt; para una descripción más general de los pros y contras de las distintas formas dbm, así como L&lt;DB_File&gt; para ver una implementación particularmente rica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 1) = 1   ==          2 01000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 1) = 1   ==          2 01000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
EXPR is omitted, C&lt;$_&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la EXPR se omite, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current process group for the specified PID.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el actual grupo del proceso especificado por el PID.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;eval BLOCK&gt; does I&lt;not&gt; count as a loop, so the loop control statements
C&lt;next&gt;, C&lt;last&gt;, or C&lt;redo&gt; cannot be used to leave or restart the block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012040Z" changeid="explorer">
        <seg>C&lt;eval BLOQUE&gt; I&lt;no&gt; cuenta como un bucle, así que las instrucciones de control de bucle C&lt;next&gt;, C&lt;last&gt;, o C&lt;redo&gt; no pueden ser usadas para dejar o reiniciar el bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sysseek FILEHANDLE,POSITION,WHENCE
X&lt;sysseek&gt; X&lt;lseek&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204337Z" changeid="explorer">
        <seg>=item sysseek GESTOR_ARCHIVO,POSICIÓN,DESDEDÓNDE
X&lt;sysseek&gt; X&lt;lseek&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The status value of the command is
returned in C&lt;$?&gt; (see L&lt;perlvar&gt; for the interpretation of C&lt;$?&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de estado del comando se devuelve en C&lt;$?&gt; (Véase L&lt;perlvar&gt; para la interpretación del valor de C&lt;$?&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an empty list, C&lt;undef&gt;, or nothing that matches the first 3 values above
is returned, then C&lt;require&gt; looks at the remaining elements of @INC.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se devuelve una lista vacía, C&lt;undef&gt;, o nada que coincida con los tres primeros valores anteriores, entonces C&lt;require&gt; mira en los elementos restantes de @INC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl585delta	Perl changes in version 5.8.5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl585delta	Cambios en la versión 5.8.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a simple but
sufficient example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un simple pero útil ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = @tmp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$i] = @tmp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the starting delimiter is an unpaired character like C&lt;/&gt; or a closing
punctuation, the ending delimiter is same as the starting delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el delimitador de partida es un carácter no emparejado, como C&lt;/&gt; o un carácter de puntuación de cierre, el delimitador de cierre es el mismo que el delimitador de inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make LDLOADLIBS=&quot;-lnet&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make LDLOADLIBS=&quot;-lnet&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::String		treat string sequences like numbers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::String             trata secuencias de cadenas como números</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Perl 4, Perl 5 treats backticks
as normal delimiters; the replacement text is not evaluated as a command.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de Perl 4, Perl 5 trata las comillas simples invertidas como delimitadores normales; el texto de reemplazo no es evaluado como un comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, C&lt;times&gt; returns C&lt;$user&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, C&lt;times&gt; devuelve C&lt;$usuario&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reference to a subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una referencia a una subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/
         (Y)            # buffer 1
         (              # buffer 2
            (X)         # buffer 3
            \g{-1}      # backref to buffer 3
            \g{-3}      # backref to buffer 1
         )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230100Z" changeid="explorer">
        <seg>/
         (Y)            # buffer 1
         (              # buffer 2
            (X)         # buffer 3
            \g{-1}      # refiere a buffer 3
            \g{-3}      # refiere a buffer 1
         )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's easy to grow to a rather large data space this
way, so use with care.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esta manera, es fácil que el espacio ocupado por los datos crezca a un gran tamaño, así que tenga cuidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 1) = 1   ==        128 00000001000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 1) = 1   ==        128 00000001000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that works, good.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si esto funciona, bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TIEHANDLE classname, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TIEHANDLE clase, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?:\s(&quot;?)([^&quot;]+)\2)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(?:\s(&quot;?)([^&quot;]+)\2)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># ...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BUILD
         -  Non-threaded Case
         -  Threaded Case
         -  Testing
         -  Installing the built perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054848Z" changeid="explorer">
        <seg>COMPILACIÓN
         -  Caso de no enhebrado
         -  Caso de enhebrado
         -  Pruebas
         -  Instalando el perl compilado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is unspecified, output goes to the current default output
channel, which starts out as STDOUT but may be changed by the
C&lt;select&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T212002Z" changeid="explorer">
        <seg>Si GESTOR_ARCHIVO no está especificado, la salida va al canal predeterminado de salida actual, que suele ser STDOUT, pero puede ser modificado por el operador C&lt;select&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unquoted identifier works like double quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un identificador sin comillas funciona igual que las comillas dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tell FILEHANDLE
X&lt;tell&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204707Z" changeid="explorer">
        <seg>=item tell GESTOR_ARCHIVO
X&lt;tell&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This distinction is determined on syntactic
grounds alone.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta distinción está determinada sólo por razones sintácticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setpgrp PID,PGRP
X&lt;setpgrp&gt; X&lt;group&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200451Z" changeid="explorer">
        <seg>=item setpgrp PID,PGRP
X&lt;setpgrp&gt; X&lt;group&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forces EXPR to be interpreted in scalar context and returns the value
of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fuerza EXPR a ser interpretada en contexto escalar y devuelve el valor de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rand</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item rand</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close STDOUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close STDOUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(On some machines,
unfortunately, the elapsed time may be up to one second less or more
than you specified because of how seconds are counted, and process
scheduling may delay the delivery of the signal even further.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En algunas máquinas, desafortunadamente, el tiempo transcurrido puede ser hasta un segundo más o menos del especificado debido a cómo los segundos son contados, y la planificación de procesos pueden retrasar la entrega de la señal incluso más).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;% +d&gt;', 12;   # prints &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;% +d&gt;', 12;   # imprime &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%F    a synonym for %f</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%F    un sinónimo para %f</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form is typically
used to trap exceptions more efficiently than the first (see below), while
also providing the benefit of checking the code within BLOCK at compile
time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma es típicamente usada para atrapar excepciones más eficientemente que la primera forma (ver arriba), mientras que también provee del beneficio de comprobar el código dentro del BLOQUE en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item log EXPR
X&lt;log&gt; X&lt;logarithm&gt; X&lt;e&gt; X&lt;ln&gt; X&lt;base&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191239Z" changeid="explorer">
        <seg>=item log EXPR
X&lt;log&gt; X&lt;logarithm&gt; X&lt;e&gt; X&lt;ln&gt; X&lt;base&gt; X&lt;logaritmo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
transpired that although the implementation introduced in 5.8.1 was source
compatible with 5.8.0, it was not binary compatible in certain cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se constató que, aunque la implementación fue introducida en 5.8.1, compatible a nivel de código fuente con 5.8.0, no era compatible a nivel binario, en ciertos casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># and, in case someone appended while we were waiting...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># y, en caso de que alguien haya añadido algo mientras esperábamos...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of overflowing the range of the integers is undefined
because it is undefined also in C.  In other words, using 32-bit
integers, C&lt;&lt; 1 &lt;&lt; 32 &gt;&gt; is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resultado del desbordamiento del rango de los números enteros no está definido, ya que tampoco está definido en C. En otras palabras, usando enteros de 32 bits, C&lt;&lt; 1 &lt;&lt; 32 &gt;&gt; no está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's also a negated version, for the same reason we have C&lt;unless&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225145Z" changeid="explorer">
        <seg>Existe también una versión negada, por la misma razón que existe C&lt;unless&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SCALAR will be grown or
shrunk so that the last byte actually read is the last byte of the
scalar after the read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESCALAR crecerá o se reducirá de manera que el último byte leído sea el último byte del escalar después de la lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The range operator is useful for writing
C&lt;foreach (1..10)&gt; loops and for doing slice operations on arrays.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador rango es útil para escribir bucles C&lt;foreach (1..10)&gt; y para hacer operaciones de troceado en los arrays.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, only double quotes &quot;interpolate&quot; variables and special
characters such as newlines (C&lt;\n&gt;):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224749Z" changeid="explorer">
        <seg>Sin embargo las variables y los caracteres especiales, como los caracteres de nueva línea (C&lt;\n&gt;), solo se &quot;interpolan&quot; con comillas dobles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\w        [3]  Match a &quot;word&quot; character (alphanumeric plus &quot;_&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223618Z" changeid="explorer">
        <seg>\w	 [3]  Coincide con un carácter de &quot;palabra&quot; (alfanumérico más &quot;_&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a list consisting of all the values of the named hash, or the values
of an array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una lista consistente de todas las claves del hash indicado, o los índices de un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The short-circuit behavior is identical.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento abreviado es idéntico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the second form, the code within the BLOCK is parsed only once--at the
same time the code surrounding the C&lt;eval&gt; itself was parsed--and executed
within the context of the current Perl program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la segunda forma, el código dentro del BLOQUE es interpretado sólo una vez -al mismo tiempo que el código que rodea al mismo C&lt;eval&gt; es interpretado- y ejecutado dentro del contexto del actual programa Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>''	 q{}	      Literal		  no</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>''	 q{}	      Literal		  no</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It behaves just as C&lt;import&gt; does with VERSION, an omitted or empty LIST, 
or no unimport method being found.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se comporta igual que C&lt;import&gt; lo hace con VERSIÓN, con una lista vacía o no, o ningún método unimport será encontrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print hex 'aF';   # same</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print hex 'aF';   # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># if the open fails, output is discarded</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># si open falla, la salida es descartada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The error, if any, is still returned in C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El error, si está, es devuelto en C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;ab&quot; =~ /a(.*)b/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;ab&quot; =~ /a(.*)b/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq4		Data Manipulation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq4		Manipulación de datos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$nread = sysread SOCKET, $buffer, $size;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$nread = sysread SOCKET, $buffer, $largo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here be dragons.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de aquí, dragones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly during unpacking, &quot;extra&quot; bits are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo durante el desempaquetado, los bits &quot;extra&quot; se ignoran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item keys HASH
X&lt;keys&gt; X&lt;key&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174124Z" changeid="explorer">
        <seg>=item keys HASH
X&lt;keys&gt; X&lt;key&gt; X&lt;clave&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl
5.8.2 the ordering can be different even between different runs of Perl
for security reasons (see L&lt;perlsec/&quot;Algorithmic Complexity Attacks&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde Perl 5.8.2 la ordenación puede ser diferente incluso entre diferentes ejecuciones de Perl por razones de seguridad (ver L&lt;perlsec/&quot;Ataques por Complejidad Algorítmica&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A line-oriented form of quoting is based on the shell &quot;here-document&quot;
syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un formato de entrecomillado orientado a líneas basado en la sintaxis shell &quot;here-document&quot; (este-documento, documento incrustado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;getsockopt TCP_NODELAY: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;getsockopt TCP_NODELAY: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @transformed = map { ... } @input;  # syntax error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @transformado = map { ... } @entrada;  # error de sintaxis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in C&lt;8
- 4 - 2&gt;, subtraction is left associative so Perl evaluates the
expression left to right.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, en C&lt;8 - 4 - 2&gt;, la resta es asociativa a la izquierda así que Perl evalúa la expresión de izquierda a derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator precedence and associativity work in Perl more or less like
they do in mathematics.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Precedencia de operadores y asociatividad funciona en Perl más o menos como se hace en matemáticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (@animals &lt; 5) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234142Z" changeid="zipf">
        <seg>if (@animales &lt; 5) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13684</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13684</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($i = 1; $i &lt; 10; $i++) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ($i = 1; $i &lt; 10; $i++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the PATTERN is delimited by bracketing quotes, the REPLACEMENT has
its own pair of quotes, which may or may not be bracketing quotes, e.g.,
C&lt;s(foo)(bar)&gt; or C&lt;&lt; s&lt;foo&gt;/bar/ &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el PATRÓN está delimitado por paréntesis, corchetes, llaves, el REEMPLAZO tiene su propio par de delimitadores, que puede o no estar encerrado entre los mismos delimitadores, por ejemplo, C&lt;s(foo)(bar)&gt; o C&lt;&lt; s&lt;foo&gt;/bar/ &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;%&gt; X&lt;remainder&gt; X&lt;modulo&gt; X&lt;mod&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;%&gt; X&lt;remainder&gt; X&lt;modulo&gt; X&lt;mod&gt; X&lt;módulo&gt; X&lt;resto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two control characters ^D and ^Z, and the tokens __END__ and __DATA__
may be used to indicate the logical end of the script before the actual
end of file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004158Z" changeid="explorer">
        <seg>Los dos caracteres de control ^D y ^Z, y los símbolos __END__ y __DATA__ pueden ser usados para indicar el fin lógico del programa antes del final real del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If multiple transliterations are given for a character, only the
first one is used:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se dan múltiples transliteraciones para un carácter, sólo se utiliza el primero:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item y/SEARCHLIST/REPLACEMENTLIST/cds</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item y/LISTA_BÚSQUEDA/LISTA_REEMPLAZO/cds</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any additional ld flags (NOT including libraries)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Any additional ld flags (NOT including libraries)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.cpan.org/       the Comprehensive Perl Archive</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://www.cpan.org/       Archivo Completo de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>assigns the entire list value to array @foo, but</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>asigna la lista completa al array @foo, pero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%c    a character with the given number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%c    un carácter del numero indicado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precompilation of the pattern into an internal representation at
the moment of qr() avoids a need to recompile the pattern every
time a match C&lt;/$pat/&gt; is attempted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La precompilación del patrón en una representación interna en el momento de qr() evita la necesidad de recompilar el patrón cada vez que una coincidencia de C&lt;/$pat/&gt; sea intentada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be pedantic, the comparison is actually C&lt;int(EXPR) == int(EXPR)&gt;,
but that is only an issue if you use a floating point expression; when
implicitly using C&lt;$.&gt; as described in the previous paragraph, the
comparison is C&lt;int(EXPR) == int($.)&gt; which is only an issue when C&lt;$.&gt;
is set to a floating point value and you are not reading from a file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ser pedante, la comparación es en realidad C&lt;int(EXPR) == int(EXPR)&gt; , pero esto sólo es un problema si utiliza una expresión de punto flotante; cuando, implícitamente, está usando C&lt;$.&gt; como se describe en el párrafo anterior, la comparación es C&lt;int(EXPR) == int($.)&gt; que sólo es un problema cuando C$.&gt; se establece en un valor de punto flotante y usted no está leyendo de un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 DIAGNOSTICS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 DIAGNÓSTICO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @executables;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @ejecutables;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;redo&gt; inside such a block will effectively
turn it into a looping construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto C&lt;redo&gt; dentro de un bloque lo convertirá de forma efectiva en una construcción de bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub process {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub procesa {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $thingie = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $cosita = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldbmfilter	Perl DBM filters</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldbmfilter	Filtros DBM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>? &quot;Error closing sort pipe: $!&quot;
                   : &quot;Exit status $?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043755Z" changeid="explorer">
        <seg>? &quot;Error cerrando la tubería con sort: $!&quot;
                   : &quot;Estado de salida $?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
unimplemented, raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no está implementada, lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bar = pack('s@4l', 12, 34);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bar = pack('s@4l', 12, 34);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With flock() support:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con soporte de flock():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not really a function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No es realmente una función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also can't be used to go into a
construct that is optimized away.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco puede ser usada para ir a una construcción que ha sido optimizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>n  An unsigned short (16-bit) in &quot;network&quot; (big-endian) order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>n  Un corto sin signo (16 bit) en orden &quot;red&quot; (big-endian).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a += ($a % 2) ? 10 : 2;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054128Z" changeid="explorer">
        <seg>$a += ($a % 2) ? 10 : 2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly,
interpolating an array with no elements is the same as if no
array had been interpolated at that point.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, la interpolación de un array sin elementos es lo mismo que si no se hubiera interpolado ningún array en ese punto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, C&lt;glob(&quot;*.c *.h&quot;)&gt; 
matches all files with a F&lt;.c&gt; or F&lt;.h&gt; extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En este sentido, C&lt;glob(&quot;*.c *.h&quot;)&gt; coincide con todos los archivos con una extensión F&lt;.c&gt; o F&lt;.h&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It cannot short circuit, of course.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede cortocircuitar, por supuesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232557Z" changeid="explorer">
        <seg>print</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the starting delimiter is an opening punctuation
(that is C&lt;(&gt;, C&lt;[&gt;, C&lt;{&gt;, or C&lt;&lt; &lt; &gt;&gt;), the ending delimiter is the
corresponding closing punctuation (that is C&lt;)&gt;, C&lt;]&gt;, C&lt;}&gt;, or C&lt;&lt; &gt; &gt;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el delimitador inicial es un carácter de puntuación (uno como C&lt;(&gt;, C&lt;[&gt;, C&lt;{&gt;, o C&lt;&lt; &lt; &gt;&gt;), el delimitador final es el correspondiente carácter de puntuación, de cierre (uno como C&lt;)&gt;, C&lt;]&gt;, C&lt;}&gt;, o C&lt;&lt; &gt; &gt;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In scalar context, returns the number of keys or indices.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En contexto escalar, devuelve el número de claves o índices).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s2p	sed to perl translator</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s2p	traductos sed a perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item quotemeta EXPR
X&lt;quotemeta&gt; X&lt;metacharacter&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192827Z" changeid="explorer">
        <seg>=item quotemeta EXPR
X&lt;quotemeta&gt; X&lt;metacharacter&gt; X&lt;metacarácter&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent
confusion, you may wish to avoid such package names as well.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para evitar confusiones, evite nombres de paquete también de esta manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$class = 'Foo::Bar';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$clase = 'Foo::Bar';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are documented in L&lt;perlvar&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T205451Z" changeid="zipf">
        <seg>Se describen en L&lt;perlvar&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr/a-zA-Z/ /cs;		# change non-alphas to single space</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr/a-zA-Z/ /cs;		# cambia los caracteres no alfabéticos por un solo espacio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>range operator (creates a list of numbers)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235419Z" changeid="zipf">
        <seg>operador de intervalo (crea una lista de números)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Internals and C Language Interface</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Interiores e interfaz con el lenguaje C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Camel Book, officially known as I&lt;Programming Perl, Third Edition&gt;,
by Larry Wall et al, is the definitive reference work covering nearly
all of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T233739Z" changeid="explorer">
        <seg>El libro del Camello, oficialmente conocido como I&lt;Programando en Perl, Tercera Edición&gt;, de Larry Wall y otros, es la referencia definitiva sobre casi todo el lenguaje Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Math::BigInt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Math::BigInt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar represents a single value:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230800Z" changeid="zipf">
        <seg>Un escalar representa un solo valor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also the source of a useful idiom for executing a function or
performing an operation in list context and then counting the number of
return values, by assigning to an empty list and then using that
assignment in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es también el origen de un modismo muy útil para ejecutar una función o realizar una operación en contexto lista, y luego contar el número de valores devueltos, mediante la asignación a una lista vacía y luego usar esa asignación en el contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $file (@ARGV) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $archivo (@ARGV) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $ref_to_AoA-&gt;[2][2];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $ref_to_AoA-&gt;[2][2];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo, 45,  2) = 3;      # 'PerlPerlPer'  . &quot;\x0c&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052419Z" changeid="explorer">
        <seg>vec($foo, 45,  2) = 3;      # 'PerlPerlPer'  . &quot;\x0c&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also a more insistent form of close because it also
disables the file descriptor in any forked copies in other
processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También es una forma más insistente de cerrar, ya que también desactiva el descriptor de archivo en cualquier copia bifurcada en otros procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item write EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item write EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$re = qr/$pattern/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$re = qr/$patron/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, either the string is a result
of C&lt;pack&gt;, or the characters of the string represent a C structure of some
kind.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo general, ya sea la cadena es un resultado de C&lt;pack&gt;, o los caracteres de la cadena representan una estructura de C de algún tipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is a B&lt;free-form&gt; language, you can format and indent it however
you like.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl es un lenguaje de B&lt;estructura libre&gt;, puede formatearlo y sangrarlo como quiera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then rerun the tests.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A continuación, vuelva a ejecutar las pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sort LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sort LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sleep</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sleep</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that, currently, C&lt;\G&gt; is only
properly supported when anchored at the very beginning of the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta también que, actualmente, C&lt;\G&gt; está sólo adecuadamente soportado cuando es anclado al comienzo del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dbmopen HASH,DBNAME,MASK
X&lt;dbmopen&gt; X&lt;dbm&gt; X&lt;ndbm&gt; X&lt;sdbm&gt; X&lt;gdbm&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170423Z" changeid="explorer">
        <seg>=item dbmopen HASH,DBNAME,MÁSCARA
X&lt;dbmopen&gt; X&lt;dbm&gt; X&lt;ndbm&gt; X&lt;sdbm&gt; X&lt;gdbm&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\n		newline               (LF, NL)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\n		nueva línea           (LF, NL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the repeat count is C&lt;*&gt;, the offset is relative to the start of the
packed string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el número de repeticiones es C&lt;*&gt;, el desplazamiento es relativo al inicio de la cadena empaquetada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack('S&gt;L&gt;', 42, 4711);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack('S&gt;L&gt;', 42, 4711);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl does its own C&lt;sprintf&gt; formatting: it emulates the C
function sprintf(3), but doesn't use it except for floating-point
numbers, and even then only standard modifiers are allowed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl hace su propio formateo C&lt;sprintf&gt;: emula la función del C sprintf(3), pero no la usa, excepto para los números en coma flotante, y aún entonces sólo se admiten modificadores estándares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default floating point numbers substituted inside strings use the
dot (&quot;.&quot;)  as the decimal separator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma predeterminada los números en punto flotante sustituidos dentro de cadenas usan el punto (&quot;.&quot;) como separador decimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$y_hi ] ]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053111Z" changeid="explorer">
        <seg>$y_hi ] ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Pari		provides access to the Pari C library</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::Pari               ofrece acceso a la biblioteca C Pari</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's why it's good to use references sometimes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T004451Z" changeid="explorer">
        <seg>Es por eso que es bueno, en algunas situaciones, utilizar referencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support futimes(2), passing filehandles raises
an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que no admiten futimes(2), pasarle un gestor de archivo lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is omitted, reads from
STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211617Z" changeid="explorer">
        <seg>Si GESTOR_ARCHIVO se omite, se lee desde STDIN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\Q		quote (disable) pattern metacharacters till \E</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\Q		escapa (desactiva) metacaracteres de patrón hasta \E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar or list context propagates down to the right operand if it
is evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los contextos escalar o lista se propagan hacia el operando de la derecha si es evaluado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\S                  non-whitespace character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230229Z" changeid="zipf">
        <seg>\S                  un carácter que no sea un espacio en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\D        [3]  Match a non-digit character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223721Z" changeid="explorer">
        <seg>\D	 [3]  Coincide con un carácter que no es dígito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;(?#...)&gt; comments are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;(?#...)&gt; los comentarios son ignorados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But from time to time, Perl's
notions differ substantially from what the author honestly meant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero de vez en cuando, las nociones de Perl difieren sustancialmente de lo que el autor, honestamente, quería decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;==&quot; returns true if the left argument is numerically equal to
the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;==&quot; devuelve verdadero si el argumento de la izquierda es numéricamente igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es equivalente a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you'd like to make C&lt;system&gt; (and many other bits of Perl) die on error,
have a look at the L&lt;autodie&gt; pragma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea hacer que C&lt;system&gt; (y muchos otros fragmentos de Perl) mueran en caso de error, eche un vistazo al pragma L&lt;autodie&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>continue; # Fall through</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>continue; # Sigue en la siguiente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If @foo exists, Perl takes a good guess about C&lt;[bar]&gt;,
and is almost always right.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si @foo existe, Perl tiene una buena pista acerca de C&lt;[bar]&gt;, y casi siempre acierta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Switch statements
X&lt;switch&gt; X&lt;case&gt; X&lt;given&gt; X&lt;when&gt; X&lt;default&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013516Z" changeid="explorer">
        <seg>=head2 Instrucciones Switch
X&lt;switch&gt; X&lt;case&gt; X&lt;given&gt; X&lt;when&gt; X&lt;default&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp;               ^     string begin         /i case insens.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;&amp;               ^     comienzo cadena      /i no caja de letras</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { local $SIG{'__DIE__'}; $answer = $a / $b; };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { local $SIG{'__DIE__'}; $respuesta = $a / $b; };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the inverse sine operation, you may use the C&lt;Math::Trig::asin&gt;
function, or use this relation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la inversa de la operación seno, puede usar la función C&lt;Math::Trig::asin()&gt;, o usar esta relación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @{ $AoA[0] }, &quot;wilma&quot;, &quot;betty&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @{ $AoA[0] }, &quot;wilma&quot;, &quot;betty&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string =~ /$re/;		# or this way</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cadena =~ /$re/;	# o de esta manera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;format s is %d, s!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;formato s es %d, s!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(ARTICLE, '-|', &quot;caesar &lt;$article&quot;)  # decrypt article</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(ARTICULO, '-|', &quot;caesar &lt;$articulo&quot;)  # decodificar artículo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $in,  &quot;&lt;&quot;,  &quot;input.txt&quot;)  or die &quot;Can't open input.txt: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T031023Z" changeid="explorer">
        <seg>open(my $entrada,  &quot;&lt;&quot;,  &quot;entrada.txt&quot;) or die &quot;No se puede abrir entrada.txt: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$@&gt; is empty then the string C&lt;&quot;Warning: Something's wrong&quot;&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$@&gt; está vacío entonces se usa la cadena C&lt;&quot;Warning: Something's wrong&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that, use C&lt;scalar @array&gt; and C&lt;scalar keys
%hash&gt;, respectively.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ello, utilice C&lt;scalar @array&gt; y C&lt;scalar keys %hash&gt;, respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setpwent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setpwent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use sysread() and check
for a return value for 0 to decide whether you're done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use sysread() y compruebe si el valor devuelto es 0 para decidir si ha llegado al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $word (@words) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $palabra (@palabras) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/&quot;$/&quot;&gt; and L&lt;perlvar/&quot;$.&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/&quot;$/&quot;&gt; y L&lt;perlvar/&quot;$.&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;japh\nJunk&quot; &amp; '_____';   	# prints &quot;JAPH\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;japh\nJunk&quot; &amp; '_____';   	# imprime &quot;JAPH\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalars aren't necessarily one thing or another.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los escalares no tienen que ser necesariamente una cosa o la otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When evaluated as a string it is treated as C&lt;''&gt;, but as a number, it
is treated as 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando es evaluado como cadena es tratado como C&lt;''&gt;, pero como número es tratado como 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub tan { sin($_[0]) / cos($_[0])  }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub tan { sin($_[0]) / cos($_[0])  }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlplan9		Perl notes for Plan 9</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlplan9		Notas para Plan 9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a C&lt;__WARN__&gt; handler provides a powerful way to silence all
warnings (even the so-called mandatory ones).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de un controlador C&lt;__WARN__&gt; proporciona una poderosa manera de silenciar a todas las advertencias (incluso las no menos llamadas obligatorias).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, a single string
consisting of all output is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, se devuelve una sola cadena consistente en toda la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might be tempted to use C&lt;$#array + 1&gt; to tell you how many items there
are in an array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224855Z" changeid="explorer">
        <seg>Podría sentirse tentado de usar C&lt;$#array + 1&gt; para determinar el número de elementos de un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwnam NAME
X&lt;getpwnam&gt; X&lt;getgrnam&gt; X&lt;gethostbyname&gt; X&lt;getnetbyname&gt; X&lt;getprotobyname&gt;
X&lt;getpwuid&gt; X&lt;getgrgid&gt; X&lt;getservbyname&gt; X&lt;gethostbyaddr&gt; X&lt;getnetbyaddr&gt;
X&lt;getprotobynumber&gt; X&lt;getservbyport&gt; X&lt;getpwent&gt; X&lt;getgrent&gt; X&lt;gethostent&gt;
X&lt;getnetent&gt; X&lt;getprotoent&gt; X&lt;getservent&gt; X&lt;setpwent&gt; X&lt;setgrent&gt; X&lt;sethostent&gt;
X&lt;setnetent&gt; X&lt;setprotoent&gt; X&lt;setservent&gt; X&lt;endpwent&gt; X&lt;endgrent&gt; X&lt;endhostent&gt;
X&lt;endnetent&gt; X&lt;endprotoent&gt; X&lt;endservent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173713Z" changeid="explorer">
        <seg>=item getpwnam NOMBRE
X&lt;getpwnam&gt; X&lt;getgrnam&gt; X&lt;gethostbyname&gt; X&lt;getnetbyname&gt; X&lt;getprotobyname&gt;
X&lt;getpwuid&gt; X&lt;getgrgid&gt; X&lt;getservbyname&gt; X&lt;gethostbyaddr&gt; X&lt;getnetbyaddr&gt;
X&lt;getprotobynumber&gt; X&lt;getservbyport&gt; X&lt;getpwent&gt; X&lt;getgrent&gt; X&lt;gethostent&gt;
X&lt;getnetent&gt; X&lt;getprotoent&gt; X&lt;getservent&gt; X&lt;setpwent&gt; X&lt;setgrent&gt; X&lt;sethostent&gt;
X&lt;setnetent&gt; X&lt;setprotoent&gt; X&lt;setservent&gt; X&lt;endpwent&gt; X&lt;endgrent&gt; X&lt;endhostent&gt;
X&lt;endnetent&gt; X&lt;endprotoent&gt; X&lt;endservent&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;break&gt;, C&lt;continue&gt;, C&lt;given&gt;, C&lt;when&gt;, C&lt;default&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;break&gt;, C&lt;continue&gt;, C&lt;given&gt;, C&lt;when&gt;, C&lt;default&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A file test, where X is one of the letters listed below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004340Z" changeid="explorer">
        <seg>Un test de archivo, donde X es una de las letras listadas abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict 'subs';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use strict 'subs';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;+&quot; has no effect whatsoever, even on strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unario &quot;+&quot; no tiene efecto alguno, incluso en cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length of an array is a scalar value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La longitud de un array es un valor escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The repeat 
count should not be more than 65.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de repeticiones no debe ser mayor de 65.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>closedir $dh;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>closedir $dh;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>He will be missed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Le echaremos de menos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(MEMORY,'&gt;', \$var)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(MEMORIA,'&gt;', \$var)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Unix
touch(1) command will in fact normally use this form instead of the
one shown in the first example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando de Unix touch(1), de hecho, utilizará esta forma en lugar de la que se muestra en el primer ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlmod&gt; describes Perl modules in general.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T183926Z" changeid="zipf">
        <seg>En L&lt;perlmod&gt; se describen los módulos de Perl en general.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While short identifiers like C&lt;$gotit&gt; are probably ok, use underscores to
separate words in longer identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras identificadores cortos como C&lt;$leenombre&gt; están bien, use guiones bajos para separar palabras en los identificadores más largos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as a number,
C&lt;undef&gt; is treated as C&lt;0&gt;; when used as a string, it is treated as
the empty string, C&lt;&quot;&quot;&gt;; and when used as a reference that isn't being
assigned to, it is treated as an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa como un número, C&lt;undef&gt; es tratado como si fuera C&lt;0&gt;; cuando se usa como una cadena de caracteres (I&lt;string&gt;), se trata como el string vacío, C&lt;&quot;&quot;&gt;; y cuando se usa como una referencia que no ha sido asignada, es tratado como un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not everything is mentioned, but 195 features may
already be overwhelming.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se menciona todo, porque 195 características pueden ser apabullantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first FreeBSD version this
change will affect is 5.0, all 4.n versions will keep the status quo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La primera versión FreeBSD con este cambio es 5.0. Todas las versiones 4.n mantendrán su status quo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It might do two totally different things.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacer dos cosas totalmente diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>STORE this, key, value</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>STORE este, clave, valor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to regenerate uconfig.h.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para regenerar uconfig.h.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bit</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192124Z" changeid="explorer">
        <seg>Bit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in the shell, if SIGNAL is negative, it kills process groups instead
of processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia del shell, si SEÑAL es negativo, mata el grupo de procesos en lugar de a los procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting from C&lt;%ENV&gt; modifies the environment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Borrando de C&lt;%ENV&gt; modifica el entorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item msgget KEY,FLAGS
X&lt;msgget&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191445Z" changeid="explorer">
        <seg>=item msgget KEY,FLAGS
X&lt;msgget&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also don't have to use push().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco tiene por qué usar push().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The conditional is true if any variables were assigned, i.e., if
the pattern matched.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>la condición es verdadera si cualquiera de las variables fueron asignadas, es decir, si el patrón emparejó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use constant;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use constant;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose you are running script &quot;canasta&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Suponga que está corriendo el script &quot;canasta&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that reversing an array to itself (as in C&lt;@a = reverse @a&gt;) will
preserve non-existent elements whenever possible, i.e., for non magical
arrays or tied arrays with C&lt;EXISTS&gt; and C&lt;DELETE&gt; methods.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que invertir un array en sí mismo (como en C&lt;@a = reverse @a&gt;) preservará elementos inexistentes cuando le sea posible, es decir, para arrays no mágicos o arrays enlazados con métodos C&lt;EXISTS&gt; y C&lt;DELETE&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlrequick 	Perl regular expressions quick start</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlrequick 	Arranque rápido sobre las expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt;'EOT';
                                      0         1         2         3
                       unpack(&quot;V&quot;,$_) 01234567890123456789012345678901</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052441Z" changeid="explorer">
        <seg>print &lt;&lt;'EOT';
                                      0         1         2         3
                       unpack(&quot;V&quot;,$_) 01234567890123456789012345678901</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;&gt; 8 if $?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171139Z" changeid="explorer">
        <seg>&gt;&gt; 8 if $?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being parsimonious on filehandles is also useful (besides being
parsimonious) for example when something is dependent on file
descriptors, like for example locking using flock().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ser parco en gestores de archivo también es útil (además de ser parsimoniosos), por ejemplo cuando algo depende de descriptores de archivo, como por ejemplo, el uso del bloqueo flock().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;Config&gt; module will also let you interrogate values
determined by the B&lt;Configure&gt; program when Perl was installed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo C&lt;Config&gt; le permitirá también interrogar por los valores determinados por el programa B&lt;Configure&gt; cuando Perl fue instalado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Basic syntax overview</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Descripción general de la sintaxis básica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#AoA ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052830Z" changeid="explorer">
        <seg>$#AoA ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fileno FILEHANDLE
X&lt;fileno&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211436Z" changeid="explorer">
        <seg>=item fileno GESTOR_ARCHIVO
X&lt;fileno&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although a
scalar may not directly hold multiple values, it may contain a
reference to an array or hash which in turn contains multiple values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque un escalar no puede contener directamente múltiples valores, podría contener una referencia a un array o un hash, los cuales a su vez sí que pueden contener múltiples valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is worth noting that C&lt;\G&gt; improperly used can result in an infinite
loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cabe señalar que C&lt;\G&gt; mal utilizado puede resultar en un bucle infinito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| die &quot;can't open UTF-8 encoded filename: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>|| die &quot;no puedo abrir archivo codificado en UTF-8: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @a = complex_calculation();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @a = calculo_complejo();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that according to the POSIX 1003.1-1996 the FILENAME may have any
number of trailing slashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que de acuerdo con POSIX 1.003.1-1996, el nombre de archivo puede tener cualquier número de barras inclinadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorry.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo sentimos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This keyword is available only when the &quot;say&quot; feature is
enabled: see L&lt;feature&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta palabra clave sólo está disponible cuando la característica &quot;say&quot; está habilitada: ver L&lt;feature&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 OpenBSD vuelca el núcleo desde getprotobyname_r y getservbyname_r con ithreads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
used to report whether memory for that aggregate has ever been
allocated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se usó para informar si la memoria para los datos agregados había sido reservada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {$b &lt;=&gt; $a} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {$b &lt;=&gt; $a} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, evaluating a filehandle in angle brackets yields
the next line from that file (the newline, if any, included), or
C&lt;undef&gt; at end-of-file or on error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, la evaluación de un gestor de archivo entre ángulos retorna la siguiente línea de ese archivo (con el carácter de salto de línea, en su caso, incluido), o C&lt;undef&gt; al final del archivo o en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With format C&lt;h&gt;, the
first character of the pair determines the least-significant nybble of the
output character; with format C&lt;H&gt;, it determines the most-significant
nybble.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con el formato C&lt;h&gt;, el primer carácter del par determina el nible menos significativo de la salida de caracteres; con el formato C&lt;H&gt;, determina el nible más significativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltoc		Perl documentation table of contents</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perltoc		Perl documentación: tabla de contenidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 1) = 1   ==         64 00000010000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 1) = 1   ==         64 00000010000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with regular pattern matching, any capturing parentheses that are not
matched in a C&lt;split()&gt; will be set to C&lt;undef&gt; when returned:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que con la coincidencia de patrones regulares, cualquier paréntesis de captura que no coincida en un C&lt;split()&gt; se establecerá a C&lt;undef&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default all sockets
operate on bytes, but for example if the socket has been changed using
binmode() to operate with the C&lt;:encoding(utf8)&gt; I/O layer (see the
C&lt;open&gt; pragma, L&lt;open&gt;), the I/O will operate on UTF-8 encoded Unicode
characters, not bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto todos los sockets operan en bytes, pero por ejemplo, si el socket ha sido cambiado usando binmode() para operar con la capa de E/S C&lt;:encoding(utf8)&gt; (ver el pragma C&lt;open&gt;, L&lt;open&gt;), la E/S operará en caracteres codificados en UTF-8, no bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond that, he has other preferences that aren't so strong:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aparte de eso, él tiene otras preferencias que no son tan estrictas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$no_caps_here    function scope my() or local() variables</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$sin_mayusculas     Ámbito de función, variables my() o local()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it succeeds it
returns true, otherwise it returns false and sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si tiene éxito, devuelve verdadero, en caso contrario devuelve falso y asigna C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just understand what you're getting yourself into.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo entienda lo que te está metiendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider writing a module or object class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere escribir un módulo o una clase de objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, that environment variable is not getting
populated by a combination of C&lt;Config&gt; entries and C&lt;ExtUtil::MakeMaker&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la actualidad, esta variable de entorno no está siendo publicitada por una combinación de entradas en C&lt;Config&gt; y C&lt;ExtUtil::MakeMaker&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if( $condition &amp;&amp; ... ) { print &quot;Hello\n&quot; };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if( $condicion &amp;&amp; ... ) { print &quot;Hola\n&quot; };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &quot;?&quot; is
the delimiter, then the match-only-once rule of C&lt;?PATTERN?&gt; applies.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si &quot;?&quot; es el delimitador, entonces se aplica la regla coincide-solo-una-vez de C&lt;?PATTERN?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| //            $     str.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>|| //            $     fin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;identifier&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;identifier&gt; X&lt;identificador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item my EXPR
X&lt;my&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191531Z" changeid="explorer">
        <seg>=item my EXPR
X&lt;my&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This doesn't work if you explicitly specify a loop variable,
as in C&lt;for $item (@array)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto no funciona si explícitamente especifica una variable de bucle, como en C&lt;for $item (@array)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltooc		Perl OO tutorial, part 2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perltooc		Seminario de POO Perl, parte 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The range operator (in list context) makes use of the magical
auto-increment algorithm if the operands are strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador rango (en contexto de lista) hace uso del algoritmo auto-incremental mágico, si los operandos son cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub newopen {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub nuevoopen {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print { $OK ? STDOUT : STDERR } &quot;stuff\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050728Z" changeid="explorer">
        <seg>print { $OK ? STDOUT : STDERR } &quot;cosas\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DESCRIPCIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8.2 introduced a bugfix
which accidentally broke the compilation of Perl extensions written in C++</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5.8.2 introdujo una corrección de errores que rompió accidentalmente la compilación de las extensiones Perl escritas en C++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is something like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resultado es algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is Perl short-hand for the more explicitly written version:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>que es la versión corta de la versión más explícita:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11475</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11475</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, '&lt;', $file);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, '&lt;', $archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = $a + 2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a = $a + 2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, C&lt;$$&gt; is the current process
id.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;$$&gt; es el ID del proceso actual).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; &gt;= &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; &gt;= &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For constructs that do interpolate, variables beginning with &quot;C&lt;$&gt;&quot;
or &quot;C&lt;@&gt;&quot; are interpolated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las construcciones que hacen interpolación, las variables que empiezan por &quot;C&lt;$&gt;&quot; o &quot;C&lt;@&gt;&quot; son interpoladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>view perl perldgux</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>view perl perldgux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common mistake is to try to separate the words with comma or to
put comments into a multi-line C&lt;qw&gt;-string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un error común es tratar de separar las palabras con una coma o poner comentarios en una cadena C&lt;qw&gt; multilínea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$element_count = scalar(@whatever);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$contador_elementos = scalar(@loquesea);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the total
number of characters removed from all its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número total de caracteres eliminados de todos sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create a symlink for libperl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crear un enlace simbólico para libperl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Unicode::Collate</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Unicode::Collate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto-EXPR&gt; form expects a label name, whose scope will be resolved
dynamically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-EXPR espera un nombre de etiqueta, cuyo ámbito será resuelto dinámicamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233552Z" changeid="zipf">
        <seg>print &quot;Hola</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlop/&quot;Gory details of parsing quoted constructs&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>L&lt;perlop/&quot;Gory details of parsing quoted constructs&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the most common values are C&lt;O_RDONLY&gt; for opening the file in
read-only mode, C&lt;O_WRONLY&gt; for opening the file in write-only mode,
and C&lt;O_RDWR&gt; for opening the file in read-write mode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos de los valores más comunes son C&lt;O_RDONLY&gt; para abrir el archivo en modo de sólo lectura, C&lt;O_WRONLY&gt; para abrir el archivo en modo de sólo escritura, y C&lt;O_RDWR&gt; para abrir el archivo en modo lectura-escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (crypt($word, $pwd) ne $pwd) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (crypt($palabra, $pwd) ne $pwd) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$line = &lt;STDIN&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$linea = &lt;STDIN&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read from an open filehandle using the C&lt;&lt; &lt;&gt; &gt;&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225309Z" changeid="explorer">
        <seg>Puede utilizar el operador C&lt;&lt; &lt;&gt; &gt;&gt; para leer de un identificador de archivo abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11485</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11485</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules look complicated, but usually they will do what
you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas reglas parecen complicadas, pero usualmente harán lo que usted desea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A
reference to the subroutine itself is passed in as C&lt;$_[0]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una referencia a la propia subrutina es pasada en C&lt;$_[0]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$y_lo, $y_hi) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053108Z" changeid="explorer">
        <seg>$y_lo, $y_hi) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I  A unsigned integer value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>I  Un valor entero sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, it's usually correct for ambiguous cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Afortunadamente, por lo general es correcta para los casos ambiguos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11490</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11490</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Same for a L&lt;quantifier|/Quantifiers&gt; such as C&lt;{3}&gt; or
C&lt;{5,}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222900Z" changeid="explorer">
        <seg>Lo mismo para los L&lt;cuantificadores|Cuantificadores&gt; como C&lt;{3}&gt; o C&lt;{5,}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that
0 is a valid match offset.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que 0 es un desplazamiento válido de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?                   zero or one of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055631Z" changeid="explorer">
        <seg>?                   cero o una coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While there may be a bug somewhere in Perl's configuration or
C&lt;ExtUtil::MakeMaker&gt; causing the problem, the most likely cause is an
incomplete understanding of Sun Studio by this author.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si bien puede haber un error en algún lugar de configuración de Perl o C&lt;ExtUtil::MakeMaker&gt; que sea la razón del problema, la causa más probable es una comprensión incompleta de Sun Studio por parte de este autor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &quot;Matching Code&quot; column is not always an exact rendition.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la columna &quot;Código similar&quot; no siempre es una interpretación exacta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A  A text (ASCII) string, will be space padded.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A  Una cadena de texto (ASCII), será rellenada con espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my(@fhlist) = split(' ',$_[0]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my(@fhlist) = split(' ',$_[0]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be consistent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sea coherente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subtest of the C&lt;ext/Sys/Syslog/t/syslog.t&gt; test fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una subprueba del test C&lt;ext/Sys/Syslog/t/syslog.t&gt; falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the context of the current subroutine call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el contexto de la llamada a la subrutina actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($string = &lt;&lt;'END');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($cadena = &lt;&lt;'END');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,20, 1) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,20, 1) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But method calls such as C&lt;&lt; $obj-&gt;meth &gt;&gt; are not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero llamadas a métodos como C&lt;&lt; $objeto-&gt;metodo &gt;&gt;, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a second
C&lt;my&gt; declaration, which will bind the name to a fresh variable, a
second C&lt;our&gt; declaration in the same package, in the same scope, is
merely redundant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de una segunda declaración de C&lt;my&gt;, que unirá el nombre a una nueva variable, una segunda declaración de C&lt;our&gt; en el mismo paquete, en el mismo ámbito, es simplemente redundante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While literal lists and named arrays are often interchangeable, that's
not the case for hashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si bien las listas literales y los array nominales a menudo, son intercambiables, este no es el caso de los hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11423</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11423</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly for the C&lt;:encoding&gt; pragma: in that
case pretty much any characters can be read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, para el pragma C&lt;:encoding&gt;: en este caso casi todos los caracteres se pueden leer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus it breaks up characters
                    into their UTF-8 bytes, so you may end up with malformed
                    pieces of UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224206Z" changeid="explorer">
        <seg>Por lo tanto, rompe los caracteres
                    UTF-8 en sus respectivos bytes, por lo que puede terminar
                    con partes incorrectos de UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then C&lt;$a&gt; and C&lt;$b&gt; are C&lt;$main::a&gt; and C&lt;$main::b&gt; (or C&lt;$::a&gt; and C&lt;$::b&gt;),
but if you're in the C&lt;FooPack&gt; package, it's the same as typing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>entonces C&lt;$a&gt; y C&lt;$b&gt; son C&lt;$main::a&gt; y C&lt;$main::b&gt; (o C&lt;$::a&gt; y C&lt;$::b&gt;), pero si está en el paquete C&lt;FooPack&gt;, es lo mismo que escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use \p{Prop} for longer names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use \p{Prop} para los nombres largos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is usually something to be avoided when writing clear code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es algo usualmente a ser evitado cuando se está escribiendo código claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlop - Perl operators and precedence</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlop - Operadores de Perl y precedencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:bytes&gt;, C&lt;:crlf&gt;, C&lt;:utf8&gt;, and any other directives of the
form C&lt;:...&gt;, are called I/O I&lt;layers&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;:bytes&gt;, C&lt;:crlf&gt;, C&lt;:utf8&gt;, y cualquier otra directiva de la forma C&lt;:...&gt;, se llaman I&lt;capas&gt; I/O.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the result of C&lt;&quot;\Q STRING \E&quot;&gt; has all metacharacters
quoted, there is no way to insert a literal C&lt;$&gt; or C&lt;@&gt; inside a
C&lt;\Q\E&gt; pair.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que el resultado de C&lt;&quot;\Q STRING \E&quot;&gt; tiene todos los metacaracteres entrecomillados, no hay forma de insertar un literal C&lt;$&gt; o C&lt;@&gt; dentro de una pareja C&lt;\Q\E&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Top of form processing is handled automatically:  if there is
insufficient room on the current page for the formatted record, the
page is advanced by writing a form feed, a special top-of-page format
is used to format the new page header, and then the record is written.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El principio de procesamiento de formularios se maneja de forma automática: si no hay suficiente espacio en la página actual para el registro formateado, la página se avanza escribiendo un avance de página, un formato especial de principio de página se utiliza para dar formato al encabezado de la página nueva, y entonces el registro se escribe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;**&quot; is the exponentiation operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;**&quot; es el operador de exponenciación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of EXPR with the first character lowercased.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor de EXPR con el primer carácter en minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($i &lt; 10) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($i &lt; 10) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$year += 1900;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$anno += 1900;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The status is returned in C&lt;$?&gt; and C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El estado se devuelve en C&lt;$?&gt; y C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common case is that the option is an
integer, in which case the result is a packed integer, which you can decode
using C&lt;unpack&gt; with the C&lt;i&gt; (or C&lt;I&gt;) format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un caso común es que la opción sea un entero, en cuyo caso el resultado es un entero empaquetado, que podrá decodificar usando C&lt;unpack&gt; con el formato C&lt;i&gt; (o C&lt;I&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value of an actual array in scalar context is the
length of the array; the following assigns the value 3 to $foo:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el valor actual de un array en contexto escalar es la longitud del array; lo siguiente asigna el valor 3 a $foo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5100delta	Perl changes in version 5.10.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5100delta	Cambios en la versión 5.10.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, note that Perl's pipes use
IO buffering, so you may need to set C&lt;$|&gt; to flush your WRITEHANDLE
after each command, depending on the application.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, tenga en cuenta que las tuberías de Perl utilizan el búfer de E/S, así que puede que necesite establecer C&lt;$|&gt; para limpiar su CONTROLADOR_ESCRITURA después de cada comando, dependiendo de la aplicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sendmsg(2) syscall is currently
unimplemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La llamada del sistema sendmsg(2) no está, actualmente, implementada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also Perl's exception trapping mechanism, where
the die operator is used to raise exceptions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También es la excepción en el sistema de atrapado de Perl, donde el operador die se usa para levantar excepciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can effect a sleep of 250 milliseconds this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede efectuar una espera de 250 milisegundos de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,10, 1) = 1   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,10, 1) = 1   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do either of those, you have to use the C&lt;$SIG{__WARN__}&gt; facility, or
turn off warnings inside the BLOCK or EXPR using S&lt;C&lt;no warnings 'all'&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para hacer cualquiera de estas dos cosas debe usar C&lt;$SIG{__WARN__}&gt;, o desactivar los avisos dentro del BLOQUE o EXPR usando S&lt;C&lt;no warnings 'all'&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;stdin&gt; X&lt;stdout&gt; X&lt;sterr&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;stdin&gt; X&lt;stdout&gt; X&lt;sterr&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this
case, only the C&lt;g&gt; and C&lt;c&gt; flags on the empty pattern is honoured -
the other flags are taken from the original pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En este caso, sólo las opciones C&lt;g&gt; y C&lt;c&gt; en el patrón vacío son tomadas en cuenta; las otras opciones son tomadas del patrón original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;VSTRING&gt; is returned if the reference points
to a L&lt;version string|perldata/&quot;Version Strings&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;VSTRING&gt; se devuelve si la referencia apunta a una L&lt;version string|perldata/&quot;Cadenas de versión&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ary = glob($pattern);  # expand filenames</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ary = glob($patron);  # expandir los nombres de los archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/^xyz/) { $xyz = 1; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/^xyz/) { $xyz = 1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort find_records(@key);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort busca_registros(@claves);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl581delta	Perl changes in version 5.8.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl581delta	Cambios en la versión 5.8.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, devuelve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\D                  a non-digit</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230245Z" changeid="zipf">
        <seg>\D                  un carácter que no sea un dígito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extend your pattern's legibility by permitting whitespace and comments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Amplía la legibilidad del patrón, al permitir espacios en blanco y comentarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also embed newlines directly in your strings, i.e., they can end
on a different line than they begin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede incrustar directamente caracteres de nueva línea dentro de sus cadenas, es decir, que puede terminar en una línea diferente de cuando empezaron.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl571delta	Perl changes in version 5.7.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl571delta	Cambios en la versión 5.7.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The I&lt;sequence-item&gt; must not
have a repeat count.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La I&lt;secuencia-item&gt; no debe tener un contador de repeticiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty -cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty -cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the ones
we've already seen include C&lt;print&gt;, C&lt;sort&gt; and C&lt;reverse&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225213Z" changeid="explorer">
        <seg>Ya hemos visto algunas funciones, como C&lt;print&gt;, C&lt;sort&gt; y C&lt;reverse&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an expression that specifies the name of a subroutine,
returns true if the specified subroutine has ever been declared, even
if it is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dada una expresión que especifica el nombre de una subrutina, devuelve verdadero si la subrutina especificada ha sido declarada, incluso si esta está indefinida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in slurp mode (C&lt;$/ = undef&gt;) or fixed-length record mode (C&lt;$/&gt; is
a reference to an integer or the like, see L&lt;perlvar&gt;) chomp() won't
remove anything.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En modo chupón (C&lt;$/ = undef&gt;) o en modo registros de longitud fija (C&lt;$/&gt; es una referencia a un entero o algo parecido, ver L&lt;perlvar&gt;) chomp() no elimina nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The content of the here doc is treated just as it would be if the
string were embedded in backticks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El contenido del documento indicado es tratado como si la cadena estuviera incrustada entre comillas invertidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11459</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11459</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as C&lt;$!&gt; is the value
of C's C&lt;errno&gt;, which can be set by any system call, this means that the value
of the exit code used by C&lt;die&gt; can be non-predictable, so should not be relied
upon, other than to be non-zero.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171410Z" changeid="explorer">
        <seg>Sin embargo, como C&lt;$!&gt; es el valor de C de C&lt;errno&gt;, que se puede establecer por cualquier llamada al sistema, esto significa que el valor del código de salida utilizada por C&lt;die&gt; puede ser no-previsible, por lo que no debe confiarse en él, aparte de ser distinto de cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#b&gt;',  12;   # prints &quot;&lt;0b1100&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#b&gt;',  12;   # imprime &quot;&lt;0b1100&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are upgrading from an earlier release such as 5.6.1, first read
the L&lt;perl58delta&gt;, which describes differences between 5.6.0 and
5.8.0, and the L&lt;perl581delta&gt; and L&lt;perl582delta&gt;, which describe differences
between 5.8.0, 5.8.1 and 5.8.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está actualizando desde una versión anterior como la 5.6.1, primero lea L&lt;perl58delta&gt;, que describe las diferencias entre 5.6.0 y 5.8.0, y L&lt;perl581delta&gt; y L&lt;perl582delta&gt;, que describe las diferencias entre 5.8.0, 5.8.1 y 5.8.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl590delta	Perl changes in version 5.9.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl590delta	Cambios en la versión 5.9.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, &quot;extra&quot; nybbles are ignored during
unpacking.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, los nibles &quot;extra&quot; son ignorados durante el desempaquetado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, '&lt;', &quot;input.txt&quot;) or die $!;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $fh, '&lt;', &quot;entrada.txt&quot;) or die $!;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uncuddled elses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else en nueva línea. No en la misma línea que la llave de cierre del if.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lt  less than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lt  menor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function and method names seem to work best as all lowercase.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Funciones y nombres de métodos parece que funcionan mejor con minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For compatibility with
older scripts written before __DATA__ was introduced, __END__ behaves
like __DATA__ in the top level script (but not in files loaded with
C&lt;require&gt; or C&lt;do&gt;) and leaves the remaining contents of the
file accessible via C&lt;main::DATA&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T003707Z" changeid="explorer">
        <seg>Por compatibilidad con I&lt;scripts&gt; viejos escritos antes de la introducción de __DATA__, __END__ se comporta como __DATA__ en el script de nivel superior (pero no en los archivos cargados con C&lt;require&gt; o C&lt;do&gt;) y deja el resto del contenido del archivo accesible a través de C&lt;main::DATA&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that write is I&lt;not&gt; the opposite of C&lt;read&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que write I&lt;no&gt; es lo contrario de C&lt;read&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a descending numeric sort of a hash by its values:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es una ordenación numérica descendente de un hash por sus valores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you cannot read from the DATA
filehandle in a BEGIN block: the BEGIN block is executed as soon
as it is seen (during compilation), at which point the corresponding
__DATA__ (or __END__) token has not yet been seen.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que no puede leer desde el gestor de archivo de datos en un bloque BEGIN: el bloque BEGIN se ejecutará tan pronto como sea visto (durante la compilación), momento en que el correspondiente símbolo __DATA__ (o __END__) aún no se ha visto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $Config{shortsize},    &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $Config{shortsize},    &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbook - Perl book information</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlbook - Información sobre libros de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%map = ('red',0x00f,'blue',0x0f0,'green',0xf00);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%map = ('rojo',0x00f,'azul',0x0f0,'verde',0xf00);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say '$foo is numerically less than 100';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>say '$foo es numéricamente menor que 100';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of a subroutine call, rather than a subroutine name, as an argument
to exists() is an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar una llamada de subrutina en lugar del nombre de una subrutina como argumento a exists() es un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BUILDING PERL ON DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 COMPILANDO PERL EN DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $lrr = shift; 	# ref to array of array refs!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053105Z" changeid="explorer">
        <seg>my $lrr = shift; 	# ¡ref. a un array de array de ref.!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/$^F&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/$^F&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the FILEHANDLE is an EXPR, then the expression
is evaluated and the resulting string is used to look up the name of
the FILEHANDLE at run time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T212016Z" changeid="explorer">
        <seg>Si el GESTOR_ARCHIVO es una EXPR, entonces la expresión se evalúa y la cadena resultante se utiliza para buscar el nombre del GESTOR_ARCHIVO en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item m//</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item m//</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot;
mode on systems where the run-time libraries distinguish between
binary and text files.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211214Z" changeid="explorer">
        <seg>Ordena que el modo de lectura o escritura para el GESTOR_ARCHIVO sea en &quot;binario&quot; o &quot;texto&quot; en sistemas donde las bibliotecas en tiempo de ejecución distingan entre archivos binarios y de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in any of the shells, single quotes do not
hide variable names in the command from interpretation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de cualquiera de los shell, las comillas simples no impiden que los nombres de variables sean interpretadas, en el comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a compile-time error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un error en tiempo de compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually this name is a single I&lt;identifier&gt;,
that is, a string beginning with a letter or underscore, and
containing letters, underscores, and digits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente, este nombre es un I&lt;identificador&gt;, es decir, una palabra que comienza por una letra o carácter de subrayado y que contiene letras, caracteres de subrayado o dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special literals __FILE__, __LINE__, and __PACKAGE__
represent the current filename, line number, and package name at that
point in your program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los literales especiales __FILE__, __LINE__ y __PACKAGE__ representan el nombre del archivo actual, número de línea, y el nombre del paquete en ese punto de su programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (defined($paragraph = &lt;&gt;)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (defined($parrafo = &lt;&gt;)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Barewords
X&lt;bareword&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035547Z" changeid="explorer">
        <seg>=head3 Palabras sueltas
X&lt;bareword&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a filehandle, then the subroutine will be
called to act as a simple source filter, with the line as read in C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay un gestor de archivo, a continuación, la subrutina será llamada a actuar como un simple filtro de código fuente, con la línea leída en C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*s&gt;', -1, &quot;string&quot;;   # prints &quot;&lt;string&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*s&gt;', -1, &quot;cadena&quot;;   # imprime &quot;&lt;cadena&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the system call fails, C&lt;syscall&gt; returns C&lt;-1&gt; and sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la llamada al sistema falla, C&lt;syscall&gt; devuelve C&lt;-1&gt; y establece C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># assign to our array, an array of array references</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># asignar a nuestro array, un array de referencias a array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\1        [5]  Backreference to a specific capture buffer or group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224256Z" changeid="explorer">
        <seg>\1        [5]  Contrareferencia a un determinado buffer de captura o grupo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR starts off with C&lt;0b&gt;, it is interpreted as a
binary string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR empieza con C&lt;0b&gt;, se interpreta como una cadena binaria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;O_EXCL&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;O_EXCL&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR
is not specified, C&lt;$_&gt; will be used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR no se especifica, se comprobará C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... and run the script as C&lt;/path/to/script.pl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230208Z" changeid="zipf">
        <seg>... y ejecutar el script como C&lt;/ruta/script.pl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are quite a few systems out there that do worse!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¡Hay pocos sistemas que lo hagan peor!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$sentences\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012125Z" changeid="explorer">
        <seg>print &quot;$instrucciones\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anywhere else it's $&lt;I&lt;digit&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En cualquier otro lugar, es $&lt;I&lt;dígito&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$Price = '$100';	# not interpolated</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$Precio = '$100';                 # no interpolado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TELL this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TELL este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the LENGTH is greater than the
data available in the SCALAR after the OFFSET, only as much data as is
available will be written.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LONGITUD es mayor que los datos disponibles en ESCALAR después del DESPLAZAMIENTO, sólo se escribirán los datos que estén disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful when the structure you're
unpacking has encoded the sizes or repeat counts for some of its fields
within the structure itself as separate fields.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil cuando la estructura que está desempaquetando tiene codificados los tamaños o recuentos de repetición para algunos de sus campos dentro de la propia estructura como campos separados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;/&gt; template character allows packing and unpacking of a sequence of
items where the packed structure contains a packed item count followed by
the packed items themselves.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La plantilla C&lt;/&gt; permite empaquetar y desempaquetar una secuencia de elementos en donde la estructura empaquetada contiene un contador de elementos empaquetados seguido por los propios elementos empaquetados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
need to exit the process with a specific exit code, see L&lt;exit&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171018Z" changeid="explorer">
        <seg>Si necesita terminar el proceso con un valor de salida específico, véase L&lt;exit&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run a Perl program from the Unix command line:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224637Z" changeid="explorer">
        <seg>Para ejecutar un programa Perl desde la línea de comandos de Unix, use el siguiente comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value replaces the value in
C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de retorno reemplaza el valor en C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use Module VERSION LIST
X&lt;use&gt; X&lt;module&gt; X&lt;import&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210418Z" changeid="explorer">
        <seg>=item use Módulo VERSIÓN LISTA
X&lt;use&gt; X&lt;module&gt; X&lt;import&gt; X&lt;módulo&gt; X&lt;importar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8 has a sort pragma for
limited control of the sort.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>v5,8 tiene un pragma para sort, para un control limitado de la ordenación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deletes the directory specified by FILENAME if that directory is
empty.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elimina el directorio especificado por NOMBRE_DIRECTORIO si ese directorio está vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setservent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setservent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make test</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make test</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that smart match's matching rules take precedence over
overloading, so if C&lt;$obj&gt; has smart match overloading, then</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note también que las reglas de coincidencias de la coincidencia inteligente toman precedencia sobre la sobrecarga, así que si C&lt;$obj&gt; tiene sobrecargado la coincidencia inteligente, entonces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X  Back up a byte.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X  Retrocede un byte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $bar;    # still prints 30</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $bar;    # sigue pintando 30</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;next&gt;, just double the braces:
X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T041156Z" changeid="explorer">
        <seg>Para C&lt;next&gt;, solamente doble las llaves:
X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the -g operator is often equivalent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># el operador -g es, a menudo, equivalente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to C&lt;print FILEHANDLE sprintf(FORMAT, LIST)&gt;, except that C&lt;$\&gt;
(the output record separator) is not appended.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Equivalente a C&lt;print GESTOR_ARCHIVO sprintf(FORMATO, LISTA)&gt;, excepto que C&lt;$\&gt; (el separador de registro a la salida) no es añadida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although
quicksort's run time is O(NlogN) when averaged over all arrays of
length N, the time can be O(N**2), I&lt;quadratic&gt; behavior, for some
inputs.)  In 5.7, the quicksort implementation was replaced with
a stable mergesort algorithm whose worst-case behavior is O(NlogN).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque el tiempo de ejecución de quicksort es O(NlogN) de promedio de todos los arrays de longitud N, el tiempo puede ser O(N**2), comportamiento I&lt;cuadrático&gt;, para algunas entradas). En v5.7 la implementación de quicksort fue reemplazada con un algoritmo estable mergesort cuyo peor comportamiento es O(NlogN).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that just because a hash is initialized in that order doesn't
mean that it comes out in that order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que sólo porque un hash se inicializa en ese orden no quiere decir que salga en ese orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All values must be read before it will start
over.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todos los valores deben ser leídos antes de empezar de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must
put the list in parentheses to avoid ambiguity.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe poner la lista entre paréntesis para evitar ambigüedades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The integer types C&lt;s&gt;, C&lt;S&gt;, C&lt;l&gt;, and C&lt;L&gt; may be
followed by a C&lt;!&gt; modifier to specify native shorts or
longs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tipos enteros C&lt;s&gt;, C&lt;S&gt;, C&lt;l&gt;, y C&lt;L&gt; pueden ser seguidos por un modificar C&lt;!&gt; para especificar un corto (short) o largo (long) nativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;O_CREAT&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;O_CREAT&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12288</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12288</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlriscos		Perl notes for RISC OS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlriscos		Notas para RISC OS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned value is a
normalized version of the original pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto es una versión normalizada del patrón original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlunitut - Perl Unicode Tutorial</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T060151Z" changeid="explorer">
        <seg>perlunitut - Seminario Unicode en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following standard quantifiers are recognized:
X&lt;metacharacter&gt; X&lt;quantifier&gt; X&lt;*&gt; X&lt;+&gt; X&lt;?&gt; X&lt;{n}&gt; X&lt;{n,}&gt; X&lt;{n,m}&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110214T002353Z" changeid="explorer">
        <seg>Se reconocen los siguientes cuantificadores estándares:
X&lt;metacharacter&gt; X&lt;quantifier&gt; X&lt;*&gt; X&lt;+&gt; X&lt;?&gt; X&lt;{n}&gt; X&lt;{n,}&gt; X&lt;{n,m}&gt; X&lt;metacarácter&gt; X&lt;cuantificador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE&gt;: Unlike C and other languages, Perl has no C&lt;\v&gt; escape sequence for
the vertical tab (VT - ASCII 11), but you may use C&lt;\ck&gt; or C&lt;\x0b&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;NOTA&gt;: A diferencia de C y otros lenguajes, Perl no tiene una secuencia de escape C&lt;\v&gt; para el tabulado vertical (VT - ASCII 11), pero puede usar C&lt;\ck&gt; o C&lt;\x0b&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One or more embedded pattern-match modifiers, to be turned on (or
turned off, if preceded by C&lt;-&gt;) for the remainder of the pattern or
the remainder of the enclosing pattern group (if any).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230756Z" changeid="explorer">
        <seg>Uno o más modificadores de coincidencia de patrón incrustados, que han de ser activados (o desactivados, si son precedidos por C&lt;-&gt;) para el resto del patrón o el resto del grupo de patrón más interior (si existe).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace
between the function and left parenthesis doesn't count, so sometimes
you need to be careful:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco entre la función y el paréntesis izquierdo no cuenta, por lo que deberá tener cuidado en algunas ocasiones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The quoted part ends on the
first C&lt;&quot;&gt; and C&lt;/&gt;, and the rest happens to be a syntax error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La parte entrecomillada termina en la primera C&lt;&quot;&gt; y C&lt;/&gt;, y el resto pasa a ser un error de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (?^$?) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (?^$?) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESTROY this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DESTROY este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you change them,
Perl won't even notice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si las cambia, Perl ni siquiera se dará cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 16  ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 16  ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLEAR this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CLEAR este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>qw(foo bar baz)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>qw(foo bar baz)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>longsize='4';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>longsize='4';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are not under C&lt;use threads::shared&gt; this does nothing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no está bajo C&lt;use threads::shared&gt;, no hará nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlopentut&gt; and
L&lt;perlfunc/open&gt; for details on this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase L&lt;perlopentut&gt; y L&lt;perlfunc/open&gt; para más detalles sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>means that no fee is charged for the item
itself, though there may be fees involved in handling the item.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>significa que no se cobra cuota por el propio elemento, aunque puede haber cargos involucrados en el manejo del elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the substring
is not found, C&lt;index&gt; returns one less than the base, ordinarily C&lt;-1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el substring no se encuentra, C&lt;index&gt; devuelve uno menos que la base, normalmente C&lt;-1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>grep {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>grep {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldebguts 	Perl debugging guts and tips</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldebguts 	Depurando, tripas y trucos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the most common reason to learn this is to unravel labyrinthine
regular expressions, because the initial steps of parsing are the
same for all quoting operators, they are all discussed together.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque la razón más común para aprender esto es desentrañar laberínticas expresiones regulares, ya que los pasos iniciales del análisis son los mismos para todos los operadores de entrecomillado, todos ellos son explicados en conjunto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gmtime EXPR
X&lt;gmtime&gt; X&lt;UTC&gt; X&lt;Greenwich&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173836Z" changeid="explorer">
        <seg>=item gmtime EXPR
X&lt;gmtime&gt; X&lt;UTC&gt; X&lt;Greenwich&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to inspect both the string given to RE engine and the
resulting finite automaton.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es posible inspeccionar tanto la cadena dada al motor RE y el autómata finito que resulta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item our EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item our EXPR : ATRIBUTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, usually.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bueno, normalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>line.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$^N&gt; can be used in
extended patterns (see below), for example to assign a submatch to a
variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$^N&gt; puede ser usado en patrones extendidos (ver abajo), por ejemplo para asignar una sub coincidencia a una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iain 'Spoon' Truskett, Perl hacker, author of L&lt;perlreref&gt; and
contributor to CPAN, died suddenly on 29th December 2003, aged 24.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Iain 'Spoon' Truskett, Perl hacker, autor de L&lt;perlreref&gt; y contribuidor a CPAN, murió repentinamente el 29 de diciembre de 2003, a la edad de 24 años.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;foo;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;foo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($key,$value) = each %ENV) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (($clave,$valor) = each %ENV) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open FILEHANDLE,MODE,EXPR,LIST</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211656Z" changeid="explorer">
        <seg>=item open GESTOR_ARCHIVO,MODO,EXPR,LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NAME should be a
packed address of the appropriate type for the socket.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NOMBRE debe ser una dirección empaquetada del tipo apropiado para el socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item scalar EXPR
X&lt;scalar&gt; X&lt;context&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200156Z" changeid="explorer">
        <seg>=item scalar EXPR
X&lt;scalar&gt; X&lt;context&gt; X&lt;escalar&gt; X&lt;contexto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%n    special: *stores* the number of characters output so far</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%n    especial: *almacena* el número de caracteres mostrados hasta ahora</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;@&gt;, C&lt;x&gt;, and C&lt;X&gt;, where it is equivalent to C&lt;0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;@&gt;, C&lt;x&gt; y C&lt;X&gt;, donde es equivalente a C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = $b || $c;		# better written this way</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a = $b || $c;		# mejor escrito de esta manera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also find out from within Perl what your
$quota and $comment fields mean and whether you have the $expire field
by using the C&lt;Config&gt; module and the values C&lt;d_pwquota&gt;, C&lt;d_pwage&gt;,
C&lt;d_pwchange&gt;, C&lt;d_pwcomment&gt;, and C&lt;d_pwexpire&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede también encontrar dentro de Perl que es lo que significan sus campos $cuota, $comentario y $expira usando el módulo C&lt;Config&gt; y los valores C&lt;d_pwquota&gt;, C&lt;d_pwage&gt;, C&lt;d_pwchange&gt;, C&lt;d_pwcomment&gt; y C&lt;d_pwexpire&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl, a sequence of statements that defines a scope is called a block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013249Z" changeid="explorer">
        <seg>En Perl, una secuencia de instrucciones que define un ámbito se llama un bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^/&gt; / if (/^$/ ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^/&gt; / if (/^$/ ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 4   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 4   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets FILEHANDLE's position, just like the C&lt;fseek&gt; call of C&lt;stdio&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Establece la posición de GESTOR_ARCHIVO, igual que la llamada C&lt;fseek&gt; de C&lt;stdio&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item foreach</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232638Z" changeid="explorer">
        <seg>=item foreach</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ITER: {
           foreach $prefix (@INC) {
               $realfilename = &quot;$prefix/$filename&quot;;
               if (-f $realfilename) {
                   $INC{$filename} = $realfilename;
                   $result = do $realfilename;
                   last ITER;
               }
           }
           die &quot;Can't find $filename in \@INC&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051104Z" changeid="explorer">
        <seg>ITER: {
           foreach $prefix (@INC) {
               $nombre_archivo_real = &quot;$prefijo/$archivo&quot;;
               if (-f $nombre_archivo_real) {
                   $INC{$archivo} = $nombre_archivo_real;
                   $resultado = do $nombre_archivo_real;
                   last ITER;
               }
           }
           die &quot;No encuentro el $archivo en \@INC&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># using an in-line function</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># usando una función incluida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a subroutine that does not
exist may still be callable: its package may have an C&lt;AUTOLOAD&gt;
method that makes it spring into existence the first time that it is
called; see L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que una subrutina que no existe puede ser llamada: su paquete puede tener un método C&lt;AUTOLOAD&gt; que la hace aparecer la primera vez que es llamada; ver L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$DOWARN = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$DOWARN = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlclib		Internal replacements for standard C library functions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlclib		Reemplazos internos para las funciones de la biblioteca estándar C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some examples that you should be able to type into your command
shell:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay algunos ejemplos que será capaz de escribir en la línea de comandos del shell:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>------------------------------------------------------------------</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>------------------------------------------------------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should be noted that C&lt;~~&gt; will refuse to work on objects that
don't overload it (in order to avoid relying on the object's
underlying structure).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se debe hacer notar que C&lt;~~&gt; rechazará funcionar en objetos que no lo sobrecargan (para no depender de la estructura subyacente del objeto)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12243</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12243</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl573delta - what's new for perl v5.7.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl573delta - qué hay de nuevo para perl v5.7.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn't matter whether those elements are already
there or not: it'll gladly create them for you, setting
intervening elements to C&lt;undef&gt; as need be.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No importa qué elementos estén allí o no: serán, con mucho gusto, creados para usted, estableciendo elementos intermedios a C&lt;undef&gt; cuando sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;useperlio&gt;
is C&lt;define&gt;, you have PerlIO, otherwise you don't.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;useperlio&gt; está C&lt;definido&gt;, tiene PerlIO activado, de lo contrario, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not use any characters
but these with this format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No utilice más que estos caracteres con este formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is I&lt;not&gt; what you want to use to capture
the output from a command, for that you should use merely backticks or
C&lt;qx//&gt;, as described in L&lt;perlop/&quot;`STRING`&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto I&lt;no&gt; es lo que desea utilizar para capturar la salida de un comando; para eso debe utilizar solamente las comillas invertidas o C&lt;qx//&gt;, como se describe en L&lt;perlop/&quot;`CADENA`&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no need
to pre-declare your variable types, but you have to declare them using
the C&lt;my&gt; keyword the first time you use them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224822Z" changeid="explorer">
        <seg>No es necesario predeclarar los tipos de las variables, pero éstas deben declararse con la palabra clave C&lt;my&gt; la primera vez que se usan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open my $logfile, &quot;&gt;&gt;&quot;, &quot;my.log&quot; or die &quot;Could not open my.log: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T222040Z" changeid="zipf">
        <seg>open my $registro, &quot;&gt;&gt;&quot;, &quot;mi.registro&quot; or die &quot;No se pudo abrir mi.registro: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (blessed($ev_err) &amp;&amp; $ev_err-&gt;isa(&quot;Some::Module::Exception&quot;)) {
            # handle Some::Module::Exception</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043853Z" changeid="explorer">
        <seg>if (blessed($ev_err) &amp;&amp; $ev_err-&gt;isa(&quot;Some::Module::Exception&quot;)) {
            # controlador Some::Module::Exception</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To transform a bit vector into a string or list of 0's and 1's, use these:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para transformar un vector de bits en una cadena o una lista de 0 y 1, utilice los siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other systems like OS/2, DOS and the
various flavors of MS-Windows your program sees a C&lt;\n&gt; as a simple C&lt;\cJ&gt;,
but what's stored in text files are the two characters C&lt;\cM\cJ&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otros sistemas como OS/2, DOS y los distintos sabores de MS-Windows tu programa vee un C&lt;\n&gt; como un simple C&lt;\cJ&gt;, pero es almacenado en los archivos de texto como los dos caracteres C&lt;\cM\cJ&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print +(1+2)+4;   # Prints 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print +(1+2)+4;	# Imprime 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>h           interpret integer as C type &quot;short&quot; or &quot;unsigned short&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>h           interpreta un entero como un &quot;short&quot; o &quot;unsigned short&quot; del C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/exec&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/exec&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to map strings between lower/upper
cases, see L&lt;perlfunc/lc&gt; and L&lt;perlfunc/uc&gt;, and in general consider
using the C&lt;s&gt; operator if you need regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea mapear cadenas entre minúsculas/mayúsculas, véase L&lt;perlfunc/lc&gt; y L&lt;perlfunc/uc&gt;; y, en general, considere el uso del operador C&lt;s&gt; si necesita usar expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If BITS is 8, &quot;elements&quot; coincide with bytes of the input string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si BITS es 8, los &quot;elementos&quot; coinciden con bytes de la cadena de entrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for fixed length data or records</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones para datos de longitud fija o registros</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ref EXPR
X&lt;ref&gt; X&lt;reference&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194520Z" changeid="explorer">
        <seg>=item ref EXPR
X&lt;ref&gt; X&lt;reference&gt; X&lt;referencia&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sin EXPR
X&lt;sin&gt; X&lt;sine&gt; X&lt;asin&gt; X&lt;arcsine&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200720Z" changeid="explorer">
        <seg>=item sin EXPR
X&lt;sin&gt; X&lt;sine&gt; X&lt;asin&gt; X&lt;arcsine&gt; X&lt;arco seno&gt; X&lt;seno&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not particularly efficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto no es particularmente eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with filehandles and labels, a bareword that consists
entirely of lowercase letters risks conflict with future reserved
words, and if you use the C&lt;use warnings&gt; pragma or the B&lt;-w&gt; switch, 
Perl will warn you about any such words.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que con gestores de archivo y las etiquetas, una palabra suelta que consiste enteramente en minúsculas tiene el riesgo de llegar a un conflicto con los futuras palabras reservadas, y si utiliza el pragma C&lt;use warnings&gt; o la opción B&lt;-w&gt;, Perl le advertirá sobre cualquiera de estas palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = 4;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194702Z" changeid="explorer">
        <seg>$x = 4;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Duping a filehandle does not take into account any existing contents
of IO buffers.) If you use the 3-arg form then you can pass either a
number, the name of a filehandle or the normal &quot;reference to a glob&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Duplicar un gestor de archivo no tiene en cuenta cualquier contenido existente de los buffers de E/S). Si utiliza la forma de tres arg. entonces puede pasar un número, el nombre de un gestor de archivo o la normal &quot;referencia a un glob&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example that looks up nonnumeric uids in the passwd file:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo que obtiene el uid numérico a partir del archivo de contraseñas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhpux		Perl notes for HP-UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlhpux		Notas para HP-UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to receive LENGTH characters
of data into variable SCALAR from the specified SOCKET filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intenta leer LONGITUD I&lt;caracteres&gt; de datos en la variable ESCALAR del gestor SOCKET especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't go through silly contortions to exit a loop at the top or the
bottom, when Perl provides the C&lt;last&gt; operator so you can exit in
the middle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No haga tontas contorsiones para salir de un bucle al inicio o al final, cuando Perl dispone del operador C&lt;last&gt; para que pueda salir desde el interior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $unlinked = unlink 'a', 'b', 'c';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $unlinked = unlink 'a', 'b', 'c';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This may seem like an
odd thing to you, but you'll use the construct in almost every Perl
script you write.)  The $_ variable is not implicitly localized.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto puede parecer algo extraño para usted, pero usará esta construcción en casi todos los scripts de Perl que escriba). La variable $_ no estará, implícitamente, localizada en el contexto del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes operands that might otherwise be interpreted as operators,
constants, single number v-strings or function calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto incluye operandos que, de lo contrario, podrían interpretarse como operadores, constantes, un solo número o v-cadenas o llamadas a funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlre&gt;, with additional examples in L&lt;perlop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;perlre&gt;, con ejemplos adicionales en L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$quota,$comment,$gcos,$dir,$shell,$expire) = getpw*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cuota,$comentario,$gcos,$dir,$shell,$expiracion) = getpw*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># open for append, using the fileno of OLDFH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Abrir para añadir, usando el número de descriptor de OLDFH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>READ this, scalar, length, offset</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>READ este, escalar, longitud, desplazamiento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that both &quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot; in Perl are implemented directly using
&quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot; in C.  If C&lt;use integer&gt; (see L&lt;Integer Arithmetic&gt;) is
in force then signed C integers are used, else unsigned C integers are
used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que tanto &quot;&lt;&lt;&quot; como &quot;&gt;&gt;&quot; en Perl están implementados directamente a través de &quot;&lt;&lt;&quot; y &quot;&gt;&gt;&quot; en C. Si C&lt;use integer&gt; (véase L&lt;Aritmética entera&gt;) está en vigor entonces se utilizan los enteros C con signo; sino, se utilizan enteros C sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;Regexp Quote-Like Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>See L&lt;perlop/&quot;Operadores Regexp&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value is the exit status of the program as returned by the
C&lt;wait&gt; call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto es el estado de salida del programa devuelto por la llamada C&lt;wait&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stick with that, and you
should be safe.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siga con eso, y estará seguro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To present something as hex, look into L&lt;/printf&gt;,
L&lt;/sprintf&gt;, or L&lt;/unpack&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para presentar algo como hex, mire en L&lt;/printf&gt;, L&lt;/sprintf&gt; o L&lt;/unpack&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the LABEL is omitted, the loop control statement
refers to the innermost enclosing loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013409Z" changeid="explorer">
        <seg>Si la ETIQUETA se omite, las instrucciones de control de bucle se refieren al bucle más interior en que se encuentren.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;, C&lt;msgsnd&gt;, C&lt;semctl&gt;, C&lt;semget&gt;, C&lt;semop&gt;,
C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;, C&lt;shmwrite&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202300Z" changeid="explorer">
        <seg>C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;, C&lt;msgsnd&gt;, C&lt;semctl&gt;, C&lt;semget&gt;, C&lt;semop&gt;,
C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;, C&lt;shmwrite&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12 blcks  strftime!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>12 blcks  strftime!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13358</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13358</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do { my $_ = EXPR; ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do { my $_ = EXPR; ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>White space can separate pack codes from each other, but modifiers and
repeat counts must follow immediately.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco puede separar los códigos de empaquetado, pero los modificadores y los contadores de repetición deben seguir de inmediato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># print out history file offsets</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># imprime los desplazamientos en el archivo histórico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -V:{short,int,long{,long}}size</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ perl -V:{short,int,long{,long}}size</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
particular, as C&lt;@_&gt; contains aliases to the caller's arguments, Perl does
not take a copy of C&lt;@_&gt;, so C&lt;@DB::args&gt; will contain modifications the
subroutine makes to C&lt;@_&gt; or its contents, not the original values at call
time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, como C&lt;@_&gt; contiene los alias de los argumentos de la función llamante, Perl no tiene una copia de C&lt;@_&gt;, así que C&lt;@DB::args&gt; contendrá modificaciones que la subrutina hace a C&lt;@_&gt; o de sus contenidos, no los valores originales a la hora de ser llamada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But you cannot do so for the very first one if it's a scalar containing
a reference, which means that $ref_to_AoA always needs it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero no puede hacerlo para el primer caso si es un escalar que contenga una referencia, lo que significa que $ref_to_AoA siempre lo necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the filename begins with C&lt;'|'&gt;, the filename is interpreted as a
command to which output is to be piped, and if the filename ends with a
C&lt;'|'&gt;, the filename is interpreted as a command that pipes output to
us.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el nombre del archivo empieza por C&lt;'|'&gt;, el nombre del archivo es interpretado como un comando a quien le entubamos nuestra salida, y si el nombre del archivo termina con un C&lt;'|'&gt;, el nombre del archivo es interpretado como un comando que entuba su salida hacia nosotros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval qq[\n#line 200 &quot;foo bar&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval qq[\n#line 200 &quot;foo bar&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @transformed = map { ...; } @input; # ; disambiguates</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @transformado = map { ...; } @entrada; # ; desambigüedad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;{$key})  { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;{$clave})  { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># @fields is (1, 'A', 2, undef, 3)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># @campos es (1, 'A', 2, undef, 3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry has his reasons for each of these things, but he doesn't claim that
everyone else's mind works the same as his does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Larry tiene sus razones para cada una de estas ideas, pero el no aspira que la mente de los demás trabaje de la misma forma que la suya.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For alignment commands, a C&lt;count&gt; of 0 is equivalent to a C&lt;count&gt; of 1;
both are no-ops.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012049Z" changeid="explorer">
        <seg>Para los comandos de alineación, un C&lt;contador&gt; de 0 es equivalente a un C&lt;contador&gt; de 1; ambos son instrucciones no efectivas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$fh = \*STDOUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$fh = \*STDOUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recursively create a directory structure, look at
the C&lt;mkpath&gt; function of the L&lt;File::Path&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para, recursivamente, crear una estructura de directorios, mire la función C&lt;mkpath&gt; del módulo L&lt;File::Path&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>N  An unsigned long (32-bit) in &quot;network&quot; (big-endian) order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>N  Un largo sin signo (32 bit) en orden &quot;red&quot; (big-endian).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default all sockets operate
on bytes, but for example if the socket has been changed using
binmode() to operate with the C&lt;:encoding(utf8)&gt; I/O layer (see
L&lt;/open&gt;, or the C&lt;open&gt; pragma, L&lt;open&gt;), the I/O will operate on UTF-8
encoded Unicode characters, not bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto todos los sockets operan en bytes, pero por ejemplo, si el socket ha sido cambiado usando binmode() para operar con la capa de E/S C&lt;:encoding(utf8)&gt; (ver el pragma C&lt;open&gt;, L&lt;open&gt;), la E/S operará en caracteres codificados en UTF-8, no bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print sort @harry;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print sort @harry;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Under NFS this will use the time of the NFS server, not the time of
the local machine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bajo NFS se utilizará la hora del servidor NFS, no el tiempo de la máquina local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this code works
in the same way on big-endian or little-endian machines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que este código funciona de la misma manera en máquinas big-endian que little-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $key (sort { $hash{$b} &lt;=&gt; $hash{$a} } keys %hash) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $key (sort { $hash{$b} &lt;=&gt; $hash{$a} } keys %hash) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if successful, the undefined value
otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tiene éxito, sino, el valor indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sub NAME (PROTO) : ATTRS BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sub NOMBRE (PROTO) : ATRIBS BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This must
be a power of two from 1 to 32 (or 64, if your platform supports
that).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto debe ser una potencia de dos desde 1 a 32 (o 64, si la plataforma lo admite).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a &quot;real&quot; C C&lt;open&gt; (see C&lt;open(2)&gt; on your system), then you
should use the C&lt;sysopen&gt; function, which involves no such magic (but
may use subtly different filemodes than Perl open(), which is mapped
to C fopen()).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si busca un &quot;auténtico&quot; C&lt;open&gt; como en C (ver C&lt;open(2)&gt; en su sistema), entonces debe usar la función C&lt;sysopen&gt;, que no supone tal magia (pero puede utilizar sutilmente diferentes modos de archivo que el open() de Perl, que es asignado a la función en C fopen()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;namespace&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;namespace&gt; X&lt;espacio de nombres&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5113delta	Perl changes in version 5.11.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5113delta	Cambios en la versión 5.11.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joins the separate strings of LIST into a single string with fields
separated by the value of EXPR, and returns that new string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Une las cadenas separados de LISTA en una única cadena con campos separados por el valor de EXPR y devuelve la nueva cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing of C&lt;\N{...}&gt; is also done here, and compiled into an intermediate
form for the regex compiler.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procesamiento de C&lt;\N{...}&gt; también se hace aquí, y compilado en una forma intermedia para el compilador de expresiones regulares (RE).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\u		uppercase next char (think vi)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\u		a mayúscula sig. car. (como en vi)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When choosing a new salt create a random two character string whose
characters come from the set C&lt;[./0-9A-Za-z]&gt; (like C&lt;join '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando escoja un nuevo salto cree un string de dos caracteres elegidos aleatoriamente del conjunto C&lt;[./0-9A-Za-z]&gt; (como por ejemplo C&lt;join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perldiag&gt; for explanations of all Perl's diagnostics.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perldiag&gt; para la explicación de todos los diagnósticos de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If umask(2) is not implemented and you are
not trying to restrict access for yourself, returns C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si umask(2) no está implementado y usted no está tratando de restringir el acceso por sí mismo, devuelve C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;&lt; $ref-&gt;{&quot;A&quot;} &gt;&gt; and C&lt;&lt; $ref-&gt;{&quot;A&quot;}-&gt;{&quot;B&quot;} &gt;&gt; will spring
into existence due to the existence test for the $key element above.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así. C&lt;&lt; $ref-&gt;{&quot;A&quot;} &gt;&gt; y C&lt;&lt; $ref-&gt;{&quot;A&quot;}-&gt;{&quot;B&quot;} &gt;&gt; aparecerán en la existencia debido al actual test por el elemento $clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implements the ioctl(2) function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Implementa la función ioctl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Auto-increment and Auto-decrement
X&lt;increment&gt; X&lt;auto-increment&gt; X&lt;++&gt; X&lt;decrement&gt; X&lt;auto-decrement&gt; X&lt;--&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T232441Z" changeid="explorer">
        <seg>=head2 Auto incremento y auto decremento
X&lt;increment&gt; X&lt;auto-increment&gt; X&lt;++&gt; X&lt;decrement&gt; X&lt;auto-decrement&gt; X&lt;--&gt; X&lt;incremento&gt; X&lt;auto incremento&gt; X&lt;decremento&gt; X&lt;auto decremento&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;failed to execute: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;fallo al ejecutar: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@z2 = ('01' ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@z2 = ('01' ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(To do runtime compilation only once,
use C&lt;/$variable/o&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para hacer la compilación en tiempo de ejecución sólo una vez, utilice C&lt;/$variable/o&gt;.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmod		Perl modules: how they work</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmod		Módulos Perl: cómo funcionan</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl572delta	Perl changes in version 5.7.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl572delta	Cambios en la versión 5.7.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pattern match succeeds and C&lt;$1&gt; is defined, although it
matched &quot;nothing&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El patrón de búsqueda tiene éxito y C&lt;$1&gt; está definida, aunque no ha correspondido con &quot;nada&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $quoted_substring = quotemeta($substring);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T193753Z" changeid="explorer">
        <seg>my $subcadena_escapada = quotemeta($subcadena);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># timed out</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># fin de temporización</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the first step at which the presence
of the C&lt;//x&gt; modifier is relevant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este es el primer caso en el que la presencia del modificador C&lt;//x&gt; es relevante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a,$b,$c,$d) = unpack('W4',$addr[0]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a,$b,$c,$d) = unpack('W4',$addr[0]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13326</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13326</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 - that is, each element smart-matches the element of same index in the</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042940Z" changeid="explorer">
        <seg>2 - es decir, cada elemento coincide inteligentemente con cada elemento del mismo índice.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the arguments get executed via the system shell, results are
subject to its quirks and capabilities.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando los argumentos son ejecutados vía el shell del sistema, los resultados están sujetos a sus peculiaridades y capacidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let it be stressed that I&lt;whatever falls between C&lt;\Q&gt; and C&lt;\E&gt;&gt;
is interpolated in the usual way.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay que hacer hincapié en que I&lt;lo que caiga dentro de C&lt;\Q&gt; y C&lt;\E&gt;&gt; es interpolado de la forma normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl58delta 	Perl changes in version 5.8.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl58delta 	Cambios en la versión 5.8.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &gt; &gt;&gt; and C&lt;&lt; &lt; &gt;&gt; modifiers can also be used on C&lt;()&gt; groups 
to force a particular byte-order on all components in that group, 
including all its subgroups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los modificadores C&lt;&lt; &gt; &gt;&gt; y C&lt;&lt; &lt; &gt;&gt; también se pueden utilizar en los grupos C&lt;()&gt; para obligar a un particular orden de bytes en todos los componentes de ese grupo, que incluye todos sus subgrupos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,}?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n,}?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that fails, or
you didn't use that, then try adjusting other optimization options
(-LNO, -INLINE, -O3 to -O2, etcetera).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003303Z" changeid="explorer">
        <seg>Si eso no funciona, o no lo ha usado, intente, a continuación, ajustar otras opciones de optimización (-LNO,-inline, O3-a-O2, etc).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If single quotes
are used, no interpretation is done on the replacement string (the C&lt;/e&gt;
modifier overrides this, however).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se utilizan comillas simples, no se realiza ninguna interpretación en la cadena de reemplazo (sin embargo, el modificador C&lt;/e&gt; reemplaza a ésta).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>time ^ $$</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>time ^ $$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;can't fcntl F_GETFL: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;no puedo hacer fcntl F_GETFL: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See also L&lt;Integer Arithmetic&gt; and
L&lt;Bitwise String Operators&gt;.)  Note that the width of the result is
platform-dependent: ~0 is 32 bits wide on a 32-bit platform, but 64
bits wide on a 64-bit platform, so if you are expecting a certain bit
width, remember to use the &amp; operator to mask off the excess bits.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185842Z" changeid="explorer">
        <seg>(Véase también L&lt;Aritmética entera&gt; y L&lt;Operadores de bit en cadenas&gt;). Tenga en cuenta que el ancho del resultado depende de la plataforma: ~0 es de 32 bits de ancho en una plataforma de 32 bits, pero 64 bits de ancho en una plataforma de 64 bits, así que si usted está esperando un determinado ancho de bits, recuerde utilizar el operador &amp; para enmascarar los bits en exceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will place into $count the number of digit groups found in $string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pondrá en $cuenta el número de grupos de dígitos que se encuentren en $cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub match {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub coincidencia {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 GETTING HELP</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 OBTENIENDO AYUDA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Terms and List Operators (Leftward)
X&lt;list operator&gt; X&lt;operator, list&gt; X&lt;term&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T190307Z" changeid="explorer">
        <seg>=head2 Términos y Operadores de listas (por la izquierda)
X&lt;list operator&gt; X&lt;operator, list&gt; X&lt;term&gt; X&lt;operador lista&gt; X&lt;operador, lista&gt; X&lt;término&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Long doubles are available only if your system supports long</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Los dobles-largos están disponibles solo si su sistema soporta valores largos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a *= 3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a *= 3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line up corresponding items vertically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alinear elementos correspondientes verticalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub byage {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub por_edad {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$pwd = (getpwuid($&lt;))[1];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$pwd = (getpwuid($&lt;))[1];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ge  greater than or equal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ge  mayor o igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 SYNOPSIS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T154324Z" changeid="zipf">
        <seg>=head1 SINOPSIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the C&lt;b&gt; and C&lt;B&gt; formats pack a string that's that many bits long.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, los formatos C&lt;b&gt; y C&lt;B&gt; empaquetan una cadena con una dada longitud de bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item msgsnd ID,MSG,FLAGS
X&lt;msgsnd&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191527Z" changeid="explorer">
        <seg>=item msgsnd ID,MSG,FLAGS
X&lt;msgsnd&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endpwent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endpwent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp; 127),  ($?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp; 127),  ($?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
can be used to go almost anywhere else within the dynamic scope,
including out of subroutines, but it's usually better to use some other
construct such as C&lt;last&gt; or C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser utilizada para ir a casi cualquier sitio que esté dentro del ámbito dinámico, incluyendo fuera de las subrutinas, pero es normalmente mucho mejor otras construcciones como C&lt;last&gt; o C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment is a little bit special in that it uses its left argument
to determine the context for the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La asignación es un poco especial en el sentido de que utiliza su argumento de la izquierda para determinar el contexto del argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El redondeo en las aplicaciones financieras puede tener consecuencias graves, y el método de redondeo utilizado debe ser descrito con precisión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,19, 1) = 1   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,19, 1) = 1   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-x&gt;[I&lt;dir&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-x&gt;[I&lt;dir&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($a) {}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($a) {}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is used by
C&lt;AUTOLOAD()&gt; subroutines that wish to load another subroutine and then
pretend that the other subroutine had been called in the first place
(except that any modifications to C&lt;@_&gt; in the current subroutine are
propagated to the other subroutine.)  After the C&lt;goto&gt;, not even C&lt;caller()&gt;
will be able to tell that this routine was called first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se usa por subrutinas C&lt;AUTOLOAD()&gt; que desean cargar otra subrutina y fingen que esta otra subrutina ha sido llamada en primer lugar (excepto que cualquier modificación a C&lt;@_&gt; en la subrutina actual se propaga a la otra). Después del C&lt;goto&gt;, ni siquiera C&lt;caller()&gt; será capaz de decir qué rutina fue llamada en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may be useful in a my() or local().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto puede ser útil en un my() o local().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict   qw(subs vars refs);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use strict   qw(subs vars refs);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the repeat count is C&lt;0&gt;, it's relative to the current position.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el número de repeticiones es C&lt;0&gt;, es relativa a la posición actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;my&gt; declares the listed variables to be local (lexically) to the
enclosing block, file, or C&lt;eval&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;my&gt; declara las variables enumeradas como locales (léxicamente) en el bloque, archivo, o C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produce the output 'h:i: :t:h:e:r:e:!:' and 'hi:there:', respectively,
both with an empty trailing field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce la salida 'h:o:l:a: :a:q:u:i:!:' y 'hola:aqui:', respectivamente, ambos con un campo vacío final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please see L&lt;perltie/SCALAR&gt; for the full details and
caveats.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por favor, vea L&lt;perltie/SCALAR&gt; para ver todos los detalles y advertencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any of these
modifiers may also be embedded within the regular expression itself using
the C&lt;(?...)&gt; construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera de estos modificadores también pueden ser incorporados dentro de la propia expresión regular usando la construcción C&lt;(?...)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reference is a scalar value and can refer to any other Perl data
type.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224949Z" changeid="explorer">
        <seg>Una referencia es un valor escalar que puede apuntar a cualquier tipo de datos de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @abbr = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @abbr = qw( Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>seek(HANDLE, 0, 0);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>seek(HANDLE, 0, 0);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any of the file tests (or either the C&lt;stat&gt; or C&lt;lstat&gt; operators) are given
the special filehandle consisting of a solitary underline, then the stat
structure of the previous file test (or stat operator) is used, saving
a system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si a cualquiera de los test de archivo (o los operadores C&lt;stat&gt; o C&lt;lstat&gt;) se les da el gestor de archivo especial consistente en un solitario subrayado (guión bajo), entonces se usa la estructura stat del archivo del test anterior (u operador stat), ahorrando una llamada del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to get at a slice (part of a row) in a multidimensional
array, you're going to have to do some fancy subscripting.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194532Z" changeid="explorer">
        <seg>Si desea obtener una porción (parte de una fila) en una matriz multidimensional, va a tener que hacer algunos juegos malabares con los subíndices.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's the equivalent of &quot;!&quot; except for the very low precedence.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es el equivalente de &quot;!&quot; excepto por tener una precedencia muy baja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldiag		Perl diagnostic messages</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldiag		Mensajes de diagnóstico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;got $a\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;tengo $a\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my($filename, $input) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my($archivo, $entrada) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;flock&gt; is Perl's portable file locking interface, although it locks
entire files only, not records.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;flock&gt; es el interfaz portable de Perl de bloqueo de archivo, aunque sólo bloquea archivos enteros, no registros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item die LIST
X&lt;die&gt; X&lt;throw&gt; X&lt;exception&gt; X&lt;raise&gt; X&lt;$@&gt; X&lt;abort&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170630Z" changeid="explorer">
        <seg>=item die LISTA
X&lt;die&gt; X&lt;throw&gt; X&lt;exception&gt; X&lt;raise&gt; X&lt;$@&gt; X&lt;abort&gt; X&lt;excepción&gt; X&lt;levantar&gt; X&lt;abortar&gt; X&lt;descartar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used to go almost anywhere
else within the dynamic scope, including out of subroutines, but it's
usually better to use some other construct such as C&lt;last&gt; or C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser utilizada para ir a casi cualquier sitio que esté dentro del ámbito dinámico, incluyendo fuera de las subrutinas, pero es usualmente mucho mejor usar otras construcciones como C&lt;last&gt; o C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, they always return
$timeleft equal to the supplied $timeout.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no, siempre devuelven $tiempo_restante igual a $tiempo_espera indicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -Dcc='cc -64' -Duse64bitint</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002544Z" changeid="explorer">
        <seg>sh Configure -Dcc='cc -64' -Duse64bitint</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Threading</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Multihilos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./Configure</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ ./Configure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;File::Glob&gt; for details, including
C&lt;bsd_glob&gt; which does not treat whitespace as a pattern separator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;File::Glob&gt; para los detalles, incluyendo C&lt;bsd_glob&gt; que no trata al espacio en blanco como separador de patrones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item MIME::Base64</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item MIME::Base64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item times
X&lt;times&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T205940Z" changeid="explorer">
        <seg>=item times
X&lt;times&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is an expression, its value is used as
the name of the real filehandle wanted.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204205Z" changeid="explorer">
        <seg>Si GESTOR_ARCHIVO es una expresión, el valor es tomado como el nombre real del gestor buscado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some concerns to keep in mind when using endianness modifier:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Éstas son algunas de las preocupaciones a tener en cuenta cuando se usa el modificador de ordenación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @ARRAY[0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @ARRAY[0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return print reverse sort num values %array;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return print reverse sort num values %array;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (values %hash)      { s/foo/bar/g }   # modifies %hash values</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (values %hash)      { s/foo/bar/g }   # modifica los valores de %hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if these
conditions are met, be warned that unlinking a directory can inflict
damage on your filesystem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso si se cumplen estas condiciones, se advierte que desvincular un directorio puede causar daños a su sistema de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;umask&gt; value is such a number
representing disabled permissions bits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de C&lt;umask&gt; es un número que representa los bits de lso permisos que quedan desactivados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last example in each block shows the pipe as &quot;list form&quot;, which is
not yet supported on all platforms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El último ejemplo de cada bloque muestra la tubería como &quot;forma de lista&quot;, que todavía no está soportado en todas las plataformas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are the quote-like operators that apply to pattern
matching and related activities.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí están los operadores, parecidos a los de entrecomillado, que se aplican a las actividades relacionadas con la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rec = {
                witch =&gt; 'Mable the Merciless',
                cat   =&gt; 'Fluffy the Ferocious',
                date  =&gt; '10/31/1776',</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T042902Z" changeid="explorer">
        <seg>$rec = {
                bruja =&gt; 'Mable la Implacable',
                gato  =&gt; 'Fluffy el Feroz',
                fecha =&gt; '10/31/1776',</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%g    a floating-point number, in %e or %f notation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%g    un número en punto flotante, en notación %e o %f</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, returns the number of fields found.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el número de campos que se han encontrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef @ary;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef @ary;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that argument processing varies depending on the
number of arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el tratamiento de los argumentos varía en función del número de argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12345</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>12345</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$year = sprintf(&quot;%02d&quot;, $year % 100);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$anno = sprintf(&quot;%02d&quot;, $anno % 100);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,15, 1) = 1   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,15, 1) = 1   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make other distribution arrangements with the Copyright Holder.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hacer otros acuerdos de distribución con el Titular del Copyright.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local *Here::blue = \$There::green;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local *Aqui::azul = \$Ahi::verde;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To return all but the last
character, use C&lt;substr($string, 0, -1)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para devolver todos menos el último carácter, use C&lt;substr($string, 0, -1)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the character represented by that NUMBER in the character set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el carácter representado por NÚMERO en el conjunto de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is only fancy fancy: if you use
the return value of C&lt;-f $file&gt; as an argument to another filetest
operator, no special magic will happen.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto solo es fascinantemente elegante: si usa el valor devuelto de C&lt;-f $archivo&gt; como un argumento para otro operador de test de archivo, no ocurrirá ninguna magia especial)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $color  = substr $s, 4, 5;      # black</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $color  = substr $s, 8, 5;      # negro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If SCALAR
has no string value but does have a numeric value, that value will be
passed rather than a pointer to the string value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si ESCALAR no tiene un valor string sino que tiene un valor numérico, este valor será el que se pase, en lugar de un puntero al valor del string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right	**</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>derecha	**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to fields allowed in pack(), you may prefix a field with
a %&lt;number&gt; to indicate that
you want a &lt;number&gt;-bit checksum of the items instead of the items
themselves.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de los campos permitidos en pack(), puede usar un prefijo de un campo con un %&lt;número&gt; para indicar que desea una suma de control a nivel de bit de los elementos en lugar de los propios elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perliol		C API for Perl's implementation of IO in Layers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perliol		API C para la implementación Perl de las capas IO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\U		uppercase till \E</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003145Z" changeid="explorer">
        <seg>\U		mayúsculas hasta \E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alpha and MIPS can be either: Digital/Compaq used/uses them in
little-endian mode, but SGI/Cray uses them in big-endian mode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alpha y MIPS pueden ser: Digital/Compaq utilizados/usados en modo little-endian, pero SGI/Cray los usa en modo big-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no, lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\H        [3]  Not horizontal whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224952Z" changeid="explorer">
        <seg>\H        [3]  No espacio en blanco horizontal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># A &quot;reverse comma operator&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Un &quot;operador coma inverso&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open FILEHANDLE,EXPR
X&lt;open&gt; X&lt;pipe&gt; X&lt;file, open&gt; X&lt;fopen&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211641Z" changeid="explorer">
        <seg>=item open GESTOR_ARCHIVO,EXPR
X&lt;open&gt; X&lt;pipe&gt; X&lt;file, open&gt; X&lt;fopen&gt; X&lt;archivo, open&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also means that if you want real
whitespace or C&lt;#&gt; characters in the pattern (outside a character
class, where they are unaffected by C&lt;/x&gt;), then you'll either have to
escape them (using backslashes or C&lt;\Q...\E&gt;) or encode them using octal,
hex, or C&lt;\N{}&gt; escapes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto también significa que si quiere un espacio en blanco real o caracteres C&lt;#&gt; en el patrón (excepto en una clase de caracteres, donde no les afecta C&lt;/x&gt;), entonces tendrá que escaparlos (usando barras invertidas o C&lt;\Q...\E&gt;) o codificarlas usando octal, hex, o secuencias de escape C&lt;\N{}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;has nondigits&quot;	if     /\D/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no dígitos&quot;           if     /\D/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hashref   ${$$foo[1]}[2] aka $foo-&gt;[1][2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>anónimo   ${$$foo[1]}[2] igual que $foo-&gt;[1][2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>qw{}	     Word list		  no</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>qw{}	   Lista palabras	  no</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's very important that you make sure to use the C&lt;[]&gt; array reference
constructor.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es muy importante que esté seguro que está utilizando el constructor de referencia a array C&lt;[]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, if the string
starts with a plus or minus, a string starting with the opposite sign
is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De otra manera, si la cadena comienza con un más o un menos, se devuelve una cadena que comience con el signo opuesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If F&lt;sys/ioctl.ph&gt; doesn't
exist or doesn't have the correct definitions you'll have to roll your
own, based on your C header files such as F&lt;&lt; &lt;sys/ioctl.h&gt; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si F&lt;sys/ioctl.ph&gt; no existe o no tiene las definiciones correctas, tendrá que incorporar las suyas propias, basadas en sus archivos de cabecera C como las de F&lt;&lt; &lt;sys/ioctl.h&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Math::BigInt</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Math::BigInt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, crypt() dies with
C&lt;Wide character in crypt&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no, crypt() muere con C&lt;Wide character in crypt&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $handle = IO::File-&gt;new;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $handle = IO::File-&gt;new;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval qq[\n#line 2001 &quot;&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval qq[\n#line 2001 &quot;&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also cannot exit out of the sort block or subroutine using any of the
loop control operators described in L&lt;perlsyn&gt; or with C&lt;goto&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También no puede salir fuera del bloque de ordenación o de la subrutina utilizando cualquiera de los operadores de control de bucle descritos en L&lt;perlsyn&gt; o con C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value gives the name
of the filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204402Z" changeid="explorer">
        <seg>GESTOR_ARCHIVO puede ser una expresión cuyo valor da el nombre del gestor de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $sentence = 'The quick brown fox jumped over the lazy dog';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012544Z" changeid="explorer">
        <seg>my $instruccion = 'El rápido zorro marrón saltó sobre el perezoso perro';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} while $kid &gt; 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} while $hijo &gt; 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@colors{'red','blue','green'} 
                   = (0xff0000, 0x0000ff, 0x00ff00);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043038Z" changeid="explorer">
        <seg>@colores{'rojo','azul','verde'} 
                   = (0xff0000, 0x0000ff, 0x00ff00);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The
\&lt;digit&gt; notation works in certain circumstances outside
the match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(La notación \&lt;dígito&gt; funciona en ciertas circunstancias fuera de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(LIST)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(LISTA)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@utmp2 = unpack($utmp_template, $utmp);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@utmp2 = unpack($utmp_template, $utmp);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Basset hounds got long ears&quot; if length $ear &gt;= 10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El perro de caza Basset tiene largas orejas&quot; if length $oreja &gt;= 10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\k&lt;name&gt;  [5]  Named backreference</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224625Z" changeid="explorer">
        <seg>\k&lt;name&gt;  [5]  Contrareferencia nominal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%X    like %x, but using upper-case letters</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%X    como %x, pero usando mayúsculas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use DB_File;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use DB_File;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes a directory opened by C&lt;opendir&gt; and returns the success of that
system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cierra un directorio abierto por C&lt;opendir&gt; y devuelve el éxito de la llamada del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following triples are more or less equivalent:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las siguientes tripletas son, más o menos equivalentes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defined(my $tcp = getprotobyname(&quot;tcp&quot;))</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>defined(my $tcp = getprotobyname(&quot;tcp&quot;))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#{$aref} ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052937Z" changeid="explorer">
        <seg>$#{$aref} ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is false as long as its left operand is false.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es falso, siempre y cuando su operando izquierdo sea falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item libnet</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item libnet</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\$(\w+)/${$1}/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/\$(\w+)/${$1}/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will transliterate any A to X.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>transliterará cualquier A a X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pos($str) = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pos($str) = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//	 m{}	   Pattern match	  yes*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>//	 m{}	    Coincidencia	  sí*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function tells the thingy referenced by REF that it is now an object
in the CLASSNAME package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función dice que la cosa referenciada por REF es ahora un objeto del paquete NOMBRECLASE (I&lt;bless&gt; es bendición en inglés, que se podría traducir mejor por bautizar, en el sentido de 'dar un nombre' al objeto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the
cost of a little more overhead, you can do this by using the /m modifier
on the pattern match operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A costa de una ligera sobrecarga, puede hacer esto usando el modificador /m en el patrón del operador de coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = chown $uid, $gid, 'foo', 'bar';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$num = chown $uid, $gid, 'foo', 'bar';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used on a hash element, it tells you whether the value is defined,
not whether the key exists in the hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa con un elemento de un hash, le indica si el valor está definido, no si la clave existe en el hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syscall returns whatever value returned by the system call it calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Syscall devuelve cualquier valor devuelto por la llamada al sistema que llama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The associated
handler is called with the error text and can change the error
message, if it sees fit, by calling C&lt;die&gt; again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El gestor asociado es llamado con el texto del error y puede cambiar el mensaje de error, si le parece, llamando de nuevo a C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a problem with C&lt;syscall(&amp;SYS_pipe)&gt;: it returns the file
number of the read end of the pipe it creates.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay un problema con C&lt;syscall(&amp;SYS_pipe)&gt;: devuelve el número de archivo de la lectura final de la tubería que crea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the constants is also more portable
than relying on 0, 1, and 2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de las constantes también es más portátil que confiar en 0, 1 y 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open mailbox: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir el buzón: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can preallocate space for a hash by assigning to the keys() function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede pre-reservar espacio para un hash asignando a la función keys().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = (foo =&gt; 11, bar =&gt; 22, baz =&gt; 33);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = (foo =&gt; 11, bar =&gt; 22, baz =&gt; 33);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it returns
inconsistent results (sometimes saying C&lt;$x[1]&gt; is less than C&lt;$x[2]&gt; and
sometimes saying the opposite, for example) the results are not
well-defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si devuelve resultados inconsistentes (algunas veces diciendo que C&lt;$x[1]&gt; es menor que C&lt;$x[2]&gt; y otras veces diciendo lo opuesto, por ejemplo) los resultados no están definidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Platform-Specific</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Plataformas específicas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FUNCTION is a reference to, or the name of,
the function whose prototype you want to retrieve.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FUNCIÓN es una referencia a, o el nombre de, la función cuyo prototipo se desea recuperar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;chr(65)&gt; is C&lt;&quot;A&quot;&gt; in either ASCII or Unicode, and
chr(0x263a) is a Unicode smiley face.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;chr(65)&gt; es C&lt;&quot;A&quot;&gt; tanto en ASCII como en Unicode, y chr(0x263a) es una cara sonriente en Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example, assuming array lengths are passed before arrays:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplo, suponiendo que las longitudes de array se pasan antes que los propios arrays:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does exactly the same thing as C&lt;exec LIST&gt;, except that a fork is
done first, and the parent process waits for the child process to
exit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace exactamente lo mismo que C&lt;exec LISTA&gt;, excepto que se hace primero un fork, y el proceso padre espera a que el proceso hijo termine.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not consider C&lt;getlogin&gt; for authentication: it is not as
secure as C&lt;getpwuid&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No considere usar C&lt;getlogin&gt; para autenticación: no es tan seguro como C&lt;getpwuid&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlpacktut&gt; for an introduction to this function.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192041Z" changeid="explorer">
        <seg>Véase L&lt;perlpacktut&gt; para una introducción a esta función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las opciones son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shifting by a negative number
of bits is also undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desplazando por un número negativo de bits también está indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tell() on pipes, fifos, and sockets usually returns -1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tell() en tuberías, colas, y sockets, por lo general, devuelve -1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns a list of lines
(however you've defined lines with C&lt;$/&gt; or C&lt;$INPUT_RECORD_SEPARATOR&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, devuelve una lista de líneas (según haya definido lo que son líneas con C&lt;$/&gt; o C&lt;$INPUT_RECORD_SEPARATOR&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;child exited with value %d\n&quot;, $?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;hijo terminó con valor %d\n&quot;, $?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 DESCRIPTION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 DESCRIPCIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that functions such as C&lt;keys&gt; and C&lt;values&gt; may return huge lists
when used on large DBM files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que las funciones como C&lt;keys&gt; y C&lt;values&gt; pueden devolver largas listas cuando se usan con archivos DBM grandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($tmp = $global) =~ tr [A-Z] [a-z];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($tmp = $global) =~ tr [A-Z] [a-z];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is usually 32766 on the most common platforms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Éste es, normalmente, 32766, en la mayoría de las plataformas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider giving away your code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere compartir su código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>, =&gt;             {3,7} repeat in range      /o cmpl pat.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>, =&gt;             {3,7} repetir en rango     /o comp.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
operator is not as well defined for negative operands, but it will
execute faster.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este operador no está tan bien definido para operandos negativos, pero se ejecutará más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar  =&gt;  {
                     description =&gt; &quot;single item&quot;,
                     sigil =&gt; '$',
                    },</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055457Z" changeid="explorer">
        <seg>scalar  =&gt;  {
                     description =&gt; &quot;elemento individual&quot;,
                     sigil =&gt; '$',
                    },</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@old) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@viejo) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly for the C&lt;:encoding&gt;
pragma: in that case pretty much any characters can be sent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, para el pragma C&lt;:encoding&gt;: en este caso casi todos los caracteres se pueden enviar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is usually
something to be avoided when writing clear code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto suele ser algo que debe ser evitado cuando se está escribiendo código claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[2]-&gt;[2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[2]-&gt;[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!/usr/bin/env perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232546Z" changeid="explorer">
        <seg>#!/usr/bin/env perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef   Array     array contains undef     grep !defined, @$b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef       Array      array contiene undef             grep !defined, @$b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the working directory to EXPR, if possible.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia el directorio de trabajo a EXPR, si es posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># sort lexically</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ordenación léxica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These examples of the yada
yada are still syntax errors:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos ejemplos de blablablá siguen siendo errores de sintaxis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the lvalue returned by the 3-arg version of substr() acts as
a 'magic bullet'; each time it is assigned to, it remembers which part
of the original string is being modified; for example:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203437Z" changeid="explorer">
        <seg>Tenga en cuenta que el I&lt;ivalor&gt;&gt; devuelto por la versión de 3 argumentos de substr() actúa como una &quot;bala mágica&quot;; cada vez que se le asigna, recuerda qué parte de la cadena original se ha modificado; por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These modifiers are restored at the end of the enclosing group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234807Z" changeid="explorer">
        <seg>Estos modificadores son reiniciados al final del grupo que lo alberga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only operators with lower precedence are the logical operators
&quot;and&quot;, &quot;or&quot;, and &quot;not&quot;, which may be used to evaluate calls to list
operators without the need for extra parentheses:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los únicos operadores con menor prioridad son los operadores lógicos &quot;and&quot;, &quot;or&quot;, y &quot;no&quot;, que pueden ser utilizados para evaluar las llamadas a los operadores de lista sin necesidad de paréntesis adicionales:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># using a prototype allows you to use any comparison subroutine</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># usando un prototipo permite usar cualquier subrutina de comparación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 AUTHORS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T155536Z" changeid="zipf">
        <seg>=head1 AUTORES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are running perl under Mac OS X, you don't want to be
here (unless you are in the Classic environment under early versions of
Mac OS X).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está ejecutando perl bajo Mac OS X, no querra estar aquí (a menos que esté en el entorno Classic en las primeras versiones de Mac OS X).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item my EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item my EXPR : ATRIBUTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'foo{bar}baz'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'foo{bar}baz'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.beos - Perl version 5.8+ on BeOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.beos - Perl versión 5.8+ en BeOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its bytes represent an unsigned integer in base 128,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sus bytes representan un entero sin signo en base 128,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$isdst&gt; is true if the specified time occurs during Daylight Saving
Time, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$isdst&gt; es verdadero si el tiempo especificado se produce durante el horario de verano; en caso contrario, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If CMD is C&lt;IPC_STAT&gt;,
then ARG must be a variable that will hold the returned C&lt;msqid_ds&gt;
structure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si CMD es C&lt;IPC_STAT&gt;, entonces ARG debe ser una variable que contendrá la estructura C&lt;msqid_ds&gt; devuelta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last will raise an exception if Perl does not understand &quot;quads&quot; in your
installation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este último elevará una excepción si Perl no entiende &quot;quads&quot; en su instalación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8 atime    last access time in seconds since the epoch</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>8 atime    tiempo último acceso, en segundos, desde el epoch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If omitted, MASK defaults to 0777.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite, por defecto MÁSCARA es 0777.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Package
modified in such a way shall still be considered the Standard Version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un paquete modificado de esa manera todavía puede ser considerado Versión Estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of the machine architecture on which it runs, the 
example above should print the following table:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Independientemente de la arquitectura de la máquina en la que se ejecuta, el ejemplo anterior debe imprimir el cuadro siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require &quot;Foo::Bar&quot;;   # not a bareword because of the &quot;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require &quot;Foo::Bar&quot;;   # no una palabra suelta por las &quot;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = $sky =~ tr/*/*/;	# count the stars in $sky</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = $sky =~ tr/*/*/;	# cuenta los asteriscos en $sky</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $animals[0];              # prints &quot;camel&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121207Z" changeid="zipf">
        <seg>print $animales[0];  # imprime &quot;camello&quot; en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>modularity and reusability using innumerable modules</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>la modularidad y la reutilización usando innumerables módulos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the values are not copied, which means modifying them will
modify the contents of the hash:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que los valores no son copiados, lo que significa que modificarles modificará el contenido del hash:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On error, C&lt;select&gt; behaves like select(2): it returns
-1 and sets C&lt;$!&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de error, C&lt;select&gt; se comporta como select(2): devuelve -1 y actualiza C&lt;$!&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is 
omitted, it stats C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, ve el estado de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On POSIX systems, you can detect this condition this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas POSIX, puede detectar esta condición de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't cd to spool: $!\n&quot; unless chdir '/usr/spool/news';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo cd a spool: $!\n&quot; unless chdir '/usr/spool/news';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I18N::LangTags</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item I18N::LangTags</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002333Z" changeid="explorer">
        <seg>Use</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># File types.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Tipos de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($X, $Y, $POINTS) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($X, $Y, $PUNTOS) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@hash{qw[key1 key2]}) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach (@hash{qw[key1 key2]}) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For floating-point conversions (C&lt;e f g E F G&gt;), numbers are usually assumed
to be the default floating-point size on your platform (double or long double),
but you can force &quot;long double&quot; with C&lt;q&gt;, C&lt;L&gt;, or C&lt;ll&gt; if your
platform supports them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las conversiones de punto flotante (C&lt;e f g E F G&gt;), se asume que los números son por lo general de punto flotante del tamaño de su plataforma (doble o doble largo), pero se puede forzar &quot;long double&quot; con C&lt;q&gt;, C&lt;L&gt;, o C&lt;ll&gt; si la plataforma es compatible con ellas.&lt;/q&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, this is
a big win except in pathological cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, esto es un gran ahorro, salvo en casos patológicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The
string specified with C&lt;=~&gt; need not be an lvalue--it may be the
result of an expression evaluation, but remember the C&lt;=~&gt; binds
rather tightly.)  See also L&lt;perlre&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203601Z" changeid="explorer">
        <seg>(La cadena especificada con C&lt;=~&gt; no tiene por qué ser un I&lt;ivalor&gt;; puede ser el resultado de una evaluación de una expresión, pero recuerde que C&lt;=~&gt; enlaza más firmemente). Véase también L&lt;perlre&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIST is
also omitted, prints C&lt;$_&gt; to the currently selected output handle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la LISTA también se omite, se imprime C&lt;$_&gt; al actual controlador de salida seleccionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the syntax for a
block and an anonymous hash reference constructor look the same unless
there's something in the braces that give Perl a hint.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, la sintaxis de un bloque y un constructor de referencia a un hash anónimo tienen el mismo aspecto a menos que haya algo dentro de las llaves que le den una pista a Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chomp VARIABLE
X&lt;chomp&gt; X&lt;INPUT_RECORD_SEPARATOR&gt; X&lt;$/&gt; X&lt;newline&gt; X&lt;eol&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170108Z" changeid="explorer">
        <seg>=item chomp VARIABLE
X&lt;chomp&gt; X&lt;INPUT_RECORD_SEPARATOR&gt; X&lt;$/&gt; X&lt;newline&gt; X&lt;eol&gt; X&lt;nueva línea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $SIG{ALRM} = sub { die &quot;alarm\n&quot; }; # NB: \n required</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local $SIG{ALRM} = sub { die &quot;alarma\n&quot; }; # NB: \n necesario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.8 and later will
emulate socketpair using IP sockets to localhost if your system implements
sockets but not socketpair.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl 5.8 y siguientes emularán socketpair usando sockets IP a localhost si el sistema implementa sockets pero no socketpair.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlamiga		Perl notes for AmigaOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlamiga		Notas para AmigaOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$output = `cmd 2&gt;&amp;1`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$salida = `comando 2&gt;&amp;1`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means C&lt;&lt; &lt;$x&gt; &gt;&gt; is always a readline() from
an indirect handle, but C&lt;&lt; &lt;$hash{key}&gt; &gt;&gt; is always a glob().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que C&lt;&lt; &lt;$x&gt; &gt;&gt; siempre es un readline() de una gestor de archivo indirecto, pero C&lt;&lt; &lt;$hash{clave}&gt; &gt;&gt; siempre es un glob().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhurd		Perl notes for Hurd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlhurd		Notas para Hurd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's documented in extravagant detail in L&lt;perlfunc&gt; and L&lt;perlopentut&gt;,
but in short:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225305Z" changeid="explorer">
        <seg>Esta función se describe de forma muy detallada en L&lt;perlfunc&gt; y L&lt;perlopentut&gt;. A continuación se muestra un resumen de cómo se usa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...           +     one or more          /s . includes \n</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043413Z" changeid="explorer">
        <seg>...           +     uno o más            /s . includes \n</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=   assignment</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=   asignación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sub NAME (PROTO) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sub NOMBRE (PROTO) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open STDOUT, '&gt;', &quot;foo.out&quot; or die &quot;Can't redirect STDOUT: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open STDOUT, '&gt;', &quot;foo.out&quot; or die &quot;No puedo redirigir STDOUT: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you get in the habit of using C&lt;&quot;\n&quot;&gt; for networking,
you may be burned some day.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se metes en el hábito de usar C&lt;&quot;\n&quot;&gt; en la gestión de redes, es posible que un día se queme.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/wantarray&gt;
for how you would dynamically discern your function's calling
context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlfunc/wantarray&gt; para saber cómo se averiguaría dinámicamente el contexto en el cual se llamó a una función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CONTEXTS  SIGILS             ARRAYS        HASHES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CONTEXTO  CARACT.            ARRAYS        HASHES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;while&gt; statement executes the block as long as the expression is
L&lt;true|/&quot;Truth and Falsehood&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013344Z" changeid="explorer">
        <seg>La instrucción C&lt;while&gt; ejecuta el bloque mientras la expresión sea L&lt;verdadera|/&quot;Verdad y Falsedad&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typeglobs are also a way to create a local filehandle using the local()
operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Typeglobs son también una manera de crear un gestor de archivo local usando el operador local().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (minimum) width</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item ancho (mínimo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function returns a packed string representing the requested socket
option, or C&lt;undef&gt; on error, with the reason for the error placed in
C&lt;$!&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La llamada devuelve una cadena empaquetada representando la opción socket solicitada, o C&lt;undef&gt; si hay un error, con la razón del error puesta en C&lt;$!&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$straddr = inet_ntoa($iaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$direccion = inet_ntoa($idireccion);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use IO::File;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use IO::File;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item glob EXPR
X&lt;glob&gt; X&lt;wildcard&gt; X&lt;filename, expansion&gt; X&lt;expand&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173832Z" changeid="explorer">
        <seg>=item glob EXPR
X&lt;glob&gt; X&lt;wildcard&gt; X&lt;filename, expansion&gt; X&lt;expand&gt; X&lt;archivo, expansión&gt; X&lt;comodín&gt; X&lt;expandir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using as compiler GCC-2.95.x rev(DG/UX)
an easy solution for configuring perl in your DG/UX
machine is to run the command:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está utilizando como compilador el GCC-2.95.x revisión DG/UX, una solución fácil para la configuración de perl en su máquina DG/UX es ejecutar el comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simply quote all non-&quot;word&quot; characters:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Escape sencillamente todos los caracteres que no formen parte de una palabra:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and UTF-8 (or UTF-EBCDIC in EBCDIC platforms) in byte mode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y UTF-8 (o UTF-EBCDIC en plataformas EBCDIC) en modo byte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># these examples are subject to system-specific variation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># estos ejemplos están sujetos a variaciones específicas del sistema</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the result of</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto, el resultado de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing subroutines is easy:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233231Z" changeid="zipf">
        <seg>Es fácil escribir subrutinas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripted variables such as C&lt;$a[3]&gt; or
C&lt;&lt; $href-&gt;{key}[0] &gt;&gt; are also interpolated, as are array and hash slices.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Variables con subrangos, como C&lt;$a[3]&gt; o C&lt;&lt; $href-&gt;{clave}[0] &gt;&gt; son también interpoladas, así como trozos de array y hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getsockopt SOCKET,LEVEL,OPTNAME
X&lt;getsockopt&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173801Z" changeid="explorer">
        <seg>=item getsockopt SOCKET,NIVEL,OPCIÓN
X&lt;getsockopt&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used in scalar context, the return value generally indicates the
success of the operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa en contexto escalar, el valor devuelto, por lo general, indica el éxito de la operación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} continue {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} continue {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you really mean for such values
to terminate the loop, they should be tested for explicitly:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si realmente quiere mirar por esos valores para terminar el bucle, deben hacerse la prueba de forma explícita:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a module or pragma only needs to be loaded 
conditionally, this can be done using the L&lt;if&gt; pragma:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si un módulo o pragma sólo necesita ser cargado en forma condicional, esto se puede hacer uso del pragma L&lt;if&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ary = (1, 3, sort 4, 2);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ary = (1, 3, sort 4, 2);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldata		Perl data structures</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldata		Estructuras de datos Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If CMD is C&lt;IPC_STAT&gt;,
then ARG must be a variable that will hold the returned C&lt;shmid_ds&gt;
structure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si CMD es C&lt;IPC_STAT&gt;, entonces ARG debe ser una variable que contendrá la estructura C&lt;shmid_ds&gt; devuelta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can browse and search
the Perl 5 bugs at http://bugs.perl.org/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede navegar y buscar en el web de los errores de Perl 5 en http://bugs.perl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LENGTH is negative, leaves that
many characters off the end of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LONGITUD es negativa, deja fuera a tantos caracteres del final de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So
this expression:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que esta expresión:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Packing with a I&lt;length-item&gt; of C&lt;a&gt; or C&lt;Z&gt; may
introduce C&lt;&quot;\000&quot;&gt; characters, which Perl does not regard as legal in
numeric strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Empaquetando con un I&lt;longitud-item&gt; de C&lt;a&gt; o C&lt;Z&gt; puede introducir caracteres C&lt;&quot;\000&quot;&gt;, que Perl no considerará como legal en cadenas numéricas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some syntax errors involving unrecognized filetest operators are now handled
correctly by the parser.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004058Z" changeid="explorer">
        <seg>Algunos errores de sintaxis involucrados en no reconocer operadores de test de archivo son ahora manejados correctamente por el analizador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(OUTPUT, '|sort &gt;foo')  # pipe to sort</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(OUTPUT, '|sort &gt;foo')  # tubería a sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Loop Control
X&lt;loop control&gt; X&lt;loop, control&gt; X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt; X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T041503Z" changeid="explorer">
        <seg>=head2 Control de bucles
X&lt;loop control&gt; X&lt;loop, control&gt; X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt; X&lt;continue&gt; X&lt;control de bucles&gt; X&lt;bucle, control&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Builtin types include:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tipos integrados incluyen:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(C&lt;state&gt; is available only if the C&lt;&quot;state&quot;&gt; feature is enabled.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(C&lt;state&gt; solo está disponible si activa la característica C&lt;&quot;state&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlop		Perl operators and precedence</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlop		Operadores y precedencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to substitute
for a simple identifier, an expression that produces a reference
to the value at runtime.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También, es posible sustituir un simple identificador por una expresión que produzca una referencia al valor en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># run-time warnings enabled after here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># advertencias en ejecución activas desde aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, C&lt;require&gt; demands that a library file be included if it
hasn't already been included.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, C&lt;require&gt; demanda que un archivo de biblioteca sea incluido si no se hubiera incluido ya.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are usually written as &quot;the C&lt;/x&gt; modifier&quot;, even though the delimiter
in question might not really be a slash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos, se describen normalmente como &quot;el modificador C&lt;/x&gt;&quot;, incluso aunque el delimitador en cuestión podría no ser en realidad una barra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map  ( lc($_), 1 ),   @array  # evaluates to (1, @array)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map  ( lc($_), 1 ),   @array  # evalúa a (1, @array)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other boolean contexts, C&lt;&lt; &lt;filehandle&gt; &gt;&gt; without an
explicit C&lt;defined&gt; test or comparison elicits a warning if the
C&lt;use warnings&gt; pragma or the B&lt;-w&gt;
command-line switch (the C&lt;$^W&gt; variable) is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otros contextos booleanos, C&lt;&lt; &lt;gestor-de-archivo&gt; &gt;&gt; sin un explícito C&lt;defined&gt; o comparación, provoca una advertencia si el pragma C&lt;use warnings&gt; o la opción B&lt;-w&gt; en la línea de comandos (la variable C&lt;$^W&gt;) está en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;//&gt; matching operator is documented in L&lt;perlop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225408Z" changeid="explorer">
        <seg>El operador de detección de coincidencias C&lt;//&gt; se describe en L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub fhbits {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub fhbits {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, C&lt;&quot;$foo\Qbaz$bar&quot;&gt;
is converted to C&lt;$foo . (quotemeta(&quot;baz&quot; . $bar))&gt; internally.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054350Z" changeid="explorer">
        <seg>Así, C&lt;&quot;$foo\Qbaz$bar&quot;&gt; es convertida internamente a C&lt;$foo . (quotemeta(&quot;baz&quot; . $bar))&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sentence =~ s{\Q$substring\E}{big bad wolf};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012614Z" changeid="explorer">
        <seg>$instruccion =~ s{\Q$subcadena\E}{gran lobo malo};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rewinddir DIRHANDLE
X&lt;rewinddir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194722Z" changeid="explorer">
        <seg>=item rewinddir GESTOR_DIR
X&lt;rewinddir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's one that avoids the
problem you get into if you explicitly test for end-of-file on
an interactive file descriptor causing your program to appear to
hang.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay una que evita el problema, al comprobar explícitamente, por el fin de archivo en un descriptor de archivo interactivo, que parezca que su programa se haya quedado colgado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sys/libcall error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sys/libcall error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exit EXPR
X&lt;exit&gt; X&lt;terminate&gt; X&lt;abort&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T172829Z" changeid="explorer">
        <seg>=item exit EXPR
X&lt;exit&gt; X&lt;terminate&gt; X&lt;abort&gt; X&lt;abortar&gt; X&lt;terminar&gt; X&lt;salir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-S  File is a socket.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004722Z" changeid="explorer">
        <seg>-S  Archivo es un socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl operators have the following associativity and precedence,
listed from highest precedence to lowest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los operadores Perl tienen la asociatividad y precedencia siguientes, enumerados de mayor a menor prioridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the `#' on the previous line must be the first char on line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># el `#' en la línea anterior debe ser el primer carácter de la línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions new in perl5
X&lt;perl5&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165256Z" changeid="explorer">
        <seg>=item Funciones nuevas en perl5
X&lt;perl5&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within each repetition of a group, positioning with
C&lt;@&gt; starts over at 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dentro de cada repetición de un grupo, posicionarse con C&lt;@&gt; comienza de nuevo en 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Variable names
X&lt;variable, name&gt; X&lt;variable name&gt; X&lt;data type&gt; X&lt;type&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Nombres de variable
X&lt;variable, name&gt; X&lt;variable name&gt; X&lt;data type&gt; X&lt;type&gt;
X&lt;variable, nombre&gt; X&lt;nombre variable&gt; X&lt;tipo dato&gt; X&lt;tipo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++($foo = '99');	# prints '100'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ++($foo = '99');	# imprime '100'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require 5.006_001;  # ditto; preferred for backwards compatibility</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require 5.006_001;  # idem; preferido para mantener la compatibilidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opens a filehandle to an anonymous temporary file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>abre un gestor de archivo a un archivo anónimo temporal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hex() and oct() functions make these conversions
for you.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las funciones hex() y oct() hacen estas conversiones por usted.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and for writing:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y para escritura:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is a bareword, the require assumes a &quot;F&lt;.pm&gt;&quot; extension and
replaces &quot;F&lt;::&gt;&quot; with &quot;F&lt;/&gt;&quot; in the filename for you,
to make it easy to load standard modules.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es una simple palabra, el require asume una extensión &quot;F&lt;.pm&gt;&quot; y le reemplaza &quot;F&lt;::&gt;&quot; con &quot;F&lt;/&gt;&quot; en el nombre del archivo, para que sea fácil cargar módulos estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bar = 20;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bar = 20;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The digest of the password is stored,
not the password itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El I&lt;digest&gt; de una contraseña se almacena, no la propia contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each call disables the
previous timer, and an argument of C&lt;0&gt; may be supplied to cancel the
previous timer without starting a new one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada llamada desactiva el temporizador anterior, y se puede indicar un argumento C&lt;0&gt; para cancelar el temporizador anterior sin empezar uno nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># 0         1          2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># 0         1         2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POSIX 1003.1 compliant library</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>compatible con la biblioteca POSIX 1003.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the typical &quot;match a double-quoted
string&quot; problem can be most efficiently performed when written as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, el problema típico de &quot;coincidir con una cadena doblemente entrecomillada&quot; puede ser más eficientemente realizada cuando se escribe como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># ...		# code for each line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ...		# código por cada línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcn		Perl for Simplified Chinese (in EUC-CN)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlcn		Perl para Chino simplificado (en EUC-CN)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that function names are considered more readable
with parentheses after their name, that is C&lt;function()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note como los nombres de función se vuelven más legibles con los paréntesis detrás de su nombre, como esta C&lt;funcion()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;foreach&gt; probably won't do what you expect if VAR is a tied or other
special variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;foreach&gt; probablemente no hará lo esperado si VAR está enlazada a otra variable especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most systems, you are not allowed to change the ownership of the
file unless you're the superuser, although you should be able to change
the group to any of your secondary groups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de los sistemas, no se le permite cambiar la propiedad del archivo a menos que sea el superusuario, aunque sí pueda cambiar el grupo a cualquiera de sus grupos secundarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When under the C&lt;use filetest 'access'&gt; the above-mentioned filetests
test whether the permission can (not) be granted using the
access(2) family of system calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando esté en C&lt;use filetest 'access'&gt; las comprobaciones de archivo mencionadas arriba comprobarán cuándo los permisos pueden (o no) ser concedidos usando la familia de llamadas del sistema access(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value gives the name of the
filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>GESTOR_ARCHIVO puede ser una expresión cuyo valor da el nombre del gestor de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'Z');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'Z');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interpolation combines with the facts that the opening
and closing parentheses are optional (except when necessary for
precedence) and lists may end with an optional comma to mean that
multiple commas within lists are legal syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta interpolación se combina con el hecho de que la apertura y cierre de paréntesis son opcionales (excepto cuando sea necesario para la precedencia) y las listas pueden terminar con una coma opcional, significando que comas múltiples dentro de las listas es sintaxis legal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array is subscripted by specifying a dollar sign (C&lt;$&gt;), then the
name of the array (without the leading C&lt;@&gt;), then the subscript inside
square brackets.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un array se subindexa especificando un signo dólar (C&lt;$&gt;), entonces el nombre del array (sin el C&lt;@&gt;), seguido del subíndice entre corchetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{
          local $@; # protect existing $@
          eval { test_repugnancy() };
          # $@ =~ /nefarious/ and die $@; # DOES NOT WORK
          $@ =~ /nefarious/ and $e = $@;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044316Z" changeid="explorer">
        <seg>{
          local $@; # protege el actual $@
          eval { test_repugnancia() };
          # $@ =~ /infame/ and die $@; # ESTO NO FUNCIONA
          $@ =~ /infame/ and $e = $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Customary  Generic        Meaning	     Interpolates</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>  Normal   Genérico     Significado	     Interpola</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item semget KEY,NSEMS,FLAGS
X&lt;semget&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200438Z" changeid="explorer">
        <seg>=item semget KEY,NSEMS,FLAGS
X&lt;semget&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default the format for
a file is the one having the same name as the filehandle, but the
format for the current output channel (see the C&lt;select&gt; function) may be set
explicitly by assigning the name of the format to the C&lt;$~&gt; variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto el formato de un archivo es el que tiene el mismo nombre que el gestor de archivo, pero el formato para el canal de salida (véase la función C&lt;select&gt;) se puede establecer de forma explícita mediante la asignación del nombre del formato a la variable C&lt;$~&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,13, 2) = 1   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,13, 2) = 1   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;-&quot; performs arithmetic negation if the operand is numeric.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unario &quot;-&quot; lleva a cabo la negación aritmética si el operando es numérico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getppid
X&lt;getppid&gt; X&lt;parent&gt; X&lt;pid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173550Z" changeid="explorer">
        <seg>=item getppid
X&lt;getppid&gt; X&lt;parent&gt; X&lt;pid&gt; X&lt;padre&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluation of EXPR may be in list, scalar, or void
context, depending on how the return value will be used, and the context
may vary from one execution to the next (see C&lt;wantarray&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evaluación de EXPR puede estar en contextos lista, escalar, o contexto vacío, dependiendo de cómo el valor de retorno será utilizado, y el contexto puede variar de una ejecución a la siguiente (ver C&lt;wantarray&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;characters&gt;: depending on the status of the filehandle,
either (8-bit) bytes or characters are read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note los I&lt;caracteres&gt;: dependiendo del estado del gestor de archivo, son leídos bytes (8-bit) o caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context,
returns the last element removed, or C&lt;undef&gt; if no elements are
removed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el último elemento eliminado, o C&lt;undef&gt; si no hay elementos eliminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open HANDLE, &quot;filename&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open HANDLE, &quot;archivo&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may seem a bit weird,
but that's okay, because it is weird.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ésto puede parecer un poco raro, pero eso está bien, porque es raro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># inspired by :1,$g/fred/s//WILMA/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># inspirado por :1,$g/fred/s//WILMA/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Delete (most) C comments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Eliminar (la mayoría) comentarios C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
final match did indeed match C&lt;p&gt;, it's a good bet that you're running an
older (pre-5.6.0) Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la última coincidencia, es, en su lugar, C&lt;p&gt;, es una buena apuesta de que está ejecutando una versión anterior de Perl (pre-5.6.0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shortsize='2';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shortsize='2';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
the LABEL is omitted, the command refers to the innermost enclosing
loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la ETIQUETA se omite, el comando se refiere al bucle más interior en que se encuentre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other assignment operators work similarly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros operadores de asignación funcionan de manera similar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@sauces = &lt;&lt;End_Lines =~ m/(\S.*\S)/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@salsas = &lt;&lt;Fin_lineas =~ m/(\S.*\S)/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl limits barewords (like
identifiers) to about 250 characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl limita las palabras sueltas (como a los identificadores) a cerca de 250 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;readline&gt; encounters an operating system error, C&lt;$!&gt; will be set
with the corresponding error message.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;readline&gt; encuentra un error del sistema operativo, C&lt;$!&gt; será puesto al correspondiente mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, C&lt;print()&gt; can also take an optional first argument specifying
which filehandle to print to:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225354Z" changeid="explorer">
        <seg>Sin embargo, C&lt;print()&gt; también puede consumir un primer argumento opcional que especifique el identificador de archivo en el que se debe imprimir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VSTRING</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VSTRING</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># The operators -f, -d, -l, -b, -c, -p, and -S.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Los operadores -f, -d, -l, -b, -c, -p, y -S.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new
behaviour in the absence of a SCALAR method is to return TRUE if in the
middle of an C&lt;each&gt; iteration, and otherwise call FIRSTKEY to check if the
hash is empty (making sure that a subsequent C&lt;each&gt; will also begin by
calling FIRSTKEY).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El nuevo comportamiento en ausencia de un método SCALAR es retornar verdadero si está en medio de una iteración C&lt;each&gt;, y de otra manera, llamar a FIRSTKEY para comprobar si el hash está vacío (asegurarse de que una posterior C&lt;each&gt; también comenzará llamando FIRSTKEY).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subroutine that is not defined
may still be callable: its package may have an C&lt;AUTOLOAD&gt; method that
makes it spring into existence the first time that it is called; see
L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una subrutina que no ha sido definida puede ser ejecutada: su paquete puede tener un método C&lt;AUTOLOAD&gt; que la hace aparecer la primera vez que es llamada; ver L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can process line directives, much like the C preprocessor.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl puede procesar directivas como lo hace el preprocesador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Time-related functions
X&lt;time&gt; X&lt;date&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165224Z" changeid="explorer">
        <seg>=item Funciones relacionadas con el tiempo
X&lt;time&gt; X&lt;date&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function msgsnd to send the message MSG to the
message queue ID.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función msgsnd de System V IPC para enviar el mensaje MSG a la cola de mensajes ID.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the substring
is beyond either end of the string, substr() returns the undefined
value and produces a warning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la subcadena está más allá de cada extremo de la cadena, substr() devuelve el valor indefinido y produce una advertencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Filehandles connected to memory objects via new features of C&lt;open&gt; may
return undefined even though they are open.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Gestores conectados a objetos en memoria vía las nuevas posibilidades de C&lt;open&gt; pueden devolver indefinido incluso si están abiertos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlaix		Perl notes for AIX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlaix		Notas para AIX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = 0644;   chmod $mode, &quot;foo&quot;;      # this is best</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = 0644;   chmod $modo, &quot;foo&quot;;      # este es el mejor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to know which files you could not remove, try them one
at a time:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere saber qué archivos no pudo eliminar, trátelos de uno en uno:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one-third of the time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>un tercio de las ocasiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item int EXPR
X&lt;int&gt; X&lt;integer&gt; X&lt;truncate&gt; X&lt;trunc&gt; X&lt;floor&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174013Z" changeid="explorer">
        <seg>=item int EXPR
X&lt;int&gt; X&lt;integer&gt; X&lt;truncate&gt; X&lt;trunc&gt; X&lt;floor&gt; X&lt;truncar&gt; X&lt;trunca&gt; X&lt;entero&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is,
if the left operand is true, the right operand is not even evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, si el operando izquierdo es verdadero, el operando de la derecha no es ni siquiera evaluado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># list context</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># contexto lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; lowercase&quot;),	redo LOOP if /\G[a-z]+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(&quot; minúsculas&quot;),	redo LOOP if /\G[a-z]+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a comparison such as C&lt;$_ E&lt;lt&gt; 10&gt; or C&lt;$x eq &quot;abc&quot;&gt;
(or of course C&lt;$_ ~~ $c&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042810Z" changeid="explorer">
        <seg>una comparación, como C&lt;$_ E&lt;lt&gt; 10&gt; o C&lt;$x eq &quot;abc&quot;&gt; (o, naturalmente, C&lt;$_ ~~ $c&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special case for C&lt;split&gt;, the empty pattern C&lt;//&gt; specifically
matches the empty string; this is not be confused with the normal use
of an empty pattern to mean the last successful match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como un caso especial para C&lt;split&gt;, el patrón vacío C&lt;//&gt; específicamente coincide con la cadena vacía; esto no ha de ser confundido con el uso normal de un patrón vacío que significa la última coincidencia exitosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item symlink OLDFILE,NEWFILE
X&lt;symlink&gt; X&lt;link&gt; X&lt;symbolic link&gt; X&lt;link, symbolic&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204039Z" changeid="explorer">
        <seg>=item symlink VIEJO,NUEVO
X&lt;symlink&gt; X&lt;link&gt; X&lt;symbolic link&gt; X&lt;link, symbolic&gt; X&lt;enlace simbólico&gt; X&lt;enlace&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A list value may also be subscripted like a normal array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una lista de valores también pueden ser indexadas como un array normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3: 'pp', pos=7</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3: 'pp', pos=7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>introduce the perlivp utility for verifying the Perl installation
(IVP = Installation Verification Procedure)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>introducir la utilidad perlivp para comprobar la instalación de Perl (PIV = Procedimiento de Verificación de la instalación)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;scalar&gt; is a unary operator, if you accidentally use for EXPR a
parenthesized list, this behaves as a scalar comma expression, evaluating
all but the last element in void context and returning the final element
evaluated in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que C&lt;scalar&gt; es un operador unario, si, accidentalmente, usa para EXPR una lista entre paréntesis, esto se comportará como una expresión escalar con comas, evaluando todos menos el último elemento en contexto vacío, y devolviendo el elemento final evaluado en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, C&lt;$::sail&gt; is equivalent to
C&lt;$main::sail&gt; (as well as to C&lt;$main'sail&gt;, still seen in ancient
code, mostly from Perl 4).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, C&lt;$::sail&gt; es equivalente a C&lt;$main::sail&gt; (y también a C&lt;$main'sail&gt;, algo que se puede ver en código muy antiguo, escrito en su mayoría en Perl 4).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/etc/games is no good at canasta line 123.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/etc/games no está bien at canasta line 123.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example of setting a filehandle named C&lt;REMOTE&gt; to be
non-blocking at the system level.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo de poner un gestor de archivo llamado C&lt;REMOTE&gt; a no bloqueante a nivel de sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not modify the values
of this hash, as they are the actual values stored in the optree.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No modifique los valores de este hash, ya que son los valores reales almacenados en el árbol de operaciones internas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may apply bug fixes, portability fixes and other modifications
derived from the Public Domain or from the Copyright Holder.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede solicitar correcciones de errores, de portabilidad y otras modificaciones derivadas del Dominio Público o del Titular del Copyright.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void      $scalar   whole:   @array        %hash</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>void      $scalar  completo: @array        %hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>i	Do case-insensitive pattern matching.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>i	Hace coincidencia de patrones independiente del tamaño de caja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value gives the name of
the actual filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>GESTOR_ARCHIVO puede ser una expresión cuyo valor da el nombre del gestor de archivo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example is checking
if a correct password is given.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un ejemplo es comprobando si se ha dado una contraseña correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ( ($home, $user) = (getpwent)[7,0]) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ( ($home, $user) = (getpwent)[7,0]) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no way for pack() and unpack()
to know where characters are going to or coming from, so they 
handle their output and input as flat sequences of characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay forma, para un pack() y unpack(), saber qué caracteres van o vienen, por lo que controlan su salida y entrada como secuencias planas de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously, it
needed to be specified explicitly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Anteriormente, era necesario que se especificara de forma explícita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m	Treat string as multiple lines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>m	Trata la cadena como un conjunto de múltiples líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It calls any
defined C&lt;END&gt; routines first, but these C&lt;END&gt; routines may not
themselves abort the exit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exit() llama primero a cualquier rutina definida C&lt;END&gt;, pero estas rutinas C&lt;END&gt; pueden abortar la salida por sí mismas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the emulation built with lockf(3) doesn't provide shared
locks, and it requires that FILEHANDLE be open with write intent.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211527Z" changeid="explorer">
        <seg>Note que la emulación integrada con lockf(3) no provee de bloqueos compartidos y requiere que el GESTOR_ARCHIVO sea abierto con intención de escribir en el.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print while ($_ = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print while ($_ = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first argument
of the list will be interpreted as the C&lt;printf&gt; format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer argumento de la lista se interpreta como el formato para C&lt;printf&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>contains all the elements of @foo followed by all the elements of @bar,
followed by all the elements returned by the subroutine named SomeSub 
called in list context, followed by the key/value pairs of %glarch.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>contiene todos los elementos de @foo seguido por todos los elementos de @bar, seguido de todos los elementos devueltos por la subrutina llamada AlgunaSub llamada en contexto lista, seguido de los pares clave/valor de %glarch.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\t		tab             (HT, TAB)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002811Z" changeid="explorer">
        <seg>\t		tab              (HT, TAB)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the I&lt;gethost*()&gt; functions, if the C&lt;h_errno&gt; variable is supported in
C, it will be returned to you via C&lt;$?&gt; if the function call fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las funciones I&lt;gethost*()&gt;, si la variable C&lt;h_errno&gt; está soportada en C, será devuelta vía C&lt;$?&gt; si la llamada a la función falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>most significant digit first, with as few digits as possible.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>primero el dígito más significativo, con el menor número posible de dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrecharclass/POSIX Character Classes&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225110Z" changeid="explorer">
        <seg>Véase L&lt;perlrecharclass/Clases carácter POSIX&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes the currently selected filehandle if the argument is
omitted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cierra el gestor actualmente seleccionado si se omite el argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a, $b, undef, $c) = &amp;foo;       # Ignore third value returned</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a, $b, undef, $c) = &amp;foo;       # Ignora tercer valor devuelto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current position of the C&lt;readdir&gt; routines on DIRHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la posición actual de la rutina C&lt;readdir&gt; sobre GESTOR_DIR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$flags = fcntl(REMOTE, F_GETFL, 0)
                or die &quot;Can't get flags for the socket: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044442Z" changeid="explorer">
        <seg>$flags = fcntl(REMOTE, F_GETFL, 0)
                or die &quot;No puedo obtener los flags para el socket: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this code has the same effect as the
Unix touch(1) command when the files I&lt;already exist&gt; and belong to
the user running the program:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, este código tiene el mismo efecto que el comando touch(1) de Unix cuando los archivos &lt;realmente existen&gt; y pertenecen al usuario que ejecuta el programa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
is the internal function implementing the C&lt;\l&gt; escape in
double-quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la función interna que implementa el escapado C&lt;\l&gt; en las cadenas entre comillas dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when it's a list-context assignment and you're trying to use
&quot;||&quot; for control flow, you probably need &quot;or&quot; so that the assignment
takes higher precedence.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, cuando se trata de una asignación en contexto de lista y usted está tratando de usar &quot;||&quot; para el control de flujo, es probable que necesite usar &quot;or&quot; para que la asignación tenga la mayor precedencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given($_) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>given($_) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lexical scoping</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ámbito léxico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;do&gt; cannot read the file, it returns undef and sets C&lt;$!&gt; to the
error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;do&gt; no puede leer el archivo, devuelve undef y pone C&lt;$!&gt; al valor del error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Relational Operators
X&lt;relational operator&gt; X&lt;operator, relational&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235014Z" changeid="explorer">
        <seg>=head2 Operadores relacionales
X&lt;relational operator&gt; X&lt;operator, relational&gt; X&lt;operador relacional&gt; X&lt;operador, relacional&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	++ --</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	++ --</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item s/PATTERN/REPLACEMENT/msixpogce
X&lt;substitute&gt; X&lt;substitution&gt; X&lt;replace&gt; X&lt;regexp, replace&gt;
X&lt;regexp, substitute&gt; X&lt;/m&gt; X&lt;/s&gt; X&lt;/i&gt; X&lt;/x&gt; X&lt;/p&gt; X&lt;/o&gt; X&lt;/g&gt; X&lt;/c&gt; X&lt;/e&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T005933Z" changeid="explorer">
        <seg>=item s/PATRÓN/REEMPLAZO/msixpogce
X&lt;substitute&gt; X&lt;substitution&gt; X&lt;replace&gt; X&lt;regexp, replace&gt;
X&lt;regexp, substitute&gt; X&lt;/m&gt; X&lt;/s&gt; X&lt;/i&gt; X&lt;/x&gt; X&lt;/p&gt; X&lt;/o&gt; X&lt;/g&gt; X&lt;/c&gt; X&lt;/e&gt; X&lt;sustitución&gt; X&lt;reemplazo&gt; X&lt;regexp, reemplazo&gt; X&lt;reemplazo, sustitución&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get the correct function definitions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para obtener las correctas definiciones de la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The standard Math::BigInt and Math::BigFloat modules provide
variable-precision arithmetic and overloaded operators, although
they're currently pretty slow.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los módulos estándar Math::BigInt y Math::BigFloat proporcionan aritmética con precisión variable y sobrecarga de operadores, aunque, en la actualidad, son bastante lentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># exactly the same</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># exactamente lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no EXPR
is given, returns an empty list in list context, the undefined value in
scalar context, and (of course) nothing at all in void context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se indica EXPR, devuelve una lista vacía en contexto de lista, el valor indefinido en el contexto escalar, y (por supuesto) nada en absoluto en el contexto vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly,
C&lt;chomp $a, $b&gt; is interpreted as C&lt;chomp($a), $b&gt; rather than
as C&lt;chomp($a, $b)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Similarmente, C&lt;chomp $a, $b&gt; es interpretado como C&lt;chomp($a), $b&gt; en vez de un C&lt;chomp($a, $b)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,13, 1) = 1   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,13, 1) = 1   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, Perl permits the following widely-supported conversions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, Perl permite las siguientes conversiones ampliamente soportadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only change I've made, that affects BONE systems is the
recognition of whether it is a BONE system or not in C&lt;hints/beos.sh&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El único cambio que he hecho, que afecta a los sistemas BONE es el reconocimiento de si se trata de un sistema BONE o no, en C &lt;hints/beos.sh&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	, =&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	, =&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The build procedure is completely standard:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procedimiento de construcción es completamente estándar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>roll-your-own magic variables (including multiple simultaneous DBM
implementations)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sus propias variables mágicas (incluyendo múltiples implementaciones simultáneas de DBM)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlsyn/&quot;Switch statements&quot;&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225108Z" changeid="explorer">
        <seg>Consulte &quot;Instrucciones switch&quot; en L&lt;perlsyn&gt; para obtener información detallada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: One should not attempt to mix buffered I/O (like C&lt;read&gt;
or &lt;FH&gt;) with C&lt;select&gt;, except as permitted by POSIX, and even
then only on POSIX systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;AVISO&gt; : No debe tratar de mezclar el E/S con buferes (como C&lt;read&gt; o &lt;FH&gt;) con C&lt;select&gt;, excepto lo autorizado por POSIX, e incluso entonces sólo en sistemas POSIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just because you I&lt;CAN&gt; do something a particular way doesn't mean that
you I&lt;SHOULD&gt; do it that way.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo porque usted I&lt;PUEDA&gt; hacer algo de una determinada manera no significa que usted I&lt;DEBA&gt; hacerlo de esa manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So,
C&lt;&quot;\Q\t\E&quot;&gt; is converted to C&lt;quotemeta(&quot;\t&quot;)&gt;, which is the same
as C&lt;&quot;\\\t&quot;&gt; (since TAB is not alphanumeric).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, C&lt;&quot;\Q\t\E&quot;&gt; es convertido a C&lt;quotemeta(&quot;\t&quot;)&gt;, que es lo mismo que C&lt;&quot;\\\t&quot;&gt; (porque TAB no es alfanumérico).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that anything inside
a C&lt;\Q...\E&gt; stays unaffected by C&lt;/x&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También tenga en cuenta que cualquier cosa dentro de un C&lt;\Q...\E&gt; queda afectado por el C&lt;/x&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlform&gt; for other examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlform&gt; para otros ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%vd&quot;, &quot;AB\x{100}&quot;;           # prints &quot;65.66.256&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%vd&quot;, &quot;AB\x{100}&quot;;           # imprime &quot;65.66.256&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is considered a symbolic reference, so
C&lt;use strict 'refs'&gt; should I&lt;not&gt; be in effect.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto se considera una referencia simbólica, por lo que C&lt;use strict 'refs'&gt; I&lt;no&gt; debe estar activada).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldgux		Perl notes for DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldgux		Notas para DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item umask EXPR
X&lt;umask&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210108Z" changeid="explorer">
        <seg>=item umask EXPR
X&lt;umask&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item format
X&lt;format&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173404Z" changeid="explorer">
        <seg>=item format
X&lt;format&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is
particularly useful for dynamic patterns, such as those read in from a
configuration file, taken from an argument, or specified in a table
somewhere.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230844Z" changeid="explorer">
        <seg>Esto es particularmente útil para los patrones dinámicos, como los que se leen desde un archivo de configuración, tomados desde un argumento, o especificados en alguna tabla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not affected by /s
                    modifier</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224920Z" changeid="explorer">
        <seg>No se ve afectado por el
                    modificador /s</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It bypasses buffered IO, so
mixing this with reads (other than C&lt;sysread())&gt;, C&lt;print&gt;, C&lt;write&gt;,
C&lt;seek&gt;, C&lt;tell&gt;, or C&lt;eof&gt; may cause confusion because the perlio and
stdio layers usually buffers data.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Omite E/S con buffer, por lo que mezclar esto con otros tipos de lecturas, C&lt;print&gt;, C&lt;write&gt;, C&lt;seek&gt;, C&lt;tell&gt;, o C&lt;eof&gt; puede causar confusión porque las capas Perlio o stdio por lo general usan búferes de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$debugging = 0 unless defined $debugging;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$debugging = 0 unless defined $debugging;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tests C&lt;lib/Net/Ping/t/450_service.t&gt; and C&lt;lib/Net/Ping/t/510_ping_udp.t&gt;
fail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los test C&lt;lib/Net/Ping/t/450_service.t&gt; y C&lt;lib/Net/Ping/t/510_ping_udp.t&gt; fallan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the embedded C&lt;#&gt; is interpreted as a literal C&lt;#&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que el C&lt;#&gt; incrustado se interpreta como un C&lt;#&gt; literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
changes to the directory specified by C&lt;$ENV{HOME}&gt;, if set; if not,
changes to the directory specified by C&lt;$ENV{LOGDIR}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, cambia al directorio especificado por C&lt;$ENV{HOME}&gt;, si está puesto; si no, cambia al directorio especificado por C&lt;$ENV{LOGDIR}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlobj&gt;, L&lt;perlboot&gt;, L&lt;perltoot&gt;, L&lt;perltooc&gt;,
and L&lt;perlbot&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;perlobj&gt;, L&lt;perlboot&gt;, L&lt;perltoot&gt;, L&lt;perltooc&gt; y L&lt;perlbot&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	| ^</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	| ^</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number 0, the strings C&lt;'0'&gt; and C&lt;''&gt;, the empty list C&lt;()&gt;, and
C&lt;undef&gt; are all false in a boolean context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número 0, las cadenas C&lt;'0'&gt; y C&lt;''&gt;, la cadena vacía C&lt;()&gt; y C&lt;undef&gt; son todos falsos en contexto booleano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#foo];	# slice last 5 items</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#foo];	# trocea los últimos 5 elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub&gt; for other scoping issues.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub&gt; para otras cuestiones sobre el ámbito o contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add Devel::PPPort</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadido Devel::PPPort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;/g&gt; modifier specifies global pattern matching--that is,
matching as many times as possible within the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El modificador C&lt;/g&gt; especifica concordancia global del patrón - es decir, coincidencia tantas veces como sea posible dentro de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After configuration is done correctly give &quot;make&quot; to compile.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Después de la configuración haya terminado, se puede hacer un &quot;make&quot; para compilar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use 5.006_001;  # ditto; preferred for backwards compatibility</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use 5.006_001;  # ídem; preferido para mantener la compatibilidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m m ^ a \s* b mmx;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>m m ^ a \s* b mmx;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the quoting rules for the end of string identifier are not
related to Perl's quoting rules.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, no están relacionadas las reglas de entrecomillado para la cadena de terminación con las reglas de entrecomillado de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset if eof;	    # clear ??</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>reset if eof;	    # limpiar el estado de ??</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several modules that let you calculate with (bound only by
memory and cpu-time) unlimited or fixed precision.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay varios módulos que permiten calcular con precisión fija o ilimitada (limitada únicamente por la memoria y el tiempo de CPU).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use constant FOO =&gt; &quot;something&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use constant FOO =&gt; &quot;algo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any element of LIST is an lvalue, you can modify it by modifying
VAR inside the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si cualquier elemento de LISTA es un I&lt;lvalue&gt; (un valor que puede ponerse en el lado izquierdo de una expresión de asignación), puede modificarlo, modificando VAR dentro del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>W  An unsigned char value (can be greater than 255).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>W  Un valor de un carácter sin signo (puede ser mayor de 255).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Single Quotes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Comillas simples</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may not charge a fee for this Package itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted no puede cobrar una cuota por el Paquete mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you have to
be careful not to include the pattern delimiter in the comment--perl has
no way of knowing you did not intend to close the pattern early.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que hay que tener cuidado de no incluir el delimitador de patrón en el comentario: perl no tiene manera de saber que no tiene intención de cerrar el patrón tan pronto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>d	Delete found but unreplaced characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>d	Elimina los caracteres que se encuentren pero que no hayan sido reemplazados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map { +&quot;\L$_&quot; =&gt; 1  } @array  # perl guesses BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map { +&quot;\L$_&quot; =&gt; 1  } @array  # perl lee bien el BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE
before locking or unlocking it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211519Z" changeid="explorer">
        <seg>Para evitar la posibilidad de descoordinación, Perl ahora vacía el GESTOR_ARCHIVO antes de bloquearlo o desbloquearlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (-x $file &amp;&amp; (($d) = stat(_)) &amp;&amp; $d &lt; 0) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (-x $archivo &amp;&amp; (($d) = stat(_)) &amp;&amp; $d &lt; 0) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a true read(2) system call, see C&lt;sysread&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener una auténtica llamada del sistema read(2), ver C&lt;sysread&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item -X EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># now process $_</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ahora, procesa $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perliol&gt; for detailed info on PerlIO.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perliol&gt; para información detallada sobre PerlIO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple examples to open a file for reading:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplos sencillos para abrir un archivo en modo lectura:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays and slices are interpolated into double-quoted strings
by joining the elements with the delimiter specified in the C&lt;$&quot;&gt;
variable (C&lt;$LIST_SEPARATOR&gt; if &quot;use English;&quot; is specified), 
space by default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Arrays y porciones son interpoladas dentro de cadenas con dobles comillas, uniendo los elementos con el delimitador especificado en la variable &lt;C$&quot;&gt; (C&lt;$LIST_SEPARATOR&gt; si se especifica &quot;use English;&quot;), siendo el espacio en blanco el valor por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $i ( 0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $i ( 0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, each execution of C&lt;m//g&gt; finds the next match,
returning true if it matches, and false if there is no further match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, cada ejecución de C&lt;m//g&gt; encuentra la siguiente coincidencia, devolviendo verdadero si coincide, y falso si no hay ninguna coincidencia más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;/&gt; X&lt;slash&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;/&gt; X&lt;slash&gt; X&lt;barra diagonal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map { (&quot;\L$_&quot; =&gt; 1) } @array  # this also works</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map { (&quot;\L$_&quot; =&gt; 1) } @array  # esto también funciona</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;BEGIN&gt; forces the C&lt;require&gt; and C&lt;import&gt; to happen at compile time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;BEGIN&gt; fuerza a ejecutar a C&lt;require&gt; e C&lt;import&gt; en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When perl is configured to use ithreads, it will use re-entrant library calls
in preference to non-re-entrant versions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando Perl está configurado para usar ithreads, usará llamadas de biblioteca reentrantes preferentemente sobre versiones no-reentrantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $1 while /(p)/gc; print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $1 while /(p)/gc; print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the smart match
implicitly dereferences any non-blessed hash or array ref, so the &quot;Hash&quot;
and &quot;Array&quot; entries apply in those cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la coincidencia inteligente, implícitamente, desreferencia cualquier referencia hash o array no bendecida, así que las entradas &quot;Hash&quot; y &quot;Array&quot; se aplican en estos casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ARRAY[++$#ARRAY] = $value;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ARRAY[++$#ARRAY] = $valor;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DIRHANDLEs have their own namespace separate from FILEHANDLEs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los GESTOR_DIR tienen su propio espacio de nombres separados de los GESTORes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also
L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, C&lt;IPC::SysV::Semaphore&gt;
documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, y C&lt;IPC::Semaphore&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Leading whitespace is ignored in all three cases.)
The following will handle decimal, binary, octal, and hex in standard
Perl notation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco que le rodea es ignorado en los tres casos). Lo que le sigue se interpretará como un decimal, binario, octal y hexadecimal en la notación estándar de Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub systell { sysseek($_[0], 0, SEEK_CUR) }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub systell { sysseek($_[0], 0, SEEK_CUR) }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pragma/warnings             333    1   0.30%  215</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pragma/warnings             333    1   0.30%  215</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iterator is implicitly reset when C&lt;each&gt; has reached
the end as just described; it can be explicitly reset by calling C&lt;keys&gt; or
C&lt;values&gt; on the hash or array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El iterador es implícitamente restablecido cuando C&lt;each&gt; ha llegado al final como se acaba de describir; puede ser explícitamente restablecido llamando a C&lt;keys&gt; o C&lt;values&gt; sobre el hash o array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you have to write</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tiene que escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Modules and Pragmata</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Módulos y Pragmata</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13452</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13452</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also, in the Bourne shell tradition, specify an EXPR beginning
with C&lt;&lt; '&gt;&amp;' &gt;&gt;, in which case the rest of the string is interpreted
as the name of a filehandle (or file descriptor, if numeric) to be
duped (as C&lt;dup(2)&gt;) and opened.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede también, en la tradición de Bourne shell, especificar una EXPR comenzando con C&lt;&lt; '&gt;&amp;' &gt;&gt;, en cuyo caso el resto de la cadena se interpreta como el nombre de un gestor de archivo (o descriptor de archivo, si es numérico) para que sea duplicado (con C&lt;dup(2)&gt; ) y luego abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must ensure your strings don't exceed this
limit after any necessary interpolations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe asegurarse de que sus cadenas de texto no superan ese límite después de cualquier necesaria interpolación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Module ();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Módulo ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FETCH this,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FETCH este,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 ]) { s/peter/paul/ }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>10 ]) { s/pedro/pablo/ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a return value of C&lt;-1&gt; could mean that child processes are
being automatically reaped, as described in L&lt;perlipc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que un valor devuelto de C&lt;-1&gt; podría significar que los procesos hijos se están automáticamente desechando, como se describe en L&lt;perlipc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When
unpacking, C&lt;A&gt; strips trailing whitespace and nulls, C&lt;Z&gt; strips everything
after the first null, and C&lt;a&gt; returns data without any sort of trimming.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al desempaquetar, C&lt;A&gt; elimina el espacio en blanco y nulos sobrantes al final, C&lt;Z&gt; elimina todo después del primer nulo, y C&lt;a&gt; devuelve los datos sin ningún tipo de recorte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = &quot;0644&quot;; chmod oct($mode), &quot;foo&quot;; # this is better</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = &quot;0644&quot;; chmod oct($modo), &quot;foo&quot;; # este es mejor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to check for C&lt;defined&gt; on the return from C&lt;fcntl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No necesita comprobar con C&lt;defined&gt; al regreso de C&lt;fcntl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this is not true of lists, which return
the last value, like the C comma operator, nor of built-in functions,
which return whatever they feel like returning.)  The following is
always true:
X&lt;array, length&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Note que esto no es cierto para las listas, que devuelven el último valor, como el operador coma de C, y tampoco para las funciones incorporadas, que devuelven lo que les parezca mejor devolver). Lo siguiente es siempre verdadero:
X&lt;array, length&gt; X&lt;array, longitud&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful with sockets when you want to tell the other
side you're done writing but not done reading, or vice versa.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil con sockets cuando desee decirle al otro lado que ha terminado de escribir, pero no ha terminado la lectura, o viceversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A patch for FreeBSD libc is available
(see http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631 )
which has been integrated into FreeBSD 4.6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un parche para la libc de FreeBSD está disponible (ver http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631 ) y ha sido integrado en FreeBSD 4.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'aaaa' =~ /a++a/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'aaaa' =~ /a++a/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getgrent();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$name  = getgrent();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl was made to be
a glue language, and one of the things it glues together is commands.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl fue creado para ser un lenguaje pegamento, y una de las cosas que aglutina, son los comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return print(reverse(sort num (values(%array))));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return print(reverse(sort num (values(%array))));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;The price is $Price.\n&quot;;	# interpolated</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El precio es $Precio.\n&quot;;  # interpolado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@many =  glob &quot;{apple,tomato,cherry}={green,yellow,red}&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@muchos =  glob &quot;{manzana,tomate,cereza}={verde,amarilla,roja}&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/do&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlfunc/do&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://perlmonks.org/?node_id=216602      the original PM post</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://perlmonks.org/?node_id=216602      la publicación original en PM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These routines are the same as their counterparts in the
system C library.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas rutinas son las mismas que sus homólogas en la biblioteca del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;split&gt; with no arguments
really does a S&lt;C&lt;split(' ', $_)&gt;&gt; internally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;split&gt; sin argumentos realmente es internamente un S&lt;C&lt;split(' ', $_)&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Perl doesn't look
ahead for the closing C&lt;}&gt; it has to take a guess at which it's dealing with
based on what it finds just after the C&lt;{&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que Perl no mira por adelantado por el cierre C&lt;}&gt;, tiene que hacer una conjetura por la que tiene que lidiar en base a lo que encuentra justo después de la &lt;C{&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In those cases the value of EXPR is used directly as a boolean.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estos casos el valor de EXPR es usado directamente como un booleano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but is more efficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pero es más eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wh.space</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>wh.space</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Exists\n&quot;  if exists &amp;subroutine;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Existe\n&quot;   if exists  &amp;subrutina;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closing a pipe also waits for the process executing
on the pipe to exit--in case you wish to look at the output of the pipe
afterwards--and implicitly puts the exit status value of that command into
C&lt;$?&gt; and C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El proceso de cierre de una tubería también espera por el proceso de ejecución en la tubería antes de salir -en caso de que desee ver después la salida de la tubería- e, implícitamente, pone el valor de estado de salida de ese comando en C&lt;$?&gt; y C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILENAME is
omitted, does a C&lt;chroot&gt; to C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ARCHIVO se omite, hace un C&lt;chroot&gt; a C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr [abc]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr [abc]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Can do.\n&quot; if -r $a || -w _ || -x _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Puedo hacerlo.\n&quot; if -r $a || -w _ || -x _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Efficient but
                   dangerous.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050709Z" changeid="explorer">
        <seg>Eficiente pero
                   peligroso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># expand tabs to 8-column spacing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># expandir tabuladores a un espaciado de 8 columnas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;-T&gt; and C&lt;-B&gt; switches work as follows.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las opciones C&lt;-T&gt; y C&lt;-B&gt; funcionan como sigue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The character following C&lt;\c&gt; is mapped to some other character by
converting letters to upper case and then (on ASCII systems) by inverting
the 7th bit (0x40).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El carácter que sigue a C&lt;\c&gt; es mapeado a otro carácter convirtiendo las letras a mayúsculas y luego, en sistemas ASCII, invirtiendo el séptimo bit (0x40).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>probably doesn't do what you expect at first glance.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>probablemente no hace lo que usted espera, a primera vista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When presented with something that might have several different
interpretations, Perl uses the B&lt;DWIM&gt; (that's &quot;Do What I Mean&quot;)
principle to pick the most probable interpretation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se le presenta algo que podría tener varias interpretaciones diferentes, Perl utiliza el B&lt;DWIM&gt; (&quot;I&lt;Do What I Mean&gt;&quot;, es decir, &quot;hacer lo que quiero decir&quot;) para escoger la interpretación más probable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Utility Changes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Cambios en las herramientas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;in bytes&gt;: even if the filehandle has been set to
operate on characters (for example by using the C&lt;:encoding(utf8)&gt; open
layer), tell() will return byte offsets, not character offsets
(because implementing that would render seek() and tell() rather slow).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota sobre lo de I&lt;en bytes&gt;: incluso si el gestor de archivo se ha puesto para operar en caracteres (por ejemplo usando la capa de open C&lt;:encoding(utf8)&gt;), tell() devolverá desplazamientos en bytes, no en caracteres (porque implementando esto convertirían en lentas a seek() y tell()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;continue&gt; block, if any, is I&lt;not&gt; executed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bloque C&lt;continue&gt;, si está, no es ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the lower bound
is not optional.)  The &quot;*&quot; quantifier is equivalent to C&lt;{0,}&gt;, the &quot;+&quot;
quantifier to C&lt;{1,}&gt;, and the &quot;?&quot; quantifier to C&lt;{0,1}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, el límite inferior no es opcional). El cuantificador &quot;*&quot; es equivalente a C&lt;{0,}&gt;, el cuantificador &quot;+&quot; a C&lt;{1,}&gt;, y el cuantificador &quot;?&quot; a C&lt;{0,1}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it does not change
semantics, details of this step are not documented and are subject
to change without notice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ya que no cambia la semántica, los detalles de este paso no están documentados y están sujetas a cambios sin previo aviso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;unless&gt; can even be followed by one or more C&lt;elsif&gt;
statements, though you may want to think twice before using that particular
language construct, as everyone reading your code will have to think at least
twice before they can understand what's going on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013335Z" changeid="explorer">
        <seg>C&lt;unless&gt; puede, incluso, ser seguido por una o más instrucciones C&lt;elsif&gt;, aunque quizás quiera pensarlo dos veces antes de usar esta construcción del lenguaje tan particular, lo mismo que cualquiera que al leer su código tendrá que pensar al menos dos veces antes de entender qué ha querido decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if those
operations have succeeded and if no error was reported by any PerlIO
layer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si las operaciones han tenido éxito y si ningún error fue reportado por alguna capa PerlIO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print sqrt(-4);    # prints 2i</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print sqrt(-4);    # imprime 2i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing with Unicode circled letters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo con letras Unicode acentuadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open my($fh), '&gt;', '/dev/passwd' or ...;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open my($fh), '&gt;', '/dev/passwd' or ...;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An exception to this is that you may assign to C&lt;undef&gt; in a list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T004414Z" changeid="explorer">
        <seg>Una excepción a esto es que puede asignar C&lt;undef&gt; en una lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Others are experimental
and may change without warning or be completely removed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros son experimentales y pueden cambiar sin previo aviso o ser retirados por completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in the example above, the final
C&lt;print $y&gt; would cause a compile-time error and prevent you from
running the program.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225058Z" changeid="explorer">
        <seg>Así, en el ejemplo anterior, la última instrucción C&lt;print $y&gt; provocará una error en tiempo de compilación que impedirá la ejecución del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash entries are returned in an apparently random order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las entradas de un hash son devueltas en un aparente orden aleatorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Using Perl modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230900Z" changeid="zipf">
        <seg>=head2 Utilización de módulos de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SALT used
to create the digest is visible as part of the digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El SALTO usado para crear el I&lt;digest&gt; es visible como parte del I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For different
quoting constructs, Perl performs different numbers of passes, from
one to four, but these passes are always performed in the same order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para diferentes construcciones de entrecomillado, Perl realiza diferentes números de pases, de uno a cuatro, pero estos pases se realizan siempre en el mismo orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readpipe
X&lt;readpipe&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194435Z" changeid="explorer">
        <seg>=item readpipe
X&lt;readpipe&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;undef&gt; indicates that the search position
is reset (usually due to match failure, but can also be because no match has
yet been run on the scalar).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;undef&gt; indica que la posición de búsqueda se restablece (generalmente debido a un fallo de coincidencia, pero también puede ser porque aún no ha sido ejecutada la coincidencia sobre el escalar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The sheet</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 La hoja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$baz = &quot;\n&quot;;		# a one-character string</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$baz = &quot;\n&quot;;		# una cadena de un carácter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$fruit_color{&quot;apple&quot;};           # gives &quot;red&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025842Z" changeid="explorer">
        <seg>$color_fruta{&quot;manzana&quot;};         # devuelve &quot;rojo&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, change &quot;.&quot; to match any character
whatsoever, even a newline, which normally it would not match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, cambia &quot;.&quot; para que coincida con cualquier carácter, incluso el de nueva línea, que normalmente no coincidiría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in B&lt;csh&gt;, no translation is done on the return data--newlines
remain newlines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de B&lt;csh&gt;, no se realiza traducción en el retorno de los datos: los caracteres de fin de línea siguen siendo caracteres de fin de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;The animal is $animal\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T231001Z" changeid="zipf">
        <seg>print &quot;El animal es $animal\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpragma		Perl modules: writing a user pragma</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlpragma		Módulos Perl: escribiendo un pragma</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function implementing the C&lt;qx/EXPR/&gt;
operator, but you can use it directly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es la función interna que implementa el operador C&lt;qx/EXPR/&gt;, pero puede usarla directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = (($foo,$bar) = (3,2,1));       # set $x to 3, not 2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035738Z" changeid="explorer">
        <seg>$x = (($foo,$bar) = (3,2,1));       # pone $x a 3, no 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Be aware&gt; that calling delete on array values is deprecated and likely to
be removed in a future version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015954Z" changeid="explorer">
        <seg>B&lt;Queda avisado&gt; que borrar elementos de un array mediante delete() es una funcionalidad obsoleta y es probable que sea eliminada en una futura versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array   CodeRef   sub truth for each elt[1] !grep { !$b-&gt;($_) } @$a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Array       RefCódigo  sub verdad por cada elemento[1]  !grep { !$b-&gt;($_) } @$a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next LINE if /^#/;	# discard comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next LINEA if /^#/;	# descartar los comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's more than one
reason you're encouraged to restrict your delimiters to non-alphanumeric,
non-whitespace choices.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay más motivos que nos alientan para restringir sus delimitadores a elecciones no alfanuméricas ni espacios en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some more examples; be aware that when using an explicit
index, the C&lt;$&gt; may need escaping:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Éstos son algunos ejemplos más; sea consciente de que cuando se utiliza un índice explícito, el C&lt;$&gt; puede ser necesario escaparlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are introduced by a keyword which
the extension recognises, and the syntax following the keyword is
defined entirely by the extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Son presentadas por un identificador que la extensión reconoce, y la sintaxis que le sigue se define enteramente por la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (&amp;aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (&amp;aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This isn't a particularly good seed, so many old
programs supply their own seed value (often C&lt;time ^ $$&gt; or C&lt;time ^
($$ + ($$ &lt;&lt; 15))&gt;), but that isn't necessary any more.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto no es una buena semilla, por lo que demasiados viejos programas tienen sus propias semillas (a menudo C&lt;time ^ $$&gt; o C&lt;time ^ ($$ + ($$ &lt;&lt; 15))&gt;), pero esto ya no es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The way C&lt;study&gt; works is this: a linked list of every
character in the string to be searched is made, so we know, for
example, where all the C&lt;'k'&gt; characters are.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(La forma en que C&lt;study&gt; funciona es la siguiente: se crea una lista enlazada de todos los caracteres en la cadena que se deben buscar, así sabremos, por ejemplo, donde están todos los caracteres C&lt;'k'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = chmod 0755, &quot;foo&quot;, &quot;bar&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = chmod 0755, &quot;foo&quot;, &quot;bar&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are suspected to be compiler errors (at least the shuffle.t
failure is known from some IRIX 6 setups) and math library errors
(the Trig.t failure), but since IRIX 5 is long since end-of-lifed,
further fixes for the IRIX are unlikely.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005239Z" changeid="explorer">
        <seg>Son sospechosos de ser errores del compilador (por lo menos, del fallo de shuffle.t se sabe de algunos IRIX seis configuraciones) y los errores de la biblioteca matemática (el fallo de Trig.t), pero como IRIX 5 está desde hace mucho tiempo al final de su vida, son poco probables los arreglos de errores para el IRIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5111delta	Perl changes in version 5.11.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5111delta	Cambios en la versión 5.11.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $oops = substr $name, 7;      # returns undef, with warning</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $oops = substr $nombre, 7;     # devuelve undef, con advertencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a, $b, $c) = (1, 2, 3);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a, $b, $c) = (1, 2, 3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4 uid      numeric user ID of file's owner</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>4 uid      ID numérico del usuario propietario del archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with filehandle reads, an automatic C&lt;defined&gt; is
generated when the glob occurs in the test part of a C&lt;while&gt;,
because legal glob returns (e.g. a file called F&lt;0&gt;) would otherwise
terminate the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que cuando un gestor de archivo lee, un C&lt;defined&gt; es generado cuando la expansión se produce en la parte de prueba de un C&lt;while&gt;, porque una expansión legal así lo devuelve (por ejemplo, un archivo llamado F&lt;0&gt;); de otra manera terminaría el bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other layers that would affect the binary nature of the stream are
I&lt;also&gt; disabled.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-- otras capas que pudieran afectar la naturaleza binaria del flujo son I&lt;también&gt; desactivadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at foo bar line 200.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at foo bar line 200.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} @old;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} @viejo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then any bareword that would NOT be interpreted as a subroutine call
produces a compile-time error instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>entonces cualquier palabra suelta que NO pueda ser interpretada como una llamada de subrutina, produce en su lugar un error en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># foo eq &quot;ABCD&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># foo es &quot;ABCD&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some words in English work this way, like &quot;fish&quot;
and &quot;sheep&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existen algunas palabras en Español que funcionan de esa manera, como &quot;crisis&quot;, &quot;ciempiés&quot; o &quot;lunes&quot;, que actúan de singular o plural dependiendo del contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>admin($_)   when [ qw/Alice Bob/ ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>admin($_)  when [ qw/Alice Bob/ ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
Boolean context is just a special kind of scalar context where no 
conversion to a string or a number is ever performed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El contexto booleano es simplemente un tipo especial de contexto escalar para el cual ni siquiera se llega a realizar ninguna conversión a cadena o a número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context it evaluates
its left argument, throws that value away, then evaluates its right
argument and returns that value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar evalúa su argumento de la izquierda, descarta este valor, y luego evalúa su argumento de la derecha y devuelve este valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @{$ref-&gt;[$x][$y]}{$key1, $key2, @morekeys};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @{$ref-&gt;[$x][$y]}{$clave1, $clave2, @masclaves};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FETCHSIZE this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FETCHSIZE este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the very least it will let some poor
schmuck bounce on the % key in B&lt;vi&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo menos esto hará que algún pobre inútil pueda usar la tecla % en B&lt;vi&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a system
error, returns the undefined value and sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay un error del sistema, devuelve el valor indefinido y actualiza C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next LINE if (1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next LINEA if (1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you're storing FILEHANDLEs in an array, or if you're using
any other expression more complex than a scalar variable to retrieve it,
you will have to use a block returning the filehandle value instead:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si usted está almacenando el GESTOR_ARCHIVO en un array, o si está usando cualquier otra expresión más compleja que una variable escalar para recuperarlo, tendrá que utilizar un bloque que retorne el valor del gestor de archivo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;in bytes&gt;: even if the filehandle has been set to
operate on characters (for example by using the C&lt;:encoding(utf8)&gt; open
layer), tell() will return byte offsets, not character offsets (because
that would render seek() and tell() rather slow).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota sobre lo de I&lt;en bytes&gt;: incluso si el gestor de archivo se ha puesto para operar en caracteres (por ejemplo usando la capa de open C&lt;:encoding(utf8)&gt;), tell() devolverá desplazamientos en bytes, no en caracteres (porque implementando esto convertirían en lentas a seek() y tell()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for this mechanism is the same as for most
C preprocessors: it matches the regular expression</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La sintaxis de este mecanismo es el mismo que para la mayoría de preprocesadores de C: coincide con la expresión regular</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>end (before \n) /m line based ^$</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234151Z" changeid="explorer">
        <seg> cad. (antes \n) /m line based ^$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;.&gt;, where it means relative to the start of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;.&gt;, donde significa relativo al inicio de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vea más abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a close-on-exec flag on files, that flag is set
on all newly opened file descriptors whose C&lt;fileno&gt;s are I&lt;higher&gt; than 
the current value of $^F (by default 2 for C&lt;STDERR&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En los sistemas que soportan las banderas cerrado-en-ejecución en los archivos, esas banderas se encuentran en todos los nuevos descriptores de archivos abiertos cuyo C&lt;fileno&gt; sean más I&lt;altos&gt; que el valor actual de $^F (por defecto 2 para C&lt;STDERR&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the argument before the ? is true, the
argument before the : is returned, otherwise the argument after the :
is returned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053827Z" changeid="explorer">
        <seg>Si el argumento anterior al ? es verdadero, se devuelve el argumento anterior al &quot;:&quot;; de lo contrario se devuelve el argumento posterior a &quot;:&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stat($filename);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>stat($nombre_de_archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;{&gt; starts both hash references and blocks, so C&lt;map { ...&gt; could be either
the start of map BLOCK LIST or map EXPR, LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;{&gt; comienza tanto una referencia a hash como bloques, por lo que C&lt;map { ...&gt; podría ser tanto el comienzo de map BLOQUE LISTA o map EXPR, LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $success = 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $exito = 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL while (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA while (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [5]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225328Z" changeid="explorer">
        <seg>=item [5]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print($foo, exit);	# Obviously not what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print($foo, exit);	# Obviamente, no lo que quiere hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { ... };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { ... };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of Perl 5.9.1, as a form of purely syntactic sugar, you can stack file
test operators, in a way that C&lt;-f -w -x $file&gt; is equivalent to
C&lt;-x $file &amp;&amp; -w _ &amp;&amp; -f _&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como en Perl 5.9.1, una dulce forma, puramente sintáctica, puede apilar operadores de test de archivo, de forma que C&lt;-f -w -x $archivo&gt; es equivalente a C&lt;-x $archivo &amp;&amp; -w _ &amp;&amp; -f _&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item binmode FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211205Z" changeid="explorer">
        <seg>=item binmode GESTOR_ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlglossary - Perl Glossary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlglossary	- Glosario Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc&gt; for an example of socketpair use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc&gt; para un ejemplo de uso de socketpair.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EOF</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EOF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If BITS is 16 or more, bytes of the input string are grouped into chunks
of size BITS/8, and each group is converted to a number as with
pack()/unpack() with big-endian formats C&lt;n&gt;/C&lt;N&gt; (and analogously
for BITS==64).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si BITS es de 16 o más, los bytes de la cadena de entrada se agrupan en bloques de tamaño BITS/8, y cada grupo es convertido a un número como con pack()/unpack() con formatos big-endian C&lt;n&gt;/C&lt;N&gt; (Y, análogamente para BITS==64).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certain operations
return list values in contexts wanting a list, and scalar values
otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ciertas operaciones devuelven una lista de valores en contextos que esperan una lista, y valores escalares en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EOC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EOC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no string is specified via the C&lt;=~&gt; or C&lt;!~&gt; operator, the C&lt;$_&gt;
variable is searched and modified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se especifica una cadena a través de los operadores C&lt;=~&gt; o C&lt;!~&gt;, se utiliza la variable C&lt;$_&gt; para la búsqueda y la modificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/^\d+$/ &amp;&amp; $_ &lt; 75) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/^\d+$/ &amp;&amp; $_ &lt; 75) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $members value returned by I&lt;getgr*()&gt; is a space separated list of
the login names of the members of the group.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de $miembros  devuelto por I&lt;getgr*()&gt; es una lista separada por espacios de los nombres de login de los miembros del grupo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's
cleaner because it's less noisy.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más limpio porque es menos ruidoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two major contexts: list and scalar.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T000203Z" changeid="explorer">
        <seg>Hay dos tipos principales de contexto: lista y escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EOL</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EOL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%+d&gt;',  12;   # prints &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%+d&gt;',  12;   # imprime &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns like C&lt;ioctl&gt;:
the undefined value for error, &quot;C&lt;0 but true&gt;&quot; for zero, or the actual
return value otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve lo mismo que C&lt;ioctl&gt;: el valor indefinido para error, C&lt;&quot;0 but true&quot;&gt; para el cero, o el valor de retorno real, en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EOT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EOT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But
anything more complicated in the subscript will be interpreted as an
expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero cualquier otra cosa más complicada, en el subíndice, se interpretará como una expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [6]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225402Z" changeid="explorer">
        <seg>=item [6]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 while foo();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 while foo();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;$hash{&quot;$foo/$bar&quot;}&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;$hash{&quot;$foo/$bar&quot;}&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sun Microsystems has released a port of their Sun Studio compiliers for
Linux.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sun Microsystems ha lanzado una versión de sus compiladores Sun Studio para Linux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;cmp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;cmp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You will not be required to justify it to the Copyright Holder, but
only to the computing community at large as a market that must bear the
fee.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(No se requerirá la justificación al Titular del Copyright, pero sólo a la comunidad informática en general como un mercado que debe tener la tasa).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You just know it will be done sometime
before or after the value is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo sabe que se hará en algún momento antes o después de que el valor sea devuelto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($days[3], $days[4], $days[5]) = qw/Wed Thu Fri/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($dias[3], $dias[4], $dias[5]) = qw/Mié Jue Vie/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &lt;EXPR&gt; &gt;&gt;
operator is discussed in more detail in L&lt;perlop/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador C&lt;&lt; &lt;EXPR&gt; &gt;&gt; se discute con más detalle en L&lt;perlop/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chdir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [7]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225427Z" changeid="explorer">
        <seg>=item [7]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alex Waugh &lt;alex@alexwaugh.com&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alex Waugh &lt;alex@alexwaugh.com&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>makes $this an alias for $that, @this an alias for @that, %this an alias
for %that, &amp;this an alias for &amp;that, etc.  Much safer is to use a reference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005416Z" changeid="explorer">
        <seg>hace que $este sea un alias de $ese, @este sea un alias de @ese, %este sea un alias de %ese, etc. Es mucho más seguro usar una referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Platform Specific Problems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Problemas en plataformas específicas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item do BLOCK
X&lt;do&gt; X&lt;block&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171422Z" changeid="explorer">
        <seg>=item do BLOQUE
X&lt;do&gt; X&lt;block&gt; X&lt;bloque&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This unary
operator takes one argument, either a filename, a filehandle, or a dirhandle, 
and tests the associated file to see if something is true about it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004357Z" changeid="explorer">
        <seg>Este operador unario toma un argumento, bien sea un nombre de archivo o un gestor de archivo o gestor de directorio, y comprueba el archivo asociado para ver si algo sobre él es cierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Config;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Config;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>setsockopt($socket, IPPROTO_TCP, TCP_NODELAY, 1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>setsockopt($socket, IPPROTO_TCP, TCP_NODELAY, 1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$wid += $jet;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$wid += $jet;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three forms: C&lt;goto&gt;-LABEL, C&lt;goto&gt;-EXPR, and
C&lt;goto&gt;-&amp;NAME.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existen tres formas: C&lt;goto&gt;-ETIQUETA, C&lt;goto&gt;-EXPR y C&lt;goto&gt;-&amp;NOMBRE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't use C&lt;exit&gt; to abort a subroutine if there's any chance that
someone might want to trap whatever error happened.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No use C&lt;exit&gt; para abortar una subrutina si existe la posibilidad de que alguien pueda capturar el error que ocurrió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, just because an operator lets you assume default arguments
doesn't mean that you have to make use of the defaults.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma similar, sólo porque un operador le permite asumir argumentos por defecto no significa que usted tenga que hacer uso de esos valores por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*s&gt;',  0, &quot;string&quot;;   # prints &quot;&lt;&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*s&gt;',  0, &quot;cadena&quot;;   # imprime &quot;&lt;&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello $_!\n&quot; foreach qw(world Dolly nurse);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Hola $_!\n&quot; foreach qw(mundo Dolly enfermera);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval `cat stat.pl`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval `cat stat.pl`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until a release of these compilers is made, support for compiling Perl with
these compiler experimental.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hasta que una liberación de estos compiladores sea hecha, el soporte para la compilación de Perl con estas herramientas es experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?+     Match 0 or 1 time and give nothing back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>?+     Coincide 0 o 1 veces y no devuelve nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># to the variable name, and then evaluated</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># al nombre de la variable, y entonces, evaluada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only resets variables or searches in the current package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo se restablecen variables o búsquedas en el paquete actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>END</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>END</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>temporarily makes $Here::blue an alias for $There::green, but doesn't
make @Here::blue an alias for @There::green, or %Here::blue an alias for
%There::green, etc.  See L&lt;perlmod/&quot;Symbol Tables&quot;&gt; for more examples
of this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>temporalmente hace que $Aqui::azul sea un alias de $Ahi::verde, pero no hace que @Aqui::azul sea un alias de @Ahi::verde, o que %Aqui::azul sea un alias de %Ahi::verde, etc. Ver L&lt;perlmod/&quot;Tablas de símbolos&quot;&gt; para más ejemplos sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getc</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Digest</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Digest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If more than one value is listed, the list must
be placed in parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se lista más de un valor, esa lista debe ser puesta entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It magically differs from
a string containing the same characters: C&lt;ref(qr/x/)&gt; returns &quot;Regexp&quot;,
even though dereferencing the result returns undef.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De manera mágica se distingue de una cadena que contenga los mismos caracteres: C&lt;ref(qr/x/)&gt; devuelve &quot;Regexp&quot;, incluso aunque desreferenciando el resultado devuelva undef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use whitespace and the C&lt;&lt; =&gt; &gt;&gt; operator to lay them out more
nicely:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224923Z" changeid="explorer">
        <seg>Puede usar espacio en blanco y el operador C&lt;&lt; =&gt; &gt;&gt; para expresarlos de manera más clara:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsyn - Perl syntax</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsyn - Sintaxis de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are not allowed to override the byte-order within a group
that already has a byte-order modifier suffix.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No está autorizado a anular la ordenación de bytes dentro de un grupo que ya tenga un sufijo de modificador de ordenación de bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef %HASH;    # forget %HASH ever existed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef %HASH;    # hacer que %HASH nunca existió</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the terminating identifier is on the last line of the program, you
must be sure there is a newline after it; otherwise, Perl will give the
warning B&lt;Can't find string terminator &quot;END&quot; anywhere before EOF...&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el identificador de final está en la última línea del programa, debe asegurarse de que hay un carácter de nueva línea después de él; de lo contrario, Perl dará la advertencia B&lt;Can't find string terminator &quot;END&quot; anywhere before EOF...&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If MODE is C&lt;&lt; '&lt;' &gt;&gt; or nothing, the file
is opened for input.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si MODO es C&lt;&lt; '&lt;' &gt;&gt; o nada, el archivo se abre para lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To capture a command's STDERR but discard its STDOUT (ordering is
important here):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Capturar el STDERR de un comando pero descartar su STDOUT (aquí, el orden es importante):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tie VARIABLE,CLASSNAME,LIST
X&lt;tie&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204806Z" changeid="explorer">
        <seg>=item tie VARIABLE,CLASE,LISTA
X&lt;tie&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perllocale&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perllocale&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endnetent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endnetent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you make changes to uconfig.sh, run</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si realiza cambios en uconfig.sh, ejecute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;&gt; symbol will return C&lt;undef&gt; for end-of-file only once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El símbolo &lt;&gt; devolverá C&lt;undef&gt; para el fin-de-archivo solo una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$Config{byteorder}\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$Config{byteorder}\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On EBCDIC systems only
'@', the letters, '[', '\', ']', '^', '_' and '?' will work, resulting
in 0x00 through 0x1F and 0x7F.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En los sistemas EBCDIC sólo '@', las letras, '[', '\', ']', '^', '_' y '?' funcionarán, resultando en 0x00 a 0x1F y 0x7F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All functions that are capable of creating filehandles (open(),
opendir(), pipe(), socketpair(), sysopen(), socket(), and accept())
automatically create an anonymous filehandle if the handle passed to
them is an uninitialized scalar variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todas las funciones que son capaces de crear gestores de archivo (open(), opendir(), pipe(), socketpair(), sysopen(), socket(), y accept()) crea automáticamente un gestor de archivo anónimo si el gestor que se les pasa es una variable escalar sin inicializar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're new to Perl, you should start by running C&lt;perldoc perlintro&gt;,
which is a general intro for beginners and provides some background to help
you navigate the rest of Perl's extensive documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si es nuevo en Perl, debe empezar ejecutando C&lt;perldoc perlintro&gt;,
que es una introducción general para novatos y ofrece una base suficiente para navegar por el resto de la extensa documentación de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Incompatible Changes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Incompatibilidades</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close OUTPUT                # wait for sort to finish</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close OUTPUT                # esperar que sort termine</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that it short-circuits: i.e., the right
expression is evaluated only if the left expression is true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que cortocircuita: es decir, la expresión de la derecha sólo se evalúa si la expresión de la izquierda es verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$caps[$a] cmp $caps[$b]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$mayusculas[$a] cmp $mayusculas[$b]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should set C&lt;$VERSION&gt; only once per package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe ajustar el valor de C&lt;$VERSION&gt; solo una vez por paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;aaaa&quot;,&quot;abcd&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;aaaa&quot;,&quot;abcd&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; ge &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; ge &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;Operator precedence&gt; means some operators are evaluated before
others.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>I&lt;Precedencia de operadores&gt; significa que algunos operadores son evaluados antes que otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a general rule, backslashes
between C&lt;\Q&gt; and C&lt;\E&gt; may lead to counterintuitive results.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como regla general, las contrabarras entre C&lt;\Q&gt; y C&lt;\E&gt; pueden dar lugar a resultados no intuitivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$user_rwx      = ($mode &amp; S_IRWXU) &gt;&gt; 6;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$usuario_rwx    = ($modo &amp; S_IRWXU) &gt;&gt; 6;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($y = 7; $y &lt; 13; $y++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052950Z" changeid="explorer">
        <seg>for ($y = 7; $y &lt; 13; $y++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;System returned %d\n&quot;, $retval;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Sistema devolvió %d\n&quot;, $retval;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is just like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IFMT($mode)    the part of $mode containing the file type
            which can be bit-anded with (for example) S_IFREG
                        or with the following functions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052210Z" changeid="explorer">
        <seg>S_IFMT($modo)    la parte de $modo conteniendo los bit del tipo
            de archivo que puede ser bit-andeado con (por ejemplo) S_IFREG
                        o con las siguientes funciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And note that C&lt;/x&gt; doesn't affect
whether space interpretation within a single multi-character construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y tenga en cuenta que C&lt;/x&gt; no afecta a la interpretación del espacio en el interior de la construcción de un multicarácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--------------------------------------------------------------------------</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004944Z" changeid="explorer">
        <seg>--------------------------------------------------------------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item say FILEHANDLE LIST
X&lt;say&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200024Z" changeid="explorer">
        <seg>=item say GESTOR_ARCHIVO LISTA
X&lt;say&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $a;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $a;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>10) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a C&lt;;&gt; inside your block to denote that the C&lt;{ ... }&gt; is
a block and not a hash reference constructor.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede utilizar un C&lt;;&gt; dentro del bloque para indicar que C&lt;{...}&gt; es un bloque y no un constructor de una referencia a un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlce		Perl notes for WinCE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlce		Notas para WinCE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;+&quot; returns the sum of two numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;+&quot; devuelve la suma de dos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;a14&quot;,&quot;abcdefg&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;a14&quot;,&quot;abcdefg&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although if your manager accused you of seeking job security (or rapid
insecurity) through inscrutable code, it would be hard to argue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200119Z" changeid="explorer">
        <seg>Pero su jefe le puede acusar de estar buscando un trabajo de seguridad (o rápida inseguridad) usando código inescrutable, y le será difícil excusarse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %fruit_color = (</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234357Z" changeid="zipf">
        <seg>my %color_fruta = (</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot; if $on_a_tty }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot; if $en_un_tty }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2401 6.2 all platform kernel rollup</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004342Z" changeid="explorer">
        <seg>2401 6.2 acumulativo kernel para todas las plataformas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>study;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>study;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hash can be initialized using a literal list holding pairs of
items to be interpreted as a key and a value:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un hash puede ser inicializado con una lista literal que contenga pares de elementos que deben interpretarse como una clave y un valor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; lt &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; lt &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when processing a file like F&lt;/etc/termcap&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, cuando se procesa un archivo como F&lt;/etc/termcap&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behaviour of a smart match depends on what type of thing its arguments
are.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento de una coincidencia inteligente depende del tipo de cosa que sean sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Splits the string EXPR into a list of strings and returns that list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Divide la cadena EXPR en una lista de cadenas y devuelve esa lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use C&lt;unless&gt; in place of C&lt;if&gt;,
the sense of the test is reversed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usa C&lt;unless&gt; en lugar de C&lt;if&gt;, el sentido del test se invierte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Outside the pattern, a named capture buffer is available via the C&lt;%+&gt; hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fuera del patrón, una memoria de captura nominada está disponible a través del hash C&lt;%+&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is I&lt;NOT&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>I&lt;NO&gt; es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a known race condition opening scripts in C&lt;suidperl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay una conocida condición de carrera al abrir scripts con C&lt;suidperl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its truth or falsehood determines how the modifier will behave.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su verdad o falsedad determina cómo se comportará el modificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The 
C&lt;&lt; &lt;=&gt; &gt;&gt; and C&lt;cmp&gt; operators are extremely useful in such routines.)
SUBNAME may be a scalar variable name (unsubscripted), in which case
the value provides the name of (or a reference to) the actual
subroutine to use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Los operadores C&lt;&lt; &lt;=&gt; &gt;&gt; y C&lt;cmp&gt; son muy útiles en este tipo de rutinas). NOMBRE_SUB puede ser el nombre de una variable escalar, en cuyo caso el valor provee el nombre de (o la referencia a) la actual subrutina a usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.perl.com/       Perl articles (O'Reilly)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://www.perl.com/       Artículos Perl (O'Reilly)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You are not allowed to C&lt;open&gt; to a command that pipes both in I&lt;and&gt;
out, but see L&lt;IPC::Open2&gt;, L&lt;IPC::Open3&gt;, and
L&lt;perlipc/&quot;Bidirectional Communication&quot;&gt; for alternatives.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(No se le permite hacer un C&lt;open&gt; a un comando que entube tanto en la entrada I&lt;como&gt; en la salida, pero véase L&lt;IPC::Open2&gt;, L&lt;IPC::Open3&gt;, y L&lt;perlipc/&quot;Comunicación bidireccional&quot;&gt; para alternativas sobre esto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and would match the same as C&lt;/(Y) ( (X) \3 \1 )/x&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y coincidiría con lo mismo que con C&lt;/(Y) ( (X) \3 \1 )/x&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;sysopen $path: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;sysopen $ruta: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the GNU General Public License, see L&lt;perlgpl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la Licencia General Pública GNU, véase L&lt;perlgpl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;my&gt; creates lexically
scoped variables instead.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225042Z" changeid="explorer">
        <seg>En cambio, C&lt;my&gt; crea variables dentro de un ámbito léxico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An OFFSET may be specified to place the read data at some place in the
string other than the beginning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DESPLAZAMIENTO puede ser especificado para colocar los datos leídos en algún otro lugar de la cadena distinto del principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, merely returns the current umask.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, simplemente devuelve la umask actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special variable C&lt;$#array&gt; tells you the index of the last element
of an array:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224852Z" changeid="explorer">
        <seg>La variable especial C&lt;$#array&gt; indica el índice del último elemento de un array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any of the bit masks can also be undef.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera de las máscaras de bits también puede ser undef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?(fred)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>?(pedro)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $some_condition = 1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181646Z" changeid="zipf">
        <seg>my $una_condicion = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item recv SOCKET,SCALAR,LENGTH,FLAGS
X&lt;recv&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194504Z" changeid="explorer">
        <seg>=item recv SOCKET,ESCALAR,LONGITUD,BANDERAS
X&lt;recv&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The directives alter the behaviour of the filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las directivas alteran el comportamiento del gestor del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort(find_records(@key));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort(busca_registros(@claves));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opens a directory named EXPR for processing by C&lt;readdir&gt;, C&lt;telldir&gt;,
C&lt;seekdir&gt;, C&lt;rewinddir&gt;, and C&lt;closedir&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Abre un directorio llamado EXPR para ser procesado por C&lt;readdir&gt;, C&lt;telldir&gt;, C&lt;seekdir&gt;, C&lt;rewinddir&gt;, y C&lt;closedir&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the main point isn't whether the user typed B&lt;-v&gt; or not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>porque el objetivo principal no es si el usuario escribió B&lt;-v&gt; o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator may be assigned to if both the 2nd and 3rd arguments are
legal lvalues (meaning that you can assign to them):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054108Z" changeid="explorer">
        <seg>El operador puede ser asignado si tanto el segundo y tercer argumentos son I&lt;ivalores&gt; legales (lo que significa que les puede asignar valores):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 ENVIRONMENT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 ENTORNO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a random integer between C&lt;0&gt; and C&lt;9&gt;, inclusive.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>devuelve un número entero aleatorio entre C&lt;0&gt; y C&lt;9&gt;, inclusive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Z  A null-terminated (ASCIZ) string, will be null padded.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Z  Una cadena terminada en cero (ASCIZ), será rellenada con nulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you have can't handle C&lt;readline&gt; errors that way with the
C&lt;ARGV&gt; filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que no puede manejar errores de C&lt;readline&gt; de esta manera con el gestor C&lt;ARGV&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort +find_records(@key);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort +busca_registros(@claves);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exit() function does not always exit immediately.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función exit() no siempre sale de forma inmediata.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Q  An unsigned quad value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Q  Un valor cuádruplo sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only one you
need to know about for now is C&lt;$_&gt; which is the &quot;default variable&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224836Z" changeid="explorer">
        <seg>La única que tiene que conocer por ahora es C&lt;$_&gt;, la &quot;variable predeterminada&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&quot;&quot;&gt;, C&lt;``&gt;, C&lt;qq//&gt;, C&lt;qx//&gt;, C&lt;&lt; &lt;file*glob&gt; &gt;&gt;, C&lt;&lt;&lt;&quot;EOF&quot;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item C&lt;&quot;&quot;&gt;, C&lt;``&gt;, C&lt;qq//&gt;, C&lt;qx//&gt;, C&lt;&lt; &lt;file*glob&gt; &gt;&gt;, C&lt;&lt;&lt;&quot;EOF&quot;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 4) = 4   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 4) = 4   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $logmessage = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T212840Z" changeid="zipf">
        <seg>my $mensaje_registro = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the two-argument (and one-argument) form, opening C&lt;&lt; '&lt;-' &gt;&gt; 
or C&lt;'-'&gt; opens STDIN and opening C&lt;&lt; '&gt;-' &gt;&gt; opens STDOUT.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la forma de dos argumentos (y de un argumento), abriendo C&lt;&lt; '&lt;-' &gt;&gt; o C&lt;'-'&gt; abre STDIN y abriendo C&lt;&lt; '&gt;-' &gt;&gt; abre STDOUT.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $e;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $e;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod/&quot;Perl Modules&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod/&quot;Módulos Perl&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @mixed   = (&quot;camel&quot;, 42, 1.23);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234015Z" changeid="zipf">
        <seg>my @mezcla   = (&quot;camello&quot;, 42, 1.23);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is especially significant, given that C&lt;__DIE__&gt; hooks can call
C&lt;die&gt; again, which has the effect of changing their error messages:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es especialmente significativo, dado que las llamadas C&lt;__DIE__&gt; pueden llamar de nuevo a C&lt;die&gt;, que tiene el efecto de cambiar los mensajes de error:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, a quantified subpattern is &quot;greedy&quot;, that is, it will match as
many times as possible (given a particular starting location) while still
allowing the rest of the pattern to match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma predeterminada, un sub-patrón cuantificado es &quot;avaricioso&quot;, es decir, que coincidirá con tantas veces como sea posible (dado un determinado lugar de partida), mientras que aún permita que el resto del patrón coincida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you C&lt;fork&gt; without ever waiting on your children, you will
accumulate zombies.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted hace un C&lt;fork&gt; sin luego esperar a sus hijos, irá acumulando zombies.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>../lib/Math/Trig.t            255 65280    29   12  41.38%  24-29</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055023Z" changeid="explorer">
        <seg>../lib/Math/Trig.t            255 65280    29   12  41.38%  24-29</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will allow the user to specify an argument of the form C&lt;&quot;rsh cat file |&quot;&gt;,
but will not work on a filename that happens to have a trailing space, while</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>permitirá al usuario especificar un argumento de la forma C&lt;&quot;rsh cat archivo |&quot;&gt;, pero no funcionará en un nombre de archivo que tenga un espacio al final, mientras que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print { $files[$i] } &quot;stuff\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print { $archivos[$i] } &quot;cosas\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsymbian 	Perl notes for Symbian</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsymbian 	Notas para for Symbian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfunc		Perl built-in functions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfunc		Funciones incorporadas (primitivas)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the system call specified as the first element of the list,
passing the remaining elements as arguments to the system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la llamada del sistema especificado en el primer elemento de la lista, pasando el resto de elementos como argumentos para la llamada al sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it will usually not work across file system
boundaries, even though the system I&lt;mv&gt; command sometimes compensates
for this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, normalmente no funcionará a través de los límites del sistema de archivos, a pesar de que el comando del sistema I&lt;mv&gt; a veces lo compense.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item int</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item int</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a negated expression C&lt;!(...)&gt; or C&lt;not (...)&gt;, or a logical
exclusive-or C&lt;(...) xor (...)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>una expresión negada C&lt;!(...)&gt; o C&lt;not (...)&gt;, o una operación lógica exclusiva-or C&lt;(...) xor (...)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; le &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; le &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5 gid      numeric group ID of file's owner</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5 gid      ID numérico del grupo del propietario del archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other modules should begin with a capital letter and use mixed
case, but probably without underscores due to limitations in primitive
file systems' representations of module names as files that must fit into a
few sparse bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros módulos deben comenzar con una letra mayúscula y usar luego una mezcla de mayúsculas y minúsculas, pero probablemente sin guiones bajos debido a limitaciones en la representación de nombres de módulos como archivos en sistemas de archivos primitivos que deben ajustarse a unos pocos bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEEK this, position, whence</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SEEK este, posición, desde_donde</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
instance</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This prints out your environment like the printenv(1) program,
but in a different order:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto imprime su entorno como el programa printenv(1), sólo que en un orden diferente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$tX = sprintf(&quot;%.${POINTS}g&quot;, $X);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$tX = sprintf(&quot;%.${PUNTOS}g&quot;, $X);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $AoA[2][2];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $AoA[2][2];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr [\200-\377]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr [\200-\377]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Sorry...\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;Lo siento...\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>May be interrupted if the process receives a signal such as C&lt;SIGALRM&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser interrumpido si el proceso recibe una señal como C&lt;SIGALRM&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;&quot;pack&quot;&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;&quot;pack&quot;&gt; para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any function in the list below may be used either with or without
parentheses around its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier función en la lista de abajo puede ser usada tanto con paréntesis como sin ellos, rodeando sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value for C&lt;atan2(0,0)&gt; is implementation-defined; consult
your atan2(3) manpage for more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165618Z" changeid="explorer">
        <seg>El valor de retorno para C&lt;atan2(0,0)&gt; depende de la implementación; consulte su página de manual de atan2(3) para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that C&lt;$(&gt;, C&lt;$)&gt;, and
C&lt;$|&gt; are not interpolated because they look like end-of-string tests.)
If you want such a pattern to be compiled only once, add a C&lt;/o&gt; after
the trailing delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tenga en cuenta que C&lt;$(&gt;, C&lt;$)&gt;, y C&lt;$|&gt; no son interpolados porque tienen la apariencia de test de final-de-cadena). Si quiere que un patrón así sea compilado solo una vez, añada un C&lt;/o&gt; después del delimitador final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;eof&gt; X&lt;end-of-file&gt; X&lt;end of file&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;eof&gt; X&lt;end-of-file&gt; X&lt;fin de archivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = tr/0-9//;		# count the digits in $_</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = tr/0-9//;		# cuenta los dígitos en $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without the C&lt;/g&gt; modifier, the C&lt;\G&gt; assertion
still anchors at pos(), but the match is of course only attempted once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin el modificador C&lt;/g&gt;, la aserción C&lt;\G&gt; todavía se ancla en pos(), pero la coincidencia, por supuesto, sólo se prueba una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intent of this document is to state the conditions under which a
Package may be copied, such that the Copyright Holder maintains some
semblance of artistic control over the development of the package,
while giving the users of the package the right to use and distribute
the Package in a more-or-less customary fashion, plus the right to make
reasonable modifications.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La intención de este documento es establecer las condiciones en que un Paquete puede ser copiado, de manera que el Titular del Copyright mantiene una apariencia de control artístico sobre el desarrollo del paquete, mientras que dan a los usuarios del paquete el derecho a utilizar y distribuir el Paquete de una manera que sea más o menos habitual, además del derecho a hacer modificaciones razonables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(EXTRACT, &quot;|sort &gt;Tmp$$&quot;)            # $$ is our process id</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(EXTRACT, &quot;|sort &gt;Tmp$$&quot;)            # $$ es nuestro proceso id</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.openbsd - Perl version 5 on OpenBSD systems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.openbsd - Perl versión 5 sobre sistemas OpenBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is not present, C&lt;$_&gt; is
checked.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR no está presente, se comprobará C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;vec&gt; may also be assigned to, in which case parentheses are needed
to give the expression the correct precedence as in</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;vec&gt; también puede ser asignado, en cuyo caso los paréntesis son necesarios para dar a la expresión la correcta precedencia, como en</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned is either the empty string for
false, or a sequence number (beginning with 1) for true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto es una cadena vacía para falso, o un número de secuencia (empezando por 1) para verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply C&lt;int()&gt; to the value returned by C&lt;rand()&gt; if you want random
integers instead of random fractional numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aplique C&lt;int()&gt; al valor devuelto por C&lt;rand()&gt; si quiere obtener enteros aleatorios en lugar de fraccionarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned value is the
amount of time remaining on the previous timer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto es la cantidad de tiempo restante del temporizador anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc/&quot;Signals&quot;&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc/&quot;Señales&quot;&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;caller&gt;, C&lt;continue&gt;, C&lt;die&gt;, C&lt;do&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;exit&gt;,
C&lt;goto&gt;, C&lt;last&gt;, C&lt;next&gt;, C&lt;redo&gt;, C&lt;return&gt;, C&lt;sub&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201740Z" changeid="explorer">
        <seg>C&lt;caller&gt;, C&lt;continue&gt;, C&lt;die&gt;, C&lt;do&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;exit&gt;,
C&lt;goto&gt;, C&lt;last&gt;, C&lt;next&gt;, C&lt;redo&gt;, C&lt;return&gt;, C&lt;sub&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An C&lt;our&gt; declaration may also have a list of attributes associated
with it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una declaración C&lt;our&gt; también puede tener una lista de atributos asociados a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular with GCC-2.7.2.x accept all the defaults
and *watch* out for the message:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, con GCC-2.7.2.x acepte todos los valores por defecto, y *busque* por el siguiente mensaje:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, unlike C and Pascal, these are defined in terms of BLOCKs,
not statements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013307Z" changeid="explorer">
        <seg>Note que, a diferencia del C y Pascal, están definidas en términos de BLOQUES, no instrucciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current value of C&lt;$\&gt; (if
any) is printed after the entire LIST has been printed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor actual de C&lt;$\&gt; (si lo tiene) se imprime después de que toda la lista haya sido impresa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check
the documentation on an individual feature to verify its current
status.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consulte la documentación de cada característica individual para verificar su estado actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\L		lowercase till \E</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003135Z" changeid="explorer">
        <seg>\L		minúsculas hasta \E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if all
platforms are using IEEE, there may still be subtle differences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso si todas las plataformas usan IEEE, todavía puede haber diferencias sutiles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run Perl with the B&lt;-w&gt; switch it can warn you about this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ejecuta Perl con la opción B&lt;-w&gt; le avisará sobre todo esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;$in&gt;) {     # assigns each line in turn to $_</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110204T164808Z" changeid="zipf">
        <seg>while (&lt;$entrada&gt;) {     # asigna una línea cada vez a $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The L&lt;crypt|/crypt&gt; function is unsuitable for hashing large quantities
of data, not least of all because you can't get the information
back.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función L&lt;crypt|/crypt&gt; no es apropiada para calcular el hash de grandes volúmenes de información, teniendo en cuenta que no es posible luego volver a obtener la misma información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write C&lt;/&gt;I&lt;sequence-item&gt; and the repeat count is obtained by
popping off the last element from the stack.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Escriba C&lt;/&gt;I&lt;secuencia-item&gt; y el contador de repeticiones se obtiene extrayéndolo del último elemento de la pila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [1]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225007Z" changeid="explorer">
        <seg>=item [1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     CodeRef   scalar sub truth          $b-&gt;($a)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  RefCódigo  escalar sub verdad               $b-&gt;($a)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($login, $passwd, $remainder) = split(/:/, $_, 3);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($login, $contraseña, $resto) = split(/:/, $_, 3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BEGIN { require Module }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BEGIN { require Módulo }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This doesn't apply to sysread()
and syswrite().)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto no se aplica a sysread () y syswrite ()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regexp</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Regexp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 AVAILABILITY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 DISPONIBILIDAD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can
use the defined() operator to determine whether a scalar value is
defined (this has no meaning on arrays or hashes), and the undef()
operator to produce an undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede usar el operador defined() para determinar si un valor escalar está definido (esto no tiene significado si se aplica a arrays o hashes), y el operador undef() para producir un valor no definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># force use of mergesort (not portable outside Perl 5.8)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># fuerza el uso del mergesort (no portátil fuera de Perl v5.8)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;   less than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;   menor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [2]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225042Z" changeid="explorer">
        <seg>=item [2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final element of a list assignment may be an array or a hash:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El elemento final de una asignación de lista puede ser un array o un hash:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rename OLDNAME,NEWNAME
X&lt;rename&gt; X&lt;move&gt; X&lt;mv&gt; X&lt;ren&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194556Z" changeid="explorer">
        <seg>=item rename NOMBRE_VIEJO,NOMBRE_NUEVO
X&lt;rename&gt; X&lt;move&gt; X&lt;mv&gt; X&lt;ren&gt; X&lt;mover&gt; X&lt;renombra&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no syseof() function, which is ok, since eof() doesn't work
well on device files (like ttys) anyway.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay función syseof(), que está bien, ya que, de todos modos, eof() no funciona bien con los archivos de dispositivo (como los ttys).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can refer to this document in Pod via &quot;L&lt;perlartistic&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacer referencia a este documento en Pod a través de &quot;L&lt;perlartistic&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = 'xyz'; print $x,&quot;\n&quot;;    # prints 1xyz4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = 'xyz'; print $x,&quot;\n&quot;;    # imprime 1xyz4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Math::Complex module (part of the standard perl distribution)
defines mathematical functions that work on both the reals and the
imaginary numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo Math::Complex (parte de la distribución estándar de Perl) define funciones matemáticas que funcionan tanto para reales como números imaginarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other escape sequences such as C&lt;\200&gt; and C&lt;\t&gt; and backslashed
characters such as C&lt;\\&gt; and C&lt;\-&gt; are replaced with appropriate
expansions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las otras secuencias de escape, como C&lt;\200&gt; y C&lt;\t&gt; y caracteres escapados con contrabarras, como C&lt;\\&gt; y C&lt;\-&gt;, son reemplazadas con los literales apropiados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a b c !;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a b c !;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&gt;&quot; returns true if the left argument is numerically greater
than the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&gt;&quot; devuelve verdadero si el argumento de la izquierda es numéricamente mayor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [3]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225114Z" changeid="explorer">
        <seg>=item [3]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 1) = 1   ==         32 00000100000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 1) = 1   ==         32 00000100000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;STRING&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;CADENA&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># whole record case-insensitively otherwise</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># el registro, independientemente del tamaño de caja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>! ~ \ u+ u-             &lt;=&gt;        cmp           tpj.com</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043348Z" changeid="explorer">
        <seg>! ~ \ u+ u-             &lt;=&gt;        cmp           tpj.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a here-doc within a delimited construct, such as in C&lt;s///eg&gt;,
the quoted material must come on the lines following the final delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si utiliza un documento incrustado en una construcción delimitada, como en C&lt;s///eg&gt;, el material entrecomillado debe venir en las siguientes líneas al delimitador final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;I have %d dog%s.\n&quot;, $n,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Tengo %d perro%s.\n&quot;, $n,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being able
to use C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt; on floating-point values can be useful,
but also dangerous if you don't know exactly what you're doing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El ser capaz de usar C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt; en valores de punto flotante puede ser útil, pero también peligroso si no sabe exactamente lo que está haciendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item vec EXPR,OFFSET,BITS
X&lt;vec&gt; X&lt;bit&gt; X&lt;bit vector&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210839Z" changeid="explorer">
        <seg>=item vec EXPR,DESPLAZAMIENTO,BITS
X&lt;vec&gt; X&lt;bit&gt; X&lt;bit vector&gt; X&lt;vectores de bit&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The size specifier C&lt;V&gt; has no effect for Perl code, but is supported for
compatibility with XS code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La especificación de tamaño C&lt;V&gt; no tiene ningún efecto en el código Perl, pero se admite para la compatibilidad con el código XS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Switching in a loop</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Conmutando en un bucle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifiers
that relate to the interpretation of the regular expression inside
are listed below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los modificadores que se relacionan con la interpretación de la expresión regular del interior se enumeran a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do {{</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do {{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Install all perl files:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Instalar todos los archivos de perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 16  ==       4096 00000000000010000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 16  ==       4096 00000000000010000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Historical information (and working binaries of the last released version)
are available from L&lt;http://dev.macperl.org&gt; as of October 2009.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La información histórica (y los binarios de trabajo de la última versión liberada) están disponibles en L&lt;http://dev.macperl.org&gt; a partir de octubre de 2009.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [4]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225146Z" changeid="explorer">
        <seg>=item [4]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The Arrow Operator
X&lt;arrow&gt; X&lt;dereference&gt; X&lt;&lt; -&gt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T232403Z" changeid="explorer">
        <seg>=head2 El operador flecha
X&lt;arrow&gt; X&lt;dereference&gt; X&lt;&lt; -&gt; &gt;&gt; X&lt;flecha&gt; X&lt;desreferencia&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En lugar de esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\d                  a digit (0-9)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230233Z" changeid="zipf">
        <seg>\d                  un dígito (0-9)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it's expecting the beginning of a new statement, if the compiler
encounters a line that begins with an equal sign and a word, like this</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013603Z" changeid="explorer">
        <seg>Mientras que él espera el comienzo de una nueva instrucción, si el compilador encuentra una línea que comienza con un signo de igual y una palabra, como esta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>E.g., C&lt;$obj-E&lt;gt&gt;as_string()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ej., C&lt;$obj-E&lt;gt&gt;como_cadena()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a
hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Liga un archivo dbm(3), ndbm(3), sdbm(3), gdbm(3), o Berkeley DB a un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, contrary to the
expectations of shell programmers, back-quotes do I&lt;NOT&gt; interpolate
within double quotes, nor do single quotes impede evaluation of
variables when used within double quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, contrariamente a las expectativas de los programadores de shell, las comillas invertidas I&lt;NO&gt; interpolan entre comillas dobles, ni las comillas simples impiden la evaluación de las variables cuando se usan dentro de comillas dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec ('foo')   or print STDERR &quot;couldn't exec foo: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec ('foo')   or print STDERR &quot;no puedo exec foo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware, however, that in many
system users are able to change this information and therefore it
cannot be trusted and therefore the $gcos is tainted (see
L&lt;perlsec&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado, sin embargo, que en muchos sistemas los usuarios son capaces de cambiar esta información y por eso no puede confiarse y por eso el $gcos es considerado contaminado (ver L&lt;perlsec&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Known Problems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Problemas conocidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\N{U+263D}	Unicode character (example: FIRST QUARTER MOON)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003032Z" changeid="explorer">
        <seg>\N{U+263D}	carácter Unicode	(ejemplo: FIRST QUARTER MOON)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE: while (&lt;STDIN&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050903Z" changeid="explorer">
        <seg>LINEA: while (&lt;STDIN&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item break</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item break</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are the
meanings of the fields:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí están los significados de los campos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the reverse, see L&lt;/chr&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para lo contrario, véase L &lt;/chr&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Miscellaneous functions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones varias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-M  Script start time minus file modification time, in days.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-M  Tiempo de arranque del script menos el tiempo de modificación del archivo, en días.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently EXPR with the value C&lt;0&gt; is
also special-cased as C&lt;1&gt; (this was undocumented before Perl 5.8.0
and is subject to change in future versions of Perl).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Actualmente EXPR con el valor de C&lt;0&gt; es también un caso especial como el de C&lt;1&gt; (no estaba documentado esto antes de Perl 5.8.0
y está sujeto a cambios en futuras versiones de Perl).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; UPPERCASE&quot;),	redo LOOP if /\G[A-Z]+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(&quot; MAYÚSCULAS&quot;),	redo LOOP if /\G[A-Z]+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takes extra time to study SCALAR (C&lt;$_&gt; if unspecified) in anticipation of
doing many pattern matches on the string before it is next modified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toma tiempo extra para estudiar ESCALAR (C&lt;$_&gt; si no se especifica) en previsión de hacer muchos patrones de coincidencia en la cadena antes de que sea modificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pos SCALAR
X&lt;pos&gt; X&lt;match, position&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192708Z" changeid="explorer">
        <seg>=item pos ESCALAR
X&lt;pos&gt; X&lt;match, position&gt; X&lt;coincidencia, posición&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.   string concatenation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055544Z" changeid="explorer">
        <seg>.   concatenación de cadenas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/%INC&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/%INC&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other
languages have borrowed syntax from Perl, particularly its regular
expression extensions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros lenguajes han tomado prestada la sintaxis de Perl, particularmente sus extensiones de expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME
X&lt;function&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200823Z" changeid="explorer">
        <seg>=head1 NOMBRE
X&lt;function&gt; X&lt;función&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match exactly n times, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide exactamente n veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POP this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>POP este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike some other regular expression languages, there
are no backslashed symbols that aren't alphanumeric.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de algunos otros lenguajes de expresiones regulares, no hay símbolos escapados que no sean alfanuméricos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo =  150  | '105';	# yields 255</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo =  150  | '105';	# produce 255</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may, however, wish to treat a
string as a multi-line buffer, such that the &quot;^&quot; will match after any
newline within the string (except if the newline is the last character in
the string), and &quot;$&quot; will match before any newline.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede, sin embargo, desear tratar a la cadena como un buffer de varias líneas, de modo que &quot;^&quot; coincidirá después de cualquier carácter nueva línea dentro de la cadena (excepto si el nueva línea es el último carácter en la cadena), y &quot;$&quot; coincidirá delante de cualquier carácter nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$url = URI::URL-&gt;new( &quot;http://example.com/&quot; ); die if $url eq &quot;xXx&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$url = URI::URL-&gt;new( &quot;http://ejemplo.com/&quot; ); die if $url eq &quot;xXx&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($pattern = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($patron = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If OFFSET and LENGTH specify a substring that is partly outside the
string, only the part within the string is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si DESPLAZAMIENTO y LONGITUD especifican una subcadena que está parcialmente fuera de la cadena, sólo la parte de dentro de la cadena se devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The '$' symbol works
semantically like the English word &quot;the&quot; in that it indicates a
single value is expected.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El signo '$' funciona semánticamente como en Español la palabra &quot;el&quot;, indicando que se espera un único valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\a		alarm (bell)          (BEL)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\a		alarma (campana)      (BEL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exit $!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171117Z" changeid="explorer">
        <seg>exit $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no string is
specified via the =~ or !~ operator, the $_ string is transliterated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se especifica una cadena vía los operadores C&lt;=~&gt; o C&lt;!~&gt;, se translitera la cadena $_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Scalar value constructors
X&lt;scalar, literal&gt; X&lt;scalar, constant&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035340Z" changeid="explorer">
        <seg>=head2 Constructores de valores escalares
X&lt;scalar, literal&gt; X&lt;scalar, constant&gt; X&lt;escalar, literal&gt; X&lt;escalar, constante&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fork
X&lt;fork&gt; X&lt;child&gt; X&lt;parent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173401Z" changeid="explorer">
        <seg>=item fork
X&lt;fork&gt; X&lt;child&gt; X&lt;parent&gt; X&lt;hijo&gt; X&lt;padre&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = (stat($filename))[2];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = (stat($archivo))[2];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = Math::BigInt-&gt;new('123456789123456789');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$x = Math::BigInt-&gt;new('123456789123456789');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, it returns a list of the
substrings matched by any capturing parentheses in the regular
expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, devuelve una lista de las subcadenas coincidentes con los paréntesis de captura de la expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exists EXPR
X&lt;exists&gt; X&lt;autovivification&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T172219Z" changeid="explorer">
        <seg>=item exists EXPR
X&lt;exists&gt; X&lt;autovivification&gt; X&lt;autovivificación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Context
X&lt;context&gt; X&lt;scalar context&gt; X&lt;list context&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T012610Z" changeid="explorer">
        <seg>=head2 Contexto
X&lt;context&gt; X&lt;scalar context&gt; X&lt;list context&gt; X&lt;contexto&gt; X&lt;contexto escalar&gt; X&lt;contexto lista&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exit $?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171132Z" changeid="explorer">
        <seg>exit $?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item values HASH
X&lt;values&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210806Z" changeid="explorer">
        <seg>=item values HASH
X&lt;values&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;cond_timedwait&gt; has been added.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se ha añadido C&lt;cond_timedwait&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.1e&gt;', 10; # prints &quot;&lt;1.0e+01&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.1e&gt;', 10; # imprime &quot;&lt;1.0e+01&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;next&gt; explicitly iterates the other loop
rather than merely terminating the inner one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;next&gt; explícitamente itera sobre el otro bucle en vez de meramente terminar el interno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setuid Perl scripts are safer than C programs
through a dataflow tracing mechanism that prevents many stupid
security holes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Scripts setuid de Perl son más seguros que los programas en C a través de un mecanismo de seguimiento de flujo de datos que impide muchos agujeros de seguridad estúpidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>subroutines can now be overridden, autoloaded, and prototyped</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>subrutinas ahora pueden ser reemplazadas, cargadas automáticamente y prototipadas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print reverse;                              # No output, list context</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print reverse;                              # No hay salida, contexto lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	&lt;&lt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	&lt;&lt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raises an exception otherwise.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso contrario, se levanta una excepción).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also
means that recipients of the item may redistribute it under the same
conditions they received it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También significa que los destinatarios del elemento pueden redistribuirlo bajo las mismas condiciones que lo recibieron.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;#&gt;
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El carácter C&lt;#&gt; también es considerado un metacarácter que antecede a un comentario, al igual que en el código normal de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Something like C&lt;&quot;\Q\\E&quot;&gt; has
no C&lt;\E&gt; inside.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algo como C&lt;&quot;\Q\\E&quot;&gt; no tiene dentro a C&lt;\E&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on formats, see L&lt;perlform&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información sobre formatos, véase L&lt;perlform&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbot		Perl OO tricks and examples</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlbot		Trucos y ejemplos de POO Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LINEA:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11794</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11794</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo, 20,  4) = 2;      # 'PerlPerlPe'   . &quot;\x02&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052405Z" changeid="explorer">
        <seg>vec($foo, 20,  4) = 2;      # 'PerlPerlPe'   . &quot;\x02&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather, it
matched something that happened to be zero characters long.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Más bien, ha coincidido con algo que parece tener cero caracteres de longitud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}} until $x++ &gt; $z;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>}} until $x++ &gt; $z;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^\s+//;           # trim leading whitespace</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^\s+//;           # quita los primeros espacios en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>world&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233559Z" changeid="zipf">
        <seg>a todos&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then that text and all remaining text up through and including a line
beginning with C&lt;=cut&gt; will be ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entonces este texto y el siguiente hasta incluir una línea que comience por C&lt;=cut&gt; será ignorada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Under VMS, the
variable C&lt;$ENV{SYS$LOGIN}&gt; is also checked, and used if it is set.) If
neither is set, C&lt;chdir&gt; does nothing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Bajo VMS, la variable C&lt;$ENV{SYS$LOGIN}&gt; es también comprobada y usada si está puesta). Si ninguna está puesta, C&lt;chdir&gt; no hace nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>STORESIZE this, count</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>STORESIZE este, contador</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;==&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;==&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Simple Statements
X&lt;statement&gt; X&lt;semicolon&gt; X&lt;expression&gt; X&lt;;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012859Z" changeid="explorer">
        <seg>=head2 Instrucciones simples
X&lt;statement&gt; X&lt;semicolon&gt; X&lt;expression&gt; X&lt;;&gt; X&lt;instrucción&gt; X&lt;punto y coma&gt; X&lt;expresión&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== 200) { print; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== 200) { print; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eval</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eval</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional state for the subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estado opcional para la subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given ($something) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>given ($algo) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Nagle's algorithm is turned &quot;, $nodelay ? &quot;off\n&quot; : &quot;on\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050138Z" changeid="explorer">
        <seg>print &quot;El algoritmo de Nagle está puesto a &quot;, $nodelay ? &quot;off\n&quot; : &quot;on\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One effect of these rules is that -bareword is equivalent
to the string &quot;-bareword&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Uno de los efectos de estas reglas es -palabra es equivalente a la cadena &quot;-palabra&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this function actually
reads a character and then C&lt;ungetc&gt;s it, so isn't useful in an
interactive context.)  Do not read from a terminal file (or call
C&lt;eof(FILEHANDLE)&gt; on it) after end-of-file is reached.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211421Z" changeid="explorer">
        <seg>(Note que esta función realmente lee un carácter y luego hace un C&lt;ungetc&gt;, así que no es útil en un contexto interactivo). No lea de un archivo del que se ha llegado al final (o vuelva a llamar a C&lt;eof(GESTOR_ARCHIVO)&gt; sobre él) después de haber alcanzado un fin-de-archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#  0         1          2      3            4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># 0         1         2       3           4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@tmp = somefunc($i);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@tmp = algunafuncion($i);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus it can be used to
increment a loop variable, even when the loop has been continued via
the C&lt;next&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013420Z" changeid="explorer">
        <seg>Así, puede ser usada para incrementar una variable de bucle, incluso cuando el ciclo ha sido parado por medio de la instrucción C&lt;next&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is semantically equivalent to the list:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es semánticamente equivalente a la lista:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get a list of anonymous hashes each with only one entry apiece.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para obtener una lista de hashes anónimos, cada uno con sólo una entrada cada uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>__END__</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>__END__</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unix datagram sockets aren't implemented in
Haiku yet.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los datagramas sockect Unix aún no están implementados en Haiku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl uses an internal type called a I&lt;typeglob&gt; to hold an entire
symbol table entry.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl utiliza un tipo interno que se llama I&lt;typeglob&gt; para mantener una entrada entera en la tabla de símbolos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hmm... here's the simple way:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194940Z" changeid="explorer">
        <seg>Hmm ... aquí está la forma más sencilla:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On many operating systems, the native text file
representation matches the internal representation, but on some
platforms the external representation of C&lt;\n&gt; is made up of more than
one character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En muchos sistemas operativos, la representación nativa de un archivo texto coincide con su representación interna, pero en algunas plataformas la representación externa de C&lt;\n&gt; se realiza con más de un carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.bebits.com/app/4030</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://www.bebits.com/app/4030</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>distribute a Standard Version of the executables and library files,
together with instructions (in the manual page or equivalent) on where
to get the Standard Version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>distribuir una Versión Estándar de los ejecutables y archivos de biblioteca, junto con instrucciones (en página de manual o equivalente) sobre dónde obtener la Versión Estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item \G assertion</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Aserción \G</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of Perl 5.11.2 you can use a bare C&lt;readdir&gt; in a C&lt;while&gt; loop,
which will set C&lt;$_&gt; on every iteration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de Perl 5.11.2 puede usar un simple C&lt;readdir&gt; en un bucle C&lt;while&gt;, que actualizará C&lt;$_&gt; en cada iteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 FreeBSD core dumps from readdir_r with ithreads</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 FreeBSD vuelca el núcleo desde readdir_r con ithreads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of these variables incurs no global performance penalty, unlike
their punctuation char equivalents, however at the trade-off that you
have to tell perl when you want to use them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de estas variables no incurre en penalización en el rendimiento global, a diferencia de sus equivalentes de caracteres de puntuación, pero sin embargo, tiene que decirle a perl cuándo desea utilizarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl 'SEEK_CUR';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl 'SEEK_CUR';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>../ext/List/Util/t/shuffle.t    0   139    ??</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055019Z" changeid="explorer">
        <seg>../ext/List/Util/t/shuffle.t    0   139    ??</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($i = 0; $i &lt;= $max; $i++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232637Z" changeid="explorer">
        <seg>for ($i = 0; $i &lt;= $max; $i++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;FILEHANDLE&gt; may also be spelled C&lt;readline(*FILEHANDLE)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T212057Z" changeid="explorer">
        <seg>&lt;GESTOR_ARCHIVO&gt; también puede ser escrito como C&lt;readline(*GESTOR_ARCHIVO)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>split(/([,-])/, &quot;1-10,20&quot;, 3);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>split(/([,-])/, &quot;1-10,20&quot;, 3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used as an lvalue, C&lt;keys&gt; allows you to increase the number of hash buckets
allocated for the given hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usado como valor a la izquierda (lvalue), C&lt;keys&gt; le permite incrementar el número de alojamientos de memoria hash para el hash indicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no C&lt;systell&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe la función C&lt;systell&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $dbase, '+&lt;', 'dbase.mine')      # open for update</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $dbase, '+&lt;', 'dbase.mine')      # abrir para actualizar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc/&quot;Using open() for IPC&quot;&gt; for more examples of this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc/&quot;Usando open() por IPC&quot;&gt; para más ejemplos de sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Numeric functions
X&lt;numeric&gt; X&lt;number&gt; X&lt;trigonometric&gt; X&lt;trigonometry&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200922Z" changeid="explorer">
        <seg>=item Funciones numéricas
X&lt;numeric&gt; X&lt;number&gt; X&lt;trigonometric&gt; X&lt;trigonometry&gt; X&lt;numérico&gt; X&lt;número&gt; X&lt;trigonométrica&gt; X&lt;trigonomía&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Defined\n&quot;   if defined $hash{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Definido\n&quot;  if defined $hash{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How come?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Por qué?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl doesn't officially have a no-op operator, but the bare constants
C&lt;0&gt; and C&lt;1&gt; are special-cased to not produce a warning in a void
context, so you can for example safely do</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl, oficialmente, no tiene un operador de no-operación, pero las constantes simples C&lt;0&gt; y C&lt;1&gt; son un caso especial, que no producen una advertencia en un contexto vacío, por lo que puede, por ejemplo, hacer de forma segura</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NAME needn't be the name of a subroutine; it can be a scalar variable
containing a code reference, or a block that evaluates to a code
reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NOMBRE no necesita ser el nombre de la subrutina; puede ser una variable escalar conteniendo una referencia a un código, o un bloque que evalúa a una referencia de código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will use miniperl to complete the rest of the build.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto utilizará miniperl para completar el resto de la construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/g&gt; option is not used, C&lt;m//&gt; in list context returns a
list consisting of the subexpressions matched by the parentheses in the
pattern, i.e., (C&lt;$1&gt;, C&lt;$2&gt;, C&lt;$3&gt;...).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la opción C&lt;/g&gt; no se utiliza, C&lt;m//&gt; en contexto lista devuelve una lista compuesta de las subexpresiones coincidentes por los paréntesis en el patrón, es decir, (C&lt;$1&gt;, C&lt;$2&gt;, C&lt;$3&gt;...).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\N{omega}&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;\N{omega}&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The usual C-style backslash rules apply for making
characters such as newline, tab, etc., as well as some more exotic
forms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las reglas normales de la barra invertida en el estilo del C se aplican para la creación de caracteres como el salto de línea, tabuladores, etc, así como algunas formas más exóticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 + 1, &quot;\n&quot;;    # Obviously not what you meant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 + 1, &quot;\n&quot;;    # Obviamente no es lo que quería decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is B&lt;not&gt; locking: exclusiveness means here that
if the file already exists, sysopen() fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto B&lt;no&gt; es bloquear: la exclusividad significa aquí que si el archivo ya existe, sysopen() falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If, however, the
variable has been used in only string contexts since it was set, and
has a value that is not the empty string and matches the pattern
C&lt;/^[a-zA-Z]*[0-9]*\z/&gt;, the increment is done as a string, preserving each
character within its range, with carry:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T010220Z" changeid="explorer">
        <seg>Sin embargo, si la variable se ha utilizado sólo en contextos de cadena desde que se creó, y tiene un valor que no es la cadena vacía y coincide con el patrón C&lt;/^[a-zA-Z]*[0-9]*\z/&gt;, el incremento se realiza como una cadena, conservando cada carácter dentro de su rango, conllevando a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>redo LINE unless eof(); # not eof(ARGV)!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>redo LINEA unless eof(); # ¡no es eof(ARGV)!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 4) = 4   ==         64 00000010000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 4) = 4   ==         64 00000010000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But see the &quot;\&quot; operator for taking a reference.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Véase, sin embargo, el operador &quot;\&quot; para tomar una referencia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't get a list
like C&lt;(1,2,3)&gt; into being in scalar context, because the compiler knows
the context at compile time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede conseguir que una lista como C&lt;(1,2,3)&gt; se convierta en contexto escalar porque el compilador conoce el contexto en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this is slightly more flexible than the behavior of some
B&lt;tr&gt; programs, which delete anything they find in the SEARCHLIST,
period.) If the C&lt;/s&gt; modifier is specified, sequences of characters
that were transliterated to the same character are squashed down
to a single instance of the character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tenga en cuenta que esto es un poco más flexible que el comportamiento de algunos programas B&lt;tr&gt;, que eliminan todo lo que encuentre en la LISTA_BÚSQUEDA, y punto). Si se especifica el modificador C&lt;/s&gt;, las secuencias de caracteres que se transliteren al mismo carácter son reducidos hasta una única instancia del carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>package Foo;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>package Foo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within any delimiters for such a
construct, allowed spaces are not affected by C&lt;/x&gt;, and depend on the
construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una construcción como esta, con cualquier tipo de delimitadores, los espacios permitidos no se verán afectados por C&lt;/x&gt;, y depende de la propia construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The syntax descriptions omit the
parentheses.)  If you use parentheses, the simple but occasionally 
surprising rule is this: It I&lt;looks&gt; like a function, therefore it I&lt;is&gt; a
function, and precedence doesn't matter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Las descripciones sintácticas omiten los paréntesis). Si usa los paréntesis, la simple (pero ocasionalmente sorprendente) regla es esta: Si I&lt;se parece&gt; a una función, por eso I&lt;es&gt; una función y la precedencia no importará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?pimsx-imsx)&gt;
X&lt;(?)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230528Z" changeid="explorer">
        <seg>=item C&lt;(?pimsx-imsx)&gt;
X&lt;(?)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If such scripts or library files are aggregated with this
Package via the so-called &quot;undump&quot; or &quot;unexec&quot; methods of producing a
binary executable image, then distribution of such an image shall
neither be construed as a distribution of this Package nor shall it
fall under the restrictions of Paragraphs 3 and 4, provided that you do
not represent such an executable image as a Standard Version of this
Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los scripts o archivos de biblioteca son agregados con este Paquete a través de los métodos &quot;undump&quot; o &quot;unexec&quot; para la producción de una imagen ejecutable binaria, entonces, la distribución de esta imagen no se interpretará como una distribución de este Paquete, ni caerá bajo las restricciones de los párrafos 3 y 4, siempre y cuando usted no intente representar que es una imagen ejecutable de una Versión Estándar de este Paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9 mtime    last modify time in seconds since the epoch</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>9 mtime    tiempo última modificación, en segundos desde el epoch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local/overseas is +1 707 829 0515.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T233742Z" changeid="explorer">
        <seg>La llamada internacional es +1 707 829 0515.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both C&lt;-T&gt; and C&lt;-B&gt; return true on an empty
file, or a file at EOF when testing a filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ambos, C&lt;-T&gt; y C&lt;-B&gt;, devuelven verdadero en un archivo vacío o en un archivo en el EOF (marca de fin de archivo) cuando se analiza un gestor de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A slice accesses several elements of a list, an array, or a hash
simultaneously using a list of subscripts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234735Z" changeid="explorer">
        <seg>Una porción accede a varios elementos de una lista, un array, o un hash, de forma simultánea, usando una lista de índices.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can manipulate C&lt;@_&gt; in other ways too:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233225Z" changeid="zipf">
        <seg>También podemos manipular C&lt;@_&gt; de otras maneras:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CODE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CODE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Darwin&quot; =&gt; &quot;Charles&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;Darwin&quot; =&gt; &quot;Charles&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item last</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item last</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl582delta - what is new for perl v5.8.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl582delta - Qué hay de nuevo en perl v5.8.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %h = (&quot;FOO&quot;, 23);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my %h = (&quot;FOO&quot;, 23);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On error, C&lt;unlink&gt; will not tell you which files it could not remove.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de error, C&lt;unlink&gt; no indicará qué archivos no se han podido borrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,18, 1) = 1   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,18, 1) = 1   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider always blessing objects in CLASSNAMEs that are mixed case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considerar siempre bautizar objetos de NOMBRECLASE que mezcle mayúsculas y minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;-T&gt;
or C&lt;-B&gt; is used on a filehandle, the current IO buffer is examined
rather than the first block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;-T&gt; o C&lt;-B&gt; se usan con un gestor de archivo, la memoria intermedia actual de IO es examinada en vez del primer bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-w  File is writable by effective uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004514Z" changeid="explorer">
        <seg>-w  Archivo es escribible por el uid/gid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print MEMORY &quot;foo!\n&quot;;                   # output will appear in $var</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print MEMORIA &quot;foo!\n&quot;;              # la salida aparecerá en $var</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any part of LIST is an array, C&lt;foreach&gt; will get very confused if
you add or remove elements within the loop body, for example with
C&lt;splice&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si cualquier parte de la LISTA es un array, C&lt;foreach&gt; quedará confundido si añade o quita elementos dentro del cuerpo del bucle, por ejemplo, al usar C&lt;splice&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#x&gt;',  12;   # prints &quot;&lt;0xc&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#x&gt;',  12;   # imprime &quot;&lt;0xc&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-bracketing delimiters use the same character fore and aft, but the four
sorts of brackets (round, angle, square, curly) will all nest, which means
that</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Delimitadores no emparejados usan el mismo carácter delante y detrás, pero los otros cuatro delimitadores (redondos -paréntesis-, cuadrados -corchetes-, ángulos y llaves) pueden ser anidados, lo que significa que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Simple matching</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T234126Z" changeid="zipf">
        <seg>=item Detección de coincidencias sencilla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Select the riscos hint file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Seleccione el archivo de pistas para riscos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Thus it's possible
to do things with named capture buffers that would otherwise require C&lt;(??{})&gt;
code to accomplish.)
X&lt;named capture buffer&gt; X&lt;regular expression, named capture buffer&gt;
X&lt;%+&gt; X&lt;$+{name}&gt; X&lt;&lt; \k&lt;name&gt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(De este modo es posible hacer cosas con las memorias de captura nominadas que, de otro modo, requerirían código C&lt;(??{})&gt; para llevarlas a cabo).
X&lt;memoria de captura nominada&gt; X&lt;expresión regular, memoria de captura nominada&gt;
X&lt;%+&gt; X&lt;$+{nombre}&gt; X&lt;&lt; \k&lt;nombre&gt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
the C&lt;open&gt; involved a pipe, the return value happens to be the pid of
the subprocess.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el C&lt;open&gt; contiene una tubería, el valor de retorno pasa a ser el pid del subproceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Selected Bug Fixes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Arreglo de determinados errores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item precision, or maximum width
X&lt;precision&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201218Z" changeid="explorer">
        <seg>=item precisión, o ancho máximo
X&lt;precision&gt; X&lt;precisión&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a (relatively expensive) work-around to compare
whether two floating-point numbers are equal to a particular number of
decimal places.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un (relativamente caro) ejemplo en torno a cómo comprobar si dos números de punto flotante son iguales en un determinado número de decimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array represents a list of values:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T231513Z" changeid="zipf">
        <seg>Un array representa una lista de valores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: not all implementations are
capable of returning the $timeleft.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota: no todas las implementaciones son capaces de devolver $tiempo_restante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;The square of $answer is &quot;, $answer * $answer, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T001501Z" changeid="zipf">
        <seg>print &quot;El cuadrado de $respuesta es &quot;, $respuesta * $respuesta, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/&quot;Switch statements&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013110Z" changeid="explorer">
        <seg>Ver también L&lt;/&quot;Instrucciones Switch&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($answer = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($respuesta = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the first integer after the first = sign, or the</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># el primer entero después del signo =, o, de otra forma, todo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $foo eq $bar</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># $foo eq $bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub unlock {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub unlock {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -le '$a = &quot;NaN&quot;; print &quot;No NaN support here&quot; if $a == $a'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl -le '$a = &quot;NaN&quot;; print &quot;No tiene soporte NaN&quot; if $a == $a'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Perl has many other internal
optimizations, but none would be triggered in the above example if
we did not use qr() operator.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Perl tiene otras muchas optimizaciones internas, pero ninguna será activada en el ejemplo anterior si no usamos el operador qr()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value gives the name of the
actual filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>GESTOR_ARCHIVO puede ser una expresión cuyo valor da el nombre del gestor de archivo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or gripe(), next LINE;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or gripe(), next LINEA;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub new { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub new { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider changing your whole
world view.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere cambiar su punto de vista vital.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, subroutines are named with an initial '&amp;', though this
is optional when unambiguous, just as the word &quot;do&quot; is often redundant
in English.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de lo anterior, las subrutinas se nombran empezando por '&amp;', aunque ésto es opcional cuando no provoque ambigüedad, igual que el sujeto de una frase en español es a menudo redundante cuando va implícito en el verbo, como en &quot;(yo) tengo lo que usted necesita&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5 gid    5 year-1900  5 wantarray    $!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5 gid    5 año-1900   5 wantarray    $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a filetest operator, with the exception of C&lt;-s&gt;, C&lt;-M&gt;, C&lt;-A&gt;, and C&lt;-C&gt;,
that return numerical values, not boolean ones.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>un operador de test de archivo, con la excepción de C&lt;-s&gt;, C&lt;-M&gt;, C&lt;-A&gt;, y C&lt;-C&gt;, que devuelven valores numéricos, no booleanos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&amp;&quot; returns its operands ANDed together bit by bit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&amp;&quot; devuelve la operación AND, bit a bit, de sus operandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time all must be OK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta vez, todo debe estar bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is
complicated by the need to cross compile.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es complicado, por la necesidad de hacer una compilación cruzada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Produces a fatal error if used on a
machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Produce un error fatal si se usa en una máquina que no implemente flock(2), bloqueo fcntl(2), o lockf(3).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A negative subscript retrieves its 
value from the end.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un subíndice negativo devuelve un valor a partir del final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for filehandles, files, or directories
X&lt;file&gt; X&lt;filehandle&gt; X&lt;directory&gt; X&lt;pipe&gt; X&lt;link&gt; X&lt;symlink&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004318Z" changeid="explorer">
        <seg>=item Funciones para controladores de archivo, archivos y directorios
X&lt;file&gt; X&lt;filehandle&gt; X&lt;directory&gt; X&lt;pipe&gt; X&lt;link&gt; X&lt;symlink&gt; X&lt;archivo&gt; X&lt;controlador de archivo&gt; X&lt;enlace&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support
symbolic links, raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En los sistemas que no admiten los enlaces simbólicos, produce una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, people can
set their I/O to be by default UTF-8 encoded Unicode, not bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También, el personal puede poner su I/O para que sea codificado en Unicode UTF-8, y no bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPERATOR PRECEDENCE     =          =        perl.plover.com</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>OPERADOR PRECEDENCIA    =          =        perl.plover.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%G    like %g, but with an upper-case &quot;E&quot; (if applicable)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%G    como %g, pero con una letra letra &quot;E&quot; mayúscula (si es aplicable)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while(readdir $dh) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while(readdir $dh) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalars, arrays and hashes are documented more fully in L&lt;perldata&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224945Z" changeid="explorer">
        <seg>Encontrará información detallada sobre los escalares, arrays y hashes en L&lt;perldata&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't just have to match on fixed strings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T234751Z" changeid="zipf">
        <seg>No tiene que limitarse a detectar coincidencias en cadenas fijas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different definitions of Perl are given in L&lt;perl&gt;, L&lt;perlfaq1&gt; and
no doubt other places.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224627Z" changeid="explorer">
        <seg>En L&lt;perl&gt;, L&lt;perlfaq1&gt; y en muchos otros sitios se incluyen definiciones de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort &amp;find_records(@key);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort &amp;busca_registros(@claves);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(&quot;, &quot;, reverse &quot;world&quot;, &quot;Hello&quot;); # Hello, world</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(&quot;, &quot;, reverse &quot;mundo&quot;, &quot;Hola&quot;); # Hola, mundo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(?'char'.)\1/                  # ... mix and match
         and print &quot;'$1' is the first doubled character\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230323Z" changeid="explorer">
        <seg>/(?'car'.)\1/                   # ... mezcla y busca
         and print &quot;'$1' es el primer carácter repetido\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta asignación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, returns the
total number of elements so generated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el número total de elementos generados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the normal array index looping, C&lt;for&gt; can lend itself
to many other interesting applications.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de recorrer los índices de los arrays, C&lt;for&gt; puede prestarse a otras interesantes aplicaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;STDIN&gt;) { print; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;STDIN&gt;) { print; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>| ^              REGEX METACHARS            REGEX MODIFIERS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>| ^              REGEX METACARACT.          REGEX MODIFICADORES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using a character valid in an identifier, whitespace is required
after the C&lt;m&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se utiliza un carácter válido en un identificador, se requiere espacios en blanco después de la C&lt;m&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Hello, world&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233540Z" changeid="zipf">
        <seg>&quot;Hola a todos&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are only required
occasionally to clarify issues of precedence.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224757Z" changeid="explorer">
        <seg>Solo son necesarios en algunos casos para aclarar la precedencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	|| //</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	|| //</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a beginning Perl programmer, your most common use of OO Perl will be
in using third-party modules, which are documented below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225546Z" changeid="explorer">
        <seg>La aplicación que suelen hacer los programadores principiantes de la programación orientada a objetos en Perl es la utilización de módulos de terceros, que se describe a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code will build up an ASCII string saying C&lt;'PerlPerlPerl'&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El código siguiente construirá una cadena ASCII diciendo C&lt;'PerlPerlPerl'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last update: Thu Jun  4 16:16:23 MDT 1998</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200504Z" changeid="explorer">
        <seg>Última actualización: mar Jun  4 16:16:23 MDT 1998</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($self, $filename) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($self, $archivo) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($coderef, $filename) = @_;  # $coderef is \&amp;my_sub</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($coderef, $archivo) = @_;  # $coderef is \&amp;mi_sub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can get at lists of keys and values with C&lt;keys()&gt; and
C&lt;values()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224932Z" changeid="explorer">
        <seg>Puede obtener una lista de las claves y los valores con C&lt;keys()&gt; y C&lt;values()&gt; respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some functions appear in more
than one place.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas funciones aparecen en más de un lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can exclude the beginning point by
waiting for the sequence number to be greater than 1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede excluir el punto de partida esperando por un número de secuencia mayor que 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>write;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>write;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>INSTALLATION</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T203651Z" changeid="zipf">
        <seg>INSTALACIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 2) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 2) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, this sorts the LIST and returns the sorted list value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, ordena la LISTA y devuelve los valores de la lista ordenados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (EXPR) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (EXPR) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;redo&gt; cannot be used to retry a block that returns a value such as
C&lt;eval {}&gt;, C&lt;sub {}&gt; or C&lt;do {}&gt;, and should not be used to exit
a grep() or map() operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;redo&gt; no puede usarse para reiniciar un bloque que devuelve un valor, como C&lt;eval {}&gt;, C&lt;sub {}&gt; o C&lt;do {}&gt;, y no debe ser usado para salir de una operación grep() o map().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod a+x /boot/common/bin/perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod a+x /boot/common/bin/perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So by storing a reference as the value of an array or hash
element, you can easily create lists and hashes within lists and
hashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224952Z" changeid="explorer">
        <seg>Así, almacenando una referencia como el valor de un elemento de array o hash, puede crear fácilmente listas y hashes dentro de listas y hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function shmctl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC shmctl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>inet_ntoa($myaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>inet_ntoa($myaddr);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;i!&gt; and C&lt;I!&gt; are also allowed, but only for completeness' sake:
they are identical to C&lt;i&gt; and C&lt;I&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;i!&gt; y C&lt;I!&gt; también están permitidos, pero solo a efectos de completar: son idénticos a C&lt;i&gt; y C&lt;I&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have to use the default
variable C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tiene que usar la variable por defecto C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlipc		Perl interprocess communication</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlipc		Comunicación interprocesos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the value or values deleted in list context, or the last such
element in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor o valores borrados en contexto lista, o el último elemento en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;pack&gt;, I&lt;sequence-item&gt; may have a repeat count, in which case
the minimum of that and the number of available items is used as the argument
for I&lt;length-item&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para C&lt;pack&gt;, I&lt;secuencia-item&gt; puede tener un contador de repeticiones, en cuyo caso el mínimo de él y del número de elementos disponibles es usado como el argumento para &lt;longitud-item&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose mnemonic identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elija identificadores mnemónicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hmm... that's still a bit ugly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194255Z" changeid="explorer">
        <seg>Hmm ... que aún es un poco feo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^\s*(.*?)\s*$/$1/;	# trim whitespace in $_, expensively</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^\s*(.*?)\s*$/$1/;	# recorta el espacio en blanco en $_, de forma onerosa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perllexwarn 	Perl warnings and their control</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perllexwarn 	Avisos y su control</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar&gt; for details on setting C&lt;%SIG&gt; entries, and for more
examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar&gt; para más detalles sobre la configuración de las entradas C&lt;%SIG&gt;, y para más ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item print FILEHANDLE LIST
X&lt;print&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192727Z" changeid="explorer">
        <seg>=item print GESTOR_ARCHIVO LISTA
X&lt;print&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike most Unix utilities, Perl does not
arbitrarily limit the size of your data--if you've got the memory,
Perl can slurp in your whole file as a single string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de la mayoría de los sistemas Unix, Perl no limita arbitrariamente el tamaño de sus datos - si tiene memoria, Perl puede sorber su archivo entero como una sola cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's safer because if code gets added
between the inner and outer loops later on, the new code won't be
accidentally executed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más seguro porque si se añade nuevo código entre los bucles interno y externo, ese nuevo código no será ejecutado accidentalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;le&quot; returns true if the left argument is stringwise less than
or equal to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;le&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente menor o igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># do something here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># hacer algo aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should in general be leery of using functions that could
potentially return lists in scalar context without explicitly stating
such.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe, por lo general, desconfiar del uso de funciones que podrían devolver listas en contexto escalar sin constancia explícita de ello.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl(1).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl(1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\()   list of refs
                          NUMBERS vs STRINGS  LINKS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043340Z" changeid="explorer">
        <seg>\()   lista de ref.
                          NÚMEROS vs CADENAS  ENLACES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($tX, $tY);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($tX, $tY);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you stick 10,000 things in a hash, but evaluating
%HASH in scalar context reveals C&lt;&quot;1/16&quot;&gt;, which means only one out
of sixteen buckets has been touched, and presumably contains all
10,000 of your items.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, supóngase que se insertan 10.000 valores en un hash, pero al evaluar el %HASH en contexto escalar nos devuelve C&lt;&quot;1/16&quot;&gt;, lo cual significa que sólo una de cada dieciséis unidades ha sido tocada, y que probablemente contiene los 10.000 elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of kill when a I&lt;PROCESS&gt; number is zero or negative depends on
the operating system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento de kill cuando el I&lt;PROCESO&gt; es el número cero o negativo depende del sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the use of $ instead of \ in the last example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note el uso de $ en lugar de \ en el último ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^\d+/              string starts with one or more digits</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235606Z" changeid="zipf">
        <seg>/^\d+/              cadena que empieza por uno o varios dígitos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltw		Perl for Traditional Chinese (in Big5)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perltw		Perl para Chino tradicional (en Big5)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal arrays are ordered lists of scalars indexed
by number, starting with 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los arrays normales son listas ordenadas de escalares indexadas por números, empezando por 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checksum is calculated by
summing numeric values of expanded values (for string fields the sum of
C&lt;ord($char)&gt; is taken, for bit fields the sum of zeroes and ones).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La suma de comprobación se calcula sumando los valores numéricos de los valores expandidos (para los campos de cadena se toma la suma de C&lt;ord($char)&gt;; para los campos de bits, la suma de ceros y unos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names
that do not start with a letter, underscore, digit or a caret (i.e.
a control character) are limited to one character, e.g.,  C&lt;$%&gt; or
C&lt;$$&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres que no empiecen ni por letra, ni subrayado, ni dígito, ni acento circunflejo (es decir, un carácter de control) están limitados a un solo carácter, como por ejemplo C&lt;$%&gt; o C&lt;$$&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following are recognized:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo siguiente es reconocido como correcto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the expression is
omitted, one-match searches (C&lt;?pattern?&gt;) are reset to match again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la expresión se omite, las búsquedas de una sola coincidencia (C&lt;?pattern?&gt;) son reinicializadas para que vuelvan a hacer el trabajo de coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise it's a list
operator or unary operator, and precedence does matter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario es un operador de lista u operador unario, y la precedencia sí importa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;THIS and THAT are dups\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;THIS Y THAT son duplicados\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o equivalentemente,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>process($file, 'fh00');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>procesa($archivo, 'fh00');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check L&lt;perlop&gt; for more
detail.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225250Z" changeid="explorer">
        <seg>Consulte L&lt;perlop&gt; para obtener más información)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called in list context, returns a 2-element list consisting of the key
and value for the next element of a hash, or the index and value for the
next element of an array, so that you can iterate over it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se le llama en contexto lista, devuelve una lista de dos elementos consistentes en la clave y el valor del siguiente elementos del hash, o el índice y valor del siguiente elemento del array, así que de esta manera puede iterar por el.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no limit to the number of captured substrings that you may
use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay límite al número de subcadenas capturadas que puede utilizar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives users the freedom of
choice: if they want protected files, they might choose process umasks
of C&lt;022&gt;, C&lt;027&gt;, or even the particularly antisocial mask of C&lt;077&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto ofrece a los usuarios la libertad de elección: si quieren archivos protegidos, podrían elegir un umasks para el proceso de C&lt;022&gt;, C&lt;027&gt;, o incluso la máscara, particularmente antisocial, de C&lt;077&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns false if the context is
looking for a scalar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve falso si el contexto está buscando por un escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you have to look for strings that you don't know till
runtime, you can build an entire loop as a string and C&lt;eval&gt; that to
avoid recompiling all your patterns all the time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si usted tiene que buscar en cadenas que no sabe hasta el tiempo de ejecución, puede crear un bucle completo como una cadena y luego hacerle un C&lt;eval&gt;, para evitar tener que volver a recompilar todos los patrones todo el tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf(&quot;%#02x &quot;, $_) for unpack(&quot;W*&quot;, pack L=&gt;0x12345678);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf(&quot;%#02x &quot;, $_) for unpack(&quot;W*&quot;, pack L=&gt;0x12345678);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (EXPR) BLOQUE elsif (EXPR) BLOQUE ... else BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052945Z" changeid="explorer">
        <seg>$n ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item our EXPR
X&lt;our&gt; X&lt;global&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191937Z" changeid="explorer">
        <seg>=item our EXPR
X&lt;our&gt; X&lt;global&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/grep&gt; for an array composed of those items of
the original list for which the BLOCK or EXPR evaluates to true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también L&lt;/grep&gt; para un array compuesto por los elementos de la lista original en que el BLOQUE o EXPR se evalúa como verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@hash{keys %hash}) { s/foo/bar/g }   # same</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@hash{keys %hash}) { s/foo/bar/g }   # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your system has a strange pointer size--meaning a pointer is neither as
big as an int nor as big as a long--it may not be possible to pack or
unpack pointers in big- or little-endian byte order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su sistema tiene un tamaño de puntero extraño -lo que significa que un puntero no es ni tan grande como un int, ni tan grande como un long- quizás no pueda ser posible empaquetar o desempaquetar punteros en orden big-endian o little-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following are equivalent:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo siguiente es equivalente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &lt;&gt; &gt;&gt; operator is most often seen in a C&lt;while&gt; loop:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T003055Z" changeid="zipf">
        <seg>El operador C&lt;&lt; &lt;&gt; &gt;&gt; se suele utilizar en un bucle C&lt;while&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Configure&gt; now invokes callbacks regardless of the value of the variable
they are called for.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;Configure&gt; ahora invoca retrollamadas, independientemente del valor de la variable que se requiera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gmtime</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gmtime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;\t&gt; X&lt;\n&gt; X&lt;\r&gt; X&lt;\f&gt; X&lt;\b&gt; X&lt;\a&gt; X&lt;\e&gt; X&lt;\x&gt; X&lt;\0&gt; X&lt;\c&gt; X&lt;\N&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;\t&gt; X&lt;\n&gt; X&lt;\r&gt; X&lt;\f&gt; X&lt;\b&gt; X&lt;\a&gt; X&lt;\e&gt; X&lt;\x&gt; X&lt;\0&gt; X&lt;\c&gt; X&lt;\N&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, the scalar variable of the same name as the
FILEHANDLE contains the filename.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211832Z" changeid="explorer">
        <seg>Si EXPR se omite, la variable escalar del mismo nombre que el GESTOR_ARCHIVO contiene el nombre del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl		Perl overview (this section)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T203952Z" changeid="zipf">
        <seg>perl		Perl información general (esta sección)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All systems use the virtual C&lt;&quot;\n&quot;&gt; to represent a line terminator,
called a &quot;newline&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todos los sistemas usan el carácter virtual C&lt;&quot;\n&quot;&gt; para representar un terminador de línea, llamado un &quot;nueva línea&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that
in the latter case, it is usually counter-productive to declare $a and
$b as lexicals.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que en este último caso, que suele ser contraproducente declarar $a y $b como léxicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your stdio requires a seek or eof between reads and writes on a
particular stream, so does Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su stdio requiere un posicionamiento, o un eof entre lecturas y escrituras en un determinado flujo, lo mismo ocurre con Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$_&gt; is lexical in the scope where the C&lt;grep&gt; appears (because it has
been declared with C&lt;my $_&gt;) then, in addition to being locally aliased to
the list elements, C&lt;$_&gt; keeps being lexical inside the block; i.e., it
can't be seen from the outside, avoiding any potential side-effects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$_&gt; es léxica en el ámbito de aplicación donde C&lt;grep&gt; aparece (porque se ha declarado con C&lt;my $_&gt;) entonces, además de ser un alias local a los elementos de la lista, C&lt;$_&gt; se mantiene léxica dentro del bloque; es decir, no puede ser vista desde el exterior, evitando cualquier potencial efecto colateral.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when ($_ &lt; 100) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when ($_ &lt; 100) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;xor&quot; returns the exclusive-OR of the two surrounding expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;xor&quot; devuelve la OR exclusiva de las dos expresiones que la rodean.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;*&quot; multiplies two numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;*&quot; multiplica dos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the LABEL is
omitted, the command refers to the innermost enclosing loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la ETIQUETA se omite, el comando se refiere al bucle más interior en que se encuentre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%by_name = reverse %by_address;  # Invert the hash</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%por_nombre = reverse %por_direccion;  # Invierte el hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a, b, c !;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a, b, c !;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can get more documentation, tutorials and community support
online at L&lt;http://www.perl.org/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede obtener más documentación, seminarios y soporte desde la comunidad en línea en L&lt;http://www.perl.org/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to use a typeglob to save away
a filehandle, do it this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si necesita utilizar un typeglob para guardar un gestor de archivo, hágalo de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item uc EXPR
X&lt;uc&gt; X&lt;uppercase&gt; X&lt;toupper&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210028Z" changeid="explorer">
        <seg>=item uc EXPR
X&lt;uc&gt; X&lt;uppercase&gt; X&lt;toupper&gt; X&lt;mayúsculas&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shutdown(Wtr, 0);        # no more reading for writer</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shutdown(Wtr, 0);        # no más lecturas para el escritor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$@&gt; is empty then the string C&lt;&quot;Died&quot;&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$@&gt; está vacío entonces se usa la cadena C&lt;&quot;Died&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is written in the POD format (see pod/perlpod.pod) which is specially
designed to be readable as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está escrito en formato POD (ver pod/perlpod.pod) que está específicamente diseñado para ser legible de forma sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open ARTICLE or die &quot;Can't find article $ARTICLE: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open ARTICULO or die &quot;No puedo encontrar el artículo $ARTICULO: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the mode contains both the file type and its permissions, you
should mask off the file type portion and (s)printf using a C&lt;&quot;%o&quot;&gt;
if you want to see the real permissions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que el modo contiene el tipo de archivo y sus permisos, debe desenmascarar la porción de tipo de archivo y usar (s)printf con C&lt;&quot;%o&quot;&gt; si desea ver los permisos reales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might like to use C&lt;do&gt; to read in a program configuration
file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar C&lt;do&gt; para leer en un programa un archivo de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when ([1,3,5,7,9]) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when ([1,3,5,7,9]) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support futimes(2), you may pass filehandles among the
files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soporten futimes(2), puede pasar gestores de archivo entre los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An exception is raised if
VERSION is greater than the version of the current Perl interpreter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se genera una excepción si VERSIÓN es mayor que la versión actual del intérprete de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Stat returns list value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># stat devuelve una lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;u&gt;, where it is equivalent to 1 (or 45, which here is equivalent).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;u&gt;, donde es equivalente a 1 (o 45, que aquí es equivalente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq		Perl frequently asked questions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq		Cuestiones frecuentes sobre Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.4g&gt;', 100.01; # prints &quot;&lt;100&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.4g&gt;', 100.01; # imprime &quot;&lt;100&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@george = qw(gone chased yz Punished Axed);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@george = qw(gone chased yz Punished Axed);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (s/\\$//) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (s/\\$//) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;\0\1\0\2&quot; on big-endian</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># &quot;\0\1\0\2&quot; en big-endian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @nums, ( /=(\d+)/ ? $1 : undef );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051414Z" changeid="explorer">
        <seg>push @numeros, ( /=(\d+)/ ? $1 : undef );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl statements end in a semi-colon:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T180809Z" changeid="zipf">
        <seg>Las instrucciones de Perl deben terminar con un signo de punto y coma:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user could specify a filename of
F&lt;&quot;rsh cat file |&quot;&gt;, or you could change certain filenames as needed:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un usuario podría especificar un nombre de archivo de F&lt;&quot;rsh cat archivo |&quot;&gt;, o usted puede cambiar ciertos nombres de archivo, según lo que necesite:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(*** The previous line contains the naughty word &quot;$1&quot;.\n)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(*** La línea anterior contiene la palabra juguetona &quot;$1&quot;.\n)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $n = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $n = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(These are available only if you enable the C&lt;&quot;switch&quot;&gt; feature.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Están disponibles solo si activa la característica C&lt;&quot;switch&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Search::Dict: allow transforming lines before comparing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Search::Dict: permite transformar líneas antes de compararlas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = @foo[$#foo-4 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = @foo[$#foo-4 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with C&lt;$1&gt; being the line number for the next line, and C&lt;$3&gt; being
the optional filename (specified with or without quotes).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>con C&lt;$1&gt; siendo el número de línea para la línea siguiente y C&lt;$3&gt; siendo el nombre de archivo opcional (especificado con o sin comillas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME
X&lt;operator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T232224Z" changeid="explorer">
        <seg>=head1 NOMBRE
X&lt;operator&gt; X&lt;operador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cybernetic pyrotechnics.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pirotecnia cibernética.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SIGNAL is zero, no signal is sent to the process, but C&lt;kill&gt;
checks whether it's I&lt;possible&gt; to send a signal to it (that
means, to be brief, that the process is owned by the same user, or we are
the super-user).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la SEÑAL es cero, no se envía señal al proceso, pero C&lt;kill&gt; comprueba si I&lt;posible&gt; enviar una señal a la misma (lo que significa, para ser breve, que el proceso es propiedad del mismo usuario, o somos el super-usuario).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-C [I&lt;number/list&gt;] &gt;]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-C [I&lt;número/lista&gt;] &gt;]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The left argument is what is
supposed to be searched, substituted, or transliterated instead of the default
$_.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El argumento de la izquierda es lo que se supone que debe ser registrado, sustituido o transcrito en lugar del predeterminado $_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item reverse LIST
X&lt;reverse&gt; X&lt;rev&gt; X&lt;invert&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194714Z" changeid="explorer">
        <seg>=item reverse LISTA
X&lt;reverse&gt; X&lt;rev&gt; X&lt;invert&gt; X&lt;invertir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$x][20] += func2($x);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$x][20] += func2($x);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For how many bytes a string encoded as
UTF-8 would take up, use C&lt;length(Encode::encode_utf8(EXPR))&gt; (you'll have
to C&lt;use Encode&gt; first).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para saber la cantidad de bytes que una cadena codificada como UTF-8 ocupa, utilice C&lt;length(Encode::encode_utf8(EXPR))&gt; (tendrá que poner C&lt;use Encode&gt; primero).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 4) = 8   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 4) = 8   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*d&gt;',  1, 0;   # prints &quot;&lt;0&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*d&gt;',  1, 0;   # imprime &quot;&lt;0&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there was no error, C&lt;$@&gt; is guaranteed to be the empty
string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay errores, se garantiza que C&lt;$@&gt; será una cadena vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsyn/Basic BLOCKs and
Switch Statements&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T195354Z" changeid="explorer">
        <seg>See L&lt;perlsyn/Basic BLOCKs and
Switch Statements&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 128 ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 128 ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$i++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$i++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shmget KEY,SIZE,FLAGS
X&lt;shmget&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200615Z" changeid="explorer">
        <seg>=item shmget CLAVE,TAMAÑO,BANDERAS
X&lt;shmget&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@folks[0, -1]  = @folks[-1, 0];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@gente[0, -1]  = @gente[-1, 0];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chop VARIABLE
X&lt;chop&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170152Z" changeid="explorer">
        <seg>=item chop VARIABLE
X&lt;chop&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of EXPR with all non-&quot;word&quot;
characters backslashed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor de EXPR con todos los caracteres que no sean &quot;palabra&quot; con una barra invertida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prior to Perl version 5.9.1, the result of using an lvalue multiple times was
unspecified.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203453Z" changeid="explorer">
        <seg>Antes de la versión Perl 5.9.1, no estaba especificado el resultado de usar varias veces un I&lt;ivalor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @AoA, [ split ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @AoA, [ split ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item select</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item select</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @sorted    = sort @animals;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025801Z" changeid="explorer">
        <seg>my @ordenados     = sort @animales;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $mon=9, $mday=18 gives &quot;Oct 18&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># $mes=9, $mdia=18 da &quot;Oct 18&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>microperl is supposed to be a really minimal perl, even more
minimal than miniperl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>microperl se supone que es realmente un perl mínimo, incluso aún más que el mínimo miniperl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See examples above under L&lt;Terms and List Operators (Leftward)&gt;.)
X&lt;+&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T190411Z" changeid="explorer">
        <seg>(Ver ejemplos anteriores en L&lt;Términos y Operadores de listas (por la izquierda)&gt;)
X&lt;+&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;-&gt; X&lt;negation, arithmetic&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;-&gt; X&lt;negation, arithmetic&gt; X&lt;negación, aritmética&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But, Unicode properties can have spaces, so
in C&lt;\p{...}&gt;  there can be spaces that follow the Unicode rules, for which see
L&lt;perluniprops/Properties accessible through \p{} and \P{}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110214T002156Z" changeid="explorer">
        <seg>Pero, las propiedades Unicode pueden tener espacios, por lo que en C&lt;\p{...}&gt; puede haber espacios que sigan las reglas Unicode, para lo cual véase L&lt;perluniprops.pod/Propiedades accesibles a través de \p{} y \P{}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NaN is not &quot;&lt;&quot;, &quot;==&quot;, &quot;&gt;&quot;,
&quot;&lt;=&quot; or &quot;&gt;=&quot; anything (even NaN), so those 5 return false.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235141Z" changeid="explorer">
        <seg>NaN no es &quot;&lt;&quot;, &quot;==&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot; o &quot;&gt;=&quot; ni cualquier otra cosa (incluso NaN), así que estos 5 devuelven falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo,  0, 32) = 0x5065726C; # 'Perl'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($foo,  0, 32) = 0x5065726C; # 'Perl'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto&gt;-EXPR form expects a label name, whose scope will be resolved
dynamically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-EXPR espera un nombre de etiqueta, cuyo ámbito será resuelto dinámicamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Logical And
X&lt;operator, logical, and&gt; X&lt;and&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002105Z" changeid="explorer">
        <seg>=head2 And lógico
X&lt;operator, logical, and&gt; X&lt;and&gt; X&lt;operador, lógico, and&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach my $arg (@ARGV) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach my $arg (@ARGV) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the new position, or the undefined value on failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la nueva posición, o el valor indefinido en caso de fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\E		end either case modification or quoted section (think vi)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110214T010921Z" changeid="explorer">
        <seg>\E		fin de modificación tamaño de caja o sección entrecomillada (como en vi)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>no warnings;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no warnings;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To capture a command's STDERR and STDOUT together:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para capturar el STDOUT y STDERR del comando, juntos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you evaluate a hash in scalar context, it returns false if the
hash is empty.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se evalúa un hash en contexto escalar, devuelve falso si el hash está vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;=~&quot; binds a scalar expression to a pattern match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;=~&quot; une una expresión escalar a un patrón de coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A few functions take no arguments at all, and therefore work as neither
unary nor list operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unas pocas funciones no toman ningún argumento, por lo que funcionan tanto como operadores unarios como operadores de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the B&lt;-u&gt;
command-line switch in L&lt;perlrun&gt;, which does the same thing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también la opción de línea de comando B&lt;-u&gt; en L&lt;perlrun&gt;, que hace lo mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 1) = 1   ==          8 00010000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 1) = 1   ==          8 00010000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrecharclass/Bracketed Character Classes&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225039Z" changeid="explorer">
        <seg>Véase L&lt;perlrecharclass/Clases carácter encorchetadas&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$year&gt; is the number of years since 1900, not just the last two digits
of the year.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$anno&gt; es el número de años desde 1900, no sólo los dos últimos dígitos del año.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -Dcc='cc -n32' -Duse64bitint</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002728Z" changeid="explorer">
        <seg>sh Configure -Dcc='cc -n32' -Duse64bitint</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eventually, when a C&lt;write&gt; is done, the contents of
C&lt;$^A&gt; are written to some filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Finalmente, cuando se hace un C&lt;write&gt;, los contenidos de C&lt;$^A&gt; se escriben al gestor de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 8   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 8   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($him, $her)   = @folks[0,-1];              # array slice</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($el, $ella)    = @gente[0,-1];              # porción array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike C&lt;my&gt;, which both allocates storage for a variable and associates
a simple name with that storage for use within the current scope, C&lt;our&gt;
associates a simple name with a package variable in the current package,
for use within the current scope.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de C&lt;my&gt;, que tanto asigna almacenamiento para una variable y asocia un nombre sencillo con este almacenamiento para su uso dentro del ámbito actual, C&lt;our&gt; asocia un nombre sencillo con una variable de paquete en el paquete actual, para su uso en el ámbito actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($paragraph =~ /[a-z]['&quot;)]*[.!?]+['&quot;)]*\s/g) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($parrafo =~ /[a-z]['&quot;)]*[.!?]+['&quot;)]*\s/g) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,17, 1) = 1   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,17, 1) = 1   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check L&lt;perlport&gt; and either the
rename(2) manpage or equivalent system documentation for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compruebe L&lt;perlport&gt; y, o bien la página de manual de rename(2) o documentación equivalente del sistema para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++ $i + $i ++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ++ $i + $i ++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open OLDERR,     &quot;&gt;&amp;&quot;, \*STDERR or die &quot;Can't dup STDERR: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open OLDERR,     &quot;&gt;&amp;&quot;, \*STDERR or die &quot;No puedo duplicar STDERR: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %fruit_color = (&quot;apple&quot;, &quot;red&quot;, &quot;banana&quot;, &quot;yellow&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234320Z" changeid="zipf">
        <seg>my %color_fruta = (&quot;manzana&quot;, &quot;rojo&quot;, &quot;plátano&quot;, &quot;amarillo&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\x{263a}	wide hex char	(example: SMILEY)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003011Z" changeid="explorer">
        <seg>\x{263a}	car. hex ancho	(ejemplo: SMILEY)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you feel the urge to write Perl modules, L&lt;perlnewmod&gt; will give you
good advice.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121048Z" changeid="zipf">
        <seg>Si desea escribir módulos de Perl, L&lt;perlnewmod&gt; le ayudará a empezar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given $foo {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>given $foo {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11865</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11865</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &lt;&lt;EOF
X&lt;here-doc&gt; X&lt;heredoc&gt; X&lt;here-document&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010411Z" changeid="explorer">
        <seg>=item &lt;&lt;EOF
X&lt;here-doc&gt; X&lt;heredoc&gt; X&lt;here-document&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt; X&lt;documento incrustado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To pass a
literal dollar-sign through to the shell you need to hide it with a
backslash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para pasar un signo de dólar literal al shell, necesita escaparlo con una barra invertida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item printf FILEHANDLE FORMAT, LIST
X&lt;printf&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192745Z" changeid="explorer">
        <seg>=item printf GESTOR_ARCHIVO FORMATO, LISTA
X&lt;printf&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%.20g\n&quot;, 123456789123456789;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%.20g\n&quot;, 123456789123456789;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### redo always comes here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>### redo siempre viene aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%.*2$x&gt;&quot;, 1, 6;   # INVALID, but in future will print &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;&lt;%.*2$x&gt;&quot;, 1, 6;   # INVÁLIDO, pero en el futuro imprimirá &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\c[		control char    (example: ESC)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002955Z" changeid="explorer">
        <seg>\c[		control car.    (ejemplo: ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;-X&gt; X&lt;filetest&gt; X&lt;operator, filetest&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;-X&gt; X&lt;filetest&gt; X&lt;operator, filetest&gt; X&lt;operador, test archivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[This function has been largely superseded by the C&lt;untie&gt; function.]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[Esta función ha sido largamente supeditada por la función C&lt;untie&gt;].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Together with
undefining C&lt;$/&gt; to input entire files as one record, this can be quite
fast, often faster than specialized programs like fgrep(1).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Junto con la indefinición de C&lt;$/&gt; para la entrada de archivos completos como un único registro, esto puede ser bastante rápido, a menudo más rápido que los programas especializados como fgrep(1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lcfirst EXPR
X&lt;lcfirst&gt; X&lt;lowercase&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175239Z" changeid="explorer">
        <seg>=item lcfirst EXPR
X&lt;lcfirst&gt; X&lt;lowercase&gt; X&lt;minúscula&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, binmode() should be called after open() but before any I/O
is done on the filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, binmode() debe ser llamada después de open() pero antes de que cualquier I/O se realice sobre el gestor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last update: 2008-10-29</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Última actualización: 2008-10-29</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is so that you can write loops like:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esa manera puede escribir bucles como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No space before the semicolon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin espacio antes de punto y coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, hashes included as parts of other lists (including
parameters lists and return lists from functions) always flatten out into
key/value pairs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, los hashes incluidos como parte de otras listas (incluidas las listas de parámetros y listas de retorno de funciones) siempre se extienden en pares clave / valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;last&gt;, C&lt;next&gt;, or C&lt;redo&gt; may appear within a C&lt;continue&gt;
block; C&lt;last&gt; and C&lt;redo&gt; behave as if they had been executed within
the main block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;last&gt;, C&lt;next&gt; o C&lt;redo&gt; puede aparecer dentro de un bucle C&lt;continue&gt;; C&lt;last&gt; y C&lt;redo&gt; se comportarán como si se hubieran ejecutado dentro del bloque principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>++ --                   == !=      eq ne         cpan.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>++ --                   == !=      eq ne         cpan.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item prototype FUNCTION
X&lt;prototype&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192801Z" changeid="explorer">
        <seg>=item prototype FUNCIÓN
X&lt;prototype&gt; X&lt;prototipo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlink @goners;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlink @goners;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11874</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11874</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results are what the C language system call C&lt;tolower()&gt; returns.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174456Z" changeid="explorer">
        <seg>Los resultados son los que devuelve la llamada del sistema en lenguaje C C&lt;tolower()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;in bytes&gt;: even if the filehandle has been set to operate
on characters (for example by using the C&lt;:encoding(utf8)&gt; I/O layer),
tell() will return byte offsets, not character offsets (because
implementing that would render sysseek() unacceptably slow).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota sobre lo de I&lt;en bytes&gt;: incluso si el gestor de archivo se ha puesto para operar en caracteres (por ejemplo usando la capa de E/S C&lt;:encoding(utf8)&gt;), tell() devolverá desplazamientos en bytes, no en caracteres (porque implementando esto convertirían en inaceptablemente lentas a seek() y tell()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If PID is omitted, returns process
group of current process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si PID se omite, devuelve el grupo del proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is a clever way of making your one-line
conditional blocks more English like:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225135Z" changeid="explorer">
        <seg>Sin embargo, puede escribir los bloques condicionales de una sola línea de manera que recuerden a una frase en inglés:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use 5.6.1;      # ditto</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use 5.6.1;      # ídem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\pP       [3]  Match P, named property.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223744Z" changeid="explorer">
        <seg>\pP	 [3]  Coincide con P, una propiedad nominal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11877</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11877</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@eldest = sort { $age{$b} &lt;=&gt; $age{$a} } keys %age;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@eldest = sort { $edad{$b} &lt;=&gt; $edad{$a} } keys %edad;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TIEARRAY classname, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TIEARRAY clase, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replace C&lt;5.8.6&gt; with your respective version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Reemplace C&lt;5.8.6&gt; con su respectiva versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can
be useful but it may be a memory hog.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225344Z" changeid="explorer">
        <seg>Puede resultar útil, pero esta operación consume mucha memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if
it succeeded, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tiene éxito; de lo contrario, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -Dcc=gcc -Duse64bitint</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002922Z" changeid="explorer">
        <seg>sh Configure -Dcc=gcc -Duse64bitint</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;keys&gt;, C&lt;each&gt;, and C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;keys&gt;, C&lt;each&gt; y C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>socketpair(Rdr, Wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>socketpair(Rdr, Wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Sticky\n&quot; if -k _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Sticky\n&quot; if -k _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setgrent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setgrent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use only on a
scalar value, an array (using C&lt;@&gt;), a hash (using C&lt;%&gt;), a subroutine
(using C&lt;&amp;&gt;), or a typeglob (using C&lt;*&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use solamente sobre un valor escalar, un array (usando C&lt;@&gt;), un hash (con C&lt;%&gt;), una subrutina (con C&lt;&amp;&gt;), o un typeglob (usando C&lt;*&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queries the option named OPTNAME associated with SOCKET at a given LEVEL.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consulta la opción con nombre OPCIÓN asociada con el SOCKET en un determinado NIVEL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The right argument is a search
pattern, substitution, or transliteration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El argumento de la derecha es un patrón de búsqueda, sustitución o transliteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$file = &lt;blurch*&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$archivo = &lt;loquesea*&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^xyz/) { $xyz = 1; last SWITCH; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^xyz/) { $xyz = 1; last SWITCH; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Files: &quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Archivos: &quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a -= 1;        # same as $a = $a - 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a -= 1;        # igual que $a = $a - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is something like
adding a row at a time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es algo así como la adición de una fila cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use Module LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item use Módulo LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used with C&lt;@&gt;, the repeat count represents an offset from the start
of the innermost C&lt;()&gt; group.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se utiliza con C&lt;@&gt;, el número de repeticiones representa un desplazamiento desde el inicio del grupo C&lt;()&gt; más interior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;3: '&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;3: '&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>info perldgux</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>info perldgux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir EXPR
X&lt;chdir&gt;
X&lt;cd&gt;
X&lt;directory, change&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chdir EXPR
X&lt;chdir&gt; X&lt;cd&gt; X&lt;directory, change&gt; X&lt;directorio, cambio&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where an argument is
specified by an explicit index, this does not affect the normal
order for the arguments, even when the explicitly specified index
would have been the next argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se especifica un argumento por un índice explícito, esto no afecta el orden normal de los argumentos, incluso cuando el índice especificado explícitamente habría sido el siguiente argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in some shells, you can enclose the variable name in braces to
disambiguate it from following alphanumerics (and underscores).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que en algunos entornos de líneas de comandos, puede encerrar el nombre de la variable entre llaves para eliminar la ambigüedad de los ulteriores caracteres alfanuméricos (y guiones bajos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example to illustrate how the bits actually fall in place:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este es un ejemplo para ilustrar cómo los bits están amparados efectivamente en su lugar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sort SUBNAME LIST
X&lt;sort&gt; X&lt;qsort&gt; X&lt;quicksort&gt; X&lt;mergesort&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200852Z" changeid="explorer">
        <seg>=item sort NOMBRE_SUB LISTA
X&lt;sort&gt; X&lt;qsort&gt; X&lt;quicksort&gt; X&lt;mergesort&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't usually use
either read-write mode for updating textfiles, since they have
variable length records.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo general, no puede utilizar el modo de lectura y escritura para la actualización de archivos de texto, ya que tienen registros de longitud variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>line number</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defined( $_ = &lt;$fh&gt; ) or die &quot;readline failed: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>defined( $_ = &lt;$fh&gt; ) or die &quot;readline falló: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop control statements don't work in an C&lt;if&gt; or C&lt;unless&gt;, since
they aren't loops.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013439Z" changeid="explorer">
        <seg>Las instrucciones de control de bucle no funcionan en un C&lt;if&gt; o C&lt;unless&gt;, porque no son bucles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also behaves similarly, but avoids $_ :</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto también se comporta de forma similar, pero evita $_:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt; &gt; &lt;= &gt;= lt gt le ge   unless ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt; &gt; &lt;= &gt;= lt gt le ge   unless ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of -pthread put here -lthread.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>en lugar de -pthread, ponga -lthread.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a short, but incomplete summary:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un breve resumen, aunque incompleto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub substr {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub substr {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11825</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11825</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrun&gt;
for the C&lt;-M&gt; and C&lt;-m&gt; command-line options to Perl that give C&lt;use&gt;
functionality from the command-line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlrun&gt; para las opciones en línea de comandos C&lt;-M&gt; y C&lt;-m&gt; para Perl que dan la funcionalidad de C&lt;use&gt; en la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my(@b) = splice(@_,0,shift);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my(@b) = splice(@_,0,shift);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then C&lt;%hash&gt; will have at least 200 buckets allocated for it--256 of them,
in fact, since it rounds up to the next power of two.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>entonces C&lt;%hash&gt; tendrá al menos 200 alojamientos de memoria reservados para él -- 256 de ellos, de hecho, ya que se redondea a la siguiente potencia de dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@b = (1,undef)[1,0,2];  # @b has three elements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@b = (1,undef)[1,0,2];  # @b tiene tres elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dbmclose HASH
X&lt;dbmclose&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170401Z" changeid="explorer">
        <seg>=item dbmclose HASH
X&lt;dbmclose&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SWITCH: {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SWITCH: {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@days		# ($days[0], $days[1],... $days[n])</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@dias		# ($dias[0], $dias[1],... $dias[n])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET
X&lt;syswrite&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211841Z" changeid="explorer">
        <seg>=item syswrite GESTOR_ARCHIVO,ESCALAR,LONGITUD,DESPLAZAMIENTO
X&lt;syswrite&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$baz = 0+$foo &amp; 0+$bar;	# both ops explicitly numeric</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$baz = 0+$foo &amp; 0+$bar;	# ambas op. explícitamente numéricas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The substitution operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador de sustitución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 4) = 8   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 4) = 8   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BINMODE this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BINMODE este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-   subtraction</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235208Z" changeid="zipf">
        <seg>-   resta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously callbacks were only invoked in the
C&lt;case $variable $define)&gt; branch.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Retrollamadas anteriores solo se invocaban en la rama C&lt;case $variable $define)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the rest is either
converted to literal strings to match, or else is ignored (as is
whitespace and C&lt;#&gt;-style comments if C&lt;//x&gt; is present).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo lo demás es o bien convertido en cadenas de literales para ser cotejados, o bien es ignorado (como lo es el espacio en blanco y los comentarios C&lt;#&gt;, si C&lt;//x&gt; está presente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;INSTALL&gt; file for how to build Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El archivo F&lt;INSTALL&gt; (INSTALAR) de cómo construir Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further investigation
is needed to get this working better.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Será necesaria una investigación adicional para que esto funcione mejor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($colors{'red'}, $colors{'blue'}, $colors{'green'})
                   = (0xff0000, 0x0000ff, 0x00ff00);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043057Z" changeid="explorer">
        <seg>($colores{'rojo'}, $colores{'azul'}, $colores{'verde'})
                   = (0xff0000, 0x0000ff, 0x00ff00);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = '150' |  105;	# yields 255</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = '150' |  105;	# produce 255</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also exit(), warn(), and the Carp module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también exit(), warn() y el módulo Carp.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Breaking out</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Saliendo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlock($mbox);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlock($mbox);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to set @ARGV to your own list of files, go right ahead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea establecer @ARGV a su propia lista de archivos, adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T193215Z" changeid="explorer">
        <seg>De otra forma:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may or may not save time, depending on the nature and number of
patterns you are searching on, and on the distribution of character
frequencies in the string to be searched; you probably want to compare
run times with and without it to see which runs faster.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto puede o no ahorrar tiempo, dependiendo de la naturaleza y el número de patrones que esté buscando, y sobre la distribución de frecuencias de caracteres de la cadena a buscar; probablemente querrá comparar los tiempos de funcionamiento con y sin él para ver qué funciona más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^-v/)     { $verbose++  }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^-v/)     { $verboso++  }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Linker Problems in Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003840Z" changeid="explorer">
        <seg>=head2 Problemas de enlazado en Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First character is at
offset C&lt;0&gt;, or whatever you've set C&lt;$[&gt; to (but don't do that).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer carácter está en la posición C&lt;0&gt;, o lo que sea que haya configurado en C&lt;$[&gt; (pero no lo haga).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because both scalars and lists are
automatically interpolated into lists.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es porque ambos tipos, escalares y listas, son automáticamente interpolados en listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An C&lt;eval ''&gt; executed within the C&lt;DB&gt; package doesn't see the usual
surrounding lexical scope, but rather the scope of the first non-DB piece
of code that called it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;eval ''&gt; ejecutado dentro del paquete C&lt;DB&gt; no ve el usual ámbito léxico circundante, sino más bien el ámbito de la primera parte del código no-DB que le llamó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HASH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>HASH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Irix 6.3
and later are okay.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004454Z" changeid="explorer">
        <seg>Irix 6.3 y siquientes están bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stability of these extensions varies widely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La estabilidad de estas extensiones varía ampliamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted incrementa una variable que es numérica, o que haya sido utilizada en un contexto numérico, se obtiene un incremento normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The following is a comprehensive reference to open(): for a gentler
introduction you may consider L&lt;perlopentut&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Lo siguiente es una referencia general a open(): para una introducción más suave puede considerar L&lt;perlopentut&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print while defined($_ = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print while defined($_ = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exhaustive information on the topic of references can be found in
L&lt;perlreftut&gt;, L&lt;perllol&gt;, L&lt;perlref&gt; and L&lt;perldsc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225034Z" changeid="explorer">
        <seg>Encontrará información detallada sobre las referencias en L&lt;perlreftut&gt;, L&lt;perllol&gt;, L&lt;perlref&gt; y L&lt;perldsc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { die &quot;foo lives here&quot; };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { die &quot;foo vive aquí&quot; };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sort( &lt;STDIN&gt; )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sort( &lt;STDIN&gt; )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else {
            # handle all other possible exceptions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043919Z" changeid="explorer">
        <seg>else {
            # controla todas las otras posibles excepciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Building with threads in Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T012147Z" changeid="explorer">
        <seg>=head2 Compilando con hilos en Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sub NAME : ATTRS BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sub NOMBRE : ATRIBS BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item alarm SECONDS
X&lt;alarm&gt;
X&lt;SIGALRM&gt;
X&lt;timer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165518Z" changeid="explorer">
        <seg>=item alarm SEGUNDOS
X&lt;alarm&gt; X&lt;SIGALRM&gt; X&lt;timer&gt; X&lt;alarma&gt; X&lt;temporizador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*before* the &quot;make -f Makefile.micro&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>*antes* del &quot;make -f Makefile.micro&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print hex '0xAf'; # prints '175'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print hex '0xAf'; # imprime '175'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File descriptors (and sometimes locks on those descriptors)
are shared, while everything else is copied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descriptores de archivo (y algunas veces bloqueos en estos descriptores) son compartidos, mientras que todo lo demás es copiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item listen SOCKET,QUEUESIZE
X&lt;listen&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175443Z" changeid="explorer">
        <seg>=item listen SOCKET,TAMAÑO_COLA
X&lt;listen&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIMIT is specified and positive, it represents the maximum number
of fields the EXPR will be split into, though the actual number of
fields returned depends on the number of times PATTERN matches within
EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LÍMITE está especificado y es positivo, representa el máximo número de campos que EXPR será dividido, aunque el número real de campos devueltos depende del número de veces que PATRÓN concuerda en EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ( prompt(); &lt;STDIN&gt;; prompt() ) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ( prompt(); &lt;STDIN&gt;; prompt() ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buyer beware.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los compradores quedan advertidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty&quot;, '-icanon', 'eol', &quot;\001&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty&quot;, '-icanon', 'eol', &quot;\001&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item no MODULE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item no MÓDULO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments should be
integers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los argumentos deben ser números enteros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Object    invokes ~~ overloading on $object, or dies</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  Objeto     invoca ~~ sobrecargado en $objeto, o muere</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 4) = 4   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 4) = 4   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What gets returned depends on several factors:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174229Z" changeid="explorer">
        <seg>Lo que se devuelve depende de varios factores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It doesn't
change your current working directory, which is unaffected.)  For security
reasons, this call is restricted to the superuser.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(No cambia su actual directorio de trabajo actual, que no queda afectado). Por razones de seguridad, esta llamada está reservada al superusuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>qr{}	      Pattern		  yes*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>qr{}	      Patrón		  sí*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 4.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; Capitalized&quot;),	redo LOOP if /\G[A-Z][a-z]+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(&quot; Capitalizados&quot;),	redo LOOP if /\G[A-Z][a-z]+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implements the C library function of the same name, which on most
systems returns the current login from F&lt;/etc/utmp&gt;, if any.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011840Z" changeid="explorer">
        <seg>Implementa la función de la biblioteca C del mismo nombre, que en la mayoría de los sistemas devuelve el login actual desde F&lt;/etc/utmp&gt;, si existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the variable is
implicitly local to the loop and regains its former value upon exiting
the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dicho de otra forma, la variable es implícitamente local al bucle y recupera su valor anterior al salir del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the C&lt;Term::ReadKey&gt;
module from your nearest CPAN site; details on CPAN can be found on
L&lt;perlmodlib/CPAN&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también el módulo C&lt;Term::ReadKey&gt; en su sitio CPAN más cercano; detalles sobre CPAN se pueden encontrar en L&lt;perlmodlib/CPAN&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Actually, there
aren't really functions in this sense, just list operators and unary
operators behaving as functions because you put parentheses around
the arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En realidad, no son realmente funciones en ese sentido, solo son operadores de lista y operadores unarios que se comportan como funciones porque usted pone paréntesis a los argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You probably cannot mix C&lt;alarm&gt; and C&lt;sleep&gt; calls, because C&lt;sleep&gt;
is often implemented using C&lt;alarm&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es probable que no se pueden mezclar las llamadas C&lt;alarm&gt; y C&lt;sleep&gt;, debido a que C&lt;sleep&gt; a menudo está implementado en C&lt;alarm&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub/&quot;Localized deletion of elements of composite types&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub/&quot;Eliminación local de elementos de tipos compuestos&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ein = $rin | $win;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ein = $rin | $win;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only characters C&lt;A-Z&gt; change, to C&lt;a-z&gt;
respectively.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174555Z" changeid="explorer">
        <seg>Sólo los caracteres C&lt;A-Z&gt; cambian, a C&lt;a-z&gt;, respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These hooks are also permitted to set the %INC entry
corresponding to the files they have loaded.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos enganches también están autorizados para establecer la entradas %INC correspondientes a los archivos que se hayan cargado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require &quot;sys/ioctl.ph&quot;;  # probably in $Config{archlib}/sys/ioctl.ph</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require &quot;sys/ioctl.ph&quot;;  # probablemente en $Config{archlib}/sys/ioctl.ph</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%10.6x&gt;', 1;    # prints &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%10.6x&gt;', 1;    # imprime &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/seek&gt; for some details about mixing reading and writing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/seek&gt; para más detalles acerca de mezclar lectura y escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 32  ==         32 00000100000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 32  ==         32 00000100000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to switch</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Palabras clave relativas al I&lt;switch&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a list consisting of all the keys of the named hash, or the indices
of an array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una lista consistente de todas las claves del hash indicado, o los índices de un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will print 'A' and then terminate, as it considers the match to
be zero-width, and thus will not match at the same position twice in a
row.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Imprimirá 'A' y entonces termina, pues considera la coincidencia de un ancho cero, y por lo tanto no coincidirá en la misma posición dos veces para la misma cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless you've
changed this (i.e., Configure -Uuseperlio), you can open filehandles 
directly to Perl scalars via:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A menos que haya cambiado esto (es decir, Configure -Uuseperlio), puede abrir gestores de archivo directamente a escalares Perl de esta forma:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 5.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can change the way that an object is matched by overloading
the C&lt;~~&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede cambiar la forma en que un objeto es comparado, sobrecargando el operador C&lt;~~&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print while &lt;STDIN&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print while &lt;STDIN&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With
an explicit repeat count for pack, the packed string is adjusted to that
length.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con un contador de repeticiones explícito para el empaquetado, la cadena de empaquetado se ajusta a esa longitud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item msgctl ID,CMD,ARG
X&lt;msgctl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191436Z" changeid="explorer">
        <seg>=item msgctl ID,CMD,ARG
X&lt;msgctl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlperf		Perl Performance and Optimization Techniques</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlperf		Técnicas de rendimiento y optimización</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is then interpreted as an external
command, and the output of that command is the value of the
backtick string, like in a shell.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entonces es interpretado como un comando externo, y la salida de ese comando es el valor de la cadena entrecomillada, como en un I&lt;shell&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that you understand how C&lt;require&gt; looks for files with a
bareword argument, there is a little extra functionality going on behind
the scenes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora que sabe cómo C&lt;require&gt; busca archivos con un argumento simple, hay una funcionalidad extra que pasa por detrás de las cámaras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;!&quot; performs logical negation, i.e., &quot;not&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El unario &quot;!&quot; realiza la negación lógica, es decir, &quot;not&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows your code to work with the standard L&lt;crypt|/crypt&gt; and
with more exotic implementations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto permite a su código trabajar con el estándar L&lt;crypt|/crypt&gt; y con implementaciones más exóticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add the if pragma</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadido el pragma if</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Starting analysis\n&quot; if $verbose;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Empezando análisis\n&quot; if $locuaz;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\Q		quote non-word characters till \E</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003230Z" changeid="explorer">
        <seg>\Q		escapa los caracteres no alfanuméricos hasta \E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl
parses it without error, but when you try to execute a yada yada, it
throws an exception with the text C&lt;Unimplemented&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl lo interpreta sin error, pero al intentar ejecutar un blablablá, produce una excepción con el texto C&lt;Unimplemented&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also triggers an
uninitialized warning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto también desencadena una advertencia de datos no inicializados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at goop line 345.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at goop line 345.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Tutorials</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Seminarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of it as a goto with an intervening core dump and reincarnation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Piense en él como un goto entre un volcado del núcleo y una reencarnación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To guarantee this to be
true, add a C&lt;0&gt; to the scalar before using it.)  The C&lt;pack&gt; and C&lt;unpack&gt;
functions may be needed to manipulate the values of structures used by
C&lt;ioctl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para garantizar este último comportamiento, añada un C&lt;0&gt; al escalar antes de usarlo). Las funciones C&lt;pack&gt; y C&lt;unpack&gt; pueden ser necesarias para manipular los valores de las estructuras usadas por C&lt;ioctl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map +( lc($_) =&gt; 1 ), @array  # this is EXPR and works!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map +( lc($_) =&gt; 1 ), @array  # esto es EXPR ¡y funciona!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># assign a reference to array of array references</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># asignar una referencia a un array de referencias de array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^\s+//;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^\s+//;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;I found the yada yada!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;¡He encontrado el blablablá!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, you have to open each element of
C&lt;@ARGV&gt; yourself since C&lt;eof&gt; handles C&lt;ARGV&gt; differently.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En este caso, tiene que abrir cada elemento de C&lt;@ARGV&gt; debido a que C&lt;eof&gt; maneja C&lt;ARGV&gt; de otra manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++($foo = 'a0');	# prints 'a1'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ++($foo = 'a0');	# imprime 'a1'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a field width obtained through C&lt;*&gt; is negative, it has the same
effect as the C&lt;-&gt; flag: left-justification.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si un ancho de campo obtenidos a través de C&lt;*&gt; es negativo, tiene el mismo efecto que la bandera C&lt;-&gt;: alineación a la izquierda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/^abc/) { $abc = 1; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/^abc/) { $abc = 1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to remove the line terminator from your here-docs,
use C&lt;chomp()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea quitar el carácter de fin de línea de los documentos incrustados, utilice C&lt;chomp()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The require function will actually look for the &quot;F&lt;Foo/Bar.pm&gt;&quot; file in the
directories specified in the C&lt;@INC&gt; array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función require realmente buscará el archivo &quot;F&lt;Foo/Bar.pm&gt;&quot; en los directorios especificados en el array C&lt;@INC&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is silently ignored for all other
types.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se ignora silenciosamente todos los demás tipos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are two common cases:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay dos casos comunes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item waitpid PID,FLAGS
X&lt;waitpid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210951Z" changeid="explorer">
        <seg>=item waitpid PID,BANDERAS
X&lt;waitpid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 3.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This requires either that the platform natively support quads,
or that Perl were specifically compiled to support quads.) You can find out
whether your Perl supports quads via L&lt;Config&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto requiere que la plataforma, ya sea que soporte quads de forma nativa, o que Perl fuera compilado específicamente para apoyar quads). Usted puede averiguar si su Perl soporta quads a través de L&lt;Config&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcall		Perl calling conventions from C</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlcall		Convenciones de llamadas desde C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$count = () = $string =~ /\d+/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cuenta = () = $cadena =~ /\d+/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SYNOPSIS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SINOPSIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare a
subroutine without defining it by saying C&lt;sub name&gt;, thus:
X&lt;subroutine, declaration&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede declarar una subrutina sin definirla diciendo C&lt;sub nombre&gt;, como: X&lt;subrutina, declaración&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&lt;&lt;&quot; returns the value of its left argument shifted left by the
number of bits specified by the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&lt;&lt;&quot; devuelve el valor de su argumento de la izquierda desplazado por el número de bits especificado por el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With non-alphabetical characters, the result is based on the 4 least-significant
bits of the input character, i.e., on C&lt;ord($char)%16&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con caracteres no-alfabéticos, el resultado se basa en los 4 bits menos significativos del carácter de entrada, es decir, en C&lt;ord($carácter)%16&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, exiting
69 (EX_UNAVAILABLE) from a I&lt;sendmail&gt; incoming-mail filter will cause
the mailer to return the item undelivered, but that's not true everywhere.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, saliendo con 69 (EX_UNAVAILABLE) desde un filtrado de un correo entrante hacia I&lt;sendmail&gt; hará que el despachador de correo devuelva el elemento sin entregar, pero no siempre es cierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$just_a = 1 when /^a/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$solo_a = 1 when /^a/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+                   one or more of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230543Z" changeid="zipf">
        <seg>+                   una o más coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, even under C&lt;use
integer&gt;, if you take the C&lt;sqrt(2)&gt;, you'll still get C&lt;1.4142135623731&gt;
or so.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, incluso bajo C&lt;use integer&gt;, si toma C&lt;sqrt(2)&gt;, seguirá obteniendo, más o menos, C&lt;1.4142135623731&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When opening a file, it's seldom a good idea to continue 
if the request failed, so C&lt;open&gt; is frequently used with
C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al abrir un archivo, es difícil que sea una buena idea seguir si la solicitud ha fallado, por lo que C&lt;open&gt; se utiliza con frecuencia con C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|	Alternation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>|	Alternativas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using
uppercase filehandles also improves readability and protects you
from conflict with future reserved words.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilizar gestores de archivo en mayúsculas mejora la legibilidad de los programas y les protege de conflictos con futuras palabras reservadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right	?:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>derecha	?:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;=  less than or equal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;=  menor o igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true
for success, false on failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero para éxito, falso en fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you should be very careful that the outer bracket type
is a round one, that is, a parenthesis.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora, debe tener mucho cuidado de que el paréntesis externo debe ser eso: un paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A special thanks to Damian Conway, who didn't only suggest important changes,
but also took the time to count the number of listed features and make a
Perl 6 version to show that Perl will stay Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un agradecimiento especial a Damian Conway, quien no sólo sugirió importantes cambios, sino que se tomó el tiempo suficiente para contar las características listadas y hacer una versión para Perl 6 y demostrar que Perl seguirá siendo Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Perl uses doubles (or long doubles, if configured) internally for
all numeric calculation, converting from double into float and thence 
to double again loses precision, so C&lt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&gt;)
will not in general equal $foo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a Perl utiliza dobles (o dobles largos, si está configurado) internamente para todos cálculos numéricos, convirtiendo de doble en flotante y de allí a doble de nuevo, pierde precisión, por lo que C&lt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&gt;) no será, generalmente, igual a $foo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>abc&quot;def</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>abc&quot;def</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Array     match against an array element[3]
                                               grep $a ~~ $_, @$b</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054652Z" changeid="explorer">
        <seg>Cualq.  Array     busca en un array      elemento[3]
                                               grep $a ~~ $_, @$b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select($rout=$rin, $wout=$win, $eout=$ein, $timeout);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select($rout=$rin, $wout=$win, $eout=$ein, $tiempo_espera);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you hit
EOF on your read and then sleep for a while, you (probably) have to stick in a
dummy seek() to reset things.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una vez que llegue al EOF en lectura y si se echa a dormir por un tiempo, (probablemente) tendrá que tocarlo con un ficticio seek() para restablecer las cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There can be whitespace between the operator and the quoting
characters, except when C&lt;#&gt; is being used as the quoting character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede haber espacios en blanco entre el operador y los caracteres delimitadores, excepto cuando C&lt;#&gt; se utiliza como carácter delimitador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, you get the name, unless the function was a
lookup by name, in which case you get the other thing, whatever it is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, obtiene el nombre, a menos que la función fuera localizar por nombre, en cuyo caso obtendrá la otra cosa, cualquiera que sea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should resolve problems with initializing and destroying the Perl
interpreter more than once in a single process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto debería resolver los problemas con la inicialización y destrucción del intérprete de Perl presente más de una vez en un único proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also get the precision from the next argument using C&lt;.*&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede obtener la precisión del siguiente argumento usando C&lt;.*&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if OS returns:      then Perl returns:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>si OS devuelve:    entonces Perl devuelve:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlobj		Perl objects</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlobj		Objetos Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcygwin		Perl notes for Cygwin</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlcygwin		Notas para Cygwin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If TEMPLATE requires fewer arguments
than given, extra arguments are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si PLANTILLA requiere menos argumentos de los que se le dan, los argumentos adicionales son ignorados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Smart matching in detail</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Coincidencia inteligente en detalle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing of C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt;, and interpolation
happens as with C&lt;qq//&gt; constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procesamiento de C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt;, e interpolación ocurre igual que en las construcciones C&lt;qq//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$iaddr = inet_aton(&quot;127.1&quot;); # or whatever address</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$iaddr = inet_aton(&quot;127.1&quot;); # o la dirección que sea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final semicolon, if any, may be omitted from the value of EXPR or within
the BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El último punto y coma, si lo hay, puede ser omitido del valor de EXPR o dentro de BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opens the UTF-8 encoded file containing Unicode characters;
see L&lt;perluniintro&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>abre el archivo codificado en UTF-8 que contiene caracteres Unicode; ver L&lt;perluniintro&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the child process, the filehandle isn't opened--I/O happens from/to
the new STDOUT/STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el proceso hijo, el gestor de archivo no se abre: la E/S sucede desde/hasta el nuevo STDOUT/STDIN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$program =~ s {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$programa =~ s {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A double-quoted, interpolated string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un doble entrecomillado, la cadena es interpolada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, Perl defines the following:
X&lt;\g&gt; X&lt;\k&gt; X&lt;\K&gt; X&lt;backreference&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110220T230137Z" changeid="explorer">
        <seg>Ademas, Perl define lo siguiente:
X&lt;\g&gt; X&lt;\k&gt; X&lt;\K&gt; X&lt;backreference&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If, on the other hand, you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por otra parte, si se escribe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of characters
actually read, C&lt;0&gt; at end of file, or undef if there was an error (in
the latter case C&lt;$!&gt; is also set).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de caracteres actualmente leídos, C&lt;0&gt; al final del archivo, o undef si hubo un error (en este último caso se actualiza el valor de C&lt;$!&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># record flocking enforcement, a platform-dependent feature.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># bloqueo forzado de registro, una característica dependiente de la plataforma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fatal error &quot;DESTROY created new reference to dead object&quot; is now
documented in L&lt;perldiag&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El error fatal &quot;DESTROY creó una nueva referencia al objeto muerto&quot; ya está documentada en L&lt;perldiag&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The inode change time of each file is set
to the current time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El tiempo de cambio de inodo de cada archivo se establece en la hora actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The byteorder on the platform where Perl was built is also available
via L&lt;Config&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El orden de los bytes en la plataforma donde Perl fue compilado está también disponible vía L&lt;Config&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;homer&quot;, &quot;bart&quot;, &quot;marge&quot;, &quot;maggie&quot;, ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;homer&quot;, &quot;bart&quot;, &quot;marge&quot;, &quot;maggie&quot;, ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$now_string = localtime;  # e.g., &quot;Thu Oct 13 04:54:34 1994&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ahora = gmtime;  # ej., &quot;Thu Oct 13 04:54:34 1994&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Foreach Loops
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042130Z" changeid="explorer">
        <seg>=head2 Bucles Foreach
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (my $j = 0; $j &lt; @ary2; $j++) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (my $j = 0; $j &lt; @ary2; $j++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And so on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y así sucesivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item -X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a real flock(2), locks are inherited across fork()
calls, whereas those that must resort to the more capricious fcntl(2)
function lose their locks, making it seriously harder to write servers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soportan un flock(2) de verdad, los bloqueos se heredan a través de las llamadas fork(), teniendo en cuenta que se recurrirá a la caprichosa función fcntl(2) que pierde sus bloqueos, haciendo difícil escribir servidores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 8   ==          8 00010000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 8   ==          8 00010000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LENGTH is negative, removes the elements from OFFSET onward
except for -LENGTH elements at the end of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LONGIIUD es negativa, elimina los elementos desde DESPLAZAMIENTO hacia adelante, excepto -LONGITUD elementos al final del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item defined EXPR
X&lt;defined&gt; X&lt;undef&gt; X&lt;undefined&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170445Z" changeid="explorer">
        <seg>=item defined EXPR
X&lt;defined&gt; X&lt;undef&gt; X&lt;undefined&gt; X&lt;definido&gt; X&lt;indefinido&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item require VERSION
X&lt;require&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194605Z" changeid="explorer">
        <seg>=item require VERSIÓN
X&lt;require&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%*1$.*s&gt;&quot;, $a, $b;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;&lt;%*1$.*s&gt;&quot;, $a, $b;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Setuid/Setgid/Stickiness/SaveText.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Setuid/Setgid/Stickiness/SaveText.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Binding Operators
X&lt;binding&gt; X&lt;operator, binding&gt; X&lt;=~&gt; X&lt;!~&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234339Z" changeid="explorer">
        <seg>=head2 Operadores de vinculación
X&lt;binding&gt; X&lt;operator, binding&gt; X&lt;=~&gt; X&lt;!~&gt; X&lt;vinculación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next LINE if /^#/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next LINEA if /^#/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if /\b(tcl|java|python)\b/i;      # :-)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if /\b(tcl|java|python)\b/i;      # :-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EXTEND this, count</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EXTEND este, contador</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; for function, variable and module names (and more
generally anything that can be considered part of code, like filehandles
or specific values).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; por función, variable y nombres de módulos (y más generalmente cualquier cosa que pueda ser considerada parte del código, como gestores de archivo o valores específicos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item system LIST
X&lt;system&gt; X&lt;shell&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204411Z" changeid="explorer">
        <seg>=item system LISTA
X&lt;system&gt; X&lt;shell&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To set the default output handle to something other than STDOUT
use the select operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para configurar el controlador de salida predeterminada a otro valor distinto de STDOUT, use el operador select.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item push ARRAY,LIST
X&lt;push&gt; X&lt;stack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192813Z" changeid="explorer">
        <seg>=item push ARRAY,LISTA
X&lt;push&gt; X&lt;stack&gt; X&lt;pila&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item truncate EXPR,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item truncate EXPR,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (;;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (;;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may want to remove it from your link line.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004734Z" changeid="explorer">
        <seg>Si lo desea puede eliminarlo de su línea de enlazado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words,
list operators tend to gobble up all arguments that follow, and
then act like a simple TERM with regard to the preceding expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, los operadores de lista tienden a devorar todos los argumentos que le siguen, y luego actuar como un simple TÉRMINO con respecto a la expresión precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are any key/value pairs, it returns true;
more precisely, the value returned is a string consisting of the
number of used buckets and the number of allocated buckets, separated
by a slash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si tiene algún par clave/valor, devuelve verdadero; más exactamente, el valor devuelto es una cadena que consiste en el número de cajones utilizados y el número de cajones reservados, separados por una barra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to sort the list returned by the function call
C&lt;find_records(@key)&gt;, you can use:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201012Z" changeid="explorer">
        <seg>Si quiere ordenar la lista devuelta por la llamada a la función C&lt;find_records(@key)&gt;, puede usar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a=3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a=3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sysread FILEHANDLE,SCALAR,LENGTH,OFFSET
X&lt;sysread&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204230Z" changeid="explorer">
        <seg>=item sysread GESTOR_ARCHIVO,ESCALAR,LONGITUD,DESPLAZAMIENTO
X&lt;sysread&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$file is executable NFS file\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$archivo es un archivo NFS ejecutable\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes various features of OpenBSD that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documentos describe varias características de OpenBSD que afectarán a cómo Perl versión 5 (de ahora en adelante sólo Perl) es compilado y/o ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-1               undefined value
         0              string &quot;0 but true&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050229Z" changeid="explorer">
        <seg>-1               valor indefinido
         0              cadena &quot;0 but true&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another consequence of using binmode() (on some systems) is that
special end-of-file markers will be seen as part of the data stream.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otra consecuencia de usar binmode() (en algunos sistemas) es que las marcas especiales de fin-de-archivo serán vistas como parte del flujo de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the C&lt;$/&gt; and C&lt;$\&gt; variables
in L&lt;perlvar&gt; for how to manually set your input and output
line-termination sequences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver las variables C&lt;$/&gt; y C&lt;$\&gt; en L&lt;perlvar&gt; para cómo poner manualmente sus secuencias de fin de línea en su entrada y salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$is_his = (stat($filename)-&gt;uid == pwent($whoever)-&gt;uid);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$is_his = (stat($archivo)-&gt;uid == pwent($loquesea)-&gt;uid);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if( $@ eq 'Unimplemented' ) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if( $@ eq 'No implementado' ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like special scalars and arrays, there are also special hashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224937Z" changeid="explorer">
        <seg>De la misma manera que hay escalares y arrays especiales, también hay hashes especiales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This isn't supposed to happen.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg> Se supone que esto no debe de ocurrir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13179</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13179</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So avoid C&lt;$&amp;&gt;, C&lt;$'&gt;, and C&lt;$`&gt;
if you can, but if you can't (and some algorithms really appreciate
them), once you've used them once, use them at will, because you've
already paid the price.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que evite C&lt;$&amp;&gt;, C&lt;$'&gt;, y C&lt;$`&gt; si puede, pero si no puede (y algunos algoritmos realmente los necesitan), una vez que los use aunque sea una sola vez, úselos a voluntad, ya que ya habrá pagado el precio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlop/&quot;Quote and Quote-like Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185014Z" changeid="explorer">
        <seg>Ver L&lt;perlop/&quot;Comillas y Operadores de comillas&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (defined($_ = &lt;STDIN&gt;)) { print; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (defined($_ = &lt;STDIN&gt;)) { print; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you're using
lexically-scoped private variables created with C&lt;my()&gt;, you'll
have to make sure
your format or subroutine definition is within the same block scope
as the my if you expect to be able to access those private variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si está usando variables privadas en un contexto local creadas con C&lt;my()&gt;, deberá asegurarse que su definición de formato o subrutina están dentro del mismo bloque que el C&lt;my&gt; si quiere acceder a estas variables privadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If what's within the angle brackets is neither a filehandle nor a simple
scalar variable containing a filehandle name, typeglob, or typeglob
reference, it is interpreted as a filename pattern to be globbed, and
either a list of filenames or the next filename in the list is returned,
depending on context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si lo que está dentro de los ángulos no es ni un gestor de archivo ni una variable escalar simple que contenga un nombre de gestor de archivo, I&lt;typeglob&gt;, o referencia a I&lt;typeglob&gt;, se interpreta como un patrón de nombre de archivo para ser expandido, y será devuelta la lista de nombres de archivo o el siguiente nombre de archivo de la lista, dependiendo del contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this filehandle must be a real filehandle (strictly a typeglob
or reference to a typeglob, blessed or unblessed); tied filehandles will be
ignored and return value processing will stop there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que este gestor de archivo debe ser un gestor de archivo real (en sentido estricto un typeglob o referencia a un typeglob, bendecido o no); controladores de archivo enlazados serán ignorados y el procesado del valor de retorno terminará ahí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values for LEVEL can also be obtained from
getprotobyname.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores para NIVEL también se pueden obtener de getprotobyname.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta también que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pluggable optimizer</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>optimizador conectable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the integer number of seconds actually slept.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número entero de segundos realmente dormidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in C&lt;2 + 4 * 5&gt;, the multiplication has higher
precedence so C&lt;4 * 5&gt; is evaluated first yielding C&lt;2 + 20 ==
22&gt; and not C&lt;6 * 5 == 30&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T010118Z" changeid="explorer">
        <seg>Por ejemplo, en C&lt;2 + 4 * 5&gt;, la multiplicación tiene una precedencia mayor por lo que C&lt;4 * 5&gt; es evaluado primero, resultando C&lt;2 + 20 == 22&gt; y no C&lt;6 * 5 == 30&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;eq&quot; returns true if the left argument is stringwise equal to
the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;eq&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must also do
this when interpolating a variable into a string to separate the
variable name from a following double-colon or an apostrophe, since
these would be otherwise treated as a package separator:
X&lt;interpolation&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También debe hacer esto cuando la interpolación de una variable en una cadena para separar el nombre de una variable del carácter dos puntos o un apóstrofo, ya que de otro modo serían tratados como un separador de paquete:
X &lt;interpolation&gt; X&lt;interpolación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $AoA[0][0];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193222Z" changeid="explorer">
        <seg>print $AoA[0][0];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval '$answer = $a / $b'; warn $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval '$respuesta = $a / $b'; warn $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So C&lt;my $logmessage = shift;&gt; shifts the first item off the list of
arguments and assigns it to C&lt;$logmessage&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T230343Z" changeid="explorer">
        <seg>Así, C&lt;my $mensaje_registro = shift;&gt; quita el primer elemento de la lista de argumentos y se lo asigna a C&lt;$mensaje_registro&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interprets EXPR as a hex string and returns the corresponding value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Interpreta EXPR como una cadena en hexadecimal y devuelve el valor correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I said foo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He dicho foo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bits of a byte are
numbered in a little-endian-ish way, as in C&lt;0x01&gt;, C&lt;0x02&gt;,
C&lt;0x04&gt;, C&lt;0x08&gt;, C&lt;0x10&gt;, C&lt;0x20&gt;, C&lt;0x40&gt;, C&lt;0x80&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los bits de un byte se numeran de la forma little-endian, como en C&lt;0x01&gt;, C&lt;0x02&gt;, C&lt;0x04&gt;, C&lt;0x08&gt;, C&lt;;0x10&gt;, C&lt;0x20&gt;, C&lt;0x40&gt;; C&lt;0x80&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use sort '_mergesort';  # note discouraging _</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use sort '_mergesort';  # note el desalentador _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (;&lt;STDIN&gt;;) { print; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (;&lt;STDIN&gt;;) { print; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@dots = grep { /^\./ &amp;&amp; -f &quot;$some_dir/$_&quot; } readdir($dh);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@dots = grep { /^\./ &amp;&amp; -f &quot;$algun_dir/$_&quot; } readdir($dh);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some have been
part of the core language for many years.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos han sido parte del núcleo del lenguaje durante muchos años.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 1+2+4;      # Prints 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print 1+2+4;	# Imprime 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the position of the first occurrence of SUBSTR in STR at
or after POSITION.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la posición de la primera ocurrencia de SUBSTR en STRING en o después de POSICIÓN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;STDIN&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;STDIN&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;O_EXCL&gt; may not work
on network filesystems, and has no effect unless the C&lt;O_CREAT&gt; flag
is set as well.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;O_EXCL&gt; quizás no funcione en sistemas de archivos en red, y no tiene ningún efecto a menos que el indicador C&lt;O_CREAT&gt; también esté establecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_ISBLK($mode) S_ISCHR($mode) S_ISFIFO($mode) S_ISSOCK($mode)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_ISBLK($modo) S_ISCHR($modo) S_ISFIFO($modo) S_ISSOCK($modo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If protected by C&lt;\&gt;, C&lt;$&gt; will be quoted to became
C&lt;&quot;\\\$&quot;&gt;; if not, it is interpreted as the start of an interpolated
scalar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está protegido por un C&lt;\&gt;, C&lt;$&gt; será escapado para convertirse en C&lt;&quot;\\\$&quot;&gt;; si no, es interpretado como el inicio de un escalar interpolado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode semantics are used for the case change.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175102Z" changeid="explorer">
        <seg>Semántica Unicode es utilizada para el cambio de tamaño de caja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your bug report, along with the
output of C&lt;perl -V&gt;, will be sent off to perlbug@perl.org to be
analysed by the Perl porting team.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su informe de error, junto con la salida de C&lt;perl -V&gt;, serán enviados a perlbug@perl.org para ser analizado por el equipo de adaptación de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;ge&quot; returns true if the left argument is stringwise greater
than or equal to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;ge&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente mayor o igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	and</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	and</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just don't forget that you have to put a semicolon on the end
to finish the statement, as Perl doesn't know you're not going to
try to do this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012733Z" changeid="explorer">
        <seg>Pero no olvide que tiene que poner un punto y coma al final para terminar la instrucción, ya que Perl no sabe que no vamos a tratar de hacer esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item while</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232633Z" changeid="explorer">
        <seg>=item while</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the Carp module for other kinds of warnings using its
carp() and cluck() functions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase el módulo Carp para otros tipos de avisos mediante sus funciones carp() y cluck().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0b011011            # binary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0b011011            # binario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The price is $Price.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El precio es $Precio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To mark FILEHANDLE as UTF-8, use C&lt;:utf8&gt; or C&lt;:encoding(utf8)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211247Z" changeid="explorer">
        <seg>Para indicar GESTOR_ARCHIVO como UTF-8, use C&lt;:utf8&gt; o C&lt;:encoding(utf8)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This safer version of L&lt;/chop&gt; removes any trailing string
that corresponds to the current value of C&lt;$/&gt; (also known as
$INPUT_RECORD_SEPARATOR in the C&lt;English&gt; module).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la versión segura de L&lt;/chop&gt;, que quita cualquier string restante que corresponda al valor actual de C&lt;$/&gt; (también conocido como $INPUT_RECORD_SEPARATOR -separador de registros en entrada- en el módulo C&lt;English&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># and UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># y UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code freeze for the next maintenance release (5.8.4) is on March 31st 2004,
with release expected by mid April.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Código congelado para la próxima versión de mantenimiento (5.8.4) será el 31 de marzo de 2004, con el lanzamiento previsto para mediados de abril.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will need to seek() to do the
reading.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Necesitará usar seek() para hacer la lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%  ??</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004948Z" changeid="explorer">
        <seg>%  ??</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Round number to 3 digits after decimal point</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Redondea número a 3 dígitos después del punto decimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This program will print only the line containing &quot;Bar&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este programa imprimirá sólo la línea que contiene &quot;Bar&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/$unquoted\Q$quoted\E$unquoted/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/$noescapados\Q$escapados\E$noescapados/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++($foo = 'Az');	# prints 'Ba'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ++($foo = 'Az');	# imprime 'Ba'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># U0-mode, so the UTF-8 bytes get joined into characters</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un modo U0, así que los bytes UTF-8 se han unidos en caracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlapi		Perl API listing (autogenerated)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlapi		Listado de la API (autogenerada)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Growing Your Own</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Creciendo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;stat&gt; is passed the special filehandle consisting of an underline, no
stat is done, but the current contents of the stat structure from the
last C&lt;stat&gt;, C&lt;lstat&gt;, or filetest are returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si a C&lt;stat&gt; se le pasa el gestor de archivo especial consistente en un subrayado, no se hacen estadísticas, sino que se devuelven el contenido actual de la estructura de estadísticas de la última llamada C&lt;stat&gt;, C&lt;lstat&gt;, o test de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># (warning: assumes no { or } in strings)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># (aviso: asumes que no hay { o } en cadenas)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implicit localisation occurs I&lt;only&gt; in a C&lt;foreach&gt;
loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta implícita localización ocurre I&lt;solamente&gt; en un bucle C&lt;foreach&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;system&gt;'s arguments are executed indirectly by the shell, 
results and return codes are subject to its quirks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando los argumentos de C&lt;system&gt; son ejecutados indirectamente por el shell, los resultados y los códigos de retorno están sujetos a sus caprichos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/my&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/my&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@fields = split /(A)|B/, &quot;1A2B3&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@campos = split /(A)|B/, &quot;1A2B3&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is at this stage that C&lt;split()&gt; silently optimizes C&lt;/^/&gt; to
mean C&lt;/^/m&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es en esta etapa en que C&lt;split()&gt;, silenciosamente, optimiza C&lt;/^/&gt; para que signifique C&lt;/^/m&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;Connect to %s [%s]\n&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Conectar a %s [%s]\n&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/^def/) { $def = 1; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/^def/) { $def = 1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is
implemented using C's pow(3) function, which actually works on doubles
internally.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto se realiza mediante la función del C pow(3), que en realidad trabaja internamente con dobles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How that string gets evaluated is entirely subject to the command
interpreter on your system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El cómo esta cadena es evaluada, está sujeta enteramente al intérprete de comandos de su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most modern systems
always sleep the full amount.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de los sistemas modernos siempre duermen la cantidad correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section hopes to clarify how Perl handles quoted constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta sección pretende aclarar la manera en que Perl maneja las construcciones entrecomilladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function shmget.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC shmget(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, because C&lt;eval&gt; traps otherwise-fatal errors, it is useful for
determining whether a particular feature (such as C&lt;socket&gt; or C&lt;symlink&gt;)
is implemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que, como C&lt;eval&gt; atrapa errores considerados fatales, es útil para determinar cuando una característica en particular (como C&lt;socket&gt; o C&lt;symlink&gt;) está implementada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you may want to truncate an already-existing file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A veces puede querer truncar un archivo ya existente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = '56789';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$x = '56789';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>p	When matching preserve a copy of the matched string so</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>p	Cuando exista una coincidencia preserva una copia de la cadena concordante,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/\*	# Match the opening delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/\*	# Busca el delimitador de apertura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/Predefined Names&gt; for these
variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/Nombres predefinidos&gt; para estas variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LVALUE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LVALUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub splice_2D {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053021Z" changeid="explorer">
        <seg>sub splice_2D {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Scalar::Util &quot;blessed&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Scalar::Util &quot;blessed&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ee  Evaluate the right side as a string then eval the result</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ee	Evalúa el lado derecho como una cadena que es pasada por eval() para obtener el resultado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use the modified Package only within your corporation or organization.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>utilice el Paquete modificado sólo dentro de su empresa u organización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A negative OFFSET specifies writing
that many characters counting backwards from the end of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DESPLAZAMIENTO negativo especifica escribir tantos caracteres contando desde el final de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Conditional and looping constructs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234706Z" changeid="zipf">
        <seg>=head2 Estructuras condicionales y de bucle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;fcntl&gt; raises an exception if used on a machine that
doesn't implement fcntl(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que C&lt;fcntl&gt; levanta una excepción si se utiliza en una máquina que no implemente fcntl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># This loop reads from STDIN, and prints non-blank lines:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121857Z" changeid="zipf">
        <seg># Este bucle lee de STDIN e imprime las líneas que no estén vacías:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;O_TRUNC&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;O_TRUNC&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require $class;       # $class is not a bareword</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require $clase;       # $clase no es una palabra suelta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This surprising autovivification in what does not at first--or even
second--glance appear to be an lvalue context may be fixed in a future
release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta sorprendente autovivificación en que al primer vistazo -o incluso al segundo- parece que es un contexto lvalor quizás será arreglado en una futura distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So anything
that looks like \\, \(, \), \&lt;, \&gt;, \{, or \} is always
interpreted as a literal character, not a metacharacter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que cualquier cosa que se parezca a \\, \(, \), \&lt;, \&gt;, \{, or \} es siempre interpretado como un carácter literal, no un metacarácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to Perl modules
X&lt;module&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201936Z" changeid="explorer">
        <seg>=item Identificadores relativos a los módulos Perl
X&lt;module&gt; X&lt;módulo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current value of C&lt;$,&gt; (if any) is
printed between each LIST item.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor actual de C&lt;$,&gt; (si lo tiene) se imprime entre cada elemento de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 'Hello, $name\n';     # prints $name\n literally</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T124130Z" changeid="zipf">
        <seg>print 'Hola, $nombre\n';  # imprime $nombre\n literalmente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>binmode() is important not only for readline() and print() operations,
but also when using read(), seek(), sysread(), syswrite() and tell()
(see L&lt;perlport&gt; for more details).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>binmode() no sólo es importante para las operaciones readline() y print(), sino también cuando se usan read(), seek(), sysread(), syswrite() y tell() (ver L&lt;perlport&gt; para más detalles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $count (10,9,8,7,6,5,4,3,2,1,'BOOM') {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $cuenta_atras (10,9,8,7,6,5,4,3,2,1,'BOOM') {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's used as the default argument to a number of functions in Perl, and
it's set implicitly by certain looping constructs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224838Z" changeid="explorer">
        <seg>Se usa como argumento predeterminado de varias funciones de Perl y su valor se establece implícitamente en determinadas estructuras de bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wrong</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191347Z" changeid="explorer">
        <seg>mal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/Capture buffers&gt; below for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225359Z" changeid="explorer">
        <seg>Véase más abajo L&lt;/Buffers de captura&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar gethostbyaddr($myaddr, AF_INET),</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>scalar gethostbyaddr($myaddr, AF_INET),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Configure</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Configure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The names I&lt;big-endian&gt; and I&lt;little-endian&gt; are comic references to the
egg-eating habits of the little-endian Lilliputians and the big-endian
Blefuscudians from the classic Jonathan Swift satire, I&lt;Gulliver's Travels&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres I&lt;big-endian&gt; y I&lt;little-endian&gt; son referencias cómicas a los hábitos alimenticios de comer huevos por el extremo pequeño de los Liliputienses y por el extremo grande de los Blefuscudianos de la clásica sátira de Jonathan Swift, I&lt;Los Viajes de Gulliver&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0x78 0x56 0x34 0x12  # little-endian</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0x78 0x56 0x34 0x12  # little-endian (byte inferior antes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Username is $1\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T031212Z" changeid="explorer">
        <seg>print &quot;El nombre del usuario  es $1\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &quot;&amp;&quot; has lower priority than relational operators, so for example
the brackets are essential in a test like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que &quot;&amp;&quot; tiene una menor prioridad que los operadores relaciones, así que, por ejemplo, los paréntesis son esenciales en una prueba como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item seekdir DIRHANDLE,POS
X&lt;seekdir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200255Z" changeid="explorer">
        <seg>=item seekdir GESTOR_DIR,POS
X&lt;seekdir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$group_read    = ($mode &amp; S_IRGRP) &gt;&gt; 3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$grupo_lectura  = ($modo &amp; S_IRGRP) &gt;&gt; 3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some older systems, it may sleep up to a full second less than what
you requested, depending on how it counts seconds.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas antiguos, se puede dormir hasta un segundo meno de lo que ha solicitado, en función de la forma en cómo se cuenten los segundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5112delta	Perl changes in version 5.11.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5112delta	Cambios en la versión 5.11.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line up your transliterations when it makes sense:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alinear transliteraciones cuando tengan sentido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlunicode&gt; for more about Unicode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlunicode&gt; para más información acerca de Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item state TYPE EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item state TIPO EXPR : ATRIBS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { ... ; die Some::Module::Exception-&gt;new( FOO =&gt; &quot;bar&quot; ) };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { ... ; die Some::Module::Exception-&gt;new( FOO =&gt; &quot;bar&quot; ) };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During this search, text between the starting and ending delimiters
is copied to a safe location.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Durante esta búsqueda, el texto entre los delimitadores inicial y final se copia a un lugar seguro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of
bytes actually read, C&lt;0&gt; at end of file, or undef if there was an
error (in the latter case C&lt;$!&gt; is also set).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de bytes realmente leídos, C&lt;0&gt; al final del archivo, o undef si hubo un error (en este último caso, también se establece C&lt;$!&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means it
was never a list to start with.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que nunca será una lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the content is interpolated
as though it were double quoted and then executed via the shell, with
the results of the execution returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, el contenido es interpolado como si estuviera entrecomillado doble y luego ejecutado a través del shell, devolviendo los resultados de la ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Has the same effect as</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tiene el mismo efecto que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3: '', pos=8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3: '', pos=8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport/gmtime&gt; for portability concerns.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport/gmtime&gt; para problemas sobre portabilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because BLOCKs are always
bounded by curly brackets, there is never any ambiguity about which
C&lt;if&gt; an C&lt;else&gt; goes with.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como los BLOQUES están siempre rodeados de llaves, nunca hay ambigüedad sobre dónde van el C&lt;if&gt; y el C&lt;else&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $path = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $ruta = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sequence
number is reset for each range encountered.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de secuencia se reinicia para cada rango encontrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;sysseek(FH, 0, 1)&gt; for that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use C&lt;sysseek(FH, 0, 1)&gt; para eso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item msgrcv ID,VAR,SIZE,TYPE,FLAGS
X&lt;msgrcv&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191451Z" changeid="explorer">
        <seg>=item msgrcv ID,VAR,SIZE,TYPE,FLAGS
X&lt;msgrcv&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the inverse cosine operation, you may use the C&lt;Math::Trig::acos()&gt;
function, or use this relation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la inversa de la operación coseno, puede usar la función C&lt;Math::Trig::acos()&gt;, o usar esta relación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (eof()) {  # check for end of last file
            print &quot;--------------\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044141Z" changeid="explorer">
        <seg>if (eof()) {  # chequea por el final del último archivo
            print &quot;--------------\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the right operand is zero or negative, it returns an empty string
or an empty list, depending on the context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el operando derecho es cero o negativo, devuelve una cadena vacía o una lista vacía, dependiendo del contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such constructs are quite frequently used, because older versions
of Perl had no official C&lt;switch&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013507Z" changeid="explorer">
        <seg>Estas construcciones son muy frecuentes, porque las versiones anteriores de Perl no tenían oficialmente una instrucción C&lt;switch&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item require</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item require</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interprets EXPR as an octal string and returns the corresponding
value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Interpreta EXPR como una cadena en octal y devuelve el valor correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 4) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 4) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.14_15_92          # a very important number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3.14_15_92          # un número muy importante</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is
omitted, returns length of C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, devuelve la longitud de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open($handle, &quot;myfile&quot;) or die &quot;myfile: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open($handle, &quot;miarchivo&quot;) or die &quot;miarchivo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;do&gt;, C&lt;import&gt;, C&lt;no&gt;, C&lt;package&gt;, C&lt;require&gt;, C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;do&gt;, C&lt;import&gt;, C&lt;no&gt;, C&lt;package&gt;, C&lt;require&gt;, C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'\\' =~ q'\\';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'\\' =~ q'\\';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://juerd.nl/site.plp/perlcheat        home of the Perl Cheat Sheet</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://juerd.nl/site.plp/perlcheat        página de la chuleta Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@new = map { $_-&gt;[0] }
           sort { $b-&gt;[1] &lt;=&gt; $a-&gt;[1]
               ||
           $a-&gt;[2] cmp $b-&gt;[2]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051512Z" changeid="explorer">
        <seg>@nuevo = map { $_-&gt;[0] }
           sort { $b-&gt;[1] &lt;=&gt; $a-&gt;[1]
               ||
           $a-&gt;[2] cmp $b-&gt;[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual
random order is subject to change in future versions of Perl, but it
is guaranteed to be the same order as either the C&lt;keys&gt; or C&lt;each&gt;
function would produce on the same (unmodified) hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El actual orden aleatorio está sujeto a cambio en futuras versiones de Perl, pero se garantiza que sea el mismo orden que las funciones C&lt;keys&gt; o C&lt;each&gt; producirían (mientras que el hash no haya sido modificado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Amongst other
things, this may have the effect of calling stdio's clearerr(3).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entre otras cosas, esto puede tener el efecto de llamar a los clearerr(3) de stdio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\n		newline         (NL)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002803Z" changeid="explorer">
        <seg>\n		nuevalínea       (NL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following modules and pragmata have been updated since Perl 5.8.1:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los siguientes módulos y pragmata se han actualizado desde Perl 5.8.1:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For floating-point formats except 'g' and 'G', this specifies
how many places right of the decimal point to show (the default being 6).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para formatos en punto flotante, excepto 'g' y 'G', especifica cuántos lugares a la derecha del punto decimal debe mostrar (el valor predeterminado es 6).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you may inspect the value of C&lt;${^CHILD_ERROR_NATIVE}&gt;
with the C&lt;W*()&gt; calls from the POSIX module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alternativamente, puede inspeccionar el valor de C&lt;${^CHILD_ERROR_NATIVE}&gt; con las llamadas C&lt;W*()&gt; desde el módulo POSIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exec PROGRAM LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exec PROGRAMA LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1: '', pos=7</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1: '', pos=7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes various features of Linux that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documentos describe varias características de Linux que afectarán a cómo Perl versión 5 (de ahora en adelante sólo Perl) es compilado y/o ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of files
successfully changed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de archivos cambiados con éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the other</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>el otro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $x;               # prints &quot;foo&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002215Z" changeid="zipf">
        <seg>print $x;               # imprime &quot;foo&quot; en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For measuring time in better granularity than one second,
you may use either the L&lt;Time::HiRes&gt; module (from CPAN, and starting from
Perl 5.8 part of the standard distribution), or if you have
gettimeofday(2), you may be able to use the C&lt;syscall&gt; interface of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para medir el tiempo con una granularidad mayor de un segundo, puede usar el módulo L&lt;Time::HiRes&gt; (de CPAN, y a partir de Perl 5.8, como parte de la distribución estándar), o si tiene gettimeofday(2), puede ser capaz de utilizar el interfaz C&lt;syscall&gt; de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order, these are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En fin, estos son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, you may need
to set C&lt;$|&gt; ($AUTOFLUSH in English) or call the C&lt;autoflush()&gt; method
of C&lt;IO::Handle&gt; on any open handles.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para estar seguro, es posible que necesite el conjunto C&lt;|&gt; ($AUTOFLUSH en English) o llame al método C&lt;autoflush()&gt; de C&lt;IO::Handle&gt; en cualquier identificador abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Retrieve $x, $y, ...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Recupera $x, $y, ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(TTY, '/dev/tty');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(TTY, '/dev/tty');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
because named unary operators are higher precedence than ||:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, debido a que los operadores unarios con nombre tienen mayor precedencia que ||:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you read this file _as_is_, just ignore the funny characters you see.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si lees este archivo _tal_como_es_, ignora los caracteres curiosos que veas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, the pointer to the string value is passed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no, se pasa el puntero al valor de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If more than one value is listed, the list must be placed
in parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se lista más de un valor, esa lista debe ser puesta entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the child pid to the
parent process, C&lt;0&gt; to the child process, or C&lt;undef&gt; if the fork is
unsuccessful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el pid del hijo al proceso padre, C&lt;0&gt; al proceso hijo, o C&lt;undef&gt; si no se consiguió el fork.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl now builds on OpenVMS I64</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl ahora se compila en OpenVMS I64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single quotes indicate the text is to be treated literally with no
interpolation of its content.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las comillas simples indican que el texto se va a tratar literalmente, sin interpolación de su contenido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Build</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/0/ ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/0/ ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you believe you have an unreported bug, please run the B&lt;perlbug&gt;
program included with your release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted cree que tiene un error no declarado, por favor, ejecute el programa B&lt;perlbug&gt; incluido en su distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, modifying an element of a
list returned by sort() (for example, in a C&lt;foreach&gt;, C&lt;map&gt; or C&lt;grep&gt;)
actually modifies the element in the original list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, modificar un elemento de la lista devuelto por grep (por ejemplo, en un C&lt;foreach&gt;, C&lt;map&gt; o C&lt;grep&gt;) modifica el elemento en la lista original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the form of pipe opens taking three or more arguments, if LIST is specified
(extra arguments after the command name) then LIST becomes arguments
to the command invoked if the platform supports it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la forma de tubería tomando tres o más argumentos, si se especifica LISTA (argumentos adicionales después del nombre del comando) entonces LISTA son los argumentos para el comando invocado, si la plataforma lo soporta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's reasonably easy to understand, and
almost everything that applies here will also be applicable later
on with the fancier data structures.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es razonablemente fácil de entender, y casi todo lo que se aplica aquí también se aplicará más tarde con las estructuras de datos más elaborados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%D    a synonym for %ld</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%D    un sinónimo para %ld</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is nice, but if you forget
your trailing quote, the error will not be reported until Perl finds
another line containing the quote character, which may be much further
on in the script.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es bueno, pero si se le olvida cerrar el entrecomillado, el error no será reportado hasta que Perl encuentre otra línea que contenga el carácter de comillas, que puede estar mucho más allá en el programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,13, 2) = 2   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,13, 2) = 2   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item index STR,SUBSTR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item index STRING,SUBSTR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are allowed to use underscores (underbars) in numeric literals
between digits for legibility.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está permitido el uso de guiones bajos en literales numéricos entre los dígitos para aumentar la legibilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They often work the same, but
see L&lt;perltrap&gt; for information about how they differ.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A menudo funcionan de la misma forma, pero mire L&lt;perltrap&gt; para ver cómo difieren.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Core Enhancements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Mejoras principales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $file (@ARGV) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $archivo (@ARGV) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,15, 2) = 1   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,15, 2) = 1   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They're also supported as operators in their own
right.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T182510Z" changeid="zipf">
        <seg>Son también operadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item select RBITS,WBITS,EBITS,TIMEOUT
X&lt;select&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200425Z" changeid="explorer">
        <seg>=item select RBITS,WBITS,EBITS,TIEMPO_ESPERA
X&lt;select&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can control which DBM library you use by loading that library
before you call dbmopen():</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede controlar qué biblioteca DBM usará cargando la biblioteca antes de llamar a dbmopen():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PRINT this, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>PRINT este, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,12, 1) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,12, 1) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function
implementing the C&lt;&lt; &lt;*.c&gt; &gt;&gt; operator, but you can use it directly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es la función interna que implementa el operador C&lt;&lt; &lt;*.c&gt; &gt;&gt;, pero puede usarla directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 4) = 2   ==         32 00000100000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 4) = 2   ==         32 00000100000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the next character from the input file attached to FILEHANDLE,
or the undefined value at end of file or if there was an error (in
the latter case C&lt;$!&gt; is set).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211609Z" changeid="explorer">
        <seg>Devuelve el siguiente carácter desde el archivo de entrada asociado a GESTOR_ARCHIVO, o el valor indefinido al final del archivo, o si ocurrió un error (en este último caso, se actualiza C&lt;$!&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item print</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item print</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $out $record;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T225640Z" changeid="zipf">
        <seg>print $salida $registro;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generalized form of backticks is C&lt;qx//&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma generalizada de las comillas invertidas es C&lt;qx//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 64  ==         64 00000010000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 64  ==         64 00000010000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, use C&lt;&quot;\n&quot;&gt; when
you mean a &quot;newline&quot; for your system, but use the literal ASCII when you
need an exact character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, utilice C&lt;&quot;\n&quot;&gt; cuando se refiera a una &quot;nueva línea&quot; para su sistema, pero use el literal ASCII cuando necesite un carácter exacto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing of C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt;, C&lt;\E&gt;,
and interpolation happens (almost) as with C&lt;qq//&gt; constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procesamiento de C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt;, C&lt;\E&gt; e interpolación ocurre (casi) como en las construcciones C&lt;qq//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_ISREG($mode) S_ISDIR($mode) S_ISLNK($mode)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_ISREG($modo) S_ISDIR($modo) S_ISLNK($modo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_SIZE  	   if $opt_s;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_SIZE  	   if $opt_s;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value is parsed every time the C&lt;eval&gt; executes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que el valor es interpretado cada vez que se ejecuta C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does not
even aim to be entirely accurate.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224541Z" changeid="explorer">
        <seg>Tampoco explica el lenguaje en detalle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># reset line numbering on each input file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># reiniciar el numerado de líneas en cada archivo de entrada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from resetting the iterator,
C&lt;values @array&gt; in list context is the same as plain C&lt;@array&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de restablecer el iterador, C&lt;values @array&gt; en contexto lista es la mismo que un simple C&lt;@array&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::BigIntFast	Bit::Vector wrapper for big numbers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::BigIntFast         envoltorio de Bit::Vector para grandes números</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://perlmonks.org/?node_id=238031      Damian Conway's Perl 6 version</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://perlmonks.org/?node_id=238031      Versión Perl 6 de Damian Conway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.0f&gt;', 1;  # prints &quot;&lt;1&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.0f&gt;', 1;  # imprime &quot;&lt;1&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getprotobynumber NUMBER</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getprotobynumber NÚMERO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DO                                      \S, \W and \D negate</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>HACER                                   \S, \W y \D negado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo,  3, 16) = 0x726C; # 'PerlPerl'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($foo,  3, 16) = 0x726C; # 'PerlPerl'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%010.6x&gt;', 1;   # prints &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%010.6x&gt;', 1;   # imprime &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also
L&lt;perlipc/&quot;SysV IPC&quot;&gt; and C&lt;IPC::SysV&gt; and C&lt;IPC::Msg&gt; documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt; y C&lt;IPC::SysV&gt; y C&lt;IPC::Msg&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's more convenient
than writing out the individual elements as a list of separate
scalar values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más conveniente que escribir los elementos individuales como una lista de valores escalares separados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditionally the result is a string of 13 bytes: two first bytes of
the salt, followed by 11 bytes from the set C&lt;[./0-9A-Za-z]&gt;, and only
the first eight bytes of PLAINTEXT mattered.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tradicionalmente, el resultado es una cadena de 13 bytes: los dos primeros son el salto, seguido de 11 bytes del conjunto C&lt;[./0-9A-Za-z]&gt;, y sólo los primeros ocho bytes del I&lt;digest&gt; interesan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the integer operation provides scalar context for the &lt;&gt;
operator, which responds by reading one line from STDIN and passing it
back to the integer operation, which will then find the integer value
of that line and return that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>la operación int establece un contexto escalar para el operador &lt;&gt;, que responde leyendo una línea de STDIN y enviándola de vuelta a la operación int, la cual entonces busca el valor entero de esa línea y lo devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And it's faster because
Perl executes a C&lt;foreach&gt; statement more rapidly than it would the
equivalent C&lt;for&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013449Z" changeid="explorer">
        <seg>Y es más rápido porque Perl ejecuta una instrucción C&lt;foreach&gt; más rápidamente que su equivalente en un bucle C&lt;for&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form, known as
v-strings, provides an alternative, more readable way to construct
strings, rather than use the somewhat less readable interpolation form
C&lt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma, conocida como &quot;v-strings&quot;, ofrece una alternativa, más legible, para construir cadenas, en lugar de una forma de interpolación mucho menos legible como C&lt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can always put another block inside of it
(for C&lt;next&gt;) or around it (for C&lt;last&gt;) to do that sort of thing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre puede poner otro bloque dentro de él  (para C&lt;next&gt;) o alrededor de él (para C&lt;last&gt;) para hacer esta suerte de cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the offset of where the last C&lt;m//g&gt; search left off for the variable
in question (C&lt;$_&gt; is used when the variable is not specified).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el desplazamiento donde la última búsqueda C&lt;m//g&gt; terminó para la variable en cuestión (C&lt;$_&gt; es usada cuando no se especifica la variable).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't rely on
it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No confíe en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>white wine</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vino blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13162</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13162</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pos</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item pos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open 'foo' for input: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir 'foo' para entrada: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># These do the print before evaluating exit:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Esto llama al print antes de evaluar exit:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pop</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item pop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} while $x++ &lt;= $z;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} while $x++ &lt;= $z;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>xX         Make x and X act as alignment commands.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>xX         Hace x y X actuar como comandos de alineamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>normal tomato</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tomate normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That is, all characters not matching
C&lt;/[A-Za-z_0-9]/&gt; will be preceded by a backslash in the
returned string, regardless of any locale settings.)
This is the internal function implementing
the C&lt;\Q&gt; escape in double-quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Es decir, todos los caracteres que no se ajusten a C&lt;/[A-Za-z_0-9]/&gt; serán precedidos por una barra invertida en la cadena devuelta, con independencia de cualquier configuración regional). Esta es la función interna que implementa el escapado de C&lt;\Q&gt; en las cadenas con doble entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;\$$x++&quot;;  # CASE 5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;\$$x++&quot;;  # CASO 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 14854</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 14854</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have a backlog of unresolved bugs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenemos un retraso de errores sin resolver.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore C&lt;-&gt; in C&lt;tr'''&gt; and C&lt;y'''&gt; is treated literally
as a hyphen and no character range is available.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto, C&lt;-&gt; en C&lt;tr'''&gt; y C&lt;y'''&gt; es tratado, literalmente, como un guion, y por lo tanto no está disponible un intervalo de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;foreach&gt; modifier is an iterator: it executes the statement once
for each item in the LIST (with C&lt;$_&gt; aliased to each item in turn).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013118Z" changeid="explorer">
        <seg>El modificador C&lt;foreach&gt; es un iterador: ejecuta la instrucción una vez por cada elemento en la LISTA (con C&lt;$_&gt; asociado a cada elemento en cada iteración).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;Exporter&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;Exporter&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slavish adherence to portability concerns shouldn't get
in the way of your getting your job done.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Adhesión servil a los requerimientos de portabilidad no debe impedirle obtener el trabajo hecho).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPEN this, mode, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>OPEN este, modo, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the right side of a list operator, it has very low precedence,
such that it controls all comma-separated expressions found there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el lado derecho de un operador de lista, tiene una precedencia muy baja, de forma que controla todas las expresiones separadas por comas que se encuentren allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This sets @ARGV to all plain text files if no @ARGV was given:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto establecerá @ARGV a todos los archivos de texto sin formato si no se indicó nada a @ARGV:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This was
once used in a common idiom to disable or quote the special meanings
of regular expression metacharacters in a string that you want to
use for a pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se usó una vez como un modismo común para desactivar o citar los significados especiales de los metacaracteres de expresiones regulares en una cadena que desea utilizar para un patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $line  = &lt;$in&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T003553Z" changeid="zipf">
        <seg>my $linea  = &lt;$entrada&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example disabling Nagle's algorithm on a socket:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un ejemplo para deshabilitar el algoritmo de Nagle del socket:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A word that has no other interpretation in the grammar will
be treated as if it were a quoted string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una palabra que no tiene otra interpretación en la gramática será tratada como si fuera una cadena entrecomillada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RedHat users should see https://rhn.redhat.com/errata/RHBA-2003-136.html
and consider upgrading their glibc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los usuarios de RedHat deberían ver la página https://rhn.redhat.com/errata/RHBA-2003-136.html y considerar la actualización de sus glibc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;do&gt; can read the file but cannot compile it, it
returns undef and sets an error message in C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;do&gt; puede leer el archivo pero no puede compilarlo, devuelve undef y pone un mensaje de error en C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$/ = &quot;&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$/ = &quot;&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, C&lt;$a // $b&gt;
is similar to C&lt;defined($a) || $b&gt; (except that it returns the value of C&lt;$a&gt;
rather than the value of C&lt;defined($a)&gt;) and is exactly equivalent to
C&lt;defined($a) ? $a : $b&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053402Z" changeid="explorer">
        <seg>Por lo tanto, C&lt;$a // $b&gt; es similar a C&lt;defined($a) || $b&gt; (excepto que devuelve el valor de C&lt;$a&gt; en lugar del valor de C&lt;defined($a)&gt;) y es equivalente exactamente a C&lt;defined($a) ? $a : $b&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item link OLDFILE,NEWFILE
X&lt;link&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175420Z" changeid="explorer">
        <seg>=item link ARCHIVO_VIEJO,ARCHIVO_NUEVO
X&lt;link&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those functions ignore the buffering, while tell() does not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esas funciones ignoran el sistema de buffer, mientras que tell(), no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+   addition</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235206Z" changeid="zipf">
        <seg>+   suma</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;\b&gt; X&lt;\A&gt; X&lt;\Z&gt; X&lt;\z&gt; X&lt;/m&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;\b&gt; X&lt;\A&gt; X&lt;\Z&gt; X&lt;\z&gt; X&lt;/m&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those loops
that scan for many short constant strings (including the constant
parts of more complex patterns) will benefit most.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los bucles que escanean por muchas cadenas constantes cortas (incluidas las partes constante de patrones más complejos) serán los más beneficiados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax error will be
reported close to the C&lt;}&gt;, but you'll need to change something near the C&lt;{&gt;
such as using a unary C&lt;+&gt; to give Perl some help:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El error de sintaxis será reportado cerca de C&lt;}&gt;, pero tendrá que cambiar algo cerca de C&lt;{&gt;, como en el uso de un unario C&lt;+&gt;, para darle un poco de ayuda a Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When verifying an existing digest string you should use the digest as
the salt (like C&lt;crypt($plain, $digest) eq $digest&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando verifique un string i&lt;digest&gt; debe usar el propio I&lt;digest&gt; como el salto (como C&lt;crypt($plano, $digest) eq $digest&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item close FILEHANDLE
X&lt;close&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211300Z" changeid="explorer">
        <seg>=item close GESTOR_ARCHIVO
X&lt;close&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++$j;  # prints 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ++$j;  # imprime 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@info = stat($file) || die;     # oops, scalar sense of stat!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@info = stat($archivo) || die;     # ¡oops, sentido escalar de stat!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item caller</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item caller</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/my.STRING/foo/is;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/mi.CADENA/foo/is;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5101delta	Perl changes in version 5.10.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5101delta	Cambios en la versión 5.10.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no C&lt;import&gt;
method can be found then the call is skipped, even if there is an AUTOLOAD
method.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se puede encontrar ningún método C&lt;import&gt; entonces la llamada se pasa por alto, incluso si hay un método AUTOLOAD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular macros which create temporary
local variables now name these variables more defensively, which should
avoid bugs where names clash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En ciertas macros que crean variables locales temporales se nombra ahora estas variables de forma más defensiva, que deberían evitar errores con la coincidencia de nombres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;/etc/games is no good&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;/etc/games no está bien&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { $x };    # CASE 4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { $x };    # CASO 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl589delta	Perl changes in version 5.8.9</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl589delta	Cambios en la versión 5.8.9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
feature can be extremely useful to give perl hints about where it
shouldn't backtrack.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta característica puede ser muy útil para dar pistas a perl sobre dónde no debe dar marcha atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You probably shouldn't rely upon the C&lt;warn()&gt; being podded out forever.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Probablemente no se dará cuenta de que el C&lt;warn()&gt; ha sido comentado para siempre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash    Array     hash keys intersection   grep { exists $a-&gt;{$_} } @$b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hash        Array      claves hash intersección         grep { exists $a-&gt;{$_} } @$b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The yada yada operator (noted C&lt;...&gt;) is a placeholder for code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador blablablá (indicado como C&lt;...&gt;) es un marcador de posición para código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	== != &lt;=&gt; eq ne cmp ~~</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	== != &lt;=&gt; eq ne cmp ~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE: while (defined($line = &lt;ARGV&gt;)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LINEA: while (defined($linea = &lt;ARGV&gt;)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix a bug in the security taint checking of open()</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>arreglado un error en la comprobación de seguridad aceitosa de open()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{ exec ('foo') }; print STDERR &quot;couldn't exec foo: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{ exec ('foo') }; print STDERR &quot;no puedo exec foo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sqrt EXPR
X&lt;sqrt&gt; X&lt;root&gt; X&lt;square root&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201252Z" changeid="explorer">
        <seg>=item sqrt EXPR
X&lt;sqrt&gt; X&lt;root&gt; X&lt;square root&gt; X&lt;raíz cuadrada&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-C  Same for inode change time (Unix, may differ for other platforms)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-C  Lo mismo, para el cambio de la fecha del inodo (en Unix, puede diferir en otras plataformas)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use a here-document to assign an array, one line per element,
you might use an approach like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para usar un documento embebido para asignar a un array, una línea por elemento, puede usar un enfoque como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@days[3,4,5]	# same as ($days[3],$days[4],$days[5])</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@dias[3,4,5]	# igual que ($dias[3],$dias[4],$dias[5])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($nfound,$timeleft) =</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($n_encontrados,$tiempo_restanto) =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global matching, and keep the Current position after failed matching.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincidencia global, y almacenar la posición actual después de una coincidencia fallida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use parentheses for functions' arguments or omit them
according to your personal taste.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224755Z" changeid="explorer">
        <seg>Puede escribir los argumentos de las funciones entre paréntesis u omitir los paréntesis, si lo prefiere.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$pattern =~ s/(\W)/\\$1/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$patrón =~ s/(\W)/\\$1/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prints a string or a list of strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Imprime una cadena o una lista de cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@part = ();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194659Z" changeid="explorer">
        <seg>@part = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus Perl provides the &quot;possessive&quot; quantifier form
as well.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, Perl proporciona también el cuantificador &quot;posesivo&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run C&lt;perldoc
perldoc&gt; to learn more things you can do with F&lt;perldoc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejecute C&lt;perldoc perldoc&gt; para aprender más cosas que puede hacer con F&lt;perldoc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item system PROGRAM LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item system PROGRAMA LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11993</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11993</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESTE PAQUETE SE PROPORCIONAL &quot;TAL CUAL&quot; Y SIN NINGUNA GARANTÍA EXPRESA O IMPLÍCITA, INCLUYENDO, SIN LIMITACIÓN, LAS GARANTÍAS IMPLÍCITAS DE COMERCIALIDAD E IDONEIDAD PARA UN PROPÓSITO PARTICULAR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Useless use of integer addition in void context at - line 1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Useless use of integer addition in void context at - line 1.
(Inútil uso de suma de enteros en contexto void en - línea 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T193248Z" changeid="explorer">
        <seg>o:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getnetbyaddr ADDR,ADDRTYPE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getnetbyaddr DIRECCIÓN,TIPODIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As far as I can tell, this is caused by
a bug in the BeOS pipes implementation that occurs when starting other child
processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo que puedo decir, es causado por un fallo en la implementación de las tuberías en BeOS que se produce cuando se inicia otro proceso hijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the
following code waits on semaphore $semnum of semaphore id $semid:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A modo de ejemplo, el siguiente código espera en un semáforo $semnum del semáforo con identificador $semid:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc&gt; for details,
and for other examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc&gt; para más detalles, y para otros ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike
B&lt;sed&gt;, we use the \&lt;I&lt;digit&gt;&gt; form in only the left hand side.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de B&lt;sed&gt;, utilizamos el formato \&lt;I&lt;dígito&gt;&gt; sólo en el lado izquierdo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not confuse this behavior with the behavior of
backslash within a string, although both forms do convey the notion
of protecting the next thing from interpolation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se debe confundir este comportamiento con el comportamiento de una barra diagonal inversa en una cadena, aunque ambas formas transmiten la idea de proteger a lo que sigue de ser interpolado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scripts run by the superuser
may thus need to do a stat() to determine the actual mode of the file,
or temporarily set their effective uid to something else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Scripts ejecutados por el superusuario pueden necesitar hacer un stat() para determinar el modo actual del archivo, o temporalmente poner su uid efectivo a otro valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($line);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($linea);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to replace
parts of the EXPR and return what was there before in one operation,
just as you can with splice().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto le permite reemplazar partes de la EXPR y devolver lo que había antes, en una operación, tal como se puede hacer con splice().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (my $line = &lt;STDIN&gt;) { print $line }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (my $linea = &lt;STDIN&gt;) { print $linea }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current priority for a process, a process group, or a user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la prioridad actual de un proceso, un grupo de procesos o un usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;pos&gt; directly accesses the location used
by the regexp engine to store the offset, so assigning to C&lt;pos&gt; will change
that offset, and so will also influence the C&lt;\G&gt; zero-width assertion in
regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;pos&gt; accede directamente a la ubicación utilizada por el motor de expresiones regulares para almacenar el desplazamiento, por lo que asignar a C&lt;pos&gt; cambiará ese desplazamiento, por lo que también influirá en la aserción de ancho cero C&lt;\G&gt; en las expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To go the other way (produce a number
in octal), use sprintf() or printf():</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para hacer lo contrario (producir un número en octal), use sprintf() o printf():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl594delta	Perl changes in version 5.9.4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl594delta	Cambios en la versión 5.9.4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item flags</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item banderas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;$hints&gt; and C&lt;$bitmask&gt; values are subject to change
between versions of Perl, and are not meant for external use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores C&lt;$hints&gt; y C&lt;$bitmask&gt; están sujetos a cambios entre versiones de Perl y no se espera que sean utilizados para uso externo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ternary &quot;?:&quot; is the conditional operator, just as in C.  It works much
like an if-then-else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ternario &quot;?:&quot; es el operador condicional, al igual que en C. Funciona como un if-then-else.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_ISENFMT($mode) S_ISWHT($mode)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_ISENFMT($modo) S_ISWHT($modo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&lt;=&quot; returns true if the left argument is numerically less than
or equal to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&lt;=&quot; devuelve verdadero si el argumento de la izquierda es numéricamente menor o igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sq = square(8);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235518Z" changeid="zipf">
        <seg>$sq = cuadrado(8);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring a subroutine allows a subroutine name to be used as if it were a
list operator from that point forward in the program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Declarar una subrutina permite que su nombre sea usado como si fuera un operador de lista, desde el punto de vista del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to write conditionals without
curly brackets there are several other ways to do it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere escribir condicionales sin llaves hay varias formas de hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,@#,@#) = @&lt;&lt; == @######### @&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,@#,@#) = @&lt;&lt; == @######### @&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contents</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Contenido</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = @b ? @b : @c;		# this works fine, though</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053420Z" changeid="explorer">
        <seg>@a = @b ? @b : @c;		# aunque esto también funciona</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>explorer perldgux.html</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>explorer perldgux.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; or C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; for file names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; o C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; para nombres de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 'STRING'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 'CADENA'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub/&quot;Temporary Values via local()&quot;&gt;
for details, including issues with tied arrays and hashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub/&quot;Valores temporales con local()&quot;&gt; para más detalles, incluidas las cuestiones relativas a arrays y hash enlazadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, C&lt;localtime()&gt; uses the current time (as returned
by time(3)).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, C&lt;localtime()&gt; utiliza la hora actual (devuelta por time(3)).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is B&lt;&quot;The Artistic License&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es B&lt;&quot;La Licencia Artística&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, $arg) or warn &quot;Can't open $arg: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $fh, $arg) or warn &quot;No puedo abrir $arg: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>named uops              if     ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>oper. con nombre        if     ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 14832</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 14832</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{}    anon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{}    hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if layers are specified in the
three-argument form, then default layers stored in ${^OPEN} (see L&lt;perlvar&gt;;
usually set by the B&lt;open&gt; pragma or the switch B&lt;-CioD&gt;) are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si las capas se especifican en la forma de tres argumentos, entonces las capas por defecto almacenadas en ${^OPEN} (ver L&lt;perlvar&gt;; normalmente fijados por el pragma B&lt;open&gt; o la opción B&lt;-CioD&gt;) son ignoradas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the absolute value of its argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor absoluto del argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is an incompatability in
OpenBSD's C&lt;getprotobyname_r&gt; and C&lt;getservbyname_r&gt; function in versions 3.7
and later that will cause a SEGV when called without doing a C&lt;bzero&gt; on
their return structs prior to calling these functions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existe una incompatibilidad en las funciones de 
OpenBSD C&lt;getprotobyname_r&gt; y C&lt;getservbyname_r&gt; en las versiones 3.7
y superiores que causarán un SEGV cuando se llamen sin haber hecho antes un C&lt;bzero&gt; en sus estructuras de retorno antes de llamar a estas funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item size</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item tamaño</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying VERSION as a literal of the form v5.6.1 should generally be
avoided, because it leads to misleading error messages under earlier
versions of Perl that do not support this syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Especificando VERSIÓN como un literal de la forma v5.6.1, debe, generalmente, evitarse, porque lleva crear mensajes de error equívocos en las versiones anteriores de Perl que no admiten esta sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the following secret stuff will be
ignored by both the compiler and the translators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que el siguiente material secreto será ignorado tanto por el compilador como por los traductores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Final: 'q', pos=8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Final: 'q', pos=8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_ATIME 	   if $opt_u;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_ATIME 	   if $opt_u;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is written in the POD format (see perlpod manpage) which is
specially designed to be readable as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está escrito en formato POD (ver la página de manual perlpod) que está específicamente diseñado para ser legible de forma sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do_something_else;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hacer_algo_despues;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say '$foo is undefined';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>say '$foo es indefinido';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = @foo[0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = @foo[0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context or if the left
operand is not enclosed in parentheses, it returns a string consisting
of the left operand repeated the number of times specified by the right
operand.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el contexto escalar o si el operando izquierdo no está encerrado entre paréntesis, devuelve una cadena consistente en el operando de la izquierda repetido el número de veces especificado por el operando de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add space after
the C&lt;s&gt; when using a character allowed in identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Añadir un espacio después de la C&lt;s&gt; cuando se utilice un carácter permitido en identificadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This assumes that
doubles must be aligned to the size of double.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto supone que los dobles deben estar alineados con el tamaño de un doble.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Non-threaded Perl on DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Perl sin I&lt;threads&gt; en DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the EXPR can be arbitrarily complicated as long as the final
operation is a hash or array key lookup or subroutine name:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que EXPR puede ser todo lo arbitrariamente complicada que se quiera con tal de que la operación final sea un escalar de un hash o de un array o el nombre de una subrutina:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $y;               # prints nothing; $y has fallen out of scope</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121341Z" changeid="zipf">
        <seg>print $y;               # no imprime nada; $y está fuera del ámbito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at - line 2001.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at - line 2001.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The character C&lt;-&gt; is treated specially and therefore C&lt;\-&gt; is treated
as a literal C&lt;-&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El carácter C&lt;-&gt; es tratado de forma especial y por lo tanto C&lt;\-&gt; es tratado como un literal C&lt;-&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsub		Perl subroutines</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsub		Subrutinas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;Package&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Paquete&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(LOG, '&gt;&gt;/usr/spool/news/twitlog');  # (log is reserved)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(LOG, '&gt;&gt;/usr/spool/news/twitlog');  # (log es reservada)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl583delta	Perl changes in version 5.8.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl583delta	Cambios en la versión 5.8.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^$/                nothing in the string (start and end are adjacent)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121804Z" changeid="zipf">
        <seg>/^$/                cadena vacía (principio y final contiguos)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Firstly, copy the source and build a native copy of perl for your host
system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En primer lugar, copiar el código fuente y crear una copia nativa de perl de su sistema principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mkdir $tmpdir, 0700	or die &quot;can't mkdir $tmpdir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>mkdir $tmpdir, 0700	or die &quot;no puedo hacer mkdir $tmpdir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If in doubt, spell out the
character sets in full.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de duda, explicite los conjuntos de caracteres completamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to intermix your source code
and your documentation text freely, as in</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto le permite entremezclar código fuente y texto de la documentación libremente, como por ejemplo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that since Perl 5.8.1 the single-number v-strings (like C&lt;v65&gt;)
are not v-strings before the C&lt;&lt; =&gt; &gt;&gt; operator (which is usually used
to separate a hash key from a hash value), instead they are interpreted
as literal strings ('v65').</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que desde Perl 5.8.1 los v-string de un solo número (como C&lt;v65&gt;) no son v-strings delante del operador C&lt;&lt; =&gt; &gt;&gt; (que se utiliza normalmente para separar una clave hash de un valor hash), sino que se interpretan como cadenas literales ('v65').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some systems (in general, DOS and Windows-based systems) binmode()
is necessary when you're not working with a text file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas (en general, sistemas basados en DOS y Windows) binmode() es necesario cuando no esté trabajando con un archivo de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See L&lt;/&quot;Smart matching in detail&quot;&gt; for more
information on smart matching.) But when EXPR is one of the below
exceptional cases, it is used directly as a boolean:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver L&lt;/&quot;Coincidencia inteligente en detalle&quot;&gt; para más información sobre coincidencia inteligente) Pero cuando EXPR es una de las excepciones abajo indicadas, se usa directamente como un booleano:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators such as C&lt;++&gt;, C&lt;--&gt;, C&lt;+=&gt;,
C&lt;-=&gt;, and C&lt;.=&gt;, that operate on undefined left values such as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operadores como C&lt;++&gt;, C&lt;--&gt;, C&lt;+=&gt;, C&lt;-=&gt; y C&lt;.=&gt;, que operan sobre valores no definidos como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be a scalar variable containing
the name of or a reference to the filehandle, thus introducing
one level of indirection.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>GESTOR_ARCHIVO puede ser una variable escalar conteniendo el nombre o una referencia al gestor de archivo, introduciendo así un nivel de indirección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If all fields are empty, they are considered to be trailing.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si todos los campos están vacíos, se consideran que están al final).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;version is v%vd\n&quot;, $^V;     # Perl's version</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;versión es v%vd\n&quot;, $^V;     # Versión de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>although without duplicating any side effects that dereferencing the lvalue
might trigger, such as from tie().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pero sin duplicar los efectos laterales que, desreferenciando el valor de la izquierda, se podrían desencadenar, como por ejemplo, de tie().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Miscellaneous</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Varios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11549</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11549</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq7		Perl Language Issues</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq7		Cuestiones sobre el lenguaje</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11541</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11541</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all pod translators are well-behaved in this regard, and perhaps
the compiler will become pickier.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No todos los traductores pod están bien entrenados a este respecto y quizá el compilador sea más quisquilloso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, they do what you want, unless you want
consistency.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, ellos hacen lo que usted quiere, siempre que quiera coherencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two
elements of the list must be the I&lt;numeric&gt; uid and gid, in that
order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los primeros dos elementos de la lista deben ser el valor I&lt;numérico&gt; del uid y gid, en este orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty trailing fields, on the other
hand, are produced when there is a match at the end of the string (and
when LIMIT is given and is not 0), regardless of the length of the match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Campos vacíos consecuentes, por el contrario, se producen cuando hay una coincidencia al final de la cadena (y cuando LÍMITE se ha dado y no es 0), independientemente de la longitud de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although exists() will return false for deleted entries,
deleting array elements never changes indices of existing values; use shift()
or splice() for that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque exists() devolverá falso para entradas eliminadas, eliminar elementos del array nunca cambia los índices de los valores existentes; use en su lugar shift() o splice().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require v5.6.1;     # run time version check</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require v5.6.1;     # comprobación de versión en tiempo de ejecución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the name tells you the particular
value to which it refers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resto del nombre indica a qué valor particular se accede.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, characters C&lt;&quot;0&quot;&gt;
and C&lt;&quot;1&quot;&gt; generate bits 0 and 1, as do characters C&lt;&quot;\000&quot;&gt; and C&lt;&quot;\001&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, los caracteres C&lt;&quot;0&quot;&gt; y C&lt;&quot;1&quot;&gt; generan los bits 0 y 1, al igual que los caracteres C&lt;&quot;\000&quot;&gt; y C&lt;&quot;\001&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now back to the regularly scheduled documentation...&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora volvamos a la documentación normal...&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>...;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it succeeds it returns true, otherwise it returns false and
sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si tiene éxito, devuelve verdadero, en caso contrario devuelve falso y asigna C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Why waste brainpower on a one-shot when you
might want to do something like it again?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Por qué perder la energía cerebral de un acierto cuando puede volver a usarlo otra vez?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is, however, syntax checked at
compile-time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Será, sin embargo, comprobada la sintaxis en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document briefly describes perl under Mac OS (Classic).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe brevemente perl bajo Mac OS (Classic).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%map = (
                 red   =&gt; 0x00f,
                 blue  =&gt; 0x0f0,
                 green =&gt; 0xf00,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T042723Z" changeid="explorer">
        <seg>%map = (
                 rojo  =&gt; 0x00f,
                 azul  =&gt; 0x0f0,
                 verde =&gt; 0xf00,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;.IX blurfl\n&quot; if /\bblurfl\b/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;.IX blurfl\n&quot; if /\bblurfl\b/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatically calls
C&lt;srand&gt; unless C&lt;srand&gt; has already been called.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Automáticamente llama a C&lt;srand&gt; a menos que C&lt;srand&gt; ya haya sido llamado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@info = stat($file) or die;     # better, now @info gets its due</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@info = stat($archivo) or die;     # mejor, ahora @info obtiene el valor correcto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to pack() or unpack() a C structure like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, para pack() o unpack() una estructura en C como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Fetching network info
X&lt;network&gt; X&lt;protocol&gt; X&lt;host&gt; X&lt;hostname&gt; X&lt;IP&gt; X&lt;address&gt; X&lt;service&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202457Z" changeid="explorer">
        <seg>=item Obteniendo información de la red
X&lt;network&gt; X&lt;protocol&gt; X&lt;host&gt; X&lt;hostname&gt; X&lt;IP&gt; X&lt;address&gt; X&lt;service&gt; X&lt;red&gt; X&lt;protocolo&gt; X&lt;servidor&gt; X&lt;dirección&gt; X&lt;servicio&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%2\$d %d\n&quot;,    12, 34;        # will print &quot;34 12\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%2\$d %d\n&quot;,    12, 34;        # imprimirá &quot;34 12\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDOUT &quot;stdout 2\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print STDOUT &quot;stdout 2\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>7 size   7 yearday    7 is_require   $$    process ID</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>7 size   7 día año    7 is_requere   $$    ID del proceso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is generally easier to read
C&lt;$var_names_like_this&gt; than C&lt;$VarNamesLikeThis&gt;, especially for
non-native speakers of English.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Generalmente es más fácil leer C&lt;$var_nombres_como_este&gt; que C&lt;$VarNombresComoEste&gt;, especialmente para los que no sean castellanoparlantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The elements we're getting from the array start with a C&lt;$&gt; because
we're getting just a single value out of the array; you ask for a scalar,
you get a scalar.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224905Z" changeid="explorer">
        <seg>Los nombres de los elementos que obtenemos del array empiezan por C&lt;$&gt; porque reciben valores individuales del array; si se pide un escalar, se obtiene un escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, it is not limited to using regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, no está limitado a usar expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data::Dumper: option to sort hashes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Data::Dumper: opción para abreviar hashes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item crypt PLAINTEXT,SALT
X&lt;crypt&gt; X&lt;digest&gt; X&lt;hash&gt; X&lt;salt&gt; X&lt;plaintext&gt; X&lt;password&gt;
X&lt;decrypt&gt; X&lt;cryptography&gt; X&lt;passwd&gt; X&lt;encrypt&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item crypt TEXTOPLANO,SALTO
X&lt;crypt&gt; X&lt;digest&gt; X&lt;hash&gt; X&lt;salt&gt; X&lt;plaintext&gt; X&lt;password&gt; X&lt;decrypt&gt; X&lt;cryptography&gt; X&lt;passwd&gt; X&lt;contraseña&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, for backward (and we do mean &quot;backward&quot;) compatibility, Perl
permits these unnecessary but widely-supported conversions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por último, para compatibilidad anterior (y nos referimos a &quot;hacia atrás&quot;), Perl permite estas innecesarias, pero ampliamente soportadas conversiones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These permission values need to be in octal, and are modified by your
process's current C&lt;umask&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos valores de permisos tiene que estar en octal, y son modificados por el valor de C&lt;umask&gt; de su proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;q#foo#&gt; is parsed as the string C&lt;foo&gt;, while C&lt;q #foo#&gt; is the
operator C&lt;q&gt; followed by a comment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;q#foo#&gt; es analizado como la cadena C&lt;foo&gt;, mientras que C&lt;q #foo#&gt; es el operador C&lt;q&gt; seguido por un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take care when using patterns that include C&lt;\G&gt; in an alternation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado al utilizar patrones que incluyan C&lt;\G&gt; en una alternativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On EBCDIC systems, the first example would be</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas EBCDIC, el primer ejemplo sería</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the right argument is an expression rather than a search pattern,
substitution, or transliteration, it is interpreted as a search pattern at run
time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el argumento derecho es una expresión en lugar de un patrón de búsqueda, sustitución o transliteración, se interpreta como un patrón de búsqueda en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;Quote and Quote-like Operators&gt; toward the end of this section,
as well as L&lt;/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185041Z" changeid="explorer">
        <seg>Véase también L&lt;Comillas y Operadores de comillas&gt; hacia el final de esta sección, así como L&lt;/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the string happens to be encoded as UTF-8 internally (and thus has
the UTF8 flag set), this is ignored by C&lt;vec&gt;, and it operates on the
internal byte string, not the conceptual character string, even if you
only have characters with values less than 256.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena pasa a ser codificado como UTF-8 de forma interna (y por tanto tiene la bandera UTF8 establecida), esto se ignora por C&lt;vec&gt;, y opera en la cadena de bytes interna, no la cadena de caracteres conceptuales, incluso si sólo tiene caracteres con valores inferiores a 256.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns like ioctl: the undefined value for error, &quot;C&lt;0&gt; but
true&quot; for zero, or the actual return value otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve lo mismo que C&lt;ioctl&gt;: el valor indefinido para error, C&lt;&quot;0 but true&quot;&gt; para el cero, o el valor de retorno real, en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>should be enough, the Configure should automatically probe for the
correct 64-bit settings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002949Z" changeid="explorer">
        <seg>debería ser suficiente, la opción Configure automáticamente debería buscar la configuración correcta para 64 bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>h  A hex string (low nybble first).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>h  Una cadena hexadecimal (primero el nibble bajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BEGIN { require Module; Module-&gt;import( LIST ); }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BEGIN { require Módulo; Módulo-&gt;import( LISTA ); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in paragraph
mode (C&lt;$/ = &quot;&quot;&gt;), it removes all trailing newlines from the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En modo párrafo (C&lt;$/ = &quot;&quot;&gt;), elimina todos los caracteres de nueva línea del string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item s///</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item s///</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;Z*Z*&quot;, pack(&quot;Z*Z*&quot;, ..)) was broken</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;Z*Z*&quot;, pack(&quot;Z*Z*&quot;, ..)) estaba roto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for real %HASHes
X&lt;hash&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201218Z" changeid="explorer">
        <seg>=item Funciones %HASH reales
X&lt;hash&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sethostent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sethostent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the RE above, which is intentionally obfuscated for illustration, the
delimiter is C&lt;m&gt;, the modifier is C&lt;mx&gt;, and after delimiter-removal the
RE is the same as for C&lt;m/ ^ a \s* b /mx&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la RE anterior, que está intencionalmente ofuscada para su ilustración, el delimitador es C&lt;m&gt;, el modificador es C&lt;mx&gt;, y después de la eliminación de los delimitadores, la RE es la misma que C&lt;m/ ^ a \s* b /mx&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11594</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11594</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;child died with signal %d, %s coredump\n&quot;,
            ($?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052232Z" changeid="explorer">
        <seg>printf &quot;hijo muerto con señal %d, %s coredump\n&quot;,
            ($?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or xor           |     alternation      \s == whitespace
                   \b    word boundary    \w == word characters
                   \z    string end       \d == digits</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043603Z" changeid="explorer">
        <seg>or xor           |     alternativa      \s == espacio
                   \b    lím. palabra     \w == caract. palabra
                   \z    final cadena     \d == dígitos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @AoA, [ @tmp ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @AoA, [ @tmp ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#foo];	# an expensive no-op</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#foo];	# una costosa no-operación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>translates a list of numbers to the corresponding characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>traduce una lista de números a sus caracteres correspondientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In time critical applications it behooves you not to split
into more fields than you really need.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En aplicaciones de tiempo crítico no es conveniente dividir en más campos de los que realmente necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod 0644, &lt;*.c&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod 0644, &lt;*.c&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;POSIX&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;POSIX&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Modules;       /$userinput/     perl.apache.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Modules;       /$userinput/     perl.apache.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	&lt; &gt; &lt;= &gt;= lt gt le ge</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	&lt; &gt; &lt;= &gt;= lt gt le ge</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The position in the file of FILEHANDLE is left unchanged.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211953Z" changeid="explorer">
        <seg>La posición en el archivo de GESTOR_ARCHIVO no cambia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#ARRAY) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#ARRAY) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This avoids expensive run-time recompilations,
and is useful when the value you are interpolating won't change over
the life of the script.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto evita costosas recompilaciones en tiempo de ejecución, y es útil cuando el valor que está interpolando no cambiará durante la vida del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl qw( :mode );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl qw( :mode );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that just as in C, Perl doesn't define B&lt;when&gt; the variable is
incremented or decremented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que, al igual que en C, Perl no define B&lt;cuando&gt; la variable se incrementa o disminuye.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item System V interprocess communication functions
X&lt;IPC&gt; X&lt;System V&gt; X&lt;semaphore&gt; X&lt;shared memory&gt; X&lt;memory&gt; X&lt;message&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202258Z" changeid="explorer">
        <seg>=item Funciones de comunicación interprocesos System V
X&lt;IPC&gt; X&lt;System V&gt; X&lt;semaphore&gt; X&lt;shared memory&gt; X&lt;memory&gt; X&lt;message&gt; X&lt;semáforo&gt; X&lt;memoria compartida&gt; X&lt;memoria&gt; X&lt;mensaje&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldsc		Perl data structures intro</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldsc		Introducción a las estructuras de datos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But if you try this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero si intenta esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words: regardless of platform, use binmode() on binary data,
like for example images.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras: indiferentemente de la plataforma, use binmode() en datos binarios, como por ejemplo imágenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11589</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11589</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@lines) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach (@lineas) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to classes and object-orientation
X&lt;object&gt; X&lt;class&gt; X&lt;package&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202029Z" changeid="explorer">
        <seg>=item Identificadores relativos a las clases y orientación a objetos
X&lt;object&gt; X&lt;class&gt; X&lt;package&gt; X&lt;objeto&gt; X&lt;clase&gt; X&lt;paquete&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opendir(my $dh, $some_dir) || die &quot;can't opendir $some_dir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>opendir(my $dh, $algun_dir) || die &quot;no puedo opendir $algun_dir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$b&gt; is negative, then C&lt;$a % $b&gt; is C&lt;$a&gt; minus the
smallest multiple of C&lt;$b&gt; that is not less than C&lt;$a&gt; (i.e. the
result will be less than or equal to zero).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$b&gt; es negativo, entonces C&lt;$a % $b&gt; es C&lt;$a&gt; menos el múltiplo más pequeño de C&lt;$b&gt; que no es menor que C&lt;$a&gt; (es decir el resultado será menor o igual a cero).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric literals are specified in any of the following floating point or
integer formats:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los literales numéricos se especifican en cualquiera de los siguientes formatos de punto flotante o entero:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no more entries, returns the undefined value in
scalar context and the empty list in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay más entradas, devuelve el valor indefinido en el contexto escalar y la lista vacía en el contexto de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TERM has the highest precedence in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un TÉRMINO tiene la mayor precedencia en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can actually put an array or hash anywhere in the list, but the first one
in the list will soak up all the values, and anything after it will become
undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede poner realmente un array o hash en cualquier lugar de la lista, pero la primera en la lista absorberá todos los demás valores, y cualquier cosa después quedará indefinida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this produces nine strings, one for
each pairing of fruits and colors:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, esto produce nueve cadenas, una por cada par de frutas y colores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This flag tells Perl to interpret the supplied string as a vector of
integers, one for each character in the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta bandera le dice a Perl que interprete la cadena indicada como un vector de enteros, uno para cada carácter en la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike C&lt;printf&gt;, C&lt;sprintf&gt; does not do what you probably mean when you
pass it an array as your first argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de C&lt;printf&gt;, C&lt;sprintf&gt; no hace lo que probablemente quiere decir cuando se le pasa un array como primer argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may distribute the programs of this Package in object code or
executable form, provided that you do at least ONE of the following:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede distribuir los programas de este Paquete en código objeto o en formato ejecutable, siempre que usted haga por lo menos UNO de los puntos siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlsub/&quot;Private Variables via my()&quot;&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L &lt;perlsub/&quot;Variables privadas con my()&quot;&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;reverse&gt; to do the
reverse.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilice C&lt;reverse&gt; para hacer lo contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignore them: in IRIX 5.3 there is no way to quieten ld about this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004759Z" changeid="explorer">
        <seg>No haga caso de ellos: en IRIX 5.3 no hay manera de silenciar ld a este respecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does a fork(2) system call to create a new process running the
same program at the same point.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace una llamada del sistema fork(2) para crear un nuevo proceso ejecutando el mismo programa en el mismo punto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An integer OPTVAL is shorthand for pack(&quot;i&quot;, OPTVAL).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un entero como OPCIÓN_VALOR es la abreviatura de pack(&quot;i&quot;, OPCIÓN_VALOR).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;or&quot; returns the logical disjunction of the two surrounding
expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;or&quot; devuelve la disyunción lógica de las dos expresiones que la rodean.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The routines are derived
(distantly) from Henry Spencer's freely redistributable reimplementation
of the V8 routines.)  See L&lt;Version 8 Regular Expressions&gt; for
details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Las rutinas se derivan (lejanamente) de la reimplementación redistribuible de henry Spencer de las rutinas V8). Véase L&lt;Expresiones regulares versión 8&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Perl script or program consists of one or more statements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un script o programa Perl consta de una o varias instrucciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can find out whether your Perl supports long
doubles via L&lt;Config&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede averiguar si su Perl soporta dobles a través de L&lt;Config&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NOTE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 NOTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item y///</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item y///</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($package, $filename, $line, $subroutine, $hasargs,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($paquete, $archivo, $linea, $subritina, $hasargs,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;gt&quot; returns true if the left argument is stringwise greater
than the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;gt&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente mayor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These modules
have the advantage of not hiding different types of the same name
during the local().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos módulos tienen la ventaja de no ocultar diferentes tipos del mismo nombre durante el local().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use strict;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlnewmod		Perl modules: preparing a new module for distribution</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlnewmod		Módulos Perl: preparando un nuevo módulo para su distribución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$utmp = pack($utmp_template, @utmp1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$utmp = pack($utmp_template, @utmp1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $f = myopen(&quot;&lt;/etc/motd&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $f = miopen(&quot;&lt;/etc/motd&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIMIT is unspecified or zero, trailing null fields are
stripped (which potential users of C&lt;pop&gt; would do well to remember).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LÍMITE no está especificado o es cero, los campos vacíos finales son descartados (que los potenciales usuarios de C&lt;pop&gt; harían bien en recordar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X FILEHANDLE
X&lt;-r&gt;X&lt;-w&gt;X&lt;-x&gt;X&lt;-o&gt;X&lt;-R&gt;X&lt;-W&gt;X&lt;-X&gt;X&lt;-O&gt;X&lt;-e&gt;X&lt;-z&gt;X&lt;-s&gt;X&lt;-f&gt;X&lt;-d&gt;X&lt;-l&gt;X&lt;-p&gt;
X&lt;-S&gt;X&lt;-b&gt;X&lt;-c&gt;X&lt;-t&gt;X&lt;-u&gt;X&lt;-g&gt;X&lt;-k&gt;X&lt;-T&gt;X&lt;-B&gt;X&lt;-M&gt;X&lt;-A&gt;X&lt;-C&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004330Z" changeid="explorer">
        <seg>=item -X GESTOR_ARCHIVO
X&lt;-r&gt;X&lt;-w&gt;X&lt;-x&gt;X&lt;-o&gt;X&lt;-R&gt;X&lt;-W&gt;X&lt;-X&gt;X&lt;-O&gt;X&lt;-e&gt;X&lt;-z&gt;X&lt;-s&gt;X&lt;-f&gt;X&lt;-d&gt;X&lt;-l&gt;X&lt;-p&gt;
X&lt;-S&gt;X&lt;-b&gt;X&lt;-c&gt;X&lt;-t&gt;X&lt;-u&gt;X&lt;-g&gt;X&lt;-k&gt;X&lt;-T&gt;X&lt;-B&gt;X&lt;-M&gt;X&lt;-A&gt;X&lt;-C&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also
L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, and C&lt;IPC::Semaphore&gt; documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, y C&lt;IPC::Semaphore&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also explicitly specify the argument number to use for
the join string using something like C&lt;*2$v&gt;; for example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede especificar, explícitamente, el número de argumento a utilizar para la combinación de cadena usando algo como C&lt;*2$v&gt;; por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = 'abc123xyz';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = 'abc123xyz';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gethostbyaddr ADDR,ADDRTYPE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gethostbyaddr DIRECCIÓN,TIPODIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;srand&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;srand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function binds a variable to a package class that will provide the
implementation for the variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función une una variable a una clase de paquete que ofrecerá la implementación para esa variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open netscape history file: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir el archivo histórico del netscape: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>support BeOS better</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>mejor soporte para BeOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LABEL is omitted, the command
refers to the innermost enclosing loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la ETIQUETA se omite, el comando se refiere al bucle más interior en que se encuentre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are advised to replace use of suidperl with tools such
as sudo ( http://www.courtesan.com/sudo/ )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se recomienda reemplazar el uso de suidperl con herramientas como sudo (http://www.courtesan.com/sudo/)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perllocale&gt; and L&lt;POSIX&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perllocale&gt; y L&lt;POSIX&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use File::stat;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use File::stat;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If more than one value is listed,
the list must be placed in parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se indica más de un valor, esa lista debe ser puesta entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-x  File is executable by effective uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004521Z" changeid="explorer">
        <seg>-x  Archivo es ejecutable por el uid/gid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very useful for providing default values
for variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es muy útil para proporcionar valores por defecto a las variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last SWITCH;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last SWITCH;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that it isn't so cumbersome to say, and will actually work.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>excepto que no es tan complicado como hemos dicho, y funciona de forma efectiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f  A single-precision float in native format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>f  Un flotante en simple precisión en formato nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.14); # same as @list = (2 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3.14); # lo mismo que @lista = (2 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Newton&quot; =&gt; &quot;Isaac&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;Newton&quot; =&gt; &quot;Isaac&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item oct</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item oct</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is supplied,
sets the new current default filehandle for output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se indica un GESTOR_ARCHIVO, se establece un nuevo gestor de archivo predeterminado para la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the empty list if C&lt;stat&gt; fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la lista vacía si C&lt;stat&gt; falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here's one way to count how many times a particular
string occurs in an array:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, aquí hay una manera de contar cuántas veces aparece una cadena particular en un array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last if /^--$/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last if /^--$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$other_execute =  $mode &amp; S_IXOTH;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$otros_ejecutar =  $modo &amp; S_IXOTH;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= caller($i);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170028Z" changeid="explorer">
        <seg>= caller($i);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a scheme is sometimes preferable to matching
particular string values of C&lt;$@&gt; with regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal esquema es algunas veces preferible a emparejar ciertas cadenas de valores de C&lt;$@&gt; usando expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in doubt, parenthesize.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de duda, coloque paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.perl.org/       the Perl homepage</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://www.perl.org/       página principal de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's all well and good for declaration of a fixed data structure,
but what if you wanted to add new elements on the fly, or build
it up entirely from scratch?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo eso está bien y es bueno para la declaración de una estructura de datos fijos, pero ¿y si quisiera añadir nuevos elementos sobre la marcha, o construirlo desde cero?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $bar{'blurfl'};      # Compare to: delete $bar{'blurfl'};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef $bar{'blurfl'};      # Comparar a: delete $bar{'blurfl'};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new filename linked to the old filename.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea un nuevo nombre de archivo enlazado con el nombre del archivo antiguo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A named array in scalar context is quite different from what would at
first glance appear to be a list in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un array con nombre, en contexto escalar, es muy diferente de lo que en un primer vistazo pudiera ser una lista en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod($perm | 0600, $fh);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod($permisos | 0600, $fh);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\K        [6]  Keep the stuff left of the \K, don't include it in $&amp;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224725Z" changeid="explorer">
        <seg>\K        [6]  Olvidar lo que está a la izquierda de \K, no incluir en $&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this operator produces an assignable result, using assignments
without parentheses will get you in trouble.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que este operador produce un resultado asignable, usar asignaciones sin paréntesis hará que se meta en problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Undefines the value of EXPR, which must be an lvalue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203504Z" changeid="explorer">
        <seg>Indefine el valor de EXPR, que debe ser un I&lt;ivalor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bar</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print scalar reverse &quot;dlrow ,&quot;, &quot;olleH&quot;;    # Hello, world</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print scalar reverse &quot;odnum ,&quot;, &quot;aloH&quot;;    # Hola, mundo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$time = (stat($file))[8];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004220Z" changeid="explorer">
        <seg>$acceso = (stat($archivo))[8];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with the release following soon after, when testing is complete.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>con el consiguiente comunicado poco después, cuando se complete los test.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If you put a space it
will be treated as a null identifier, which is valid, and matches the
first empty line.)  The terminating string must appear by itself
(unquoted and with no surrounding whitespace) on the terminating line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si pone un espacio será tratado como un identificador nulo, que es válido, y coincide con la primera línea en blanco). La cadena de terminación debe aparecer a sí mismo (sin comillas y sin espacios en blanco que la rodee) en la línea de terminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual
random order is subject to change in future versions of Perl, but it
is guaranteed to be the same order as either the C&lt;values&gt; or C&lt;each&gt;
function produces (given that the hash has not been modified).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El actual orden aleatorio está sujeto a cambio en futuras versiones de Perl, pero se garantiza que sea el mismo orden que las funciones C&lt;values&gt; o C&lt;each&gt; producirían (mientras que el hash no haya sido modificado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CFLAGS=-I/path/to/flock/server/headers ./configure.gnu \</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CFLAGS=-I/path/to/flock/server/headers ./configure.gnu \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+       prefix non-negative number with a plus sign</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>+       prefija un número no negativo con un signo más</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;$user not in passwd file&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;$usuario no está en archivo de contraseñas&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (\&amp;complicated_check) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (\&amp;confirmacion_complicada) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example, C&lt;0666 &amp; ~027&gt; is 0640.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;0666 &amp; ~027&gt; es 0640.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;|&quot; returns its operands ORed together bit by bit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;|&quot; devuelve la operación OR, bit a bit, de sus operandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is
slower than unprototyped subroutines, where the elements to be
compared are passed into the subroutine
as the package global variables $a and $b (see example below).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es más lento que las subrutinas no prototipadas, donde los elementos a comparar son pasados a la subrutina en las variables globales del paquete actual $a y $b (ver ejemplo abajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 I/O Operators
X&lt;operator, i/o&gt; X&lt;operator, io&gt; X&lt;io&gt; X&lt;while&gt; X&lt;filehandle&gt;
X&lt;&lt; &lt;&gt; &gt;&gt; X&lt;@ARGV&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185607Z" changeid="explorer">
        <seg>=head2 Operadores E/S
X&lt;operator, i/o&gt; X&lt;operator, io&gt; X&lt;io&gt; X&lt;while&gt; X&lt;filehandle&gt;
X&lt;&lt; &lt;&gt; &gt;&gt; X&lt;@ARGV&gt; X&lt;operador, e/s&gt; X&lt;operador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq9		Networking</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq9		Redes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an expression that specifies an element or slice of a hash, C&lt;delete&gt;
deletes the specified elements from that hash so that exists() on that element
no longer returns true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dada una expresión que especifica un elemento o una porción de un hash, C&lt;delete&gt; elimina los elementos especificados de este hash de tal forma que exists() en ese elemento ya no devuelve verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To match
the actual end of the string and not ignore an optional trailing
newline, use C&lt;\z&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para coincidir con el final actual de la cadena, sin ignorar un posible carácter de fin de línea, use C&lt;\z&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$first;          # Or here.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$primero;          # O aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, and
C&lt;IPC::SysV::Msg&gt; documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, y C&lt;IPC::SysV::Msg&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;Artistic&gt; and F&lt;Copying&gt; files for copyright information.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los archivos F&lt;Artistic&gt; y F&lt;Copying&gt; para ver la información sobre derechos de autor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but, because * is higher precedence than named operators:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pero, debido a que * es de mayor precedencia que los operadores con nombre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;continue&gt; block, if any, is not executed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bloque C&lt;continue&gt;, si está, no es ejecutado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== 101 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== 101 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also translators to turn your B&lt;sed&gt; and B&lt;awk&gt;
scripts into Perl scripts.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También hay traductores para convertir sus scripts B&lt;sed&gt; y B&lt;awk&gt; en scripts Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as an lvalue, specifying a
substring that is entirely outside the string raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203409Z" changeid="explorer">
        <seg>Cuando se utiliza como un I&lt;ivalor&gt;, especificando una subcadena que está totalmente fuera de la cadena lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>intsize='4';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>intsize='4';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example in L&lt;perlipc/&quot;Sockets: Client/Server Communication&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el ejemplo en L&lt;perlipc/&quot;Sockets: Comunicación Cliente/Servidor&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/&quot;(?&gt;(?:(?&gt;[^&quot;\\]+)|\\.)*)&quot;/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/&quot;(?&gt;(?:(?&gt;[^&quot;\\]+)|\\.)*)&quot;/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you open a pipe on the command C&lt;'-'&gt;, i.e., either C&lt;'|-'&gt; or C&lt;'-|'&gt;
with 2-arguments (or 1-argument) form of open(), then
there is an implicit fork done, and the return value of open is the pid
of the child within the parent process, and C&lt;0&gt; within the child
process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si abre una tubería en el comando C&lt;'-'&gt;, es decir, ya sea C&lt;'|-'&gt; o C&lt;'-|'&gt; con la forma de 2 argumentos (o un argumento) de open(), entonces se realiza un fork() implícito, y el valor de retorno del open() es el PID del hijo dentro del proceso padre, y C&lt;0&gt; en el proceso hijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl561delta	Perl changes in version 5.6.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl561delta	Cambios en la versión 5.6.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists &amp;{$ref-&gt;{A}{B}{$key}})   { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists &amp;{$ref-&gt;{A}{B}{$clave}})   { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of non-leap seconds since whatever time the system
considers to be the epoch, suitable for feeding to C&lt;gmtime&gt; and
C&lt;localtime&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de segundos no bisiestos desde el momento en que el sistema considera que es el I&lt;epoch&gt;, apto para ser alimentado a C&lt;gmtime&gt; y C&lt;localtime&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As noted earlier in this document, the scalar sense of list assignment
is the number of elements on the right-hand side of the assignment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como se ha señalado anteriormente en este documento, el sentido escalar de una asignación de una lista es el número de elementos en el lado derecho de la asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Remember, of course, that you can always write a loop to do a slice
operation.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194631Z" changeid="explorer">
        <seg>(Recuerde, por supuesto, que siempre se puede escribir un bucle para hacer una operación de corte)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>redo unless eof();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>redo unless eof();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 - empty hashes or arrays will match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 - hash o array vacíos coincidirán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When writing, if STRING is too long, only SIZE
bytes are used; if STRING is too short, nulls are written to fill out
SIZE bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al escribir, si CADENA es demasiado larga, sólo se utilizan TAMAÑO bytes; si CADENA es demasiado corta, se escriben nulos para llenar TAMAÑO bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lc EXPR
X&lt;lc&gt; X&lt;lowercase&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174212Z" changeid="explorer">
        <seg>=item lc EXPR
X&lt;lc&gt; X&lt;lowercase&gt; X&lt;minúscula&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intent is to squeeze as much possible information about the likely cause
into the limited space of the system exit code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171255Z" changeid="explorer">
        <seg>La intención es comprimir la mayor información posible sobre la causa probable en el limitado espacio del código de salida del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptors, as determined by the value
of $^F.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que apoyan la bandera close-on-exec en archivos, esta bandera se establecerá para los nuevos descriptores de archivo abiertos, según lo determinado por el valor de $^F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gethostent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gethostent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the shared memory
segment id, or the undefined value if there is an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el identificador de la memoria compartida, o el valor indefinido si hay un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A question mark was chosen for this and for the minimal-matching
construct because 1) question marks are rare in older regular
expressions, and 2) whenever you see one, you should stop and
&quot;question&quot; exactly what is going on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un signo de interrogación fue elegido para esto y para la construcción mínima de coincidencia porque: 1) signos de interrogación son poco frecuentes en expresiones regulares antiguas, y 2) cada vez que veas uno, debe pararse y &quot;cuestionarse&quot; exactamente lo que está pasando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is called when
a tied hash is used in scalar context, such as</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se activa cuando un hash enlazado se utiliza en contexto escalar, como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpeername SOCKET
X&lt;getpeername&gt; X&lt;peer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173520Z" changeid="explorer">
        <seg>=item getpeername SOCKET
X&lt;getpeername&gt; X&lt;peer&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a C&lt;continue&gt; BLOCK, it is always executed just before the
conditional is about to be evaluated again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si existe un BLOQUE C&lt;continue&gt;, siempre es ejecutado justo antes de que la condición sea evaluada de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $y = &quot;bar&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232629Z" changeid="explorer">
        <seg>my $y = &quot;bar&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $1 if /\G(q)/gc;  print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $1 if /\G(q)/gc;  print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These may look like functions, but
may also look completely different.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pueden parecerse a funciones, pero también pueden ser complementamente diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $name = 'fred';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $nombre = 'pedro';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/undef&gt;, L&lt;/exists&gt;, L&lt;/ref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/undef&gt;, L&lt;/exists&gt;, L&lt;/ref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A loop's LABEL is not actually a valid target for
a C&lt;goto&gt;; it's just the name of the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La ETIQUETA de un bucle no es realmente un destino válido para un C&lt;goto&gt;; sólo es el nombre del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item mkdir FILENAME,MASK
X&lt;mkdir&gt; X&lt;md&gt; X&lt;directory, create&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191422Z" changeid="explorer">
        <seg>=item mkdir ARCHIVO,MÁSCARA
X&lt;mkdir&gt; X&lt;md&gt; X&lt;directory, create&gt; X&lt;directorio, crear&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*this = *that;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>*este = *ese;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Perl assumes that it must do most of its arithmetic in
floating point.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma predeterminada, Perl se supone que debe hacer la mayor parte de su aritmética en punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $@ if $@;                # prints &quot;bar lives here&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $@ if $@;                # imprime &quot;bar vive aquí&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$mday&gt; is the day of the month, and C&lt;$mon&gt; is the month itself, in
the range C&lt;0..11&gt; with 0 indicating January and 11 indicating December.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$mdia&gt; es el día del mes, y C&lt;$mes&gt; es el propio mes, en el rango C&lt;0..11&gt; con 0 indicando enero y 11, diciembre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Numeric comparison</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235219Z" changeid="zipf">
        <seg>=item Comparación numérica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The text is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El texto es ignorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all methods indicated above need be implemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No todos los métodos indicados es necesario implementarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item reset</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item reset</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item wantarray
X&lt;wantarray&gt; X&lt;context&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211004Z" changeid="explorer">
        <seg>=item wantarray
X&lt;wantarray&gt; X&lt;context&gt; X&lt;contexto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?#text)&gt;
X&lt;(?#)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230512Z" changeid="explorer">
        <seg>=item C&lt;(?#text)&gt;
X&lt;(?#)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;hv_clear_placeholders&gt; is now part of the perl API</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;hv_clear_placeholders&gt; ahora es parte de la API de perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do just
C&lt;&lt; open(A, '&gt;&gt;&amp;B') &gt;&gt;, the filehandle A will not have the same file
descriptor as B, and therefore flock(A) will not flock(B), and vice
versa.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hace sólo C&lt;&lt; open(A, '&gt;&gt;&amp;B') &gt;&gt;, el gestor de archivo A no tendrá el mismo descriptor de archivo que B, y por lo tanto flock(A) no hará un flock(B), y viceversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eof());  # quote body</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eof());  # citar el cuerpo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&gt;=&quot; returns true if the left argument is numerically greater
than or equal to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&gt;=&quot; devuelve verdadero si el argumento de la izquierda es numéricamente mayor o igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDERR &quot;stderr 2\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print STDERR &quot;stderr 2\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The yada yada
is a syntax error if Perl doesn't guess that the C&lt;{ ... }&gt; is a
block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El blablablá es un error de sintaxis si Perl no adivina que el C&lt;{...}&gt; sea un bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We know that these values do I&lt;not&gt; work under
OS/390 &amp; VM/ESA Unix and on the Macintosh; you probably don't want to
use them in new code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sabemos que estos valores I&lt;no&gt; funcionan bajo OS/390 y VM/ESA Unix y en el Macintosh; es probable que no desea utilizarlos en nuevos programas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Differences from Perl 6</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Diferencias con Perl 6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>struct {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently implemented pragmas are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las pragmas actualmente implementadas son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A list of
them is given at the start of L&lt;perlfunc&gt; and you can easily read
about any given function by using C&lt;perldoc -f I&lt;functionname&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225220Z" changeid="explorer">
        <seg>Al principio de L&lt;perlfunc&gt; se incluye una lista completa de funciones. También puede obtener fácilmente información sobre cualquier función mediante el comando C&lt;perldoc -f I&lt;nombre_función&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@animals[0..2];                 # gives (&quot;camel&quot;, &quot;llama&quot;, &quot;owl&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T213957Z" changeid="explorer">
        <seg>@animales[0..2];           # devuelve (&quot;camello&quot;, &quot;llama&quot;, &quot;búho&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod&gt; para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The perlfunc(1) entry on
C&lt;umask&gt; discusses the choice of MASK in more detail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La entrada perlfunc(1) sobre C&lt;umask&gt; discute la elección de la máscara con más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Version 8 Regular Expressions
X&lt;regular expression, version 8&gt; X&lt;regex, version 8&gt; X&lt;regexp, version 8&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T200129Z" changeid="explorer">
        <seg>=head2 Expresiones regulares versión 8
X&lt;regular expression, version 8&gt; X&lt;regex, version 8&gt; X&lt;regexp, version 8&gt; X&lt;expresión regular, versión 8&gt; X&lt;regex, versión 8&gt; X&lt;regexp, versión 8&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chroot FILENAME
X&lt;chroot&gt; X&lt;root&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170252Z" changeid="explorer">
        <seg>=item chroot NOMBRE_ARCHIVO
X&lt;chroot&gt; X&lt;root&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Look at the L&lt;Digest&gt; module for more robust algorithms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mire en el módulo L&lt;Digest&gt; por algoritmos más robustos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When different buffers within the same pattern have the same name, C&lt;$+{name}&gt;
and C&lt;&lt; \k&lt;name&gt; &gt;&gt; refer to the leftmost defined group.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando memorias de captura diferentes dentro del mismo patrón tienen el mismo nombre, C&lt;+${nombre}&gt; y C&lt;&lt; \k&lt;nombre&gt; &gt;&gt; se refieren al grupo definido que esté más a la izquierda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;\$foo is alive and $foo!&quot;;     # does show up</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;\$foo está vivo y $foo!&quot;;     # lo muestra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The numbers refer to the Perl repository change numbers; see
L&lt;Changes58&gt; (or L&lt;Changes&gt; in Perl 5.8.1).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los números se refieren a los números de cambio en el repositorio Perl; véase L&lt;Changes58&gt; (o L&lt;Cambios&gt; en Perl 5.8.1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Slices
X&lt;slice&gt; X&lt;array, slice&gt; X&lt;hash, slice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035909Z" changeid="explorer">
        <seg>=head2 Porciones
X&lt;slice&gt; X&lt;array, slice&gt; X&lt;hash, slice&gt; X&lt;porción&gt; X&lt;array, porción&gt; X&lt;hash, porción&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;alarm&gt;, C&lt;exec&gt;, C&lt;fork&gt;, C&lt;getpgrp&gt;, C&lt;getppid&gt;, C&lt;getpriority&gt;, C&lt;kill&gt;,
C&lt;pipe&gt;, C&lt;qx//&gt;, C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;sleep&gt;, C&lt;system&gt;,
C&lt;times&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;alarm&gt;, C&lt;exec&gt;, C&lt;fork&gt;, C&lt;getpgrp&gt;, C&lt;getppid&gt;, C&lt;getpriority&gt;, C&lt;kill&gt;, C&lt;pipe&gt;, C&lt;qx/STRING/&gt;, C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;sleep&gt;, C&lt;system&gt;, C&lt;times&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;ext/POSIX/t/waitpid&gt; test fails at #1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El test C&lt;ext/POSIX/t/waitpid&gt; falla en el número 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for SCALARs or strings
X&lt;scalar&gt; X&lt;string&gt; X&lt;character&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043447Z" changeid="explorer">
        <seg>=item Functiones para ESCALARES o cadenas
X&lt;scalar&gt; X&lt;string&gt; X&lt;character&gt; X&lt;escalar&gt; X&lt;cadena&gt; X&lt;carácter&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The @ARGV array is then processed as a list
of filenames.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Luego, el array @ARGV es procesado como una lista de nombres de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example to define a &quot;systell&quot; function:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, para definir una función &quot;systell&quot;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;PerlIO&gt;, L&lt;perlrun&gt;, and the discussion about the
PERLIO environment variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;PerlIO&gt;, L&lt;perlrun&gt; y la discusión sobre la variable de entorno PERLIO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Integer Arithmetic
X&lt;integer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011135Z" changeid="explorer">
        <seg>=head2 Aritmética entera
X&lt;integer&gt; X&lt;entero&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then one is added to the return value
of C&lt;print&gt; (usually 1).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entonces uno es añadido al valor devuelto por C&lt;print&gt; (generalmente 1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>READLINE this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>READLINE este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlembed		Perl ways to embed perl in your C or C++ application</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlembed		Formas de embeber perl en su aplicación C o C++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;qx/EXPR/&gt;
operator is discussed in more detail in L&lt;perlop/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador C&lt;qx/EXPR/&gt; se discute con más detalle en L&lt;perlop/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you evaluate an array in scalar context, it returns the length
of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se evalúa un array en un contexto escalar, éste devuelve la longitud del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%*.*s&gt;&quot;, $a, $b, $c;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;&lt;%*.*s&gt;&quot;, $a, $b, $c;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;last&gt; cannot be used to exit a block that returns a value such as
C&lt;eval {}&gt;, C&lt;sub {}&gt; or C&lt;do {}&gt;, and should not be used to exit
a grep() or map() operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;last&gt; no puede usarse para salir de un bloque que devuelve un valor, como C&lt;eval {}&gt;, C&lt;sub {}&gt; o C&lt;do {}&gt;, y no debe ser usado para salir de una operación grep() o map().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endgrent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endgrent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that the loop control statements described
later will I&lt;NOT&gt; work in this construct, because modifiers don't take
loop labels.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013204Z" changeid="explorer">
        <seg>Note también que las instrucciones de control de bucles descritas más adelante I&lt;NO&gt; funcionarán con esta construcción, porque los modificadores no toman etiquetas de bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;context&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;contexto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item continue BLOCK
X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170336Z" changeid="explorer">
        <seg>=item continue BLOQUE
X&lt;continue&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x   string multiplication</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>x   multiplicación de cadenas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;\&quot; creates a reference to whatever follows it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unario &quot;\&quot; crea una referencia a lo que sigue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can actually chomp anything that's an lvalue, including an assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede recortar cualquier cosa que sea un lvalue (valor a la izquierda), incluyendo una asignación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A numeric repeat count may optionally be enclosed in brackets, as
in C&lt;pack(&quot;C[80]&quot;, @arr)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un número de repeticiones podría estar opcionalmente encerrada entre paréntesis, como en C&lt;pack(&quot;C[80]&quot;, @arr)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+ 20;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>+ 20;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>assigns the value of variable $bar to the scalar variable $foo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>asigna el valor de la variable $bar a la variable escalar $foo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chroot</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chroot</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They fall into two major categories: list operators and named unary
operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se agrupan en dos categorías principales: operadores de listas y operadores unarios con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system 'stty', 'icanon', 'eol', '^@'; # ASCII NUL</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system 'stty', 'icanon', 'eol', '^@'; # ASCII NUL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If C&lt;use locale&gt; is set, then this depends on the current locale.)
Today it is more common to use the quotemeta() function or the C&lt;\Q&gt;
metaquoting escape sequence to disable all metacharacters' special
meanings like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si C&lt;use locale&gt; está establecido, entonces esto depende de la localización actual). Hoy es más común el uso de la función quotemeta() o de la secuencia de escapado C&lt;\Q&gt; para desactivar los significados especiales de los metacaracteres, como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any way, if you're seeing failures beyond those mentioned in this
document, please consider upgrading to the latest Hurd before reporting
the failure as a bug.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De cualquier forma, si está viendo fallos más allá de los aquí mencionados en este documento, considere, por favor, actualizar al último Hurd antes de informar del fallo como si fuera un bug.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this way C&lt;our&gt; differs from C&lt;use vars&gt;, which is package scoped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esta manera, C&lt;our&gt; difiere de la C&lt;use vars&gt;, en que su ámbito es el paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return log($n)/log(10);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return log($n)/log(10);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that the whole range idea is rather unportable between
character sets--and even within character sets they may cause results
you probably didn't expect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta también que la idea de rango es poco transportable entre conjuntos de caracteres; e incluso dentro de los mismos conjuntos de caracteres pueden causar resultados que probablemente no espera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211712Z" changeid="explorer">
        <seg>=item open GESTOR_ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 List value constructors
X&lt;list&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035721Z" changeid="explorer">
        <seg>=head2 Constructores de lista de valores
X&lt;list&gt; X&lt;lista&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.hurd - Perl version 5 on Hurd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.hurd - Perl versión 5 sobre Hurd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;t/io/fflush&gt; test fails at #6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El test C&lt;t/io/fflush&gt; falla en el número 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if the filehandle has been marked as C&lt;:utf8&gt; Unicode
characters are read instead of bytes (the LENGTH, OFFSET, and the
return value of sysread() are in Unicode characters).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si el gestor de archivo ha sido marcado como  C&lt;:utf8&gt;, son leídos caracteres Unicode en lugar de bytes (la LONGITUD, el DESPLAZAMIENTO y el valor de retorno de sysread() están descritos en forma de número de caracteres Unicode).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice the inner loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193931Z" changeid="explorer">
        <seg>Observe el bucle interior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regarding aesthetics of code lay out, about the only thing Larry
cares strongly about is that the closing curly bracket of
a multi-line BLOCK should line up with the keyword that started the construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con respecto a la estética del código, a lo único que Larry le preocupa es que la llave de cierre de un BLOQUE multilínea debe alinearse con la palabra reservada que inició esa estructura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(1, '-', 10, ',', 20)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(1, '-', 10, ',', 20)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,m}?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n,m}?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is an error
to try to write off the beginning of the string (i.e., negative OFFSET).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es un error tratar de cancelar el principio de la cadena (es decir, DESPLAZAMIENTO negativo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># then back the top to re-check EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># entonces regresa arriba a recomprobar la EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp; s//BETTY $1 BETTY/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>  &amp;&amp; s//BETTY $1 BETTY/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It would generate the scalar comma operator
there, not the list construction version of the comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se generará aquí el operador coma, no la versión de construcción de listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5115delta	Perl changes in version 5.11.5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5115delta	Cambios en la versión 5.11.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the rules and rigors of ANSI C, on some systems you have to do a
seek whenever you switch between reading and writing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a las normas y rigores de la norma ANSI C, en algunos sistemas tendrá que hacer una búsqueda cada vez que alterne entre la lectura y la escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If bits is 4 or less, the string is broken into bytes, then the bits
of each byte are broken into 8/BITS groups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si bits son 4 o menos, la cadena se divide en bytes, y a continuación, los bits de cada byte se dividen en grupos de 8/BITS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you chop a list, each element is chopped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si recorta una lista, cada elemento es recortado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Commonly available C&lt;S_IF*&gt; constants are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comúnmente disponibles las constantes C&lt;S_IF*&gt; son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;README&gt; file for general stuff.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El archivo F&lt;README&gt; (LEEME) para asuntos generales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are all documented in L&lt;perlfunc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Están todas documentadas en L&lt;perlfunc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the list above LIMIT would have been 4 by
default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la lista de arriba LÍMITE hubiera sido 4 por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the template in brackets contains alignment
commands (such as C&lt;x![d]&gt;), its packed length is calculated as if the
start of the template had the maximal possible alignment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la plantilla que figura entre corchetes contiene los comandos de alineación (como C&lt;x![d]&gt;), su longitud se calculará como si el comienzo de la plantilla tuviera la máxima alineación posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EXPR is executed as a system command.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EXPR es ejecutada como un comando del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;\&gt; X&lt;reference&gt; X&lt;backslash&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;\&gt; X&lt;reference&gt; X&lt;backslash&gt; X&lt;referencia&gt; X&lt;barra diagonal inversa&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the substr() function as an lvalue, in which case EXPR
must itself be an lvalue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203351Z" changeid="explorer">
        <seg>Puede utilizar la función substr() como un I&lt;ivalor&gt;, en cuyo caso la EXPR debe ser en si mismo un I&lt;ivalor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support fchown(2), you may pass filehandles among the
files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soporten fchown(2), puede pasar gestores de archivo entre los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use C&lt;alarm&gt; to time out a system call you need to use an
C&lt;eval&gt;/C&lt;die&gt; pair.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere usar C&lt;alarm&gt; controlar la duración de una llamada del sistema necesita una pareja C&lt;eval&gt;/C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$scalar = delete $hash{foo};             # $scalar is 11</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$scalar = delete $hash{foo};             # $scalar es 11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See also L&lt;Integer Arithmetic&gt; and L&lt;Bitwise String Operators&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185900Z" changeid="explorer">
        <seg>(Véase también L&lt;Aritmética entera&gt; y L&lt;Operadores de bit en cadenas&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Works only for non-negative operands unless you've
loaded the C&lt;Math::Complex&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo funciona para operandos no negativos a menos que haya cargado el módulo C&lt;Math::Complex&gt;x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may mail your bug reports (be sure to include full configuration
information as output by the myconfig program in the perl source
tree, or by C&lt;perl -V&gt;) to perlbug@perl.org .  If you've succeeded
in compiling perl, the B&lt;perlbug&gt; script in the F&lt;utils/&gt; subdirectory
can be used to help mail in a bug report.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T041126Z" changeid="explorer">
        <seg>Puede enviar sus informes de fallos (asegúrese de incluir la información de configuración completa en términos de producción por el programa myconfig en el árbol de código fuente Perl, o con C&lt;perl -V&gt;) a perlbug@perl.org. Si tuvo éxito en la compilación de perl, el script B&lt;perlbug&gt; en el subdirectorio F&lt;utils/&gt; se puede utilizar para el envío de un correo electrónico con el informe de errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No message is printed if there is a C&lt;$SIG{__WARN__}&gt; handler
installed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ningún mensaje se imprime si hay instalado un controlador C&lt;$SIG{__WARN__}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Saying C&lt;undef $hash{$key}&gt;
will probably not do what you expect on most predefined variables or
DBM list values, so don't do that; see L&lt;delete&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Decir C&lt;undef $hash{$key}&gt; probablemente no vaya a hacer lo que usted espera en la mayoría de las variables predefinidas o lista de valores DBM, así que no haga eso; vea L&lt;delete&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our $foo;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>our $foo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, '-|') || exec 'cat', '-n', $file;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, '-|') || exec 'cat', '-n', $archivo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FH, &quot;&gt;&gt;&amp;=OLDFH&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FH, &quot;&gt;&gt;&amp;=OLDFH&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub/&quot;Localized deletion of elements
of composite types&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub/&quot;Eliminación local de elementos de tipos compuestos&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with
LOCK_NB.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>OPERACIÓN es una de LOCK_SH, LOCK_EX, o LOCK_UN, posiblemente combinado con LOCK_NB.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @compiled = map qr/$_/i, @$patterns;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @compilados = map qr/$_/i, @$patrones;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The old behaviour was that %tied_hash would return whatever would have been
returned for that hash before the hash was tied (so usually 0).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento anterior era que %hash_enlazado devolvería todo la que hubiera devuelto este hash antes de ser enlazado (por lo general, 0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's also a negated version of it:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T002702Z" changeid="zipf">
        <seg>También existe la versión negada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/x/) { say '$foo contains an x'; continue }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/x/) { say '$foo contiene una x'; continue }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Basic BLOCKs
X&lt;block&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T195412Z" changeid="explorer">
        <seg>=head2 BLOQUES básicos
X&lt;block&gt; X&lt;bloque&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
C&lt;@addrs&gt; value returned by a successful call is a list of raw
addresses returned by the corresponding library call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto C&lt;@addrs&gt; por una exitosa llamada es una lista de las direcciones en crudo devueltas por la correspondiente llamada a la biblioteca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is
omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If unimplemented, raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no está implementada, lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can find out whether Perl considers &quot;long double&quot; to be the default
floating-point size to use on your platform via L&lt;Config&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>puede averiguar si Perl considera &quot;long double&quot; como el valor por defecto para el tamaño del punto flotante para su plataforma a través de L&lt;Config&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'good men to come to.'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'los hombres buenos por venir.'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
the C-comment deletion code in L&lt;perlop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vea el código en C para eliminar comentarios en L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is useful
syntactically for separating a function name from a parenthesized expression
that would otherwise be interpreted as the complete list of function
arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es útil para separar sintácticamente un nombre de función de una expresión entre paréntesis que, de otro modo, sería interpretada como la lista completa de argumentos de la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@names) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@nombres) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;time+86_400&gt; always means
C&lt;time() + 86_400&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;time+86_400&gt; siempre significa C&lt;time() + 86_400&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't bother with -n32 unless you have 7.1
or later compilers (use cc -version to check).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002507Z" changeid="explorer">
        <seg>No se moleste en poner -n32 a menos que tenga un compilador 7.1 o superior (use cc -version para comprobarlo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$login = getlogin || getpwuid($&lt;) || &quot;Kilroy&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$login = getlogin || getpwuid($&lt;) || &quot;Kilroy&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl provides customary quote characters
for these behaviors, but also provides a way for you to choose your
quote character for any of them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl no solo proporciona caracteres normales de entrecomillado para estos comportamientos, sino que también proporciona una manera para que usted elija su carácter de entrecomillado para cualquiera de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the left value is greater than the right value then it
returns the empty list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el valor de la izquierda es mayor que el valor de la derecha entonces devuelve la lista vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $list[$_] foreach 0 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234915Z" changeid="zipf">
        <seg>print $lista[$_] foreach 0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8 atime  8 is_dst     8 hints        $.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>8 atime  8 es_dst     8 hints        $.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use here documents instead of repeated C&lt;print()&gt; statements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use documentos incluídos en vez de repetir instrucciones C&lt;print()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rin = $win = $ein = '';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$rin = $win = $ein = '';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is not ok, as the regex engine will end up trying to compile the
pattern C&lt;\&gt;, which it will consider a syntax error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no es correcto, porque el motor de expresiones regulares acabará tratando de compilar el patrón C&lt;\&gt;, que va generar un error de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, if the REPLACEMENTLIST is shorter
than the SEARCHLIST, the final character is replicated till it is long
enough.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, si la LISTA_REEMPLAZO es más corta que la LISTA_BÚSQUEDA, el carácter final es replicado hasta que sea lo suficientemente larga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sends a signal to a list of processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Manda una señal a una lista de procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qw/STRING/
X&lt;qw&gt; X&lt;quote, list&gt; X&lt;quote, words&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010312Z" changeid="explorer">
        <seg>=item qw/CADENA/
X&lt;qw&gt; X&lt;quote, list&gt; X&lt;quote, words&gt; X&lt;entrecomillado, lista&gt; X&lt;entrecomillado, palabras&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc/&quot;SysV IPC&quot;&gt; and C&lt;IPC::SysV&gt; documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt; y C&lt;IPC::SysV&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;delete&gt;, C&lt;each&gt;, C&lt;exists&gt;, C&lt;keys&gt;, C&lt;values&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;delete&gt;, C&lt;each&gt;, C&lt;exists&gt;, C&lt;keys&gt;, C&lt;values&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsec/&quot;Algorithmic Complexity Attacks&quot;&gt; for the original
rationale behind this change.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsec/&quot;Ataques de complejidad algorítmica&quot;&gt; para la justificación original de este cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
can locate an O'Reilly order form, you can also fax to +1 707 829 0104.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T233745Z" changeid="explorer">
        <seg>Si encuentra un formulario de pedido de O'Reilly, puede enviarlo por fax a +1 707 829 0104.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># read in config files: system first, then user</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># leer en archivos de configuración: primero el sistema, luego el usuario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hdrs   =  (UNIX_FROM =&gt; split /^(\S*?):\s*/m, $header);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%cabeceras  =  (UNIX_FROM =&gt; split /^(\S*?):\s*/m, $encabezado);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any non-whitespace delimiter may replace the slashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier delimitador distinto del espacio en blanco puede sustituir a las barras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing, but with explicit sort routine</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, pero con una rutina de ordenación explícita</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over 4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=over 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How it behaves
depends on the context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El cómo se comporta depende del contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following (inefficiently) deletes all the values of %HASH and @ARRAY:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo siguiente borra (ineficientemente) todos los valores de %HASH y @ARRAY:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also use apostrophes instead of angle brackets to delimit the
name; and you may use the bracketed C&lt;&lt; \g{name} &gt;&gt; backreference syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede utilizar apóstrofes en lugar de ángulos para delimitar el nombre; y puede utilizar la sintaxis de la forma con paréntesis C&lt;&lt; \g{nombre} &gt;&gt; de contrareferencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Defined\n&quot;   if defined $array[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Definido\n&quot;  if defined $array[$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my (@AoA, $i, $line);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my (@AoA, $i, $linea);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Children's times are only included for terminated children.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tiempos de los hijos solo se incluyen de los hijos terminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Will both leave the sentence as is.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012633Z" changeid="explorer">
        <seg>Ambas dejará la instrucción como estaba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over 8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=over 8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print (1+2)+4;    # Also prints 3!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print (1+2)+4;	# ¡También imprime 3!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl cannot be compiled with threading support ATM.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl no puede ser compilado con soporte multihilo ATM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to compile Perl 32-bit.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002345Z" changeid="explorer">
        <seg>para compilar Perl de 32 bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entire arrays (and slices of arrays and hashes) are denoted by '@',
which works much like the word &quot;these&quot; or &quot;those&quot; does in English,
in that it indicates multiple values are expected.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los arrays enteros (y las porciones de arrays o hashes) son designados por '@', que funciona como los determinantes &quot;estos&quot; o &quot;esos&quot; del Español, indicando que se esperan múltiples valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because C&lt;chomp $cwd = `pwd`;&gt;
is interpreted as C&lt;(chomp $cwd) = `pwd`;&gt;, rather than as
C&lt;chomp( $cwd = `pwd` )&gt; which you might expect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es porque C&lt;chomp $cwd = `pwd`;&gt; es interpretado como C&lt;(chomp $cwd) = `pwd`;&gt;, en vez de un C&lt;chomp( $cwd = `pwd` )&gt; que es lo que se esperaba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;DB_File&gt;
or the F&lt;Config&gt; module for interesting C&lt;tie&gt; implementations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;DB_File&gt; o el módulo F&lt;Config&gt; para interesantes implementaciones de C&lt;tie&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not a decimal number&quot; unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es número real&quot;    unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $y;           # prints &quot;bar&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002208Z" changeid="zipf">
        <seg>print $y;           # imprime &quot;bar&quot; en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;say LIST&gt; is simply an abbreviation for C&lt;{ local $\ = &quot;\n&quot;; print
LIST }&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;say LISTA&gt; es simplemente una abreviatura de C&lt;{ local $\ = &quot;\n&quot;; print LISTA }&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use subs     qw(afunc blurfl);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use subs     qw(afunc blurfl);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If, however, the string begins with a
non-alphabetic character (excluding &quot;+&quot; or &quot;-&quot;), Perl will attempt to convert
the string to a numeric and the arithmetic negation is performed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si la cadena comienza con un carácter no-alfabético (con exclusión de &quot;+&quot; o &quot;-&quot;), Perl tratará de convertir la cadena en un código numérico y se lleva a cabo la negación aritmética.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print FH $data		or die &quot;Can't write to FH: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print FH $dato		or die &quot;No puedo escribir a FH: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;characters&gt;: depending on the status of the socket, either
(8-bit) bytes or characters are sent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note los I&lt;caracteres&gt;: dependiendo del estado del socket, son enviados bytes (8-bit) o caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a format typically
does one C&lt;formline&gt; per line of form, but the C&lt;formline&gt; function itself
doesn't care how many newlines are embedded in the PICTURE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que un formato típicamente hace un C&lt;formline&gt; por línea del formato, pero a la misma función C&lt;formline&gt; no le preocupa cuántos avances de línea están incluidos en el CUADRO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item package NAMESPACE VERSION
X&lt;package&gt; X&lt;module&gt; X&lt;namespace&gt; X&lt;version&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192515Z" changeid="explorer">
        <seg>=item package ESPACIO_NOMBRES VERSIÓN
X&lt;package&gt; X&lt;module&gt; X&lt;namespace&gt; X&lt;version&gt; X&lt;paquete&gt; X&lt;módulo&gt; X&lt;espacio de nombres&gt; X&lt;versión&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the number of exponent digits in the scientific notation produced
by C&lt;%e&gt;, C&lt;%E&gt;, C&lt;%g&gt; and C&lt;%G&gt; for numbers with the modulus of the
exponent less than 100 is system-dependent: it may be three or less
(zero-padded as necessary).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el número de dígitos del exponente en notación científica producida por C&lt;%e&gt;, C&lt;%E&gt;, C&lt;%g&gt; y C&lt;%G&gt; para los números con el módulo del exponente menor de 100 es dependiente del sistema: puede ser de tres o menos (con relleno de ceros según sea necesario).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LENGTH is omitted, removes everything from OFFSET onward.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite LONGITUD, se suprime todo desde DESPLAZAMIENTO en adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exp EXPR
X&lt;exp&gt; X&lt;exponential&gt; X&lt;antilog&gt; X&lt;antilogarithm&gt; X&lt;e&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T172901Z" changeid="explorer">
        <seg>=item exp EXPR
X&lt;exp&gt; X&lt;exponential&gt; X&lt;antilog&gt; X&lt;antilogarithm&gt; X&lt;e&gt; X&lt;exponencial&gt; X&lt;anti logaritmo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} elsif (!$result) {
           delete $INC{$filename};
           die &quot;$filename did not return true value&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051227Z" changeid="explorer">
        <seg>} elsif (!$resultado) {
           delete $INC{$archivo};
           die &quot;$archivo no devolvió un valor verdadero&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More detailed information about Perl syntax can be found in L&lt;perlsyn&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224800Z" changeid="explorer">
        <seg>Encontrará información más detallada sobre la sintaxis de Perl en L&lt;perlsyn&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#...                        # print stuff to output</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#...                        # imprimir a la salida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't use slash as a delimiter when your regexp has slashes or backslashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No use barras inclinadas como delimitador cuando en su expresión regular tenga barras o contrabarras inclinadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But by saying</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero al decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variables are scoped to the block
(i.e. a bunch of statements surrounded by curly-braces) in which they
are defined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225044Z" changeid="explorer">
        <seg>El ámbito de las variables es el bloque (conjunto de instrucciones entre llaves) en el que se definen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,25, 1) = 1   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,25, 1) = 1   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the traditional way</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># la manera tradicional</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;%&quot; is the modulo operator, which computes the division
remainder of its first argument with respect to its second argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;%&quot; es el operador módulo, que calcula el resto de la división de su primer argumento con respecto a su segundo argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlref&gt;, L&lt;perlsub&gt;,
and L&lt;perlmod/&quot;Symbol Tables&quot;&gt; for more discussion on typeglobs and
the C&lt;*foo{THING}&gt; syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlref&gt;, L&lt;perlsub&gt; y L&lt;perlmod/&quot;Tablas de símbolos&quot;&gt; para una mayor discusión sobre typeglobs y la sintaxis &lt;C*foo{COSA}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This permits more
elaborate exception handling using objects that maintain arbitrary state
about the exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto permite un manejo de las excepciones más elaborado que usando objetos que mantengan un estado arbitrario sobre la naturaleza de la excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;~&quot; performs bitwise negation, i.e., 1's complement.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unario &quot;~&quot; realiza la negación bit a bit, es decir, el complemento a uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On FreeBSD the full path of the perl interpreter is found by reading
the symlink F&lt;/proc/curproc/file&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En FreeBSD el camino completo del intérprete perl se encuentra leyendo el enlace simbólico F&lt;/proc/curproc/file&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
I&lt;need&gt; to use literal backslashes within C&lt;\Q...\E&gt;,
consult L&lt;perlop/&quot;Gory details of parsing quoted constructs&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si I&lt;necesita&gt; usar contrabarras literales dentro de C&lt;\Q...\E&gt;,
consulte L&lt;perlop/&quot;Detalles sangrientos del análisis de las construcciones entrecomilladas&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.freebsd - Perl version 5 on FreeBSD systems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.freebsd - Perl versión 5 sobre sistemas FreeBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item stat DIRHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item stat GESTOR_DIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &quot;'&quot; is used as the delimiter, no interpolation
is done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se usa &quot;'&quot; como delimitador, no se realiza ninguna interpolación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@tmp = split;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@tmp = split;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 64  == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 64  == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use if $] &lt; 5.008, &quot;utf8&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use if $] &lt; 5.008, &quot;utf8&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a binary version of
perl available from L&lt;http://www.cp15.org/perl/&gt; which you may wish to
use instead of trying to compile it yourself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay una versión binaria de perl disponible en L&lt;http://www.cp15.org/perl/&gt; que es posible que desee utilizar en lugar de tratar de compilarlo usted mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 9.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.6d&gt;', 1;      # prints &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.6d&gt;', 1;      # imprime &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ord</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item ord</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See L&lt;perlsyn/&quot;Compound Statements&quot;&gt;.)
X&lt;$+&gt; X&lt;$^N&gt; X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;
X&lt;$1&gt; X&lt;$2&gt; X&lt;$3&gt; X&lt;$4&gt; X&lt;$5&gt; X&lt;$6&gt; X&lt;$7&gt; X&lt;$8&gt; X&lt;$9&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230433Z" changeid="explorer">
        <seg>(Véase L&lt;perlsyn/&quot;Instrucciones compuestas&quot;&gt;.)
X&lt;$+&gt; X&lt;$^N&gt; X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;
X&lt;$1&gt; X&lt;$2&gt; X&lt;$3&gt; X&lt;$4&gt; X&lt;$5&gt; X&lt;$6&gt; X&lt;$7&gt; X&lt;$8&gt; X&lt;$9&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second version didn't;
it tried to run a program named I&lt;&quot;echo surprise&quot;&gt;, didn't find it, and set
C&lt;$?&gt; to a non-zero value indicating failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La segunda versión no; intentó ejecutar un programa llamado literalmente I&lt;&quot;echo sorpresa&quot;&gt;, no lo encontró, y puso C&lt;$?&gt; a un valor distinto de cero para indicar un fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lengthening
an array that was previously shortened does not recover values
that were in those elements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alargar un array que ha sido acortado previamente no permite recuperar los valores que había en esos elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$sec&gt;, C&lt;$min&gt;, and C&lt;$hour&gt; are the seconds, minutes, and hours
of the specified time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$seg, $min y $hora son los segundos, minutos y horas del tiempo especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the variable
is preceded with the keyword C&lt;my&gt;, then it is lexically scoped, and
is therefore visible only within the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la variable es precedida por el identificador C&lt;my&gt;, entonces su ámbito es léxicamente local y por eso es visible sólo dentro del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp; 127) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp; 127) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwuid UID</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getpwuid UID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally used in a C&lt;continue&gt; block at the end of a loop to clear
variables and reset C&lt;??&gt; searches so that they work again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Generalmente se usa en un bloque C&lt;continue&gt;, al final de un bucle para limpiar variables y reinicializar las búsquedas C&lt;??&gt;, para que funcionen de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that parentheses are necessary when you're chomping anything
that is not a simple variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota que los paréntesis son necesarios cuando esté recortando cualquier cosa que no sea una simple variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;   greater than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&gt;   mayor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its argument will be taken
from the next line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su argumento se tomará de la línea siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $1 while /(o)/gc; print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $1 while /(o)/gc; print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The possible values and flag bits of the MODE parameter are
system-dependent; they are available via the standard module C&lt;Fcntl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores posibles y bits de bandera del parámetro MODO son dependientes del sistema; están disponibles en el módulo estándar C&lt;Fcntl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deletes a list of files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elimina una lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 8.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lack of processing of C&lt;\\&gt; creates specific restrictions on
the post-processed text.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La falta de tratamiento de C&lt;\\&gt; crea restricciones específicas en el pos-procesado del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$	Match the end of the line (or before newline at the end)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$	Coincide con el final de línea (o antes del nuevo línea del final)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = gethostbyaddr($iaddr, AF_INET);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$name  = gethostbyaddr($iaddr, AF_INET);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open FILEHANDLE,MODE,REFERENCE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211702Z" changeid="explorer">
        <seg>=item open GESTOR_ARCHIVO,MODO,REFERENCIA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($filename) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($nombrearchivo) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>banana =&gt; &quot;yellow&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234410Z" changeid="zipf">
        <seg>plátano =&gt; &quot;amarillo&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$tY = sprintf(&quot;%.${POINTS}g&quot;, $Y);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$tY = sprintf(&quot;%.${PUNTOS}g&quot;, $Y);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A group may
take a repeat count either as postfix, or for unpack(), also via the C&lt;/&gt;
template character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un grupo puede tener un contador de repeticiones, ya sea de forma postfija, o para unpack(), también a través del carácter de plantilla C&lt;/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^-D(.*)/) { $debug = $1 }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^-D(.*)/) { $debug = $1 }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $ARRAY[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $ARRAY[$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item UNIVERSAL</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item UNIVERSAL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item cos EXPR
X&lt;cos&gt; X&lt;cosine&gt; X&lt;acos&gt; X&lt;arccosine&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170356Z" changeid="explorer">
        <seg>=item cos EXPR
X&lt;cos&gt; X&lt;cosine&gt; X&lt;acos&gt; X&lt;arccosine&gt; X&lt;coseno&gt; X&lt;arco coseno&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you have to
roll yourself a loop or two.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193431Z" changeid="explorer">
        <seg>En su lugar, tiene que hacer un bucle o dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11623</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11623</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-------------------------------------------------------------------------</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-------------------------------------------------------------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that functions such as C&lt;keys&gt; and C&lt;values&gt; may return huge lists
when used on large objects, like DBM files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que las funciones como C&lt;keys&gt; y C&lt;values&gt; pueden devolver largas listas como cuando se usan con grandes archivos DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 2) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 2) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regex   Hash      hash key grep            grep /$a/, keys %$b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Regex       Hash       grep clave hash                  grep /$a/, keys %$b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@list = (2.18 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@lista = (2.18 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shift ARRAY
X&lt;shift&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200557Z" changeid="explorer">
        <seg>=item shift ARRAY
X&lt;shift&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/&quot;(?:[^&quot;\\]++|\\.)*+&quot;/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/&quot;(?:[^&quot;\\]++|\\.)*+&quot;/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments start with a hash symbol and run to the end of the line</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224730Z" changeid="explorer">
        <seg>Los comentarios comienzan con un símbolo # y van hasta el final de la línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes various features of FreeBSD that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documentos describe varias características de FreeBSD que afectarán a cómo Perl versión 5 (de ahora en adelante sólo Perl) es compilado y/o ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a = $b) or $c;		# really means this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a = $b) or $c;		# en realidad significa esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most platforms store
signed integers in two's-complement notation, so usually this is not an issue.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de las plataformas almacenan enteros con signo en notación de complemento a dos, así que por lo general esto no es ningún problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're using strict, you I&lt;must not&gt; declare $a
and $b as lexicals.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201055Z" changeid="explorer">
        <seg>Si está usando strict, I&lt;no debe&gt; declarar $a y $b como léxicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is a general-purpose programming language originally developed for
text manipulation and now used for a wide range of tasks including
system administration, web development, network programming, GUI
development, and more.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224606Z" changeid="explorer">
        <seg>Perl es un lenguaje de programación de propósito general desarrollado originalmente para la manipulación de texto y que, en la actualidad, se usa para una amplia gama de tareas, como administración de sistemas, desarrollo web, programación de red, desarrollo de interfaces gráficas de usuario, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (my $i = 0; $i &lt; @ary1; $i++) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (my $i = 0; $i &lt; @array1; $i++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use sigtrap  qw(SEGV BUS);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use sigtrap  qw(SEGV BUS);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In non-Unix environments, the functionality of some
Unix system calls may not be available, or details of the available
functionality may differ slightly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En entornos no Unix, la funcionalidad de algunas llamadas del sistema Unix pueden no estar disponibles, o los detalles de la funcionalidad disponible diferir ligeramente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bar = q('This is it.');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bar = q('Así es.');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more detail on looping constructs (and some that weren't mentioned in
this overview) see L&lt;perlsyn&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225206Z" changeid="explorer">
        <seg>Para obtener más información sobre las estructuras de bucle (y otras estructuras que no se han mencionado en esta introducción), consulte L&lt;perlsyn&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always use the two-argument
version if a derived class might inherit the function doing the blessing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre usar la versión de dos argumentos si una clase derivada puede heredar la función con un nuevo bautizo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir +($foo) || die;	# (chdir $foo) || die</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir +($foo) || die;	# (chdir $foo) || die</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The terminator of this construct is found using the same rules as
for finding the terminator of a C&lt;{}&gt;-delimited construct, the only
exception being that C&lt;]&gt; immediately following C&lt;[&gt; is treated as
though preceded by a backslash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El terminador de esta construcción es encontrado usando las mismas reglas que para encontrar el terminador de la construcción delimitada por llaves, C&lt;{}&gt;, con la única excepción de que C&lt;]&gt; inmediatamente después de un C&lt;[&gt; es tratado como si estuviera precedido por una barra invertida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp;  and</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232642Z" changeid="explorer">
        <seg>&amp;&amp;  and</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;True\n&quot;      if $array[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Verdadero\n&quot;   if $array[$index];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment to a list (or slice, which is just a list
anyway) also evaluates the righthand side in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La asignación a una lista (o a una porción, que también es una lista después de todo) también evalúa el lado derecho en contexto de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@days[3..5]    = qw/Wed Thu Fri/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@dias[3..5]    = qw/Mié Jue Vie/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Determination of whether $BSD_STYLE should be set
is left as an exercise to the reader.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La determinación de cómo poner $BSD_STYLE se deja como ejercicio al lector.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Perl will no longer be part of &quot;base FreeBSD&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Perl ya no formará parte de la &quot;base FreeBSD&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11643</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11643</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># more flexible:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234651Z" changeid="explorer">
        <seg># más flexible:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For certain applications, the catch and throw pair of
C&lt;eval{}&gt; and die() for exception processing can also be a prudent approach.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ciertas aplicaciones, la pareja C&lt;eval{}&gt; y C&lt;die()&gt; puede ser un prudente planteamiento para el procesamiento de excepciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that some versions of C&lt;flock&gt; cannot lock things over the
network; you would need to use the more system-specific C&lt;fcntl&gt; for
that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note también que algunas versiones de C&lt;flock&gt; no pueden bloquear cosas sobre la red; necesitará usar un C&lt;fcntl&gt; más específico del sistema para hacer esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On many Unix systems fdopen() fails when file descriptors exceed a
certain value, typically 255.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En muchos sistemas Unix fdopen() falla cuando los descriptores de archivo exceden de un valor determinado, por lo general 255.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to list some (not all may be available simultaneously), or it may
be read I&lt;as is&gt;: as F&lt;README.dgux&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>por listar algunos (no todos pueden estar disponibles simultáneamente), o puede ser leído I&lt;tal cual&gt;: como F&lt;README.dgux&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will print the sorted contents of the file &quot;blam&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>imprimirá el contenido ordenado del archivo &quot;Blam&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After preprocessing
described above, and possibly after evaluation if concatenation,
joining, casing translation, or metaquoting are involved, the
resulting I&lt;string&gt; is passed to the RE engine for compilation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Después del proceso previo descrito anteriormente, y posiblemente después de la evaluación si la concatenación, unión, traducción de tamaño de caja, o metaentrecomillado están involucrados, el I&lt;string&gt; resultante es pasado al motor de RE para su compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array grows or shrinks as necessary.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El array crece o se reduce según sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># The following are compatibility aliases for S_IRUSR, S_IWUSR, S_IXUSR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Los siguientes son los alias de compatibilidad para S_IRUSR, S_IWUSR, S_IXUSR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An OFFSET may be specified to write the data from some part of the
string other than the beginning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DESPLAZAMIENTO puede ser especificado para escribir datos desde algún otro lugar de la cadena distinto del principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;until&gt; statement executes the block as long as the expression is
false.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013352Z" changeid="explorer">
        <seg>La instrucción C&lt;until&gt; ejecuta el bloque mientras la expresión sea falsa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words,
names beginning with $ or @, followed by an optional bracketed
expression as a subscript.)  The following code segment prints out &quot;The
price is $Z&lt;&gt;100.&quot;
X&lt;interpolation&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En otras palabras, nombres que empiezan con $ o @, seguido de una opcional expresión entre corchetes como si fuera un subíndice). El segmento de código siguiente imprime &quot;El precio es $Z&lt;&gt;100&quot;.
X &lt;interpolation&gt; X&lt;interpolación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11656</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11656</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each programmer will, of course, have his or her own preferences in
regards to formatting, but there are some general guidelines that will
make your programs easier to read, understand, and maintain.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada programador tendrá, naturalmente, sus propias preferencias con respecto al estilo, pero hay algunas directrices que harán sus programas más fáciles de leer, entender y mantener.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;ne&quot; returns true if the left argument is stringwise not equal
to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;ne&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente distinto que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can replace a numeric repeat count with a template letter enclosed in
brackets to use the packed byte length of the bracketed template for the
repeat count.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede reemplazar un número de repeticiones con una plantilla de letras encerrada entre corchetes para utilizar la longitud en bytes empaquetada de la plantilla entre corchetes para indicar ese número de repeticiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;LA LA LA\n&quot; while 1;          # loops forever</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;LA LA LA\n&quot; while 1;          # bucle sin fin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in scalar context the operator returns
the next value each time it's called, or C&lt;undef&gt; when the list has
run out.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, en contexto escalar el operador devuelve el siguiente valor cada vez que se le llama, o C&lt;undef&gt; cuando la lista se ha agotado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VMS: waitpid enhancements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VMS: mejoras en waitpid</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty -echo&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty -echo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	named unary operators</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	operadores unarios nombrados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support fchmod(2), passing filehandles raises
an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que no admiten fchmod(2), pasarle un gestor de archivo lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $x * $x;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $x * $x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require Foo::Bar;     # a splendid bareword</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require Foo::Bar;     # algo atractivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
the operand is an identifier, a string consisting of a minus sign
concatenated with the identifier is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el operando es un identificador, es devuelta una cadena formada por un signo menos concatenado con el identificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Declarations
X&lt;declaration&gt; X&lt;undef&gt; X&lt;undefined&gt; X&lt;uninitialized&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040757Z" changeid="explorer">
        <seg>=head2 Declaraciones
X&lt;declaration&gt; X&lt;undef&gt; X&lt;undefined&gt; X&lt;uninitialized&gt; X&lt;declaración&gt; X&lt;indefinido&gt; X&lt;no inicializado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The BLOCK construct can be used to emulate case structures.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La construcción BLOQUE puede ser usada para emular estructuras I&lt;switch&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;|tr '[a-z]' '[A-Z]'&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, &quot;|tr '[a-z]' '[A-Z]'&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing only one of the first two elements as C&lt;undef&gt; is
equivalent to passing a 0 and will not have the effect 
described when both are C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pasando solo uno de los dos primeros elementos como C&lt;undef&gt; es equivalente a pasar un 0 y no tendrá el efecto descrito cuando ambos son C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!open(FOO)) { die &quot;Can't open $FOO: $!&quot;; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (!open(FOO)) { die &quot;No puedo abrir $FOO: $!&quot;; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shutdown(SOCKET, 2);    # I/we have stopped using this socket</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shutdown(SOCKET, 2);    # Hemos dejado de usar el socket</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($login,$pass,$uid,$gid) = getpwnam($user)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($login,$pass,$uid,$gid) = getpwnam($usuario)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;Z&gt; always packs a trailing null, except
for when the count is 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto C&lt;Z&gt; siempre empaqueta un valor nulo a continuación, excepto cuando el contador es 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($ary1[$i] &gt; $ary2[$j]) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($ary1[$i] &gt; $ary2[$j]) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item select FILEHANDLE
X&lt;select&gt; X&lt;filehandle, default&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200404Z" changeid="explorer">
        <seg>=item select GESTOR_ARCHIVO
X&lt;select&gt; X&lt;filehandle, default&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some Unixes, select(2) may report a socket file
descriptor as &quot;ready for reading&quot; when no data is available, and
thus a subsequent read blocks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas Unix, select(2) puede informar de un descriptor de archivo socket como &quot;listo para leer&quot; cuando no hay datos disponibles, y por lo tanto una lectura posterior produce un bloqueo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fcntl($filehandle, F_GETFL, $packed_return_buffer)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>fcntl($gestor, F_GETFL, $buffer_retorno_empaquetado)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is undefined, returns C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es indefinido, devuelve C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make -f Makefile.micro</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make -f Makefile.micro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other Perl books from various publishers and authors 
can be found listed in L&lt;perlfaq2&gt; or on the web at
L&lt;http://books.perl.org/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T233750Z" changeid="explorer">
        <seg>Otros libros sobre Perl de otras editoriales y autores pueden encontrarse en L&lt;perlfaq2&gt; o en la web L&lt;http://books.perl.org/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, because we didn't
C&lt;chdir&gt; there, it would have been testing the wrong file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, porque no hicimos un C&lt;chdir&gt; antes, se estará probando en un archivo incorrecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select(undef, undef, undef, 0.25);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select(undef, undef, undef, 0.25);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What is Perl?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 ¿Qué es Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try &quot;/hurd/pfinet --help&quot; for more
information.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intente &quot;/hurd/pfinet --help&quot; para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Win32: non-blocking waitpid(-1,WNOHANG)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Win32: waitpid(-1,WNOHANG) no bloqueante</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} []gsx;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} []gsx;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl was born in Unix and can therefore access all common Unix
system calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl nació en Unix y por eso puede acceder a todas las llamadas normales del sistema Unix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%010.6d&gt;', 1;   # prints &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%010.6d&gt;', 1;   # imprime &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;wantarray()&gt;'s result is unspecified in the top level of a file,
in a C&lt;BEGIN&gt;, C&lt;UNITCHECK&gt;, C&lt;CHECK&gt;, C&lt;INIT&gt; or C&lt;END&gt; block, or
in a C&lt;DESTROY&gt; method.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resultado de C&lt;wantarray()&gt; no está especificado en el nivel superior de un archivo, en un C&lt;BEGIN&gt;, C&lt;UNITCHECK&gt;, C&lt;CHECK&gt;, C&lt;INIT&gt; o bloque C&lt;END&gt;, o en un método C&lt;DESTROY&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your
integer arguments are not literals and have never been interpreted in a
numeric context, you may need to add C&lt;0&gt; to them to force them to look
like numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sus argumentos enteros no son enteros, y nunca han sido interpretados en un contexto numérico, es posible que deba agregarles C&lt;0&gt; para obligarles a que se parezcan a números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcommunity	Perl community information</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlcommunity	Información sobre la comunidad Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Has semantics similar to the following subroutine:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tiene una semántica similar a la subrutina siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = [ @tmp ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$i] = [ @tmp ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is a hash, it chops the hash's values, but not its keys.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE es un hash, recorta los valores del hash, pero no sus claves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;foreach&gt; keyword is actually a synonym for the C&lt;for&gt; keyword, so
you can use C&lt;foreach&gt; for readability or C&lt;for&gt; for brevity.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El identificador C&lt;foreach&gt; es realmente un sinónimo del identificador C&lt;for&gt;, así que puede usar C&lt;foreach&gt; por legibilidad o C&lt;for&gt; por brevedad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-       left-justify within the field</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-       justifica a la izquierda dentro del campo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These modifiers are especially useful 
given how C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt; and C&lt;V&gt; don't cover signed integers, 
64-bit integers, or floating-point values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos modificadores son especialmente útiles dado que C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt; y C&lt;V&gt; no cubren valores enteros con signo, enteros de 64 bits, o de punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$                   end of string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235535Z" changeid="zipf">
        <seg>$                   final de una cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, several special variables that provide windows into
the inner working of Perl have names containing punctuation characters
and control characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, ciertas variables especiales que proporcionan acceso al medio interno de Perl tienen nombres que contienen caracteres de puntuación y caracteres de control.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt; &quot;abc\&quot;def&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt; &quot;abc\&quot;def&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FETCH this, key</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FETCH este, clave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl will not guarantee what the result of the above statements is.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012118Z" changeid="explorer">
        <seg>Perl no garantizará el resultado de las instrucciones anteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always returns the
undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre devuelve el valor indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This latter is useful for counting characters in a class or for
squashing character sequences in a class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto último es útil para el recuento de caracteres de una clase o para reducir las secuencias de caracteres de una clase.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, a comma terminates the argument of
a unary operator, but merely separates the arguments of a list
operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, una coma determina al argumento de un operador unario, pero sólo sirve de separación entre argumentos en un operador de listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>support for light-weight processes (threads)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T012132Z" changeid="explorer">
        <seg>apoyo a procesos ligeros (hilos)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;1,,3&gt; is C&lt;(1,),(3)&gt; is C&lt;1,3&gt; (And
similarly for C&lt;1,,,3&gt; is C&lt;(1,),(,),3&gt; is C&lt;1,3&gt; and so on.)  Not that
we'd advise you to use this obfuscation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;1,,3&gt; es C&lt;(1,),(3)&gt; es C&lt;1,3&gt; (y similarmente para C&lt;1,,,3&gt; es C&lt;(1,),(,),3&gt; es C&lt;1,3&gt; y así sucesivamente). No le aconsejamos usar este tipo de ofuscación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless (ref($r)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless (ref($r)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
the other end can't handle that, be sure to read all the data before
closing the pipe.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si en el otro extremo no puede manejar esto, asegúrese de leer todos los datos antes de cerrar la tubería.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you understand
this rule, you may skip the rest of this section on the first
reading.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted entiende esta regla, puede omitir la primera lectura del resto de esta sección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support fchdir(2),
passing handles raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que no admiten fchdir(2), pasarle un gestor lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\N{name}	named Unicode character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003044Z" changeid="explorer">
        <seg>\N{nombre}	car. Unicode denominado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the right side is either a C&lt;[...]&gt;, C&lt;{...}&gt;, or a
C&lt;(...)&gt; subscript, then the left side must be either a hard or
symbolic reference to an array, a hash, or a subroutine respectively.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el lado derecho es, o una C&lt;[...]&gt;, C&lt;{...}&gt;, o un subrango C&lt;(...)&gt;, entonces el lado izquierdo debe ser una referencia dura o simbólica a un array, un hash, o una subrutina, respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that we have the C&lt;*foo{THING}&gt; notation, typeglobs aren't used as much
for filehandle manipulations, although they're still needed to pass brand
new file and directory handles into or out of functions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005538Z" changeid="explorer">
        <seg>Ahora que tenemos la notación C&lt;*foo{COSA}&gt;, typeglobs no se utilizan tanto para la manipulación de gestores de archivo, aunque siguen siendo necesarios para pasar gestores de archivo y de directorio dentro o fuera de funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker,
a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque Perl 5.10 incluía la versión para Mac OS, ExtUtils::MakeMaker, una parte central de la instalación de infraestructura de módulos Perl oficialmente abandonó el soporte para Mac OS en abril de 2004.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: Once Perl sees that you need one of C&lt;$&amp;&gt;, C&lt;$`&gt;, or
C&lt;$'&gt; anywhere in the program, it has to provide them for every
pattern match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;ADVERTENCIA&gt;: Una vez que Perl considera que necesitas una de C&lt;$&amp;&gt;, C&lt;$`&gt;, o C&lt;$'&gt;, en cualquier parte del programa, las usará para todos los patrones de coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 List Operators (Rightward)
X&lt;operator, list, rightward&gt; X&lt;list operator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001712Z" changeid="explorer">
        <seg>=head2 Operadores de lista (por la derecha)
X&lt;operator, list, rightward&gt; X&lt;list operator&gt; X&lt;operador, lista, por la derecha&gt; X&lt;operador de lista&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;our&gt; associates a simple name with a package variable in the current
package for use within the current scope.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;our&gt; asocia un nombre sencillo con una variable de paquete en el paquete actual para ser usado en el ámbito actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following tests are known to fail as of Perl 5.005_03:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los siguientes test se sabe que fallan en 5.005_03:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>srand (time ^ $$ ^ unpack &quot;%L*&quot;, `ps axww | gzip -f`);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>srand (time ^ $$ ^ unpack &quot;%L*&quot;, `ps axww | gzip -f`);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is the same as</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es lo mismo que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$s = &quot;hi there\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$s = &quot;hola por aquí\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a % 2 ? $a += 10 : $a += 2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054114Z" changeid="explorer">
        <seg>$a % 2 ? $a += 10 : $a += 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unshift(@ARGV, '-e') unless $ARGV[0] =~ /^-/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unshift(@ARGV, '-e') unless $ARGV[0] =~ /^-/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SECONDS is not
specified, the value stored in C&lt;$_&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se ha especificado SEGUNDOS, se usará el valor almacenado en C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;~~&quot; does a smart match between its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;~~&quot; hace una coincidencia inteligente entre sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item uc</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item uc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point numbers are only approximations to what a mathematician
would call real numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Números de punto flotante son sólo aproximaciones a lo que un matemático llamaría a los números reales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scalar value is B&lt;not&gt; locale dependent but is a Perl builtin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este valor escalar B&lt;no&gt; es dependiente de la región, sino que viene de una función interna de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;chop&gt; returns the last character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;chop&gt; devuelve el último carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the output is empty and C&lt;$@&gt; already contains a value (typically from a
previous eval) that value is used after appending C&lt;&quot;\t...caught&quot;&gt;
to C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la salida está vacía y C&lt;$@&gt; ya contiene un valor (típicamente de un eval() anterior) este valor es utilizado después de añadirle C&lt;&quot;\t...caught&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means it actually
has both compile-time and run-time effects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que tiene efectos tanto en tiempo de compilación como en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/foo/bar/;               # replaces foo with bar in $_</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T030211Z" changeid="explorer">
        <seg>s/foo/bar/;               # reemplaza foo por bar en $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\d        [3]  Match a decimal digit character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223712Z" changeid="explorer">
        <seg>\d	 [3]  Coincide con un dígito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @colors = values %fruit_colors;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234512Z" changeid="zipf">
        <seg>my @colores = values %colores_fruta;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>remove Time::Piece</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eliminar Time::Piece</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is more than one argument in LIST,
or if LIST is an array with more than one value, starts the program
given by the first element of the list with arguments given by the
rest of the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay más de un argumento en LISTA, o si la lista es un array con más de un valor, se inicia el programa indicado en el primer elemento de la lista, con los argumentos indicados por el resto de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that on some systems, a return value of C&lt;-1&gt; could mean that child
processes are being automatically reaped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que en algunos sistemas, un valor devuelto de C&lt;-1&gt; podría significar que los procesos hijos se están automáticamente desechando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Note that the exact meaning of these is system dependent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Tenga en cuenta que el significado exacto de éstos depende del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is mainly an issue on 64-bit platforms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es sobre todo un problema en plataformas de 64-bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># search for some stuff and put it into files</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># buscar por algo y ponerlo en el archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POS
must be a value returned by C&lt;telldir&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>POS debe ser un valor devuelto por C&lt;telldir&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They check different things so you need both.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224708Z" changeid="explorer">
        <seg>Comprueban cosas distintas, por lo que ambas deben ser incluidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opens a socket of the specified kind and attaches it to filehandle
SOCKET.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Abre un socket de la clase especificada y lo adhiere al gestor de archivo SOCKET.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Even\n&quot; if ($x &amp; 1) == 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Par\n&quot; if ($x &amp; 1) == 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You can use C&lt;for my $_ (@array)&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Puede usar C&lt;for my $_ (@array)&gt;.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;:utf8&gt; just marks the data as UTF-8 without further checking,
while C&lt;:encoding(utf8)&gt; checks the data for actually being valid
UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;:utf8&gt; solo marca los datos como UTF-8 sin más comprobaciones ulteriores, mientras que C&lt;:encoding(utf8)&gt; comprueba que los datos sean UTF-8 válidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^$/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/^$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is only an illusion that the operating system,
device drivers, C libraries, and Perl all conspire to preserve.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es sólo una ilusión que el sistema operativo, controladores de dispositivo, bibliotecas de C, y Perl, conspiran para preservar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The socket tests may fail if the network is not configured.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El test de socket fallará si la red no está configurada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function places an advisory lock on a shared variable, or referenced
object contained in I&lt;THING&gt; until the lock goes out of scope.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función coloca un bloqueo sobre una variable compartida, o un objeto referenciado contenido en I&lt;COSA&gt; hasta que el bloqueo salga del ámbito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s	Squash duplicate replaced characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s	Elimina caracteres duplicados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%*2$s&gt;', &quot;a&quot;, 6; # prints &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%*2$s&gt;', &quot;a&quot;, 6; # imprime &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub bintodec {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub bintodec {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ARRAY = ();    # completely empty @ARRAY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ARRAY = ();    # vaciar completamente @ARRAY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl officially stands for Practical Extraction and Report Language,
except when it doesn't.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl, oficialmente, significa Lenguaje práctico para la extracción e informe (I&lt;Practical Extraction and Report Language&gt;), excepto cuando no hace eso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following equivalences hold (assuming C&lt;&lt; $[ == 0 and $#a &gt;= $i &gt;&gt; )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las siguientes equivalencias se mantienen (suponiendo que C&lt;&lt; $[ == 0 y $#a &gt;= $i &gt;&gt; )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some systems, you can avoid this by setting
C&lt;$SIG{CHLD}&gt; to C&lt;&quot;IGNORE&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas, puede evitar esto poniendo C&lt;$SIG{CHLD}&gt; a C&lt;&quot;IGNORE&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\f		form feed             (FF)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\f		avance de página      (FF)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hint: sometimes appending C&lt;&quot;, stopped&quot;&gt; to your message will cause it
to make better sense when the string C&lt;&quot;at foo line 123&quot;&gt; is appended.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consejo: algunas veces añadir C&lt;&quot;, parado&quot;&gt; a tu mensaje hará aparecerle con un sentido mejor cuando se le añada la cadena C&lt;&quot;at foo line 123&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>STORE this, value</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>STORE este, valor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($cwd = `pwd`);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($cwd = `pwd`);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opendir(D, $dir)	 or die &quot;can't opendir $dir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>opendir(D, $dir)	 or die &quot;no puedo hacer opendir $dir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, if the
PATTERN contains a $ that looks like a variable rather than an
end-of-string test, the variable will be interpolated into the pattern
at run-time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, si el PATRÓN contiene un $ que parece más una variable que una marca de fin de cadena, la variable será interpolada en el patrón, en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Small
changes in the PLAINTEXT or SALT will result in large changes in the
digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pequeños cambios en TEXTPLANO o SALTO resultarán en grandes cambios en el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>other array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042953Z" changeid="explorer">
        <seg>del otro array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @fruits = keys %fruit_colors;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025845Z" changeid="explorer">
        <seg>my @frutas  = keys %colores_fruta;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$field = $query-&gt;radio_group(
               name      =&gt; 'group_name',
               values    =&gt; ['eenie','meenie','minie'],
               default   =&gt; 'meenie',
               linebreak =&gt; 'true',
               labels    =&gt; \%labels</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043005Z" changeid="explorer">
        <seg>$field = $query-&gt;radio_group(
               name      =&gt; 'nombre_grupo',
               values    =&gt; ['eenie','meenie','minie'],
               default   =&gt; 'meenie',
               linebreak =&gt; 'true',
               labels    =&gt; \%etiquetas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;x&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;x&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>==  equality</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120408Z" changeid="zipf">
        <seg>==  igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub aeq {  # compare two list values</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub aeq {  # comparar dos listas de valores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values are usually referred to by name, or through a named reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A los valores se accede normalmente por su nombre, o a través de una referencia con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$home = $ENV{'HOME'} // $ENV{'LOGDIR'} //</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$home = $ENV{'HOME'} // $ENV{'LOGDIR'} //</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@hashes = map +{ lc($_) =&gt; 1 }, @array # EXPR, so needs comma at end</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@hashes = map +{ lc($_) =&gt; 1 }, @array # EXPR, por lo que necesita una coma al final</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlunifaq		Perl Unicode FAQ</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlunifaq		Unicode FAQ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, this has to
unwind one hash and build a whole new one, which may take some time
on a large hash, such as from a DBM file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, esto tiene el efecto de desmontar un hash y construir uno nuevo, algo que puede tardar algún tiempo en un hash grande, como en un archivo DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FORMAT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FORMAT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>alarm 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>alarm 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>regular expression enhancements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>mejoras en expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
on a Mac, these are reversed, and on systems without line terminator,
printing C&lt;&quot;\n&quot;&gt; may emit no actual data.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, en un Mac, estos se invierten, y en los sistemas sin terminador de línea, la impresión de C&lt;&quot;\n&quot;&gt; puede no emitir datos reales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the arctangent of Y/X in the range -PI to PI.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el arcotangente de Y/X en el rango -PI a PI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub myopen {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub miopen {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous assignments are exactly equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las asignaciones anteriores son exactamente iguales a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may otherwise modify your copy of this Package in any way, provided
that you insert a prominent notice in each changed file stating how and
when you changed that file, and provided that you do at least ONE of the
following:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004109Z" changeid="explorer">
        <seg>De lo contrario puede modificar su copia de este Paquete de cualquier manera, siempre que se inserte de forma visible en cada archivo cambiado, indicando cómo y cuándo se ha cambiado ese archivo, y siempre que usted haga por lo menos UNO de los puntos siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Bitwise And
X&lt;operator, bitwise, and&gt; X&lt;bitwise and&gt; X&lt;&amp;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235303Z" changeid="explorer">
        <seg>=head2 And binario
X&lt;operator, bitwise, and&gt; X&lt;bitwise and&gt; X&lt;&amp;&gt; X&lt;operador, binario, and&gt; X&lt;binario and&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but as you might well imagine, this is pretty rough on the reader.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194804Z" changeid="explorer">
        <seg>pero como se podrá imaginar, esto es bastante duro para el lector.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure &lt;gethostbyname()&gt; is called in SCALAR context and that
its return value is checked for definedness.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cerciorarse de que &lt;gethostbyname()&gt; es llamado en contexto ESCALAR y que se comprueba que su valor de retorno está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shutdown(Rdr, 1);        # no more writing for reader</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shutdown(Rdr, 1);        # no más escrituras para el lector</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = grep {!/^#/} @bar;    # weed out comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = grep {!/^#/} @bar;    # quitar los comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In the absence of an explicit C&lt;return&gt;, a subroutine, eval,
or do FILE automatically returns the value of the last expression
evaluated.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En ausencia de un C&lt;return&gt; explícito, una subrutina, eval, o do ARCHIVO, automáticamente devuelve el valor de la última expresión evaluada).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is a problem, you
can call C&lt;POSIX:_exit($status)&gt; to avoid END and destructor processing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si esto es un problema, puede llamar a C&lt;POSIX:_exit($estado)&gt; para saltar el procesado de END y de los destructores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you like you can force Perl to ignore your system's flock(2)
function, and so provide its own fcntl(2)-based emulation, by passing
the switch C&lt;-Ud_flock&gt; to the F&lt;Configure&gt; program when you configure
Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si le gusta la idea, puede forzar a Perl a ignorar la función del sistema flock(2) y proveer de su propia emulación basada en fcntl(2), pasando la opción C&lt;-Ud_flock&gt; al programa F&lt;Configure&gt; cuando configure la compilación de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlmod&gt;, L&lt;perlmodlib&gt;, and L&lt;perlmodinstall&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;perlmod&gt;, L&lt;perlmodlib&gt; y L&lt;perlmodinstall&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;&gt; is just a synonym for &lt;ARGV&gt;, which
is magical.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;&gt; es justo un sinónimo de &lt;ARGV&gt;, lo cual es mágico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@  Null-fill or truncate to absolute position, counted from the</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@  Relleno con nulos o truncar a una posición absoluta, contado desde el</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may prefer to use the
C&lt;each&gt; function to iterate over such.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede preferir usar la función C&lt;each&gt; para iterar sobre tales listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@array) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach (@array) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array   Array     arrays are comparable[2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Array       Array      arrays son comparables[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item if</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232630Z" changeid="explorer">
        <seg>=item if</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 4   ==          4 00100000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 4   ==          4 00100000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SPLICE this, offset, length, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SPLICE este, desplazamiento, longitud, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Version Strings
X&lt;version string&gt; X&lt;vstring&gt; X&lt;v-string&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035459Z" changeid="explorer">
        <seg>=head3 Cadenas de versión
X&lt;version string&gt; X&lt;vstring&gt; X&lt;v-string&gt; X&lt;cadena versión&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Assignment Operators
X&lt;assignment&gt; X&lt;operator, assignment&gt; X&lt;=&gt; X&lt;**=&gt; X&lt;+=&gt; X&lt;*=&gt; X&lt;&amp;=&gt;
X&lt;&lt;&lt; &lt;&lt;= &gt;&gt;&gt; X&lt;&amp;&amp;=&gt; X&lt;-=&gt; X&lt;/=&gt; X&lt;|=&gt; X&lt;&lt;&lt; &gt;&gt;= &gt;&gt;&gt; X&lt;||=&gt; X&lt;//=&gt; X&lt;.=&gt;
X&lt;%=&gt; X&lt;^=&gt; X&lt;x=&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001252Z" changeid="explorer">
        <seg>=head2 Operadores de asignación
X&lt;assignment&gt; X&lt;operator, assignment&gt; X&lt;=&gt; X&lt;**=&gt; X&lt;+=&gt; X&lt;*=&gt; X&lt;&amp;=&gt;
X&lt;&lt;&lt; &lt;&lt;= &gt;&gt;&gt; X&lt;&amp;&amp;=&gt; X&lt;-=&gt; X&lt;/=&gt; X&lt;|=&gt; X&lt;&lt;&lt; &gt;&gt;= &gt;&gt;&gt; X&lt;||=&gt; X&lt;//=&gt; X&lt;.=&gt;
X&lt;%=&gt; X&lt;^=&gt; X&lt;x=&gt; X&lt;asignación&gt; X&lt;operador, asignación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endhostent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endhostent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll probably have to say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Probablemente escribirá</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># sort numerically ascending</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ordenación numérica ascendente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $key, ' = ', unpack('L',$val), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $clave, ' = ', unpack('L',$valor), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step is the last one for all constructs except regular expressions,
which are processed further.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este paso es el último para todas las construcciones, salvo las expresiones regulares, que son procesadas ulteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq3		Programming Tools</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq3		Herramientas de programación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;SelfLoader&gt; for more description of __DATA__, and
an example of its use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;Autocargador&gt; para una mayor descripción de __DATA__, y ejemplos de su uso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact meaning of the $gcos field varies but it usually contains
the real name of the user (as opposed to the login name) and other
information pertaining to the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El significado exacto del campo $gcos varía pero usualmente contiene el nombre real del usuario (como opuesto al nombre de login) y otra información perteneciente al usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open STDOUT, '&gt;', \$variable or die &quot;Can't open STDOUT: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open STDOUT, '&gt;', \$variable or die &quot;No puedo abrir STDOUT: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means for example that C&lt;$version{2.0}++&gt; is
equivalent to C&lt;$version{2}++&gt;, not to C&lt;$version{'2.0'}++&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035440Z" changeid="explorer">
        <seg>Esto significa, por ejemplo, que C&lt;$version{2.0}++&gt; es equivalente a C&lt;$version{2}++&gt;, no a C&lt;$version{'2.0'}++&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmodlib		Perl modules: how to write and use</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmodlib		Módulos Perl: cómo escribir y usar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, for an C&lt;eval BLOCK&gt; statement,
$subroutine is C&lt;(eval)&gt;, but $evaltext is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012324Z" changeid="explorer">
        <seg>En particular, para una instrucción C&lt;eval BLOQUE&gt;, $subrutina es C&lt;(eval)&gt;, pero $evaltext es indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For delays of finer granularity than one second, the Time::HiRes module
(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides ualarm().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para lapsos de tiempo inferiores a un segundo, el módulo Time::HiRes (en CPAN, y desde Perl 5.8 parte de la distribución estándar) ofrece ualarm().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment operators work as in C.  That is,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operadores de asignación funcionan como en C. Es decir,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That method may be best because otherwise you won't treat IEEE
notations like C&lt;NaN&gt; or C&lt;Infinity&gt; properly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este método podría ser mejor porque de otro modo no podría tratar notaciones IEEE como C&lt;Nan&gt; o C&lt;Infinity&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same as map assignment above</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># la misma asignación que la anterior con map</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl
bug database at http://bugs.perl.org.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted encuentra algo que piensa que es un error, podría verificar los artículos publicados recientemente en el grupo de noticias comp.lang.perl.misc y la base de datos de errores de perl en http://bugs.perl.org/.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;redo&gt; command restarts the loop block without evaluating the
conditional again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;redo&gt; reinicia la iteración sin evaluar de nuevo la condición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can put a C&lt;'+'&gt; in front of the C&lt;&lt; '&gt;' &gt;&gt; or C&lt;&lt; '&lt;' &gt;&gt; to
indicate that you want both read and write access to the file; thus
C&lt;&lt; '+&lt;' &gt;&gt; is almost always preferred for read/write updates--the 
C&lt;&lt; '+&gt;' &gt;&gt; mode would clobber the file first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede poner un C&lt;'+'&gt; en frente de C&lt;&lt; '&gt;' &gt;&gt; o C&lt;&lt; '&lt;' &gt;&gt; para indicar que desea tanto acceder al archivo en lectura como en escritura; C&lt;&lt; '+&lt;' &gt;&gt; casi siempre es lo preferido para la lectura/escritura de actualizaciones -el modo C&lt;&lt; '+&gt;' &gt;&gt; primero borraría el archivo-.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $expire
field, if present, encodes the expiration period of the account or the
password.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El campo $expira, si está presente, codifica el periodo de expiración de la cuenta o de la contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = $b or $c;		# bug: this is wrong</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a = $b or $c;		# error: esto está mal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When N is a positive integer the C&lt;\g{N}&gt; notation is
exactly equivalent to using normal backreferences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando N es un entero positivo la notación C&lt;\g{N}&gt; es exactamente equivalente a la utilización de contrareferencias normales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please report any errors, updates, or suggestions to F&lt;perlbug@perl.org&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por favor, informe de cualquier error, actualización o sugerencias a  F&lt;perlbug@perl.org&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By
default, empty leading fields are preserved, and empty trailing ones are
deleted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto, los campos vacíos precedentes son preservados, y los campos vacíos consecuentes son eliminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Install</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Instalación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eof FILEHANDLE
X&lt;eof&gt;
X&lt;end of file&gt;
X&lt;end-of-file&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211346Z" changeid="explorer">
        <seg>=item eof GESTOR_ARCHIVO
X&lt;eof&gt; X&lt;end of file&gt; X&lt;end-of-file&gt; X&lt;fin de archivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>otherwise it's necessary to protect any leading and trailing whitespace:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>de lo contrario es necesario proteger los espacios en blanco iniciales y finales:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the constructs except here-docs, single characters are used as starting
and ending delimiters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las construcciones, salvo los documentos incrustados, caracteres simples son utilizados como delimitadores de inicio y finalización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\	Quote the next metacharacter</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\	Escapa al siguiente metacarácter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do B&lt;not&gt; call srand() (i.e., without an argument) more than once per
process.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201445Z" changeid="explorer">
        <seg>B&lt;No&gt; llame a srand() (e.d., sin un argumento) más de una vez por proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = $ok ? $b : $c;  # get a scalar</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053840Z" changeid="explorer">
        <seg>$a = $ok ? $b : $c;  # obtiene un escalar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 4) = 8   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 4) = 8   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shmread() taints the variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shmread() contamina a la variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or the opposite of a C&lt;push&gt;,
depending on how you look at it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>O lo contrario de un C&lt;push&gt;, dependiendo de cómo se mire.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Quads are available only if your system supports 64-bit</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Cuádruplos están disponibles solo si su sistema soporta valores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lc</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item lc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may include dynamically
looking back your call-stack at run time to find the LABEL.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto puede incluir el analizar la pila de llamadas, de forma dinámica, en tiempo real, para encontrar la ETIQUETA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {$a &lt;=&gt; $b} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {$a &lt;=&gt; $b} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the Copyright Holder may not be used to endorse or promote
products derived from this software without specific prior written permission.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El nombre del Titular del Copyright no puede utilizarse para apoyar o promocionar productos derivados de este software sin previo consentimiento escrito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	or xor</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	or xor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also put
directly the path to your perl executable, like in C&lt;#!/usr/bin/perl&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224652Z" changeid="explorer">
        <seg>También puede especificar directamente la ruta de acceso a su ejecutable perl: C&lt;#!/usr/bin/perl&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its exact
           size depends on what a local C compiler calls 'int'.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su tamaño exacto depende de lo que un compilador C local llama 'int').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item continue</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item continue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 ACKNOWLEDGEMENTS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T171351Z" changeid="zipf">
        <seg>=head1 AGRADECIMIENTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[This function has been largely superseded by the C&lt;tie&gt; function.]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[Esta función ha sido largamente supeditada por la función C&lt;tie&gt;].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $tX eq $tY;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return $tX eq $tY;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort(find_records @key);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort(busca_registros @claves);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^$/);  # skip header lines, short for
                               #   next LINE if ($.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053549Z" changeid="explorer">
        <seg>/^$/);  # salta las líneas de cabecera, resumen de
                               #   next LINEA if ($.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print @ary;		# prints 1324</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print @ary;		# imprime 1324</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;STRING&gt; is interpolated the same way as I&lt;PATTERN&gt;
in C&lt;m/PATTERN/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003412Z" changeid="explorer">
        <seg>I&lt;CADENA&gt; es interpolada de la misma manera que I&lt;PATRÓN&gt; en C&lt;m/PATRÓN/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the C&lt;break&gt; keyword to break out of the enclosing
C&lt;given&gt; block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar el identificador C&lt;break&gt; para salir del bloque C&lt;given&gt; actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Because
backticks always undergo shell expansion as well, see L&lt;perlsec&gt; for
security concerns.)
X&lt;qx&gt; X&lt;`&gt; X&lt;``&gt; X&lt;backtick&gt; X&lt;glob&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Debido a que las comillas invertidas siempre provocan una expansión a nivel de shell, vea someterse a expansión de la shell, véase L&lt;perlsec&gt; por motivos de seguridad). X&lt;qx&gt; X&lt;`&gt; X&lt;``&gt; X&lt;backtick&gt; X&lt;glob&gt; X&lt;comilla invertida&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$count = ($paragraph =~ s/Mister\b/Mr./g);  # get change-count</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$contador = ($parrafo =~ s/Señor\b/Sr./g);  # obtener el número de cambios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 ctime    inode change time in seconds since the epoch (*)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>10 ctime    tiempo cambio inodo, en segundos desde el (*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(?&lt;char&gt;.)\k&lt;char&gt;/            # ... a different way
         and print &quot;'$+{char}' is the first doubled character\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230234Z" changeid="explorer">
        <seg>/(?&lt;car&gt;.)\k&lt;car&gt;/              # ... de otra forma
         and print &quot;'$+{car}' es el primer carácter repetido\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;\1\0\2\0&quot; on little-endian</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># &quot;\1\0\2\0&quot; en little-endian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;next&gt; cannot be used to exit a block which returns a value such as
C&lt;eval {}&gt;, C&lt;sub {}&gt; or C&lt;do {}&gt;, and should not be used to exit
a grep() or map() operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;next&gt; no se puede utilizar para salir de un bloque que devuelve un valor, como en C&lt;eval {}&gt;, C&lt;sub {}&gt; o C&lt;do {}&gt;, y no debe ser utilizado para salir de una operación grep() o map().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because unlike C, in perl you can't freely
interchange arrays and references thereto.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Eso es porque, a diferencia de C, en perl no puede intercambiar libremente los array y referencias a ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;lt&quot;, &quot;le&quot;, &quot;ge&quot;, &quot;gt&quot; and &quot;cmp&quot; use the collation (sort) order specified
by the current locale if C&lt;use locale&gt; is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;lt&quot;, &quot;le&quot;, &quot;ge&quot;, &quot;gt&quot; y &quot;cmp&quot; usan el orden de intercalación (sort) especificado por la configuración regional actual si C&lt;use locale&gt; está en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc/&quot;Safe Pipe Opens&quot;&gt; for more examples of this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc/&quot;Aperturas seguras de tuberías&quot;&gt; para más ejemplos sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since v5.8.0, Perl has built using PerlIO by default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde v5.8.0, Perl ha sido construido para que use PerlIO por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See
C&lt;open&gt;.)  However, an explicit C&lt;close&gt; on an input file resets the line
counter (C&lt;$.&gt;), while the implicit close done by C&lt;open&gt; does not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver C&lt;open&gt;). Sin embargo, un C&lt;close&gt; explícito en un archivo de entrada reinicia el contador de líneas (C&lt;$.&gt;), mientras que un C&lt;close&gt; implícito hecho por C&lt;open&gt;, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To (re)open C&lt;STDOUT&gt; or C&lt;STDERR&gt; as an in-memory file, close it first:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para (re)abrir C&lt;STDOUT&gt; o C&lt;STDERR&gt; como un archivo en memoria, primero, cierrelos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($in_header) {
            # do something</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053649Z" changeid="explorer">
        <seg>if ($en_cabecera) {
            # hacer algo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>J   A Perl internal unsigned integer value (UV).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>J   Un valor Perl interno entero sin signo (UV).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the left operand is true, the range operator stays true until the
right operand is true, I&lt;AFTER&gt; which the range operator becomes false
again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una vez que el operando izquierdo sea verdadero, el operador rango se mantiene así hasta que el operando de la derecha sea verdadero, I&lt;DESPUÉS&gt; de lo cual, el operador rango se vuelve falso de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$num = $cost/$quantity;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$num = $cost/$quantity;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a cheap and nasty way to break an email address up into parts</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120852Z" changeid="zipf">
        <seg># manera rápida de descomponer una dirección de correo electrónico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
instance the above example could also be written as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, el ejemplo anterior también se podría escribir de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn't become false till the next time the range operator
is evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se vuelve falso hasta la próxima vez que el operador rango es evaluado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;True\n&quot;      if $hash{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Verdadero\n&quot;   if $hash{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;||&quot; performs a short-circuit logical OR operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;||&quot; realiza una operación lógica OR abreviada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readline
X&lt;readline&gt; X&lt;gets&gt; X&lt;fgets&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194429Z" changeid="explorer">
        <seg>=item readline
X&lt;readline&gt; X&lt;gets&gt; X&lt;fgets&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare L&lt;/values&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compare con L&lt;/values&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open memory file: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir el archivo en memoria: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$hinthash&gt; is a reference to a hash containing the value of C&lt;%^H&gt; when the
caller was compiled, or C&lt;undef&gt; if C&lt;%^H&gt; was empty.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$hinthash&gt; es una referencia a un hash conteniendo el valor de C&lt;%^H&gt; cuando el llamante ha sido compilado, o C&lt;undef&gt; si C&lt;%^H&gt; estaba vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could, for example, group binary
digits by threes (as for a Unix-style mode argument such as 0b110_100_100)
or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Podría, por ejemplo, agrupar los dígitos binarios en grupos de tres en tres (como si fuera, al estilo Unix, de un argumento de modo, como en 0b110_100_100) o de cuatro en cuatro (para representar nibbles, como en 0b1010_0110) o en otros grupos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\bgreen\b/mauve/g;		# don't change wintergreen</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/\bverde\b/malva/g;                # no cambia verdeazul</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REF</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>REF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;The LAYER parameter of the binmode() function is described as &quot;DISCIPLINE&quot;
in &quot;Programming Perl, 3rd Edition&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>I&lt;El parámetro CAPA de la función binmode() se describe como &quot;DISCIPLINA&quot; en &quot;Programming Perl, 3rd Edition&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Socket library makes this slightly easier:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La biblioteca Socket hace esto ligeramente más fácilmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub logger {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T233832Z" changeid="zipf">
        <seg>sub registrador {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BUGS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T171504Z" changeid="zipf">
        <seg>=head1 ERRORES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dbmclose(%HIST);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dbmclose(%HIST);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programs that want to lie to themselves about what was just input 
normally use this command:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los programas que quieren engañarse a sí mismos acerca de lo que se acaba de introducir suelen utilizar este comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need more file
descriptors than that, consider rebuilding Perl to use the C&lt;sfio&gt;
library, or perhaps using the POSIX::open() function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si necesita más descriptores de archivo que esa cantidad, contemple la posibilidad de reconstruir Perl para que use la biblioteca C&lt;sfio&gt;, o tal vez usar la función estándar POSIX::open().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For functions that can be used in either a scalar or list context,
nonabortive failure is generally indicated in a scalar context by
returning the undefined value, and in a list context by returning the
empty list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para funciones que pueden ser usadas tanto en contexto escalar como en lista, un fallo no abortivo es indicado, generalmente, devolviendo el valor indefinido, y en contexto lista devolviendo la lista vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $file (@filenames) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $archivo (@archivos) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example, the smart match operator short-circuits whenever possible, but
C&lt;grep&gt; does not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, el operador de coincidencia inteligente intenta siempre abreviar donde sea posible, mientras que C&lt;grep&gt;, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlthrtut		Perl threads tutorial</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T012119Z" changeid="explorer">
        <seg>perlthrtut		Seminario de ejecución por hilos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the code to be executed doesn't vary, you may use the eval-BLOCK
form to trap run-time errors without incurring the penalty of
recompiling each time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el código a ser ejecutado no varía, puede usar la forma BLOQUE de eval para atrapar errores en tiempo de ejecución sin incurrir en la penalidad de recompilar cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar    @array    slice:   @array[0, 2]  @hash{'a', 'b'}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T233923Z" changeid="explorer">
        <seg>escalar   @array   trozo:    @array[0, 2]  @hash{'a', 'b'}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item continuation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item continuation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO,$foo) || die &quot;Can't open $foo: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO,$foo) || die &quot;No puedo abrir $foo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mysockaddr = getsockname(SOCK);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$mysockaddr = getsockname(SOCK);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates to a list of the words extracted out of STRING, using embedded
whitespace as the word delimiters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa a una lista de palabras extraídas de CADENA, utilizando los espacios en blanco incrustados como delimitadores de palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;use strict 'vars'&gt; is in
effect, C&lt;our&gt; lets you use declared global variables without qualifying
them with package names, within the lexical scope of the C&lt;our&gt; declaration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando C&lt;use strict 'vars'&gt; esté activo, C&lt;our&gt; le permite usar variables globales declaradas sin calificarlas con nombres de paquetes, en el ámbito léxico de la declaración C&lt;our&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;@DB::args&gt;, like C&lt;@_&gt;, does not hold explicit references to its
elements, so under certain cases its elements may have become freed and
reallocated for other variables or temporary values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;@DB::args&gt;, como C&lt;@_&gt;, no incluye referencias explícitas a sus elementos, por lo que en algunos casos sus elementos pueden haberse liberado y reasignado a otras variables o valores temporales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first form, the return value of EXPR is parsed and executed as if it
were a little Perl program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la primera forma, el valor devuelto por EXPR es interpretado y ejecutado como si fuera un pequeño programa Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the above usage will create global variables throughout your
program, which is bad programming practice.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225040Z" changeid="explorer">
        <seg>Sin embargo, el uso anterior creará variables globales en todo el programa, algo que no se recomienda en programación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ASCII semantics are used for the case change.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175203Z" changeid="explorer">
        <seg>Semántica ASCII es utilizada para el cambio de tamaño de caja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item c)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item c)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@lines = (&quot;   - Foo&quot;,
              &quot;01 - Bar&quot;,
              &quot;1  - Baz&quot;,
              &quot;   - Quux&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053712Z" changeid="explorer">
        <seg>@lineas = (&quot;   - Foo&quot;,
              &quot;01 - Bar&quot;,
              &quot;1  - Baz&quot;,
              &quot;   - Quux&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should give end users more
flexibility in their choice of upgrade timing, and allow them easier
assessment of the impact of upgrades.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto debería dar a los usuarios finales una mayor flexibilidad en su elección del momento de la actualización, y permitir una evaluación más sencilla de los efectos de las actualizaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlre&gt; and
L&lt;perlop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlre&gt; y L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, when called from within the DB package, caller returns more
detailed information: it sets the list variable C&lt;@DB::args&gt; to be the
arguments with which the subroutine was invoked.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015933Z" changeid="explorer">
        <seg>Además, cuando se le llama desde el interior de un paquete DB, caller devuelve información más detallada: actualiza la variable C&lt;@DB::args&gt; con los argumentos con los que la subrutina fue invocada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$x][$y] = func($x, $y);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$x][$y] = func($x, $y);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most if not all systems
implement lockf(3) in terms of fcntl(2) locking, though, so the
differing semantics shouldn't bite too many people.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayor parte si no todos los sistemas implementan lockf(3) en términos de bloqueo con fcntl(2), aunque, las diferencias en la semántica no llame la atención a mucha gente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No space between function name and its opening parenthesis.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin espacio entre el nombre de función y su paréntesis de apertura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$&amp;&gt; returns the entire matched string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$&amp;&gt; devuelve toda la cadena coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Otherwise, if C&lt;use feature 'unicode_strings'&gt; is in effect:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174935Z" changeid="explorer">
        <seg>=item De lo contrario, si C&lt;use feature 'unicode_strings'&gt; está activo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item b)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolation in patterns has several quirks: C&lt;$|&gt;, C&lt;$(&gt;, C&lt;$)&gt;, C&lt;@+&gt;
and C&lt;@-&gt; are not interpolated, and constructs C&lt;$var[SOMETHING]&gt; are
voted (by several different estimators) to be either an array element
or C&lt;$var&gt; followed by an RE alternative.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La interpolación en los patrones tiene varias peculiaridades: C&lt;$|&gt;, C&lt;$(&gt;, C&lt;$)&gt;, C&lt;@+&gt; y C&lt;@-&gt; no son interpoladas, y construcciones C&lt;$var[ALGO]&gt; son promovidas (por varios estimadores diferentes) a ser un elemento de array o C&lt;$var&gt; seguida de una RE alternativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will find this behavior is slightly different from that of
C&lt;$SIG{__DIE__}&gt; handlers (which don't suppress the error text, but can
instead call C&lt;die&gt; again to change it).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted encontrará que este comportamiento es ligeramente diferente a la de los controladores C&lt;$SIG{__DIE__}&gt; (que no suprimen el texto de error, pero puede llamar, en su lugar, a C&lt;die&gt; de nuevo para cambiarlo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are infinitely more reals than floats,
so some corners must be cut.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay infinitamente más reales que flotantes, por lo que algunos detalles deben ser tenidos en cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators return a count of successful
operations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven una cuenta del número de operaciones exitosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two potentially non-obvious but traditional C&lt;flock&gt; semantics are
that it waits indefinitely until the lock is granted, and that its locks
B&lt;merely advisory&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dos potenciales no obvias pero tradicionales semánticas de C&lt;flock&gt; son que espera indefinidamente hasta que el bloqueo es efectivo, y que B&lt;meramente es un consejo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;q()&gt;, C&lt;qq()&gt;, and the like are not
supported in place of C&lt;''&gt; and C&lt;&quot;&quot;&gt;, and the only interpolation is for
backslashing the quoting character:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;q()&gt;, C&lt;qq()&gt;, y similares no están soportadas, en lugar de C&lt;''&gt; y C&lt;&quot;&quot;&gt;, y la única interpolación es para escapar el carácter de entrecomillado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one wants the hook to do
nothing in such situations, put</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si uno quiere que el gancho no haga nada en estas situaciones, ponga</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Floating-point Arithmetic
X&lt;floating-point&gt; X&lt;floating point&gt; X&lt;float&gt; X&lt;real&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011215Z" changeid="explorer">
        <seg>=head2 Aritmética de punto flotante
X&lt;floating-point&gt; X&lt;floating point&gt; X&lt;float&gt; X&lt;real&gt; X&lt;punto flotante&gt; X&lt;flotante&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class implementing an ordinary array should have the following methods:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una clase implementando un array ordinario común debe tener los siguientes métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 4) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 4) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, whether
C&lt;&lt; &quot;a $b -&gt; {c}&quot; &gt;&gt; really means:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, si C&lt;&lt; &quot;a $b -&gt; {c}&quot; &gt;&gt; realmente significa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item a)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item a)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is only one scalar argument or an array with one element in it,
the argument is checked for shell metacharacters, and if there are any,
the entire argument is passed to the system's command shell for parsing
(this is C&lt;/bin/sh -c&gt; on Unix platforms, but varies on other platforms).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sólo hay un argumento escalar o un array con un elemento dentro de él, se comprueba si el argumento tiene metacaracteres, y si hay alguno, el argumento entero es pasado al shell de comandos para que sea interpretado (suele ser C&lt;/bin/sh -c&gt; en plataformas Unix, pero varía en otras plataformas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a*&quot;)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a*&quot;)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># in-memory files</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># archivos en memoria</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programs should rarely if ever make policy decisions better left to
the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los programas rara vez o nunca deben tomar decisiones políticas, que es mejor dejar al usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember that a umask is a number, usually given in octal; it is I&lt;not&gt; a
string of octal digits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recuerde que un umask es un número, generalmente indicado en octal; I&lt;no&gt; es una cadena de dígitos octales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F  A Perl internal floating-point value (NV) in native format</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>F  Un valor Perl interno de punto flotante (NV) en formato nativo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If OFFSET is negative (or more precisely, less than C&lt;$[&gt;), starts
that far from the end of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si DESPLAZAMIENTO es negativo (o más precisamente, menor que C&lt;$[&gt;), cuenta la posición desde el final de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.	Match any character (except newline)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T200439Z" changeid="explorer">
        <seg>.        Coincide con cualquier carácter (excepto el nueva línea)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getgrgid GID</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getgrgid GID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifiers that alter the way a regular expression
is used by Perl are detailed in L&lt;perlop/&quot;Regexp Quote-Like Operators&quot;&gt; and
L&lt;perlop/&quot;Gory details of parsing quoted constructs&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Modificadores que alteran la forma en que una expresión regular es utilizada por Perl se detallan en L&lt;perlop/&quot;Operadores Regexp Entrecomillados&quot;&gt; y L&lt;perlop/&quot;Detalles sangrientos del análisis de las construcciones entrecomilladas&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlirix		Perl notes for Irix</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlirix		Notas para Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Current Perl's
should handle this problem correctly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El Perl actual debería manejar este problema correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use feature &quot;:5.10&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use feature &quot;:5.10&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, stats C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, stats C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The position after the last match can be read or set using the pos()
function; see L&lt;perlfunc/pos&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La posición después de la última coincidencia puede ser leída o establecida mediante la función pos(); véase L&lt;perlfunc/pos&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual sizes (in bytes) of native shorts, ints, longs, and long
longs on the platform where Perl was built are also available from
the command line:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tamaños reales (en bytes) de short, int, long y long largos nativos en la plataforma donde Perl fue compilado también están disponibles desde la línea de comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getpwent();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$name  = getpwent();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an indirect object with C&lt;exec&gt; or C&lt;system&gt; is also more
secure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar un objeto indirecto con C&lt;exec&gt; o C&lt;system&gt; es también más seguro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\033	octal char	(example: ESC)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002902Z" changeid="explorer">
        <seg>\033	car. octal        (ejemplo: ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $result;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235528Z" changeid="zipf">
        <seg>return $resultado;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;\t elt $i is [ @{$AoA[$i]} ],\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052909Z" changeid="explorer">
        <seg>print &quot;\t ítem $i es [ @{$AoA[$i]} ],\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, C&lt;when()&gt; will always do an implicit smart match
with its argument, whilst it is convenient in Perl 5 to
suppress this implicit smart match in certain situations,
as documented above.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En Perl 6, C&lt;when()&gt; siempre hará una coincidencia inteligente con sus argumentos, mientras que en Perl 5 es conveniente suprimir esta coincidencia inteligente en ciertas situaciones, como se ha documentado anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item defined</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item defined</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ .= qq</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ .= qq</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used with C&lt;.&gt;, the repeat count determines the starting position to
calculate the value offset as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se utiliza con C&lt;.&gt;, el número de repeticiones determina la posición de partida para calcular el valor de desplazamiento de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL foreach VAR (LIST) BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA foreach VAR (LIST) BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arguments are interpreted
as follows: if a given argument is numeric, the argument is passed as
an int.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los argumentos se interpretan de la siguiente manera: si un argumento dado es numérico, el argumento se pasa como un int.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do_something;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hacer_algo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @new = @old[ sort {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @nuevo = @viejo[ sort {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for staying almost, but not entirely similar to
C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para mantenerse casi, pero no del todo, similar a C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#.0o&gt;', 0;        # prints &quot;&lt;0&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#.0o&gt;', 0;        # imprime &quot;&lt;0&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $j++ until $j &gt;  10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $j++ until $j &gt;  10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, sprintf() takes the next unused argument as the value to
format for each format specification.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente, sprintf () toma el siguiente argumento utilizado como el valor de formato para cada especificación de formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $foo, exit;	# Nor is this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $foo, exit;	# Tampoco esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 14694</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 14694</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>syscall(&amp;SYS_write, fileno(STDOUT), $s, length $s);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>syscall(&amp;SYS_write, fileno(STDOUT), $s, length $s);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl defines the following zero-width assertions:
X&lt;zero-width assertion&gt; X&lt;assertion&gt; X&lt;regex, zero-width assertion&gt;
X&lt;regexp, zero-width assertion&gt;
X&lt;regular expression, zero-width assertion&gt;
X&lt;\b&gt; X&lt;\B&gt; X&lt;\A&gt; X&lt;\Z&gt; X&lt;\z&gt; X&lt;\G&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225605Z" changeid="explorer">
        <seg>Perl define las siguientes aserciones de ancho cero:
X&lt;zero-width assertion&gt; X&lt;assertion&gt; X&lt;regex, zero-width assertion&gt;
X&lt;regexp, zero-width assertion&gt;
X&lt;regular expression, zero-width assertion&gt;
X&lt;\b&gt; X&lt;\B&gt; X&lt;\A&gt; X&lt;\Z&gt; X&lt;\z&gt; X&lt;\G&gt;
X&lt;aserción ancho cero&gt; X&lt;aserción&gt; X&lt;regex, aserción ancho cero&gt;
X&lt;regexp, aserción ancho cero&gt;
X&lt;expresión regular, aserción ancho cero&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting from Perl 5.10, you can say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de Perl 5.10, puede decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpriority WHICH,WHO
X&lt;getpriority&gt; X&lt;priority&gt; X&lt;nice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173706Z" changeid="explorer">
        <seg>=item getpriority CUÁL,QUIÉN
X&lt;getpriority&gt; X&lt;priority&gt; X&lt;nice&gt; X&lt;prioridad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make -f Makefile.micro regen_uconfig</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make -f Makefile.micro regen_uconfig</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the reverse, use L&lt;/ord&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para lo contrario, use L&lt;/ord&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:encoding(...)&gt; layer implicitly introduces the C&lt;:utf8&gt; layer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La capa C&lt;:encoding(...)&gt; implícitamente introduce la capa C&lt;:utf8&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,31, 1) = 1   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,31, 1) = 1   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Opciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filehandle is left open pointing to the
contents after __DATA__.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El gestor de archivo se deja abierto apuntando al contenido que hay después de __DATA__.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($login, $passwd, $uid, $gid,
         $gcos, $home, $shell) = split(/:/);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051547Z" changeid="explorer">
        <seg>($login, $passwd, $uid, $gid,
         $gcos, $home, $shell) = split(/:/);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special string C&lt;&quot;0 but true&quot;&gt; is exempt from B&lt;-w&gt; complaints
about improper numeric conversions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La cadena especial C&lt;&quot;0 but true&quot;&gt; (0, pero verdadero) es una excepción de los mensajes de aviso activados por B&lt;-w&gt; sobre una conversión numérica impropia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolating an array or slice interpolates the elements in order,
separated by the value of C&lt;$&quot;&gt;, so is equivalent to interpolating
C&lt;join $&quot;, @array&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Interpolando un array o una parte de él, es interpolar los elementos por orden, separándolos por el valor de C&lt;$&quot;&gt;, que es equivalente a C&lt;join $&quot;, @array&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful for displaying ordinal values of
characters in arbitrary strings:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto puede ser útil para mostrar los valores ordinales de caracteres en cadenas arbitrarias:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this feature was 
to be run only right before your program was to exit, this is not
currently so: the C&lt;$SIG{__DIE__}&gt; hook is currently called
even inside eval()ed blocks/strings!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque esta característica está preparada para ser ejecutada sólo antes de que el programa termine, así no es como se hace ahora: el gancho C&lt;$SIG{__DIE__}&gt;, ¡es llamado incluso dentro de cadenas y bloques eval()uados!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>qw!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>qw!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common way to access an array or a hash is one scalar element at a
time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234638Z" changeid="explorer">
        <seg>Una forma cotidiana de acceder a un array o un hash es, cada vez, por un elemento escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($file) = &lt;blurch*&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($archivo) = &lt;loquesea*&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of C&lt;defined&gt; on aggregates (hashes and arrays) is deprecated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de C&lt;defined&gt; sobre datos agregados (hashes y arrays) está desaconsejado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;ccxxcc&quot;,65,66,67,68);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;ccxxcc&quot;,65,66,67,68);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C-style Logical And
X&lt;&amp;&amp;&gt; X&lt;logical and&gt; X&lt;operator, logical, and&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235520Z" changeid="explorer">
        <seg>=head2 And lógico al estilo del C
X&lt;&amp;&amp;&gt; X&lt;logical and&gt; X&lt;operator, logical, and&gt; X&lt;and lógico&gt; X&lt;operador, lógico, and&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;hash, scalar context&gt; X&lt;hash, bucket&gt; X&lt;bucket&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;hash, scalar context&gt; X&lt;hash, contexto escalar&gt; X&lt;hash, bucket&gt; X&lt;hash, cajones&gt; X&lt;bucket&gt; X&lt;cajones&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is true of an operation it will be mentioned in
the documentation for that operation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T000510Z" changeid="explorer">
        <seg>Si esto es cierto para una determinada operación, entonces estará mencionado en la documentación de esa operación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, you may need to set
C&lt;$|&gt; ($AUTOFLUSH in English) or call the C&lt;autoflush()&gt; method of
C&lt;IO::Handle&gt; on any open handles.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para estar seguro, es posible que necesite el conjunto C&lt;|&gt; ($AUTOFLUSH en English) o llame al método C&lt;autoflush()&gt; de C&lt;IO::Handle&gt; en cualquier identificador abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use warnings;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use warnings;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;ext/Socket/t/socketpair.t&gt; test fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El test C&lt;ext/Socket/t/socketpair.t&gt; falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;\n#line &quot; . __LINE__ . ' &quot;' . __FILE__ .&quot;\&quot;\ndie 'foo'&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054705Z" changeid="explorer">
        <seg>eval &quot;\n#línea &quot; . __LINE__ . ' &quot;' . __FILE__ .&quot;\&quot;\ndie 'foo'&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, splice() has three scalar
arguments followed by a list, whereas gethostbyname() has four scalar
arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, splice() tiene tres argumentos escalares seguidos por una lista, mientras que gethostbyname() tiene cuatro argumentos escalares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlrebackslash	Perl regular expression backslash sequences</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlrebackslash	Expresiones regulares, las contrabarras</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># we'll build auxiliary indices instead</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># construiremos índices auxiliares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can reduce some of the looping through slices</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T195019Z" changeid="explorer">
        <seg>Podemos reducir algunos de los bucles usando porciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See how much easier this is?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Ha visto que es mucho más fácil?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the length of the input string is not evenly divisible by 8, the
remainder is packed as if the input string were padded by null characters
at the end.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la longitud de la cadena de entrada no es divisible por 8, el resto se rellena como si la cadena de entrada estuviera completada con caracteres nulos hasta el final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a =~ s/foo/bar/;         # replaces foo with bar in $a</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T030222Z" changeid="explorer">
        <seg>$a =~ s/foo/bar/;         # reemplaza foo por bar en $a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fix is to re-compile and re-install the modules using 5.8.2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La solución es volver a compilar y volver a instalar los módulos usando 5.8.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator and function decides which sort of value would be most
appropriate to return in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada operador y función decide qué clase de valor será más apropiado para devolver en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just run ./Configure script from the top directory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo tiene que ejecutar el script ./Configure desde el directorio principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 4) = 4   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 4) = 4   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when($_ ~~ $foo)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when($_ ~~ $foo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$ARGV $.: $_&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$ARGV $.: $_&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A
number of popular modules are included with the Perl distribution
itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225558Z" changeid="explorer">
        <seg>La distribución de Perl incluye muchos módulos populares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item stat EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item stat EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	* / % x</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	* / % x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;system @args failed: $?&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;system @args falló: $?&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($startx = $x = 4; $x &lt;= 8; $x++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053005Z" changeid="explorer">
        <seg>for ($startx = $x = 4; $x &lt;= 8; $x++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;\@array contains $count copies of 'foo'\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;\@array contiene $cuenta copias de 'foo'\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-s  File has nonzero size (returns size in bytes).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004627Z" changeid="explorer">
        <seg>-s  Archivo no tiene tamaño cero (devuelve el tamaño en bytes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item d)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item d)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select(REPORT1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select(INFORME1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\d+/$&amp;*2/e;		# yields 'abc246xyz'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/\d+/$&amp;*2/e;		# queda como 'abc246xyz'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For blessed references, the
&quot;Object&quot; entries apply.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para referencias bendecidas, se aplica la entrada &quot;Objeto&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use VERSION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item use VERSIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Object  Any       invokes ~~ overloading on $object, or falls back:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Objeto      Cualquiera invoca ~~ sobrecargado en $objeto, o termina:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also exempt from the normal B&lt;-w&gt; warnings
on improper numeric conversions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También es una excepción en el sistema de avisos B&lt;-w&gt; sobre conversiones numéricas impropias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ARGV = grep { -f &amp;&amp; -T } glob('*') unless @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ARGV = grep { -f &amp;&amp; -T } glob('*') unless @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, waiting for a particular
pid with FLAGS of C&lt;0&gt; is implemented everywhere.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, esperar por un particular pid con BANDERAS a C&lt;0&gt; está implementado en todas partes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perllocale&gt;
and L&lt;POSIX&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perllocale&gt; y L&lt;POSIX&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It fails and
returns false only if the command does not exist I&lt;and&gt; it is executed
directly instead of via your system's command shell (see below).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fallará y devolverá falso sólo si el comando no existe I&lt;y&gt; es ejecutado directamente en lugar de hacerlo con el shell de comandos del sistema (ver abajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign something shorter than LENGTH,
the string will shrink, and if you assign something longer than LENGTH,
the string will grow to accommodate it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si asigna algo más corto que LONGITUD, la cadena se reducirá, y si asigna algo más largo que LONGITUD, la cadena crecerá para acogerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That algorithm was not stable, and I&lt;could&gt; go quadratic.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este algoritmo no era estable, y I&lt;podría&gt; ser cuadrático.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, a list assignment in list context produces the list of
lvalues assigned to, and a list assignment in scalar context returns
the number of elements produced by the expression on the right hand
side of the assignment.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203547Z" changeid="explorer">
        <seg>Del mismo modo, una asignación de lista en contexto de lista produce la lista de I&lt;ivalores&gt; asignados, y una asignación de lista en contexto escalar devuelve el número de elementos producidos por la expresión en el lado derecho de la asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item next LABEL
X&lt;next&gt; X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191539Z" changeid="explorer">
        <seg>=item next ETIQUETA
X&lt;next&gt; X&lt;continue&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chomp</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chomp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.riscos - Perl version 5 for RISC OS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.riscos - Perl versión 5 para sistemas operativos RISC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setnetent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setnetent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># NOTE: The examples above featuring &quot;W&quot; and &quot;c&quot; are true</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># NOTA: Los ejemplos anteriores de &quot;W&quot; y &quot;c&quot; son correctos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 4) = 4   ==          4 00100000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 4) = 4   ==          4 00100000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11725</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11725</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also
some non-standard modules that provide faster implementations via
external C libraries.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También hay algunos módulos no estándar que ofrecen implementaciones más rápidas a través de bibliotecas de C externas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $null = substr $name, 6, 2;   # returns &quot;&quot; (no warning)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $nulo = substr $nombre, 7, 2;  # devuelve &quot;&quot; (sin advertencia)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return value of -1
indicates a failure to start the program or an error of the wait(2) system
call (inspect $!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un valor devuelto de -1 indica un fallo en el arranque del programa o un error de la llamada al sistema wait(2) (inspeccionar $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the REPLACEMENTLIST is empty, the SEARCHLIST is replicated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la LISTA_REEMPLAZO está vacía, la LISTA_BÚSQUEDA es replicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open STDIN, &quot;&lt;&amp;BLAM&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open STDIN, &quot;&lt;&amp;BLAM&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results end up in C&lt;$1&gt;, C&lt;$2&gt; and so on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T232457Z" changeid="zipf">
        <seg>Los resultados se almacenan en C&lt;$1&gt;, C&lt;$2&gt;, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures
crypt() will hash the new string with the same salt as the digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto asegura que crypt() hará el hash de la nueva cadena con el mismo salto que el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($fh) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($fh) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;\g{1}&gt; X&lt;\g{-1}&gt; X&lt;\g{name}&gt; X&lt;relative backreference&gt; X&lt;named backreference&gt;
In order to provide a safer and easier way to construct patterns using
backreferences, Perl provides the C&lt;\g{N}&gt; notation (starting with perl
5.10.0).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;\g{1}&gt; X&lt;\g{-1}&gt; X&lt;\g{nombre}&gt; X&lt;contrareferencia relativa&gt; X&lt;contrareferencia nominada&gt;
A fin de proporcionar una forma más fácil y segura de construir patrones usando contrareferencias, Perl proporciona la notación C&lt;\g{N}&gt; (a partir de Perl
v5.10.0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for throwing away some of the return values of a
function:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para descartar algunos de los valores de retorno de una función:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;a&gt;, C&lt;A&gt;, and C&lt;Z&gt; types gobble just one value, but pack it as a
string of length count, padding with nulls or spaces as needed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tipos C&lt;a&gt;, C&lt;A&gt;, y C&lt;Z&gt; absorben un solo valor, pero se empaqueta como una cadena de longitud indicada, rellenada con nulos o espacios según sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[...]     [1]  Match a character according to the rules of the bracketed
                    character class defined by the &quot;...&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223311Z" changeid="explorer">
        <seg>[...]     [1]  Busca un carácter de acuerdo a las reglas de la clase
                    carácter definida por &quot;...&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use
diagnostics&gt; pragma automatically turns Perl's normally terse warnings
and errors into these longer forms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El pragma C&lt;use diagnostics&gt; automáticamente cambia las normalmente concisas advertencias y errores de Perl en formatos más largos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operands to a binary bitwise op are strings of different
sizes, B&lt;|&gt; and B&lt;^&gt; ops act as though the shorter operand had
additional zero bits on the right, while the B&lt;&amp;&gt; op acts as though
the longer operand were truncated to the length of the shorter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los operandos a una operación bit a bit binaria son cadenas de diferentes tamaños, los operadores B&lt;|&gt; y B&lt;^&gt; actúan como si el operando más corto tuviera más bit cero a la derecha, mientras que el operador B&lt;&amp;&gt; actúa como si el operando más largo fuera truncado a la longitud de la menor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could write the last two using the C&lt;-u&gt; and C&lt;-d&gt; operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Podría escribir las dos últimas utilizando los operadores C&lt;-u&gt; y C&lt;-d&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
and only if the input symbol is the only thing inside the conditional
of a C&lt;while&gt; statement (even if disguised as a C&lt;for(;;)&gt; loop),
the value is automatically assigned to the global variable $_,
destroying whatever was there previously.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si y sólo si el símbolo de entrada es la única cosa dentro de la condición de una declaración C&lt;while&gt; (incluso si está disfrazado como un bucle C&lt;for(;;)&gt;), el valor es automáticamente asignado a la variable global $_, destruyendo su valor anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item state EXPR
X&lt;state&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201631Z" changeid="explorer">
        <seg>=item state EXPR
X&lt;state&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=back</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>length pack(&quot;s&quot;), length pack(&quot;s!&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>length pack(&quot;s&quot;), length pack(&quot;s!&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If CLASSNAME is omitted, the current package
is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite NOMBRECLASE, se usa el paquete actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Readable\n&quot; if -r _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Leíble\n&quot; if -r _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Irix 5.3</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004549Z" changeid="explorer">
        <seg>=head2 Irix 5.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or because
the Bourne shell is more familiar to you than I&lt;csh&gt;, so writing C&lt;for&gt;
comes more naturally.)  If VAR is omitted, C&lt;$_&gt; is set to each value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(O si le es más familiar el shell Bourne que el I&lt;csh&gt;, escribir C&lt;for&gt; le será más natural). Si VAR se omite, C&lt;$_&gt; se inicializa con cada valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &lt;*.c&gt; &gt;&gt; operator is discussed in
more detail in L&lt;perlop/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185205Z" changeid="explorer">
        <seg>El operador C&lt;&lt; &lt;*.c&gt; &gt;&gt; se discute con más detalle en L&lt;perlop/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item undef EXPR
X&lt;undef&gt; X&lt;undefine&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210130Z" changeid="explorer">
        <seg>=item undef EXPR
X&lt;undef&gt; X&lt;undefine&gt; X&lt;indefine&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item write FILEHANDLE
X&lt;write&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211037Z" changeid="explorer">
        <seg>=item write GESTOR_ARCHIVO
X&lt;write&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can't be used to get out of a block or
subroutine given to C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se puede utilizar para salir de un bloque o una subrutina pasada a C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example: [[:upper:]] matches any uppercase
                    character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223515Z" changeid="explorer">
        <seg>Ejemplo: [[:upper:]] coincide con cualquier
                    mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This 'cheat sheet' is a handy reference, meant for beginning Perl
programmers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta 'chuleta' es una referencia rápida, para los programadores principiantes de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbook		Perl book information</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlbook		Información bibliográfica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open BLAM, &quot;blam&quot; || die &quot;Can't open: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open BLAM, &quot;blam&quot; || die &quot;No puedo abrir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item format</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item format</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, the arguments to a subroutine are available
to us as a special array called C&lt;@_&gt; (see L&lt;perlvar&gt; for more on that).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225524Z" changeid="explorer">
        <seg>Los argumentos pasados a una subrutina están disponibles en un array especial denominado C&lt;@_&gt; (consulte L&lt;perlvar&gt; para obtener más información).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exceptions to this rule are when the file or directory should be
kept private (mail files, for instance).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las excepciones a esta regla son cuando el archivo o directorio debe mantenerse privados (archivos de correo, por ejemplo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also insert hooks into the import facility, by putting Perl code
directly into the @INC array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194624Z" changeid="explorer">
        <seg>También puede insertar enganches en la facilidad import, poniendo código Perl directamente en el array C&lt;@INC&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within search patterns (which also undergo double-quotish substitution)
there is an unfortunate ambiguity:  Is C&lt;/$foo[bar]/&gt; to be interpreted as
C&lt;/${foo}[bar]/&gt; (where C&lt;[bar]&gt; is a character class for the regular
expression) or as C&lt;/${foo[bar]}/&gt; (where C&lt;[bar]&gt; is the subscript to array
@foo)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dentro de los patrones de búsqueda (que también están bajo la sustitución del entrecomillado doble) existe una desafortunada ambigüedad: ¿Debe C&lt;/$foo[bar]/&gt; ser interpretado como C&lt;/${foo}[bar]/&gt; (donde C&lt;[bar]&gt; es una clase carácter para la expresión regular) o como C&lt;/${foo[bar]}/&gt; (donde C&lt;[bar]&gt; es el subíndice del array @foo)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 1) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 1) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%g&gt;', 100;      # prints &quot;&lt;100&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%g&gt;', 100;      # imprime &quot;&lt;100&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if $!;              # errno</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171121Z" changeid="explorer">
        <seg>if $!;              # errno</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a couple of special arrays too, such as C&lt;@ARGV&gt; (the command
line arguments to your script) and C&lt;@_&gt; (the arguments passed to a
subroutine).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224915Z" changeid="explorer">
        <seg>También hay dos arrays especiales: C&lt;@ARGV&gt; (los argumentos de línea de comandos pasados al script) y C&lt;@_&gt; (los argumentos pasados a una subrutina).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is the moral equivalent of these two:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es el equivalente moral de estos dos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty echo&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty echo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($@) {
           $INC{$filename} = undef;
           die $@;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051144Z" changeid="explorer">
        <seg>if ($@) {
           $INC{$archivo} = undef;
           die $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could also read C&lt;$^A&gt;
and then set C&lt;$^A&gt; back to C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede también leer C&lt;$^A&gt; y volver a ponerla otra vez a C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = ()[1,0];           # @a has no elements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@a = ()[1,0];           # @a no tiene elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual random
order is subject to change in future versions of Perl, but it is
guaranteed to be in the same order as either the C&lt;keys&gt; or C&lt;values&gt;
function would produce on the same (unmodified) hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El actual orden aleatorio está sujeto a cambio en futuras versiones de Perl, pero se garantiza que sea el mismo orden que las funciones C&lt;keys&gt; o C&lt;values&gt; producirían (mientras que el hash no haya sido modificado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Argument processing and
value returned work just like C&lt;ioctl&gt; below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procesado de argumentos y el valor devuelto funcionan como C&lt;ioctl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;&quot;qr/STRING/msixpo&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también L&lt;&quot;qr/CADENA/msixpo&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the file will not be included twice under the same specified
name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el archivo no será incluido dos veces con el mismo nombre especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These override the normal built-ins, supplying
versions that return objects with the appropriate names
for each field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas sobreescriben a las integradas, con versiones que devuelven objetos con los nombres apropiados para cada campo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq5		Files and Formats</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003917Z" changeid="explorer">
        <seg>perlfaq5		Archivos y formatos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ make</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ make</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir($foo)   || die;	# (chdir $foo) || die</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir($foo)   || die;	# (chdir $foo) || die</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;use locale&gt; is in effect, the case map is taken from the current
locale.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;use locale&gt; está en vigor, se toma el mapa de tamaño de caja de la localización actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns true on success,
false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tuvo éxito, sino, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2000 Irix 6.2 Posix 1003.1b support modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004302Z" changeid="explorer">
        <seg>2000 Irix 6.2 Posix 1003.1b soporte de módulos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you know I&lt;exactly&gt; what you're doing, you can use the C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt;
modifiers to force big- or little-endian byte-order on floating-point values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sabe I&lt;exactamente&gt; lo que está haciendo, puede usar los modificadores C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt; para forzas una ordenación de bytes de los valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Binary\n&quot; if -B _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Binario\n&quot; if -B _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first version of this document appeared on Perl Monks, where several
people had useful suggestions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La primera versión de este documentos apareció en Perl Monks, en donde muchas personas dieron sus útiles sugerencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, '&gt;', &quot;output.txt&quot;) or die $!;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $fh, '&gt;', &quot;salida.txt&quot;) or die $!;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item abs VALUE
X&lt;abs&gt; X&lt;absolute&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165421Z" changeid="explorer">
        <seg>=item abs VALOR
X&lt;abs&gt; X&lt;absolute&gt; X&lt;absoluto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the C&lt;..&gt; and C&lt;...&gt; flip-flop operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>los operadores biestables C&lt;..&gt; y C&lt;...&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item split</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item split</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Truncates the file opened on FILEHANDLE, or named by EXPR, to the
specified length.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211944Z" changeid="explorer">
        <seg>Trunca el archivo abierto en GESTOR_ARCHIVO, o nombrado por EXPR, a la longitud especificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Win32: fix bugs in handling of the virtualized environment</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Win32: fallos arreglados en el manejo de entornos virtualizados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item semop KEY,OPSTRING
X&lt;semop&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200443Z" changeid="explorer">
        <seg>=item semop KEY,OPSTRING
X&lt;semop&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and this all reduces to one string internally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y todo esto se reduce a una sola cadena, internamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item split /PATTERN/,EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item split /PATRÓN/,EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;The value of $key is $hash{$key}\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234942Z" changeid="zipf">
        <seg>print &quot;El valor de $clave es $hash{$clave}\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a platform independent C&lt;move&gt; function look at the L&lt;File::Copy&gt;
module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una función independiente de la plataforma vea C&lt;move&gt; en el módulo L&lt;File::Copy&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(':', split(/(?=\w)/, 'hi there!'));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(':', split(/(?=\w)/, 'hola por aqui!'));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following compound statements may be used to control flow:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013257Z" changeid="explorer">
        <seg>Las siguientes instrucciones compuestas pueden ser usadas para controlar el flujo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, evaluates C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, se evalúa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(C&lt;\v&gt;
does have meaning in regular expression patterns in Perl, see L&lt;perlre&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(C&lt;\v&gt; tiene significado en los patrones de las expresiones regulares en Perl, véase L&lt;perlre&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On unpacking, bits are converted to a string of C&lt;&quot;0&quot;&gt;s and C&lt;&quot;1&quot;&gt;s.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al desempaquetar, los bits son convertidos en una cadena de C&lt;&quot;0&quot;&gt; y C&lt;&quot;1&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some people may wish to outlaw barewords entirely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas personas tal vez deseen prohibir palabras sueltas por completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is one minor difference: if variables are declared with C&lt;my&gt;
in the initialization section of the C&lt;for&gt;, the lexical scope of
those variables is exactly the C&lt;for&gt; loop (the body of the loop
and the control sections).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay una pequeña diferencia: si hay variables declaradas con C&lt;my&gt; en la sección de inicialización del C&lt;for&gt;, el ámbito léxico de estas variables es exactamente el bucle C&lt;for&gt; (el cuerpo del bucle y las secciones de control).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*	   Match 0 or more times</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>*	   Coincide con 0 o más veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$pattern = &quot;(?i)foobar&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234657Z" changeid="explorer">
        <seg>$patron = &quot;(?i)foobar&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (defined $packed_ip) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (defined $packed_ip) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The index function searches for one string within another, but without
the wildcard-like behavior of a full regular-expression pattern match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función index busca por un string dentro de otro, pero sin tener el comportamiento de un sistema de coincidencias basado en expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to change the installation directory or
have a standard DG/UX with C compiler GCC-2.7.2.x
then you have no choice than to do an interactive
build by issuing the command:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea cambiar el directorio de instalación o tiene una DG/UX estándar con un compilador de C GCC-2.7.2.x, entonces no tiene más remedio que hacer una compilación interactiva mediante la ejecución de la orden:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, it's just the list argument separator, and inserts
both its arguments into the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, es solo el separador de la lista de argumentos, e inserta sus argumentos en la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A good rule of thumb is that if
your platform has true C&lt;fork()&gt; (in other words, if your platform is
Unix) you can use the list form.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una buena regla general es que si la plataforma tiene un verdadero C&lt;fork()&gt; (en otras palabras, si su plataforma es Unix), puede utilizar la forma de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @parameters = @$arrayref[1..$#$arrayref];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @parametros = @$arrayref[1..$#$arrayref];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>length pack(&quot;l&quot;), length pack(&quot;l!&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>length pack(&quot;l&quot;), length pack(&quot;l!&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In particular, calling values() in void context resets
the iterator with no other overhead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(De forma particular, llamando a values() en contexto nulo (void) resetea el iterador sin otro efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Other regexp features</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Otras características de las expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C subroutines (or comparably compiled subroutines in other
languages) supplied by you and linked into this Package in order to
emulate subroutines and variables of the language defined by this
Package shall not be considered part of this Package, but are the
equivalent of input as in Paragraph 6, provided these subroutines do
not change the language in any way that would cause it to fail the
regression tests for the language.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Subrutinas en C (o, comparativamente, subrutinas compiladas en otros lenguajes) suministradas por usted y vinculadas a este Paquete con el fin de emular a subrutinas y variables del lenguaje definido por este Paquete no se considerarán parte de este Paquete, sino que son el equivalente a lo indicado en el apartado 6, siempre que estas subrutinas no cambien el lenguaje de cualquier manera que pudieran hacer fracasar las pruebas de regresión para el lenguaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any subroutine named
C&lt;ToLower&gt; will not be used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175129Z" changeid="explorer">
        <seg>Cualquier subrutina denominada C&lt;ToLower&gt; no será usada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\x{263a}	long hex char         (example: Unicode SMILEY)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\x{263a}	car. largo hex        (ejemplo: Unicode SMILEY)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many systems the C&lt;O_EXCL&gt; flag is available for opening files in
exclusive mode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En muchos sistemas la bandera C&lt;O_EXCL&gt; está disponible para abrir archivos en modo exclusivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each such format, pack() generates 4 bits of the result.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para cada formato así, pack() genera 4 bits del resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a regular C&lt;foreach&gt; loop for this purpose would be clearer in
most cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de un bucle C&lt;foreach&gt; normal para este propósito sería más claro en la mayoría de los casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negative values give the Unicode replacement character (chr(0xfffd)),
except under the L&lt;bytes&gt; pragma, where the low eight bits of the value
(truncated to an integer) are used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Valores negativos dan el carácter de reemplazo Unicode (chr(0xfffd)), salvo bajo el pragma L&lt;bytes&gt;, donde se utilizan los ocho bits más bajos del valor (truncado a un entero).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the POSIX module's C&lt;pause&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también la función C&lt;pause&gt; del módulo POSIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string enclosed by backticks (grave accents) first undergoes
double-quote interpolation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una cadena delimitada por comillas simples invertidas (acentos graves) se somete a una primera interpolación de entrecomillado doble.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, it is better to create directories with permissive MASK,
and let the user modify that with their C&lt;umask&gt;, than it is to supply
a restrictive MASK and give the user no way to be more permissive.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, es mejor crear directorios con una MÁSCARA permisiva y dejar que el usuario lo modifique que con su C&lt;umask&gt;, que suministrar una MÁSCARA restrictiva y no darle al usuario una forma de ser más permisivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11743</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11743</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; &lt;=&gt; &gt;&gt; X&lt;spaceship&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; &lt;=&gt; &gt;&gt; X&lt;spaceship&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have only
one C&lt;study&gt; active at a time: if you study a different scalar the first
is &quot;unstudied&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo puede tener una C&lt;study&gt; activa a la vez: si usted estudia un escalar diferente, la primera queda &quot;sin estudiar&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @caps, uc($_);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @mayusculas, uc($_);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;   sSiIlLqQ   Force big-endian byte-order on the type.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&gt;   sSiIlLqQ   Fuerza un orden de bytes en big-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For constructs with three-part delimiters (C&lt;s///&gt;, C&lt;y///&gt;, and
C&lt;tr///&gt;), the search is repeated once more.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para construcciones con delimitadores en tres partes (C&lt;s///&gt;, C&lt;y///&gt;, y C&lt;tr///&gt;), la búsqueda se repite una vez más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Software Foundation; either version 1, or (at your option) any</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Software Foundation; ya sea la versión 1, o (en su opinión) cualquier</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;chomp&gt;, C&lt;chop&gt;, C&lt;chr&gt;, C&lt;crypt&gt;, C&lt;hex&gt;, C&lt;index&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;,
C&lt;length&gt;, C&lt;oct&gt;, C&lt;ord&gt;, C&lt;pack&gt;, C&lt;q//&gt;, C&lt;qq//&gt;, C&lt;reverse&gt;,
C&lt;rindex&gt;, C&lt;sprintf&gt;, C&lt;substr&gt;, C&lt;tr///&gt;, C&lt;uc&gt;, C&lt;ucfirst&gt;, C&lt;y///&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043451Z" changeid="explorer">
        <seg>C&lt;chomp&gt;, C&lt;chop&gt;, C&lt;chr&gt;, C&lt;crypt&gt;, C&lt;hex&gt;, C&lt;index&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;,
C&lt;length&gt;, C&lt;oct&gt;, C&lt;ord&gt;, C&lt;pack&gt;, C&lt;q//&gt;, C&lt;qq//&gt;, C&lt;reverse&gt;,
C&lt;rindex&gt;, C&lt;sprintf&gt;, C&lt;substr&gt;, C&lt;tr///&gt;, C&lt;uc&gt;, C&lt;ucfirst&gt;, C&lt;y///&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rex = qr/my.STRING/is;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$rex = qr/mi.CADENA/is;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If Unicode (for example, C&lt;\N{}&gt; or wide hex characters of 0x100 or
beyond) is being used, the case map used by C&lt;\l&gt;, C&lt;\L&gt;, C&lt;\u&gt; and
C&lt;\U&gt; is as defined by Unicode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se usa Unicode (por ejemplo, C&lt;\N{}&gt; o caracteres hex. anchos, de 0x100 o superiores), el mapeo de tamaño de caja usado por C&lt;\l&gt;, C&lt;\L&gt;, C&lt;\u&gt; y C&lt;\U&gt; está definido por Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that here C&lt;$1&gt; etc. are
also set, and that this differs from Perl 4's behavior.)  When there are
no parentheses in the pattern, the return value is the list C&lt;(1)&gt; for
success.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tenga en cuenta que aquí C&lt;$1&gt;, etc, también son establecidas, y que esto difiere del comportamiento de Perl 4). Cuando no hay paréntesis en el patrón, el valor de retorno es la lista C&lt;(1)&gt; en caso de éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document gives instructions for building Perl for RISC OS.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento proporciona instrucciones para la construcción de Perl para sistemas operativos RISC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can determine your system endianness with this incantation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede determinar la ordenación de bytes de su sistema con este conjuro:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $index (0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $indice (0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s  A signed short (16-bit) value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s  Un valor de un corto con signo (16 bit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The POSIX module (part of the standard perl distribution) implements
ceil(), floor(), and other mathematical and trigonometric functions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo POSIX (parte de la distribución estándar de Perl) implementa ceil(), floor(), y otras funciones matemáticas y trigonométricas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note
that simply using</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el simple uso de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the value of the
last C&lt;chop&gt; is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo se devuelve el valor del último recorte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my($a, $b, %rest) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my($a, $b, %resto) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { $answer = }; # WRONG</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { $respuesta = }; # MAL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the variable was previously declared with C&lt;my&gt;, it uses
that variable instead of the global one, but it's still localized to
the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la variable fue previamente declarada con C&lt;my&gt;, usará esta variable en vez de la global, pero sigue siendo local en el bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-&gt;                      +          .        search.cpan.org</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043344Z" changeid="explorer">
        <seg>-&gt;                      +          .        search.cpan.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no decrypt function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe la función decrypt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
scalar context, it comes back as a single (potentially multi-line)
string, or undef if the command failed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, se devuelve como una sola cadena de caracteres (con, posiblemente, múltiples líneas dentro), o undef si el comando ha fallado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#.5o&gt;', 012345;   # prints &quot;&lt;012345&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#.5o&gt;', 012345;   # imprime &quot;&lt;012345&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Multiplicative Operators
X&lt;operator, multiplicative&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234355Z" changeid="explorer">
        <seg>=head2 Operadores multiplicativos
X&lt;operator, multiplicative&gt; X&lt;operador, multiplicativo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when a message is received, the message type as a
native long integer will be the first thing in VAR, followed by the
actual message.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que en cuanto se recibe un mensaje, el tipo de mensaje, en formato de un entero largo en forma nativa, será la primera cosa almacenada en VAR, seguida por el mensaje real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(\d\s){3}/         a three digits, each followed by a whitespace
                        character (eg &quot;3 4 5 &quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055706Z" changeid="explorer">
        <seg>/(\d\s){3}/         tres dígitos, cada uno seguido de un carácter
                        espacio (ej. &quot;3 4 5 &quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also a good language for many
system management tasks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es también un buen lenguaje para muchas tareas de gestión de sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, this operator is implemented using the standard
C&lt;File::Glob&gt; extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comenzando con v5.6.0, este operador está implementado usando la extensión estándar C&lt;File::Glob&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SCALAR will be grown or shrunk 
so that the last character actually read is the last character of the
scalar after the read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESCALAR crecerá o se reducirá de manera que el último carácter leído es el último carácter del escalar después de la lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the socket option requested.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Establece la opción de socket solicitada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlrecharclass	Perl regular expression character classes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlrecharclass	Expresiones regulares, las clases carácter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sentences++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$sentencias++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Test::Harness</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Test::Harness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is due to Haiku
not implementing C&lt;/dev/log&gt; support yet.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se debe a que Haiku aún no implementa soporte para C&lt;/dev/log&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>package main;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>package main;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;\t&quot; x ($tab/8), ' ' x ($tab%8);	# tab over</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;\t&quot; x ($tab/8), ' ' x ($tab%8);	# relleno con tabuladores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191357Z" changeid="explorer">
        <seg>bien</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sysopen(HANDLE, $path, O_RDWR|O_CREAT|O_EXCL)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sysopen(HANDLE, $ruta, O_RDWR|O_CREAT|O_EXCL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first version, the one without the indirect object, ran the I&lt;echo&gt;
program, passing it C&lt;&quot;surprise&quot;&gt; an argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La primera versión, sin el objeto indirecto, ejecuta el programa I&lt;echo&gt;, pasándole C&lt;&quot;sorpresa&quot;&gt; como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl 5.7.2, if the first two elements of the list are C&lt;undef&gt;, 
the utime(2) syscall from your C library is called with a null second
argument.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011928Z" changeid="explorer">
        <seg>Desde Perl 5.7.2, si los dos primeros elementos de la lista son C&lt;undef&gt;, se llama a la biblioteca del sistema C utime(2) con un segundo argumento nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function msgget(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC msgget(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlgpl		GNU General Public License</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlgpl		Licencia Pública General GNU</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De otra forma</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Executable\n&quot; if -x _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Ejecutable\n&quot; if -x _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has two
effects: first, a C&lt;write&gt; or a C&lt;print&gt; without a filehandle will
default to this FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto tiene dos efectos: primero, un C&lt;write&gt; o un C&lt;print&gt; sin un gestor de archivo será por defecto este GESTOR_ARCHIVO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hint: you could say
C&lt;open(LOG,'logfile')&gt; rather than C&lt;open(log,'logfile')&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un consejo: es mejor escribir C&lt;open(LOG,'archlog')&gt; que C&lt;open(log,'archlog')&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A BLOCK by itself (labeled or not) is semantically equivalent to a
loop that executes once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un BLOQUE por sí mismo (etiquetado o no) es semánticamente equivalente a un bucle que se ejecuta una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get all normal letters of the English alphabet, or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener todas las letras normales del alfabeto Inglés, o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getprotoent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getprotoent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then again, you could always use parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por otra parte, siempre se puede utilizar paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close OUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close OUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Put an asterisk C&lt;*&gt; before the C&lt;v&gt; to override the string to
use to separate the numbers:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pone un asterisco C&lt;*&gt; antes de C&lt;v&gt; para reemplazar la cadena a utilizar para separar los números:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may want to
call L&lt;seek&gt; before writing to the file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede llamar a L&lt;seek&gt; antes de escribir en el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's C-style C&lt;for&gt; loop works like the corresponding C&lt;while&gt; loop;
that means that this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El estilo de los bucles C&lt;for&gt; del C funcionan igual que el correspondiente bucle C&lt;while&gt;. Es decir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using single-quote as a delimiter protects the command from Perl's
double-quote interpolation, passing it on to the shell instead:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando comillas simples como delimitadores impide la interpolación del doble entrecomillado de Perl, pasándolo, en su lugar, al shell:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the power comes from implicit smart matching:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayor parte del poder viene de la coincidencia inteligente implícita:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack('s&lt;l&lt;', -42, 4711);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack('s&lt;l&lt;', -42, 4711);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>V  An unsigned long (32-bit) in &quot;VAX&quot; (little-endian) order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>V  Un largo sin signo (32 bit) en orden &quot;VAX&quot; (little-endian).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that packed floating-point data written on one machine
may not be readable on another, even if both use IEEE floating-point
arithmetic (because the endianness of the memory representation is not part
of the IEEE spec).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que datos empaquetados de punto flotante escritos en una máquina quizás no puedan ser leídos en otra, aunque ambas utilizan aritmética IEEE de punto flotante (porque la ordenación de bytes de la representación en memoria no es parte de la especificación IEEE).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, C&lt;IPC::Semaphore&gt;
documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, y C&lt;IPC::Semaphore&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;perldoc&gt; program gives you access to all the documentation that comes
with Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El programa F&lt;perldoc&gt; le da acceso a toda la documentación que viene con Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlartistic	Perl Artistic License</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlartistic	Licencia Artística Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/foo/)       { ... }  # true if $_ contains &quot;foo&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T212748Z" changeid="zipf">
        <seg>if (/foo/)       { ... }  # verdadero si $_ contiene &quot;foo&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do what you meant properly, you must write:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para hacer correctamente lo que quería decir, debe escribir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;perlsub&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($realfilename,$result);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($realnombrearchivo,$resultado);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($HOST = $host) =~ tr/a-z/A-Z/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($HOST = $host) =~ tr/a-z/A-Z/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8.3 23:59:59 GMT, Wednesday December 31st 2003</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5.8.3 23:59:59 GMT miércoles, 31 de diciembre 2003</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,12, 2) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,12, 2) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also parsed as terms are the C&lt;do {}&gt; and C&lt;eval {}&gt; constructs, as
well as subroutine and method calls, and the anonymous
constructors C&lt;[]&gt; and C&lt;{}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También son analizados como términos las construcciones C&lt;do {}&gt; y C&lt;eval {}&gt;, así como subrutina y llamadas a métodos, y los constructores anónimos C&lt;[]&gt; y C&lt;{}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item accept NEWSOCKET,GENERICSOCKET
X&lt;accept&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165436Z" changeid="explorer">
        <seg>=item accept NUEVOSOCKET,SOCKETGENÉRICO
X&lt;accept&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no need to have a C&lt;main()&gt; function or anything of
that kind.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224725Z" changeid="explorer">
        <seg>Es decir, no es necesario utilizar una función C&lt;main()&gt; ni nada similar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try to document your code and use Pod formatting in a consistent way.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intente documentar su código y usar formateo Pod de una forma consistente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result may be used as a subpattern in a match:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resultado puede ser utilizado como un sub-patrón en una coincidencia:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A local modifies the listed variables to be local to the enclosing
block, file, or eval.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un local() modifica las variables listadas para que sean locales en el bloque que les rodea, un archivo o un eval().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If OFFSET is
past the end of the array, Perl issues a warning, and splices at the
end of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el DESPLAZAMIENTO es más allá del final del array, Perl lanza una advertencia, y extrae al final del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;dbmclose&gt;, C&lt;dbmopen&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;dbmclose&gt;, C&lt;dbmopen&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (TYPE)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item (TYPE)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(C&lt;and&gt;, C&lt;or&gt; and C&lt;not&gt; aren't just in the above table as descriptions
of the operators.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225243Z" changeid="explorer">
        <seg>(En la tabla anterior C&lt;and&gt;, C&lt;or&gt; y C&lt;not&gt; no son solo descripciones de los operadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = &quot;dlrow ,olleH&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = &quot;odnum ,aloH&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;Quote and Quote-like Operators&quot;&gt; for a list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T184743Z" changeid="explorer">
        <seg>Ver L&lt;perlop/&quot;Comillas y Operadores de comillas&quot;&gt; para una lista de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello, $name\n&quot;;     # works fine</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T124136Z" changeid="zipf">
        <seg>print &quot;Hola, $nombre\n&quot;;  # funciona correctamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, C&lt;$AoA[2]&gt; is not an
array, but an array ref.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, C&lt;$AoA[2]&gt; no es un array, si no una referencia a un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 128 ==        128 00000001000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 128 ==        128 00000001000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reentrant functions will (once more) work with C++.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Funciones reentrantes trabajarán (una vez más) con C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>% perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>% perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{3,}                matches 3 or more of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230631Z" changeid="zipf">
        <seg>{3,}                detecta 3 o más coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $middle = substr $s, 4, -11;    # black cat climbed the</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $middle = substr $s, 3, -12;    # gato negro subió el</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For reference on how regular expressions are used in matching
operations, plus various examples of the same, see discussions of
C&lt;m//&gt;, C&lt;s///&gt;, C&lt;qr//&gt; and C&lt;??&gt; in L&lt;perlop/&quot;Regexp Quote-Like
Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para tener una referencia sobre cómo las expresiones regulares se utilizan en operaciones de búsqueda, además de varios ejemplos de lo mismo, vea las discusiones sobre C&lt;m//&gt; C&lt;s///&gt;, C&lt;qr//&gt; y C&lt;??&gt; en L&lt;perlop/&quot;Operadores Regexp Entrecomillados&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most subroutines do not
need to bother, though.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, la mayoría de las subrutinas no necesitan encargarse de esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhist		Perl history records</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlhist		Registros históricos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME
X&lt;regular expression&gt; X&lt;regex&gt; X&lt;regexp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T224505Z" changeid="explorer">
        <seg>=head1 NOMBRE
X&lt;expresión regular&gt; X&lt;regex&gt; X&lt;regexp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Namespaces with all lowercase names are considered reserved for
Perl pragmata.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio de nombres en minúsculas está considerado reservado para los pragmas de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'foo', 'bar', 'baz'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'foo', 'bar', 'baz'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n = @$aref - 1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052941Z" changeid="explorer">
        <seg>$n = @$aref - 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-u  File has setuid bit set.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004748Z" changeid="explorer">
        <seg>-u  Archivo tiene puesto el bit setuid.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider generalizing your
code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere generalizar su código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are the statistics for Perl 5.005_62 on my system:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí están las estadísticas de Perl 5.005_62 en mi sistema:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make -f Makefile.micro patch_uconfig</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make -f Makefile.micro patch_uconfig</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#B&gt;',  12;   # prints &quot;&lt;0B1100&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#B&gt;',  12;   # imprime &quot;&lt;0B1100&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A word boundary (C&lt;\b&gt;) is a spot between two characters
that has a C&lt;\w&gt; on one side of it and a C&lt;\W&gt; on the other side
of it (in either order), counting the imaginary characters off the
beginning and end of the string as matching a C&lt;\W&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un límite de palabra (C&lt;\b&gt;) es un punto que hay entre dos caracteres que tienen un C&lt;\w&gt; a un lado y un C&lt;\W&gt; al otro lado de él (en cualquier orden), contando con los caracteres imaginarios del principio y final de la cadena coincidentes con un C&lt;\W&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Add one to the value of any numbers in the string</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Suma uno al valor de todos los números en la cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preserve the string matched such that ${^PREMATCH}, ${^MATCH}, and
${^POSTMATCH} are available for use after matching.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Preserva la cadena coincidente, de tal manero que ${^PREMATCH}, ${^MATCH} y ${^POSTMATCH} están disponibles para su uso después de la comprobación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Here There Be Pods!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 ¡Aquí estarán los Pods!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C style for loop is rarely needed in Perl since Perl provides
the more friendly list scanning C&lt;foreach&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225152Z" changeid="explorer">
        <seg>El bucle for de C no se suele usar, ya que Perl proporciona una alternativa más sencilla para recorrer listas, el bucle C&lt;foreach&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is portable only when all platforms sharing packed data use the
same binary representation for signed integers; for example, when all
platforms use two's-complement representation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es portátil solo cuando todas las plataformas compartiendo datos empaquetados usa la misma representación binaria de enteros con signo; por ejemplo, cuando todas las plataformas utilizan la representación de complemento a dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item splice ARRAY,OFFSET,LENGTH,LIST
X&lt;splice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201112Z" changeid="explorer">
        <seg>=item splice ARRAY,DESPLAZAMIENTO,LONGITUD,LISTA
X&lt;splice&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Written by Jarkko Hietaniemi &lt;F&lt;jhi@iki.fi&gt;&gt;, with many contributions
from The Perl Porters and Perl Users submitting feedback and patches.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Escrito por Jarkko Hietaniemi &lt;F&lt;jhi@iki.fi&gt;&gt;, con muchas contribuciones de los I&lt;Perl Porters&gt; y usuarios Perl que suministraron comentarios y revisiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($x_lo, $x_hi,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053106Z" changeid="explorer">
        <seg>my ($x_lo, $x_hi,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$oldfh = select(HANDLE); $| = 1; select($oldfh);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$anterior_fh = select(HANDLE); $| = 1; select($anterior_fh);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;Neither POD nor CODE!?&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;Ni POD ni CÓDIGO!?&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bit::Vector		manipulate bit vectors fast (uses C)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bit::Vector              manipula vectores bit rápidamente (usa C)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;W/a&quot;, &quot;\04Gurusamy&quot;)            gives (&quot;Guru&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;W/a&quot;, &quot;\04Gurusamy&quot;)            da (&quot;Guru&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The difference is largely because Perl 5
does not, even internally, have a boolean type.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(La diferencia es incluso mayor, porque Perl 5 no tiene, incluso internamente, un tipo booleano)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chr</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { $answer = $a / $b; }; warn $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { $respuesta = $a / $b; }; warn $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbeos		Perl notes for BeOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlbeos		Notas para BeOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or technically speaking, a location capable of holding a hard
reference, if it's an array or hash reference being used for
assignment.)  See L&lt;perlreftut&gt; and L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(O técnicamente hablando, un lugar capaz de contener una referencia dura, si se trata de una asignación de una referencia a un array o un hash). Véase L&lt;perlreftut&gt; y L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perltie&gt;,
L&lt;Tie::Hash&gt;, L&lt;Tie::Array&gt;, L&lt;Tie::Scalar&gt;, and L&lt;Tie::Handle&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perltie&gt;, L&lt;Tie::Hash&gt;, L&lt;Tie::Array&gt;, L&lt;Tie::Scalar&gt;, y L&lt;Tie::Handle&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>7 size     total size of file, in bytes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>7 size     tamaño total del archivo, en bytes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't open $foo: $!&quot; unless open(FOO,$foo);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo abrir $foo: $!&quot; unless open(FOO,$foo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLASSNAME is the name of a class implementing objects
of correct type.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CLASE es el nombre de la clase que implementa objetos del tipo correcto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_CTIME 	   if $opt_c;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_CTIME 	   if $opt_c;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getsockname SOCKET
X&lt;getsockname&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173716Z" changeid="explorer">
        <seg>=item getsockname SOCKET
X&lt;getsockname&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;$/&gt; is set to C&lt;undef&gt;
(sometimes known as file-slurp mode) and the file is empty, it
returns C&lt;''&gt; the first time, followed by C&lt;undef&gt; subsequently.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando C&lt;$/&gt; está configurado a C&lt;undef&gt; (a veces conocido como modo sorber-el-archivo) y el archivo está vacío, devuelve C&lt;''&gt; la primera vez, seguido por un C&lt;undef&gt;, posteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless ($return = do $file) {
            warn &quot;couldn't parse $file: $@&quot; if $@;
            warn &quot;couldn't do $file: $!&quot;    unless defined $return;
            warn &quot;couldn't run $file&quot;       unless $return;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044023Z" changeid="explorer">
        <seg>unless ($return = do $file) {
            warn &quot;no puedo analizar $file: $@&quot; if $@;
            warn &quot;no puedo hacer $file: $!&quot;    unless defined $return;
            warn &quot;no puedo ejecutar $file&quot;     unless $return;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/(\d+)/1 + $1/eg;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/(\d+)/1 + $1/eg;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator quotes (and possibly compiles) its I&lt;STRING&gt; as a regular
expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este operador entrecomilla (y posiblemente compila) I&lt;CADENA&gt; como una expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ARGV = map { /\.(gz|Z)$/ ? &quot;gzip -dc &lt; $_ |&quot; : $_ } @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054421Z" changeid="explorer">
        <seg>@ARGV = map { /\.(gz|Z)$/ ? &quot;gzip -dc &lt; $_ |&quot; : $_ } @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/pattern/) {{</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/patrón/) {{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Metacharacters</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Metacaracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replace any occurrence of C&lt;if BLOCK&gt; by C&lt;if (do BLOCK)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Reemplace cada ocurrencia de C&lt;if BLOQUE&gt; por C&lt;if (do BLOQUE)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIRSTKEY this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FIRSTKEY este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0       use zeros, not spaces, to right-justify</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0       usa ceros, no espacios, justificados a la derecha</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function msgrcv to receive a message from
message queue ID into variable VAR with a maximum message size of
SIZE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC msgrcv para recibir un mensaje desde la cola de mensaje ID en la variable VAR con un tamaño máximo de mensaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;()&gt; group is a sub-TEMPLATE enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un grupo C&lt;()&gt; es una sub-PLANTILLA encerrada entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 For Loops
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042052Z" changeid="explorer">
        <seg>=head2 Bucles for
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item localtime</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item localtime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CGCC-2.7.2.x
that comes with the DG/UX OS does NOT know the -pthread
switch.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CGCC-2.7.2.x que viene con el sistema operativo DG/UX NO conoce la opción -pthread.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item p
X&lt;/p&gt; X&lt;regex, preserve&gt; X&lt;regexp, preserve&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222833Z" changeid="explorer">
        <seg>=item p
X&lt;/p&gt; X&lt;regex, preserve&gt; X&lt;regexp, preserve&gt; X&lt;regex, preservar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;''&gt;, C&lt;q//&gt;, C&lt;tr'''&gt;, C&lt;y'''&gt;, the replacement of C&lt;s'''&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item C&lt;''&gt;, C&lt;q//&gt;, C&lt;tr'''&gt;, C&lt;y'''&gt;, y el reemplazo de C&lt;s'''&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>each file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>por cada archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Changes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Cambios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, if you try this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, si intenta esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior may disappear in future versions of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comportamiento puede desaparecer en futuras versiones de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select STDOUT; $| = 1;  # make unbuffered</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select STDOUT; $| = 1;  # hacerlo sin buffers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub square {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235522Z" changeid="zipf">
        <seg>sub cuadrado {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, you cannot expect it to be a
&quot;creation time&quot;, see L&lt;perlport/&quot;Files and Filesystems&quot;&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, no puede esperar que sea el &quot;tiempo de creación&quot;, véase L&lt;perlport/&quot;Archivos y sistemas de archivos&quot;&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following documentation is written in euc-jp encoding.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055053Z" changeid="explorer">
        <seg>The following documentation is written in euc-jp encoding.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array   Hash      hash keys intersection   grep { exists $b-&gt;{$_} } @$a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Array       Hash       claves hash intersección         grep { exists $b-&gt;{$_} } @$a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset;          # just reset ?one-time?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>reset;          # sólo reinicia las ?una-vez?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may also be
information at http://www.perl.org, the Perl Home Page.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede haber información en http://www.perl.org/, La página oficial de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although these are grouped by family, they all have the precedence
of assignment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque estos están agrupados por familia, todos ellos tienen la precedencia de la asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(NOTE: If FILEHANDLE is a variable and
the next token is a term, it may be misinterpreted as an operator
unless you interpose a C&lt;+&gt; or put parentheses around the arguments.)
If FILEHANDLE is omitted, prints to standard output by default, or
to the last selected output channel; see L&lt;/select&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(NOTA: Si GESTOR_ARCHIVO es una variable y el siguiente símbolo es un término, puede ser mal interpretado como un operador a menos que se interponga un C&lt;+&gt; o poner entre paréntesis los argumentos). GESTOR_ARCHIVO, si se omite, se imprime en la salida estándar por defecto, o al canal de salida seleccionado la última vez, ver L&lt;/select&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-g  File has setgid bit set.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004804Z" changeid="explorer">
        <seg>-g  Archivo tiene puesto el bit setgid.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $count, &quot;\n&quot;; sleep(1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $cuenta, &quot;\n&quot;; sleep(1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is the string C&lt;&quot;\0X\0\0YZ&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es la cadena C&lt;&quot;\0X\0\0YZ&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;accept&gt;, C&lt;bind&gt;, C&lt;connect&gt;, C&lt;getpeername&gt;, C&lt;getsockname&gt;,
C&lt;getsockopt&gt;, C&lt;listen&gt;, C&lt;recv&gt;, C&lt;send&gt;, C&lt;setsockopt&gt;, C&lt;shutdown&gt;,
C&lt;socket&gt;, C&lt;socketpair&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202131Z" changeid="explorer">
        <seg>C&lt;accept&gt;, C&lt;bind&gt;, C&lt;connect&gt;, C&lt;getpeername&gt;, C&lt;getsockname&gt;,
C&lt;getsockopt&gt;, C&lt;listen&gt;, C&lt;recv&gt;, C&lt;send&gt;, C&lt;setsockopt&gt;, C&lt;shutdown&gt;,
C&lt;socket&gt;, C&lt;socketpair&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use warnings qw(all);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use warnings qw(all);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to get a month name from a list:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto hace que sea fácil obtener un nombre de mes desde una lista:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also call C&lt;die&gt; with a reference argument, and if this is trapped
within an C&lt;eval&gt;, C&lt;$@&gt; contains that reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede llamar a C&lt;die&gt; con una referencia como argumento, y si éste queda atrapado en un C&lt;eval&gt;, C&lt;$@&gt; contiene esa referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, concatenates the
elements of LIST and returns a string value with all characters
in the opposite order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, concatena los elementos LISTA y devuelve un valor de cadena con todos los caracteres en orden inverso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Formats likely
to be of most use are integer-packing ones like C&lt;n&gt; for Java strings,
C&lt;w&gt; for ASN.1 or SNMP, and C&lt;N&gt; for Sun XDR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Formatos de mayor uso son los empaquetados de enteros como C&lt;n&gt; para las cadenas de Java, C&lt;w&gt; de ASN.1 o SNMP, y C&lt;N&gt; de XDR de Sun</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub require {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub require {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In a scalar context, returns the number of values.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En contexto escalar, devuelve el número de valores).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Smart matching
is described in L&lt;perlsyn/&quot;Smart matching in detail&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincidencia inteligente se describe en L&lt;perlsyn/&quot;Coincidencia inteligente en detalle&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ioctl FILEHANDLE,FUNCTION,SCALAR
X&lt;ioctl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211628Z" changeid="explorer">
        <seg>=item ioctl GESTOR_ARCHIVO,FUNCIÓN,ESCALAR
X&lt;ioctl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the second C&lt;\&gt; in C&lt;qq/\c\/&gt; is interpreted as a part
of C&lt;\/&gt;, and the following C&lt;/&gt; is not recognized as a delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, el segundo C&lt;\&gt; en C&lt;qq/\c\/&gt; es interpretado como una parte de C&lt;\/&gt;, y el siguiente C&lt;/&gt; no es reconocido como un delimitador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the C&lt;continue&gt; keyword to fall through from one
case to the next:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar el identificador C&lt;continue&gt; para pasar de un caso al siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open IN, $ARGV[0];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open IN, $ARGV[0];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpod		Perl plain old documentation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlpod		Documentación en texto llano</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For historical reasons, some values work on almost every system
supported by Perl: 0 means read-only, 1 means write-only, and 2
means read/write.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por razones históricas, algunos valores funcionan en casi todos los sistemas soportados por Perl: 0 significa solo lectura, 1 significa sólo escritura y 2 significa lectura y escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus you can use any of the loop control
statements in it to leave or restart the block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013459Z" changeid="explorer">
        <seg>Así que puede usar cualquiera de las instrucciones de control de bucle dentro de él para salir o reiniciarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir $foo * 20;	# chdir ($foo * 20)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir $foo * 20;	# chdir ($foo * 20)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the umask for the process to EXPR and returns the previous value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Establece la umask para el proceso a EXPR y devuelve el valor anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, Perl overloads
certain operations based on whether the expected return value is
singular or plural.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, Perl sobrecarga ciertas operaciones basándose en si el valor de retorno esperado es singular o plural.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>form that you can possibly imagine, not even excepting</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>forma que pueda posiblemente imaginar, incluyendo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FILEHANDLE, &quot;&lt;&amp;=$fd&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FILEHANDLE, &quot;&lt;&amp;=$fd&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside an C&lt;eval&gt; the error message is stuffed
into C&lt;$@&gt; and the C&lt;eval&gt; is terminated with the undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170737Z" changeid="explorer">
        <seg>Dentro de un C&lt;eval()&gt;, el mensaje de error es colocado en C&lt;$@&gt; y el C&lt;eval&gt; termina con el valor I&lt;undef&gt; (indefinido).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of C&lt;ref&gt; as a C&lt;typeof&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede pensar en C&lt;ref&gt; como un operador C&lt;typeof&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/%(.)/$percent{$1} || $&amp;/ge;	# expr now, so /e</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/%(.)/$porciento{$1} || $&amp;/ge; # ahora es una expr., así que /e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%4d %s\n&quot;, $hash{$key}, $key;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%4d %s\n&quot;, $hash{$clave}, $clave;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key distinction between systems that need
C&lt;binmode&gt; and those that don't is their text file formats.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La distinción clave entre los sistemas que requieren C&lt;binmode&gt; y los que no, es en sus formatos de archivo de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Operator Precedence and Associativity
X&lt;operator, precedence&gt; X&lt;precedence&gt; X&lt;associativity&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T232300Z" changeid="explorer">
        <seg>=head2 Precedencia de operadores y asociatividad
X&lt;operator, precedence&gt; X&lt;precedence&gt; X&lt;associativity&gt; X&lt;operador, precedencia&gt; X&lt;precedencia&gt; X&lt;asociatividad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item localtime EXPR
X&lt;localtime&gt; X&lt;ctime&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T190706Z" changeid="explorer">
        <seg>=item localtime EXPR
X&lt;localtime&gt; X&lt;ctime&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-R  File is readable by real uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004542Z" changeid="explorer">
        <seg>-R  Archivo es legible por el uid/gid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlstyle - Perl style guide</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlstyle - Guía de estilo Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to select on many filehandles, you may wish to write a
subroutine like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea seleccionar en muchos gestores de archivo, puede desear escribir una subrutina de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the C&lt;%a&gt; and C&lt;%b&gt;, the short forms of the day of the week
and the month of the year, may not necessarily be three characters wide.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;%a&gt; y C&lt;%b&gt;, las formas cortas del día de la semana y el mes del año, pueden no ser necesariamente de tres caracteres de ancho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($line =~ s/\\$//) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($linea =~ s/\\$//) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Low-level socket functions
X&lt;socket&gt; X&lt;sock&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202127Z" changeid="explorer">
        <seg>=item Funciones de bajo nivel de sockets
X&lt;socket&gt; X&lt;sock&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Systems
like Unix, Mac OS, and Plan 9, that end lines with a single
character and encode that character in C as C&lt;&quot;\n&quot;&gt; do not
need C&lt;binmode&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los sistemas como Unix, Mac OS, y Plan 9, cuyos finales de línea terminan con un único carácter y codifican ese carácter en C como C&lt;&quot;\n&quot;&gt; no necesitan C&lt;binmode&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the current position for the C&lt;readdir&gt; routine on DIRHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Establece la posición actual de la rutina C&lt;readdir&gt; en GESTOR_DIR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals are usually delimited by either single or double
quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los literales de cadena se suelen delimitar con comillas simples o dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar
context, returns the number of times the expression was true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el número de veces que la expresión fue verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print `sort`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print `sort`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL for (EXPR; EXPR; EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA for (EXPR; EXPR; EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.........</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>.........</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UPPERCASE line-noise lowercase line-noise lowercase line-noise</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>MAYÚSCULAS línea-ruidosa minúsculas línea-ruidosa minúsculas línea-ruidosa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The defined test avoids problems where line has a string
value that would be treated as false by Perl, for example a &quot;&quot; or
a &quot;0&quot; with no trailing newline.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La prueba de definición evita problemas donde la línea contiene un valor de cadena que sería tratado como falso por Perl, como por ejemplo, un &quot;&quot; o un &quot;0&quot; sin salto de línea final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>join() could return garbage when the same join() statement was used to
process 8 bit data having earlier processed UTF8 data, due to the flags
on that statement's temporary workspace not being reset correctly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012236Z" changeid="explorer">
        <seg>join() podría devolver basura cuando la misma instrucción join() fue anteriormente usada para procesar datos de 8 bits habiendo procesado anteriormente datos UTF8, debido a que las banderas en ese área de trabajo temporal no eran correctamente reinicializadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always returns
1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre devuelve 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;default&gt; behaves exactly like C&lt;when(1 == 1)&gt;, which is
to say that it always matches.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;default&gt; se comporta exactamente igual que C&lt;when(1 == 1)&gt;, que es lo mismo que decir que siempre coincide.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raises an exception when used on a machine that doesn't
implement POSIX setpgid(2) or BSD setpgrp(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Eleva una excepción si se usa en una máquina que no implemente POSIX setpgid(2) o BSD setpgrp(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/sort&gt; for examples
of how to arrange for an output ordering.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlfunc/sort&gt; para ejemplos de cómo organizar una salida ordenada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, the return values from the
various get routines are as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, los valores devueltos por varias de ellas son como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler bug has been
reported to SGI.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003826Z" changeid="explorer">
        <seg>El error del compilador ha sido reportado a SGI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\     references      $$foo[1]       aka $foo-&gt;[1]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234004Z" changeid="explorer">
        <seg>\     referencias    $$foo[1]       igual que $foo-&gt;[1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ref_to_AoA is a reference to an
array, whereas @AoA is an array proper.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ref_to_AoA es una referencia a un array, mientras que @AoA es un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system(&quot;program args 1&gt;program.stdout 2&gt;program.stderr&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system(&quot;programa argumentos 1&gt;programa.stdout 2&gt;programa.stderr&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-cw&gt; ] [ B&lt;-d&gt;[B&lt;t&gt;][:I&lt;debugger&gt;] ] [ B&lt;-D&gt;[I&lt;number/list&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-cw&gt; ] [ B&lt;-d&gt;[B&lt;t&gt;][:I&lt;debugger&gt;] ] [ B&lt;-D&gt;[I&lt;número/lista&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 ctime  just use                    @INC  include paths</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>10 ctime  solo usar                   @INC  rutas de inclusión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call srand($seed) with the same $seed to reproduce the
I&lt;same&gt; sequence from rand(), but this is usually reserved for
generating predictable results for testing or debugging.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede llamar a srand($semilla) con la misma $semilla para reproducir la I&lt;misma&gt; secuencia desde rand(), pero esto generalmente se reserva para la generación de resultados predecibles para pruebas o depuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If either operand of scalar &quot;..&quot; is a constant expression,
that operand is considered true if it is equal (C&lt;==&gt;) to the current
input line number (the C&lt;$.&gt; variable).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si alguno de los operandos del escalar &quot;..&quot; es una expresión constante, este operando es considerado cierto si es igual (C&lt;==&gt;) al número de línea actual de la entrada (la variable C&lt;$.&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In OS X C&lt;setreuid&gt; and friends are troublesome - perl will now work
around their problems as best possible.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En OS X, C&lt;setreuid&gt; y amigos, son molestos; perl ahora trabajará en torno a sus problemas de la mejor manera posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're confused about why you use an '@' there on a hash slice
instead of a '%', think of it like this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T235138Z" changeid="explorer">
        <seg>Si se siente confuso sobre el porqué usa un '@' en una porción de hash en lugar de un '%', piénselo así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To remove a directory tree recursively (C&lt;rm -rf&gt; on Unix) look at
the C&lt;rmtree&gt; function of the L&lt;File::Path&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para eliminar un árbol de directorio recursivamente (C&lt;rm -rf&gt; en Unix) mire la función C&lt;rmtree&gt; del módulo L&lt;File::Path&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception: It is always safe to delete the item most recently
returned by C&lt;each()&gt;, so the following code works properly:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Excepción: siempre es seguro borrar el último ítem devuelto por C&lt;each()&gt;, por lo que entonces el siguiente código funcionará correctamente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On failure, it returns false and sets C&lt;$!&gt;
(errno):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de fallo, se devuelve falso y establece C&lt;$!&gt; (errno):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is subroutine definition, not a real function I&lt;per se&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la definición de subrutina, no una función real I&lt;per se&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failed match normally resets the
search position to the beginning of the string, but you can avoid that
by adding the C&lt;/c&gt; modifier (e.g. C&lt;m//gc&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una coincidencia fallida, normalmente, restablece la posición de búsqueda al principio de la cadena, pero puede evitarlo añadiendo el modificador C&lt;/c&gt; (por ejemplo C&lt;m//gc&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.haiku - Perl version 5.10+ on Haiku</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.haiku - Perl versión 5.10+ en Haiku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.1g&gt;', 100;    # prints &quot;&lt;1e+02&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.1g&gt;', 100;    # imprime &quot;&lt;1e+02&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor as determined by the value
of $^F.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que apoyan la bandera close-on-exec en archivos, esta bandera se establecerá para el descriptor de archivo abierto recientemente según lo determinado por el valor de $^F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/%(.)/$percent{$1}/g;	# change percent escapes; no /e</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/%(.)/$porciento{$1}/g;        # cambia los escapados con el %; sin /e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># prints AbelAxedCainPunishedcatchaseddoggonetoxyz</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># prints AbelAxedCainPunishedcatchaseddoggonetoxyz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Obituary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Obituario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add LC_MESSAGES to POSIX :locale_h export tag</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadir LC_MESSAGES a la etiqueta de exportación :locale_h de POSIX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Most of these one character names have a predefined
significance to Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(La mayor parte de estos nombres de un solo carácter tienen un significado predefinido para Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $dbase, '+&lt;dbase.mine')          # ditto</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $dbase, '+&lt;dbase.mine')          # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef   Any       undefined                !defined($b)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef       Cualquiera indefinido                       !defined($b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>n and m are limited
to non-negative integral values less than a preset limit defined when perl is built.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>n y m están limitados a enteros no negativos menores que un límite predefinido cuando perl se compiló.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is an undefined scalar variable (or array or hash element)
the variable is assigned a reference to a new anonymous filehandle,
otherwise if FILEHANDLE is an expression, its value is used as the name of
the real filehandle wanted.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211744Z" changeid="explorer">
        <seg>Si GESTOR_ARCHIVO es un variable escalar indefinida (o elemento de un array o hash) la variable es asignada a una referencia a un nuevo gestor de archivo anónimo; de lo contrario, si GESTOR_ARCHIVO es una expresión, su valor se utiliza como el nombre del gestor de archivo real buscado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They have strange names so they don't accidentally
collide with one of your normal variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Éstas tienen extraños nombres, y por tanto no pueden colisionar accidentalmente con ninguna de sus variables normales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (%tied_hash) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (%hash_enlazado) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;splice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;splice&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#.6x&gt;', 1;     # prints &quot;&lt;0x000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#.6x&gt;', 1;     # imprime &quot;&lt;0x000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to replace such an alphanumeric name with an expression
that returns a reference to the appropriate type.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es posible sustituir cualquier nombre alfanumérico por una expresión que devuelva una referencia a un dato del tipo apropiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A '?' maps to the DEL character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un '?' mapea al carácter DEL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpgrp PID
X&lt;getpgrp&gt; X&lt;group&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173531Z" changeid="explorer">
        <seg>=item getpgrp PID
X&lt;getpgrp&gt; X&lt;group&gt; X&lt;grupo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp; s//MARGE $1 MARGE/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;&amp; s//MARGE $1 MARGE/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$a ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$a ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, this isn't important because you automatically
get them all anyway.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, esto no es importante, ya que, de todos modos, los obtiene automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%06s&gt;', 12;   # prints &quot;&lt;000012&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%06s&gt;', 12;   # imprime &quot;&lt;000012&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make perl fork() safe even on platforms that don't have pthread_atfork()</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hacer que el fork() de perl sea seguro incluso en plataformas que no tienen pthread_atfork()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function implementing
the C&lt;\u&gt; escape in double-quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la función interna del escapado C&lt;\u&gt; en las cadenas doblemente entrecomilladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...			# code for each line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>...			# código por cada línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... except inside quoted strings:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230706Z" changeid="zipf">
        <seg>... salvo cuando está entre comillas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a private exception trap for divide-by-zero</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un trampa privada para una excepción de división-por-cero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to test whether you can write,
either use file tests or try setting a dummy hash entry inside an C&lt;eval&gt; 
to trap the error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere comprobar si puede escribir o no, use test de archivo o intente asignar una entrada hash ficticia dentro de un C&lt;eval&gt;, para atrapar el error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may also be
information at http://www.perl.com/, the Perl Home Page.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede haber información en http://www.perl.com/, La página oficial de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># These evaluate exit before doing the print:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Evalúan exit antes de hacer el print:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!=  inequality</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120430Z" changeid="zipf">
        <seg>!=  distinto que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is C&lt;... &amp;&amp; ...&gt; or C&lt;... and ...&gt;, the test
is applied recursively to both arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es C&lt;... &amp;&amp; ...&gt; o C&lt;... and ...&gt;, el test se aplica recursivamente a ambos argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\w                  a word character (a-z, A-Z, 0-9, _)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230250Z" changeid="zipf">
        <seg>\w                  un carácter de palabra (a-z, A-Z, 0-9, _)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unpack TEMPLATE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item unpack PLANTILLA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ref_to_AoA-&gt;[2][2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ref_to_AoA-&gt;[2][2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when backslashes are used as the delimiters (like C&lt;qq\\&gt; and
C&lt;tr\\\&gt;), nothing is skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, cuando se usan las barras invertidas como delimitadores (como C&lt;qq\\&gt; y C&lt;tr\\\&gt; ), no se omite nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setprotoent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setprotoent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TEMPLATE has the same format as in the C&lt;pack&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La PLANTILLA tiene el mismo formato que en la función C&lt;pack&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s{}{}	    Substitution	  yes*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s{}{}	    Substitución	  sí*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eof;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eof;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation improved</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mejor documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loops, subroutines and other
control structures allow you to jump around within the code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bucles, subrutinas y otras estructuras de control le permiten saltar a lo largo del código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some passes discussed below are performed concurrently, but because
their results are the same, we consider them individually.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos pases discutidos a continuación se realizan de forma simultanea, pero como sus resultados son los mismos, los consideramos por separado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@files = glob(&quot;$dir/*.[ch]&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@archivos = glob(&quot;$dir/*.[ch]&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates EXPR and exits immediately with that value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa EXPR y sale inmediatamente con este valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exec LIST
X&lt;exec&gt; X&lt;execute&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171653Z" changeid="explorer">
        <seg>=item exec LISTA
X&lt;exec&gt; X&lt;execute&gt; X&lt;ejecutar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should also always run under C&lt;use strict&gt; or know the
reason why not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debería siempre también correr con C&lt;use strict&gt; o conocer la razón de porqué no hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item length</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item length</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it isn't a goto in the normal sense at all, and
doesn't have the stigma associated with other gotos.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De hecho, no es un goto en el sentido normal y no tiene el estigma asociado con los otros gotos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar is a 
single string (of any size, limited only by the available memory),
number, or a reference to something (which will be discussed
in L&lt;perlref&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234241Z" changeid="explorer">
        <seg>Un escalar es una cadena de caracteres (de cualquier tamaño, limitada únicamente por la memoria disponible), un número o una referencia a algo (esto se tratará en L&lt;perlref&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr/a-zA-Z//s;		# bookkeeper -&gt; bokeper</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr/a-zA-Z//s;		# coonnttaable -&gt; contable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push $AoA[0], &quot;wilma&quot;, &quot;betty&quot;;  # WRONG!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push $AoA[0], &quot;wilma&quot;, &quot;betty&quot;;  # ¡MAL!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If three or more arguments are specified then the mode of opening and
the filename are separate.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se especifican tres o más argumentos entonces el modo de apertura y el nombre del archivo están separados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you get complaints about so_locations then search in the file
hints/irix_6.sh for &quot;lddflags&quot; and do the suggested adjustments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003930Z" changeid="explorer">
        <seg>Si recibe problemas sobre so_locations entonces busque en el archivo hints/irix_6.sh por &quot;lddflags&quot; y haga los ajustes sugeridos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$semop = pack(&quot;s!3&quot;, $semnum, -1, 0);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$semop = pack(&quot;s!3&quot;, $semnum, -1, 0);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 2) = 2   ==         32 00000100000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 2) = 2   ==         32 00000100000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Breaking complex templates into
individual line-by-line components, suitably annotated, can do as much to
improve legibility and maintainability of pack/unpack formats as C&lt;/x&gt; can
for complicated pattern matches.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Rompiendo plantillas complejas en líneas individuales, debidamente comentadas, puede servir para mejorar la legibilidad y facilitar el mantenimiento de los formatos pack/unpack, como C&lt;/x&gt; lo es para las expresiones regulares complicadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># This is the UTF-8 encoding of the string in the previous example</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Esta es la codificación UTF-8 de la cadena del ejemplo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A second C&lt;e&gt; modifier will cause the replacement portion
to be C&lt;eval&gt;ed before being run as a Perl expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un segundo modificador C&lt;e&gt; hará que la parte de reemplazo sea C&lt;eval&gt;uada antes de la ejecución como una expresión Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general rule is
that the identifier must be a string literal.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La regla general es que el identificador debe ser una cadena literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates the BLOCK or EXPR for each element of LIST (locally setting
C&lt;$_&gt; to each element) and returns the list value composed of the
results of each such evaluation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa el BLOQUE o EXPR para cada elemento de LISTA (poniendo localmente C&lt;$_&gt; a cada elemento) y devuelve una lista de valores compuesta de los resultados de cada evaluación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Socket;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Socket;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Find a hex digit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Buscar un dígito hexadecimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Changed Internals</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Cambios internos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implements the fcntl(2) function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Implementa la función fcntl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[xyz];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[xyz];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any following text is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier texto que le siga, es ignorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlref		Perl references, the rest of the story</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlref		Referencias, el resto de la historia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension modules can also hook into the Perl parser to define new
kinds of compound statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013431Z" changeid="explorer">
        <seg>Hay módulos de extensiones que también pueden engancharse en el intérprete de Perl para definir nuevas clases de instrucciones compuestas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We recommend that you use void context C&lt;keys @array&gt; for this, but reasoned
that it taking C&lt;values @array&gt; out would require more documentation than
leaving it in.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Le recomendamos que utilice el contexto vacío C&lt;keys @array&gt; para esto, pero razonando que hacer C&lt;values @array&gt; exigirá más comentarios que dejarlo tal cual)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ord(&quot;z&quot;))      gives &quot;2ab&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ord(&quot;z&quot;))      da &quot;2ab&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
argument is omitted, tests C&lt;$_&gt;, except for C&lt;-t&gt;, which tests STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el argumento se omite, se prueba C&lt;$_&gt;, excepto para C&lt;-t&gt;, que prueba STDIN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Better to omit it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es mejor omitirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new filename symbolically linked to the old filename.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea un nuevo nombre de archivo vinculado simbólicamente al nombre del archivo antiguo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if you aren't in doubt, consider the mental welfare of the person
who has to maintain the code after you, and who will probably put
parentheses in the wrong place.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso si usted no tiene dudas, considerar el bienestar mental de la persona que tenga que mantener el código después de usted, y quien seguramente pondrá los paréntesis en el lugar equivocado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you'd like to manually inspect C&lt;system&gt;'s failure, you can check all
possible failure modes by inspecting C&lt;$?&gt; like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea inspeccionar manualmente el fallo de C&lt;system&gt;, puede comprobar todas las posibles causas del fallo mediante la inspección de C&lt;$?&gt; como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $rex;                 # prints (?si-xm:my.STRING)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $rex;                 # imprime (?si-xm:mi.CADENA)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's how you get at elements in an array:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224848Z" changeid="explorer">
        <seg>Para obtener los elementos de un array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ABC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ABC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item *</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;scalar&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;scalar&gt; X&lt;escalar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here $subroutine may be C&lt;(eval)&gt; if the frame is not a subroutine
call, but an C&lt;eval&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí, $subrutina puede ser C&lt;(eval)&gt; si el marco de llamada no es una llamada a una subrutina, sino un C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime(time);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050252Z" changeid="explorer">
        <seg>($seg,$min,$hora,$mdia,$mes,$anno,$sdia,$ydia,$esdst) =
					    localtime(time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add the \[$@%&amp;*] prototype support</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadir soporte al prototipado de \[$@%&amp;*]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} map { [$_, /=(\d+)/, uc($_)] } @old;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} map { [$_, /=(\d+)/, uc($_)] } @viejo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-I&gt;I&lt;dir&gt; ] [ B&lt;-m&gt;[B&lt;-&gt;]I&lt;module&gt; ] [ B&lt;-M&gt;[B&lt;-&gt;]I&lt;'module...'&gt; ] [ B&lt;-f&gt; ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-I&gt;I&lt;dir&gt; ] [ B&lt;-m&gt;[B&lt;-&gt;]I&lt;módulo&gt; ] [ B&lt;-M&gt;[B&lt;-&gt;]I&lt;'módulo...'&gt; ] [ B&lt;-f&gt; ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 4) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 4) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( /$pattern/i ) { }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234640Z" changeid="explorer">
        <seg>if ( /$patron/i ) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is you, if you're thinking about copying or distributing this Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es usted, si usted está pensando en copiar o distribuir este paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user types in a password that is
crypt()'d with the same salt as the stored digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El usuario escribe la contraseña que es en-crypt()-tada con el mismo salto con el que fue almacenado el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = [ split ' ', $line ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$i] = [ split ' ', $linea ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lock($mbox);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lock($mbox);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item substr EXPR,OFFSET</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item substr EXPR,DESPLAZAMIENTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSE this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CLOSE este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So to split
a string into individual characters, the following:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que para dividir una cadena en caracteres individuales, lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all
systems read C&lt;&quot;\r&quot;&gt; as ASCII CR and C&lt;&quot;\n&quot;&gt; as ASCII LF.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No todos los sistemas leen C&lt;&quot;\r&quot;&gt; como ASCII CR y C&lt;&quot;\n&quot;&gt; como ASCII LF.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the string
describing the equivalent prototype is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, se devuelve la cadena que describe el prototipo equivalente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can arrange for a callback to be run just before the C&lt;die&gt;
does its deed, by setting the C&lt;$SIG{__DIE__}&gt; hook.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede disponer que una retrollamada se ejecute antes de que C&lt;die&gt; haga sus funciones, actualizando el gancho C&lt;$SIG{__DIE__}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll need to write something like C&lt;m/\Quser\E\@\Qhost/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tendrá que escribir algo como C&lt;m/\Qusuario\E\@\Qservidor/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are running under C&lt;use strict&gt;, you'll have to add some
declarations to make it happy:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está ejecutando bajo C&lt;use strict&gt;, tendrá que agregar algunas declaraciones para hacerle feliz:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo,  8,  8) = 0x50;   # 'PerlPerlP'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($foo,  8,  8) = 0x50;   # 'PerlPerlP'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL
X&lt;setsockopt&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200553Z" changeid="explorer">
        <seg>=item setsockopt SOCKET,NIVEL,OPCIÓN_NOMBRE,OPCIÓN_VALOR
X&lt;setsockopt&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Perl stringifies uncaught exception messages before display,
you'll probably want to overload stringification operations on
exception objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como Perl convertirá en cadena de caracteres los mensajes de excepción no capturados antes de mostrarlos, quizás quiera sobrecargar las operaciones de conversión a cadena en objetos de excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any list operator (print(), etc.) or any unary operator (chdir(), etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si cualquier operador de lista (print(), etc) o cualquier otro operador unario (chdir(), etc) es seguido por un paréntesis de apertura como el siguiente token, el operador y los argumentos entre paréntesis se considera que son de mayor prioridad, como en una llamada a una función normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VERSION may be either a numeric argument such as 5.006, which will be
compared to C&lt;$]&gt;, or a literal of the form v5.6.1, which will be compared
to C&lt;$^V&gt; (aka $PERL_VERSION).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VERSIÓN puede ser un argumento numérico, como 5.006, que será comparado con C&lt;$]&gt;, o un literal de la forma v5.6.1, que será comparado con C&lt;$^V&gt; (alias de $PERL_VERSION).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because we don't
have special variable types, and Perl needs to know whether to sort
numerically (where 99 is less than 100) or alphabetically (where 100 comes
before 99).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225239Z" changeid="explorer">
        <seg>Porque Perl no distingue el tipo del contenido de las variables y tiene que determinar si debe ordenar numéricamente (99 menor que 100) o alfabéticamente (100 es anterior a 99).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For WHENCE, you may also use the constants C&lt;SEEK_SET&gt;, C&lt;SEEK_CUR&gt;,
and C&lt;SEEK_END&gt; (start of the file, current position, end of the file)
from the Fcntl module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para DESDEDÓNDE puede usar las constantes C&lt;SEEK_SET&gt;,
C&lt;SEEK_CUR&gt;, y C&lt;SEEK_END&gt; (inicio de archivo, posición actual, y fin de archivo) desde el módulo Fcntl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A PATTERN of C&lt;/^/&gt; is treated as if it were C&lt;/^/m&gt;, since it isn't
much use otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un PATRÓN C&lt;/^/&gt; es tratado como si fuera C&lt;/^/m&gt;, ya que de lo contrario no serviría de mucho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = '1234';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$x = '1234';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># In Foo.pm</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># En Foo.pm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the currently selected filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el gestor de archivo seleccionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is at this step that C&lt;\1&gt; is begrudgingly converted to C&lt;$1&gt; in
the replacement text of C&lt;s///&gt;, in order to correct the incorrigible
I&lt;sed&gt; hackers who haven't picked up the saner idiom yet.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es en este paso que C&lt;\1&gt; es convertido, de mala gana, en C&lt;$1&gt; en el texto de reemplazo de C&lt;s///&gt;, con el fin de corregir a los incorregibles hackers de I&lt;sed&gt; que todavía no han aprendido la correcta forma de indicar esta expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Password: &quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Contraseña: &quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An
exception is raised if VERSION is greater than the version of the
current Perl interpreter; Perl will not attempt to parse the rest of the
file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se genera una excepción si la VERSIÓN es mayor que la versión del intérprete actual de Perl; Perl no tratará de analizar el resto del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All documentation
of this version of Perl therefore refers to &quot;layers&quot; rather than to
&quot;disciplines&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toda documentación desde esta versión de Perl se refiere a &quot;capas&quot; en vez de a &quot;disciplinas&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::GMP		another one using an external C library</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::GMP                otro usando una biblioteca C externa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an element off the end of the string is written to, Perl will first
extend the string with sufficiently many zero bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se escribe un elemento al final de la cadena, Perl primero extenderá la cadena con una cantidad suficiente de bytes cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, each converted value looks
like its machine-level representation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente, cada valor convertido se parece a su representación a nivel de máquina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &quot;'&quot; is the delimiter, no interpolation is performed on the PATTERN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si &quot;'&quot; &quot;es el delimitador, no se realiza interpolación en el PATRÓN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmacos		Perl notes for Mac OS (Classic)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmacos		Notas para Mac OS (Classic)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, the behaviour of C&lt;sort()&gt; is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, el comportamiento de C&lt;sort()&gt; es indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$/ = &quot;\n&quot;;        # put back to normal input delimiter</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$/ = &quot;\n&quot;;           # volvemos al delimitador de entrada normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match 0 or more times, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide con 0 o más veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or perhaps as a real reference, like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o tal vez como una referencia real, de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such use shall not be
construed as a distribution of this Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal uso no debe interpretarse como una distribución de este Paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, quoted strings cannot span multiple lines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por último, las cadenas entrecomilladas no puede abarcar varias líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsec&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsec&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you know what version or patchlevel a particular feature was
implemented, you can test C&lt;$]&gt; (C&lt;$PERL_VERSION&gt; in C&lt;English&gt;) to see if it
will be there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted sabe en qué versión o patchlevel fue implementada una cierta característica, puede comprobar C&lt;$]&gt; (C&lt;$PERL_VERSION&gt; en C&lt;English&gt;) para ver si está incluida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@part = @{ $AoA[4] } [ 7..12 ];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194737Z" changeid="explorer">
        <seg>@part = @{ $AoA[4] } [ 7..12 ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3 nlink    number of (hard) links to the file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3 nlink    número de enlaces (duros) al archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Same as C&lt;y///&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Igual que el C&lt;y///&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The L&lt;Time::gmtime&gt; and L&lt;Time::localtime&gt; modules provides a convenient,
by-name access mechanism to the gmtime() and localtime() functions,
respectively.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los módulos L&lt;Time::gmtime&gt; y L&lt;Time::localtime&gt; proporcionan convenientes mecanismos de acceso por nombres para las funciones gmtime() y localtime(), respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This file contains instructions how to build Perl for Haiku and lists
known problems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este archivo contiene instrucciones de cómo construir Perl para Haiku y listas de problemas conocidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec @args;               # subject to shell escapes
                                # if @args == 1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044348Z" changeid="explorer">
        <seg>exec @args;               # sujeto a los escapados del shell
                                # if @args == 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With an C&lt;eval&gt;, you should be especially careful to remember what's
being looked at when:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dentro de C&lt;eval&gt;, debe, especialmente, recordar que es lo que está haciendo en cada momento:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl570delta	Perl changes in version 5.7.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl570delta	Cambios en la versión 5.7.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$success = 1, last if /$pat/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$exito = 1, last if /$pat/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;TTY&gt; =~ /^y/i &amp;&amp; foo();	# do foo if desired</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;TTY&gt; =~ /^s/i &amp;&amp; foo();	# hacer foo() si así se desea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or maybe even this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193925Z" changeid="explorer">
        <seg>o tal vez incluso así.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Perl Functions by Category
X&lt;function&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043338Z" changeid="explorer">
        <seg>=head2 Funciones Perl por categoría
X&lt;function&gt; X&lt;función&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 mode   2 hour       2 line         $/    input separator</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2 mode   2 hora       2 línea        $/    sep. entrada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These various prefixes correspond to the fopen(3) modes of C&lt;'r'&gt;,
C&lt;'r+'&gt;, C&lt;'w'&gt;, C&lt;'w+'&gt;, C&lt;'a'&gt;, and C&lt;'a+'&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos prefijos se corresponden con los modos de la función fopen(3) de C&lt;'r'&gt;, C&lt;'r+'&gt;, C&lt;'w'&gt;, C&lt;'w+'&gt;, C&lt;'a'&gt; y C&lt;'a+'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This subroutine is called as above, but the first parameter is
the array reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta subrutina se llama como antes, pero el primer parámetro es la referencia al array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several memory leaks associated with variables shared between threads
have been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Varias agotamientos de memoria, asociados con variables compartidas entre hilos han sido corregidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;U4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;U4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However any other combinations of C&lt;\&gt; followed by a character
are not substituted but only skipped, in order to parse them
as regular expressions at the following step.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No obstante, cualquier otra combinación de C&lt;\&gt; seguido de un carácter no va a ser sustituido, sino sólo obviado, con el fin de analizarlos como expresiones regulares en el paso siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Interpolation
X&lt;interpolation&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010450Z" changeid="explorer">
        <seg>=item Interpolación
X&lt;interpolation&gt; X&lt;interpolación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The possible
modifiers are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los posibles modificadores son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;/&gt; will
finish the regular expression, C&lt;\/&gt; will be stripped to C&lt;/&gt; on
the previous step, and C&lt;\\/&gt; will be left as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;/&gt; terminará la expresión regular, C&lt;\/&gt; será reducido a C&lt;/&gt; en el paso anterior, y C&lt;\\/&gt; será mantenido tal cual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last LINE if $foo;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last LINEA if $foo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is just a funny way to write</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es sólo una manera divertida de escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Cwd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Cwd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add -Wall in cflags when compiling with gcc to weed out dubious
C practices</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadir -Wall en cflags cuando se compila con gcc para eliminar prácticas dudosas de C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, '-|', &quot;cat&quot;, '-n', $file);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, '-|', &quot;cat&quot;, '-n', $archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function should have been named wantlist() instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función debería haber sido nombrada wantlist().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Feynman&quot; =&gt; &quot;Richard&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;Feynman&quot; =&gt; &quot;Richard&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the time, C&lt;when(EXPR)&gt; is treated as an implicit smart match of
C&lt;$_&gt;, i.e. C&lt;$_ ~~ EXPR&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayor parte de los casos, C&lt;when(EXPR)&gt; es tratado como una coincidencia inteligente implícita de C&lt;$_&gt;, es decir, C&lt;$_ ~~ EXPR&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing, but less efficient</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, pero menos eficiente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Character mode is the default unless the format string 
starts with C&lt;U&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El modo carácter es el defecto a menos que la cadena de formato se inicia con C&lt;U&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll assume an @AoA
variable as before.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194658Z" changeid="explorer">
        <seg>Vamos a suponer una variable @AoA, como antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from sort&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>desde sort&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A useful idiom for C&lt;lex&gt;-like scanners is C&lt;/\G.../gc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un modismo útil para escáneres tipo C&lt;lex&gt; es C&lt;/\G.../gc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item g and c
X&lt;/g&gt; X&lt;/c&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222841Z" changeid="explorer">
        <seg>=item g y c
X&lt;/g&gt; X&lt;/c&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example in
L&lt;perlipc/&quot;Sockets: Client/Server Communication&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el ejemplo en L&lt;perlipc/&quot;Sockets: Comunicación Cliente/Servidor&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The numbered match variables ($1, $2, $3, etc.) and the related punctuation
set (C&lt;$+&gt;, C&lt;$&amp;&gt;, C&lt;$`&gt;, C&lt;$'&gt;, and C&lt;$^N&gt;) are all dynamically scoped
until the end of the enclosing block or until the next successful
match, whichever comes first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las variables numerales de coincidencia ($1, $2, $3, etc.)  y sus versiones especiales (C&lt;$+&gt;, C&lt;$&amp;&gt;, C&lt;$`&gt;, C&lt;$'&gt;, y C&lt;$^N&gt;) están todas ellas dinámicamente encerradas en un ámbito hasta el final del bloque o hasta la siguiente coincidencia exitosa, lo que ocurra antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously, the C code implementing $^E
did not preserve C&lt;errno&gt;, so reading $^E could cause C&lt;errno&gt; and therefore
C&lt;$!&gt; to change unexpectedly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Anteriormente, el código en C que implementaba $^E no preservaba C&lt;errno&gt;, por lo que la lectura de $^E podría causar que C&lt;errno&gt; y, por lo tanto, C&lt;$!&gt; cambiaran de forma inesperada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run Configure with -Duseithreads which will configure Perl with
the Perl 5.8.0 &quot;interpreter threads&quot;, see L&lt;threads&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T012200Z" changeid="explorer">
        <seg>Ejecute Configure con -Duseithreads que configurará Perl con hilos de ejecución Perl 5.8.0 a nivel de intérprete; véase L&lt;threads&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item goto EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item goto EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other restrictions include whether it works on directories,
open files, or pre-existing files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otras restricciones incluyen si funciona en directorios, archivos abiertos, o archivos pre-existentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt; on a C&lt;()&gt; group, this affects
all types inside the group that accept byte-order modifiers,
including all subgroups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt; en un grupo C&lt;()&gt;, afecta a todos los tipos dentro del grupo que acepten a los modificadores de ordenación de bytes, incluyendo a todos los subgrupos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is irrelevant:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T001249Z" changeid="zipf">
        <seg>El espacio en blanco no es significativo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Text\n&quot; if -T _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Texto\n&quot; if -T _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?	   Match 1 or 0 times</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223200Z" changeid="explorer">
        <seg>?	   Coincide 1 o 0 veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;-I&lt;X&gt;&gt;, C&lt;chdir&gt;, C&lt;chmod&gt;, C&lt;chown&gt;, C&lt;chroot&gt;, C&lt;fcntl&gt;, C&lt;glob&gt;,
C&lt;ioctl&gt;, C&lt;link&gt;, C&lt;lstat&gt;, C&lt;mkdir&gt;, C&lt;open&gt;, C&lt;opendir&gt;,
C&lt;readlink&gt;, C&lt;rename&gt;, C&lt;rmdir&gt;, C&lt;stat&gt;, C&lt;symlink&gt;, C&lt;sysopen&gt;,
C&lt;umask&gt;, C&lt;unlink&gt;, C&lt;utime&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;chomp&gt;, C&lt;chop&gt;, C&lt;chr&gt;, C&lt;crypt&gt;, C&lt;hex&gt;, C&lt;index&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;, C&lt;length&gt;, C&lt;oct&gt;, C&lt;ord&gt;, C&lt;pack&gt;, C&lt;q//&gt;, C&lt;qq//&gt;, C&lt;reverse&gt;, C&lt;rindex&gt;, C&lt;sprintf&gt;, C&lt;substr&gt;, C&lt;tr///&gt;, C&lt;uc&gt;, C&lt;ucfirst&gt;, C&lt;y///&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value to pack is too long, the result is truncated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el valor a empaquetar es demasiado largo, el resultado se trunca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and call it with C&lt;perl dangerous.pl 'rm -rfv *|'&gt;, it actually opens a
pipe, executes the C&lt;rm&gt; command and reads C&lt;rm&gt;'s output from that pipe.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y lo llama con C&lt;perl peligroso.pl 'rm -rfv *|'&gt;, realmente abre una tubería, ejecuta el comando C&lt;rm&gt; y lee la salida de C&lt;rm&gt; desde esa tubería.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also subscript a list to get a single element from it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede subindexar una lista para obtener un solo elemento de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfilter		Perl source filters</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfilter		Filtros de código fuente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># pack big-endian 16- and 32-bit unsigned integers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># empaqueta 16 y 32-bit enteros sin signo, en big-endian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} else {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item atan2 Y,X
X&lt;atan2&gt; X&lt;arctangent&gt; X&lt;tan&gt; X&lt;tangent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165537Z" changeid="explorer">
        <seg>=item atan2 Y,X
X&lt;atan2&gt; X&lt;arctangent&gt; X&lt;tan&gt; X&lt;tangent&gt; X&lt;arcotangente&gt; X&lt;tangente&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12874</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12874</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that, for the superuser on the local filesystems, the C&lt;-r&gt;,
C&lt;-R&gt;, C&lt;-w&gt;, and C&lt;-W&gt; tests always return 1, and C&lt;-x&gt; and C&lt;-X&gt; return 1
if any execute bit is set in the mode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También note que, para el superusuario en el sistema de archivos local, los test C&lt;-r&gt;, C&lt;-R&gt;, C&lt;-w&gt; y C&lt;-W&gt; siempre devuelven 1, y C&lt;-x&gt; y C&lt;-X&gt; devuelven 1 si cualquier bit de ejecución está puesto en el modo del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE:&gt; The behaviour of a C&lt;my&gt; statement modified with a statement
modifier conditional or loop construct (e.g. C&lt;my $x if ...&gt;) is
B&lt;undefined&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013221Z" changeid="explorer">
        <seg>B&lt;NOTA:&gt; El comportamiento de una instrucción C&lt;my&gt; modificada con una instrucción de modificador condicional o construcción de bucle (p.e. C&lt;my $x if ...&gt;) es B&lt;indefinido&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlintro		Perl introduction for beginners</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlintro		Perl introducción para principiantes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These arguments are also evaluated
from left to right.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos argumentos también son evaluados de izquierda a derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the bracketing group did not match, the associated backreference won't
match either.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el agrupamiento de los paréntesis no se ha encontrado, la contrareferencia asociada no corresponderá con nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$temp = join($&quot;, @ARGV);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$temporal = join($&quot;, @ARGV);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*d&gt;', -1, 0;   # prints &quot;&lt;0&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*d&gt;', -1, 0;   # imprime &quot;&lt;0&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perl581delta/&quot;Future Directions&quot;&gt; for more soothsaying.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perl581delta/&quot;Direcciones futuras&quot;&gt; para tener una mayor perspectiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (s|({.*}.*){.*}|$1 |) {}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (s|({.*}.*){.*}|$1 |) {}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly 5.8.5's freeze will be at
the end of June, with release by mid July.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, la congelación de 5.8.5 será a finales de junio, con el lanzamiento a mediados de julio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach my $key (keys %hash) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234932Z" changeid="zipf">
        <seg>foreach my $clave (keys %hash) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlretut		Perl regular expressions tutorial</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlretut		Seminario sobre las expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Logical Not
X&lt;operator, logical, not&gt; X&lt;not&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001759Z" changeid="explorer">
        <seg>=head2 Not lógico
X&lt;operator, logical, not&gt; X&lt;not&gt; X&lt;operador, lógico, not&gt; X&lt;not&gt; X&lt;no&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this automatically
filters compressed arguments through B&lt;gzip&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, esto filtrará automáticamente los argumentos comprimidos a través de B&lt;gzip&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may prefer to use the C&lt;each&gt;
function to iterate over large DBM files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede preferir usar la función C&lt;each&gt; para iterar sobre archivos DBM grandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is,
if the left operand is false, the right operand is not even evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, si el operando izquierdo es falso, el operando de la derecha no es ni siquiera evaluado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get at hash elements:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234422Z" changeid="zipf">
        <seg>Para obtener los elementos de un hash:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select(REPORT2);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select(INFORME2);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'f')[$num &amp; 15];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'f')[$numero &amp; 15];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest need it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resto lo necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OO Perl is relatively simple and is implemented using references which
know what sort of object they are based on Perl's concept of packages.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225541Z" changeid="explorer">
        <seg>La programación orientada a objetos en Perl es relativamente sencilla y se implementa con referencias que &quot;conocen&quot; qué tipo de objeto son, basándose en el concepto de paquetes de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See the precedence table in L&lt;perlop&gt;.)  List
operators take more than one argument, while unary operators can never
take more than one argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver la tabla de precedencia en L&lt;perlop&gt;.)  Los operadores de listas toman más de un argumento, mientras que los operadores unarios nunca toman más de un argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The internal state of the random number generator should
contain more entropy than can be provided by any seed, so calling
srand() again actually I&lt;loses&gt; randomness.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El estado interno del generador de números aleatorios debería contener más entropía que la ofrecida por cualquier semilla, así que volver a llamar a srand() realmente hace I&lt;perder&gt; la aleatoriedad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Regular Expressions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Expresiones Regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To read both a command's STDOUT and its STDERR separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004254Z" changeid="explorer">
        <seg>Leer tanto el STDOUT como el STDERR de un comando, pero separadamente, es más fácil hacerlos redireccionar separadamente a archivos, y luego leer esos archivos cuando el programa termine:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To learn how to install modules you download from CPAN, read
L&lt;perlmodinstall&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225606Z" changeid="explorer">
        <seg>Para aprender a instalar los módulos que descargue de CPAN, lea L&lt;perlmodinstall&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, when a quantified subpattern does not allow the rest of the
overall pattern to match, Perl will backtrack.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma predeterminada, cuando un sub-patrón cuantificado no permite que el resto del patrón coincida, Perl dará marcha atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;That doesn't look like a number&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;Esto no parece un número&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Both of these count from 0 to 10.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Estas dos líneas cuentan de 0 a 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub&gt; and L&lt;perlref&gt; for details about subroutines and
references, and L&lt;attributes&gt; and L&lt;Attribute::Handlers&gt; for more
information about attributes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub&gt; y L&lt;perlref&gt; para los detalles acerca de subrutinas y referencias, y L&lt;attributes&gt; y L&lt;Attribute::Handlers&gt; para obtener más información acerca de los atributos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Input from &lt;&gt; comes either from
standard input, or from each file listed on the command line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La entrada desde &lt;&gt; puede venir, ya sea desde la entrada estándar, o de cada archivo listado en la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $INC{$filename}) {
           return 1 if $INC{$filename};
           die &quot;Compilation failed in require&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050939Z" changeid="explorer">
        <seg>if (exists $INC{$archivo}) {
           return 1 if $INC{$archivo};
           die &quot;Falló la compilación en require&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that using C&lt;eval&gt; neither silences Perl from printing
warnings to STDERR, nor does it stuff the text of warning messages into C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado porque usar C&lt;eval&gt; ni silencia a Perl a la hora de imprimir avisos al STDERR, ni rellena el texto de los mensajes de aviso dentro de C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the final match matched C&lt;q&gt; instead of C&lt;p&gt;, which a match
without the C&lt;\G&gt; anchor would have done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Observe que el último emparejamiento es C&lt;q&gt; en vez de C&lt;p&gt;, que una coincidencia sin el anclaje C&lt;\G&gt; habría hecho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Frequently called programs (like CGI scripts) that simply use</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Programas ejecutados frecuentemente (como los scripts CGI) usan, simplemente,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scripts and library files supplied as input to or produced as
output from the programs of this Package do not automatically fall
under the copyright of this Package, but belong to whoever generated
them, and may be sold commercially, and may be aggregated with this
Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las secuencias de comandos y archivos de biblioteca suministrados como entrada o producidos como salida de los programas de este Paquete no quedan automáticamente bajo el copyright de este Paquete, sino que pertenecen a quien los ha generado, y puede ser vendidos comercialmente, y se podrán sumar a este paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two additional lines request from perl to catch various common
problems in your code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224706Z" changeid="explorer">
        <seg>Estas dos líneas adicionales ordenan a perl que detecte diversos problemas comunes en el código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(':', split(/ */, 'hi there')), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(':', split(/ */, 'hola por aqui')), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just because you can subscript a list value like
a normal array does not mean that you can subscript a list value as a
hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo porque usted puede indexar una lista de valores como un array normal no significa que puede indexar una lista de valores como un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Otherwise, If EXPR has the UTF8 flag set</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174629Z" changeid="explorer">
        <seg>=item De lo contrario, si EXPR tiene la bandera UTF8 puesta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tell</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item tell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item flock FILEHANDLE,OPERATION
X&lt;flock&gt; X&lt;lock&gt; X&lt;locking&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211455Z" changeid="explorer">
        <seg>=item flock GESTOR_ARCHIVO,OPERACIÓN
X&lt;flock&gt; X&lt;lock&gt; X&lt;locking&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following problems are encountered with Haiku revision 28311:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los siguientes problemas se encuentran en la versión Haiku 28311:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($ARGV = shift) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($ARGV = shift) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;unless&gt; is the opposite, it executes the statement I&lt;unless&gt;
the condition is true (i.e., if the condition is false).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013035Z" changeid="explorer">
        <seg>C&lt;unless&gt; es el opuesto, ejecuta la instrucción si la condición I&lt;no es&gt; verdadera (e.d., si la condición es falsa).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item cos</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item cos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $hash{A}{B}{$key})       { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $hash{A}{B}{$clave})       { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item length EXPR
X&lt;length&gt; X&lt;size&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175353Z" changeid="explorer">
        <seg>=item length EXPR
X&lt;length&gt; X&lt;size&gt; X&lt;longitud&gt; X&lt;tamaño&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chris Nandor E&lt;lt&gt;pudge@pobox.comE&lt;gt&gt;
continued development and maintenance for the duration of the port's life.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Chris Nandor E&lt;lt&gt;pudge@pobox.comE&lt;gt&gt; continuó el desarrollo y mantenimiento durante la vida útil de esta versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot;Hello, world\n&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233857Z" changeid="zipf">
        <seg>print(&quot;Hola a todos\n&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note: If your rand function consistently returns numbers that are too
large or too small, then your version of Perl was probably compiled
with the wrong number of RANDBITS.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Nota: si su función rand devuelve constantemente números demasiado grandes o demasiado pequeños, entonces su versión de Perl fue, probablemente, compilada con un número incorrecto de RANDBITS).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;Reasonable copying fee&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Cuota razonable por las copias&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading $^E now preserves $!.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Leyendo $^E ahora preserva $!.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;regex, capture buffer&gt; X&lt;regexp, capture buffer&gt;
X&lt;regular expression, capture buffer&gt; X&lt;backreference&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230035Z" changeid="explorer">
        <seg>X&lt;regex, capture buffer&gt; X&lt;regexp, capture buffer&gt;
X&lt;regular expression, capture buffer&gt; X&lt;backreference&gt;
X&lt;regex, buffer de captura&gt; X&lt;regexp, buffer de captura&gt;
X&lt;expresión regular, buffer de captura&gt; X&lt;contrareferencia&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec $shell '-sh';    # pretend it's a login shell</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec $shell '-sh';    # finge que es un shell de login</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of these pseudo-modules import semantics into the current
block scope (like C&lt;strict&gt; or C&lt;integer&gt;, unlike ordinary modules,
which import symbols into the current package (which are effective
through the end of the file).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos de estos pseudo-módulos importa semántica en el ámbito del bloque actual (como C&lt;strict&gt; o C&lt;integer&gt;, a diferencia de los módulos comunes, que importan los símbolos en el paquete actual (que son efectivos hasta el final del archivo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case I&lt;is&gt; significant--&quot;FOO&quot;,
&quot;Foo&quot;, and &quot;foo&quot; are all different names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El tamaño de caja I&lt;es&gt; significativo: &quot;FOO&quot;, &quot;Foo&quot; y &quot;foo&quot; son todos ellos nombres diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;variable, built-in&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;variable, built-in&gt; X&lt;variable, primitiva&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is just like C's comma operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es igual que el operador coma del C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whereas here's how a Perl programmer more comfortable with the idiom might
do it:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y aquí está cómo un programador de Perl, más cómodo con el lenguaje, puede hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;The Third Element is&quot;, $myarray[2], &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El tercer elemento es&quot;, $miarray[2], &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; alphanumeric&quot;),	redo LOOP if /\G[A-Za-z0-9]+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(&quot; alfanumérico&quot;),	redo LOOP if /\G[A-Za-z0-9]+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item do SUBROUTINE(LIST)
X&lt;do&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171435Z" changeid="explorer">
        <seg>=item do SUBRUTINA(LISTA)
X&lt;do&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%s    a string</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%s    una cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It binds even more
tightly than unary minus, so -2**4 is -(2**4), not (-2)**4.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se une aún más estrechamente que la resta unaria, por lo que -2**4 es -(2**4), no (-2)**4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BUILD</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 BUILD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also be careful not to
follow the print keyword with a left parenthesis unless you want
the corresponding right parenthesis to terminate the arguments to
the print; put parentheses around all the arguments 
(or interpose a C&lt;+&gt;, but that doesn't look as good).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También tenga cuidado de no seguir la palabra clave print con un paréntesis de apertura a menos que desee que el correspondiente paréntesis de cierre ponga fin a los argumentos de la impresión; poner paréntesis alrededor de todos los argumentos (o interponer un C&lt;+&gt;, pero esto no parece tan bonito).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfork		Perl fork() information</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfork		Información sobre fork()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ref_to_AoA = [</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ref_a_AoA = [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unshift(@ARGV, '-') unless @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unshift(@ARGV, '-') unless @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ($foo), exit;	# Or even this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ($foo), exit;	# O incluso esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, the
C&lt;use warnings&gt; pragma and the B&lt;-w&gt; switch (that is, the C&lt;$^W&gt; variable)
produces warnings if the STRING contains the &quot;,&quot; or the &quot;#&quot; character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por esta razón, el pragma C&lt;use warnings&gt; y la opción B&lt;-w&gt; (es decir, la variable C&lt;$^W&gt;) produce advertencias de si la cadena contiene la &quot;,&quot; o el carácter &quot;#&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item glob</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item glob</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These examples of the yada yada work:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos ejemplos de blablablá funcionan:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;/&quot; divides two numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;/&quot; divide dos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keywords C&lt;given&gt; and C&lt;when&gt; are analogous
to C&lt;switch&gt; and C&lt;case&gt; in other languages, so the code
above could be written as</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los identificadores C&lt;given&gt; y C&lt;when&gt; son análogos a C&lt;switch&gt; y C&lt;case&gt; en otros lenguajes, por lo que el código anterior podrá ser escrito como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treat string as multiple lines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Trata a la cadena como un conjunto de varias líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item mkdir</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item mkdir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Older threaded Perls (5.8.6 or earlier)
will run into this problem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Anteriores Perls con threads (5.8.6 o anteriores) tendrán este problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that, try something more like:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para esto, intente algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcompile 	Perl compiler suite intro</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T011505Z" changeid="explorer">
        <seg>perlcompile		Introducción al sistema de compilación Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
subroutine should return either nothing or else a list of up to three 
values in the following order:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La subrutina debe devolver, o nada, o bien una lista de hasta tres valores en el orden siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You get this from taking the reference of function calls like
C&lt;pos()&gt; or C&lt;substr()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Obtiene esto de la referencia a las llamadas a funciones como C&lt;pos()&gt; o C&lt;substr()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used together, as C&lt;/ms&gt;, they let the &quot;.&quot; match any character whatsoever,
while still allowing &quot;^&quot; and &quot;$&quot; to match, respectively, just after
and just before newlines within the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usados juntos, como C&lt;/ms&gt;, permiten que &quot;.&quot; coincida con cualquier carácter, mientras que siguen permitiendo que &quot;^&quot; y &quot;$&quot; coincidan, respectivamente, con el después y el antes de los caracteres nueva línea dentro de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
also can't be used to go into a construct that is optimized away.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco puede ir en una construcción que sea optimizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,11, 2) = 1   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,11, 2) = 1   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s|^|$front\{|;
                    redo LINE;
                }
            }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050858Z" changeid="explorer">
        <seg>s|^|$frente\{|;
                    redo LINEA;
                }
            }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of November 2005, only an alpha version has been released.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En noviembre de 2005, sólo ha sido lanzada una versión alfa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ( prompt(); defined( $_ = &lt;STDIN&gt; ); prompt() ) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ( prompt(); defined( $_ = &lt;STDIN&gt; ); prompt() ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A null pointer is created if the corresponding value for
C&lt;p&gt; or C&lt;P&gt; is C&lt;undef&gt;; similarly with unpack(), where a null pointer
unpacks into C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un puntero nulo es creado si el valor correspondiente para C&lt;p&gt; o C&lt;P&gt; es C&lt;undef&gt;; de forma similar con unpack(), donde un puntero nulo se descomprime en C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real numbers (floats and doubles) are in native machine format only.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los números reales (float y double) solo están en formato nativo de la máquina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike C&lt;dbmopen&gt;, the C&lt;tie&gt; function will not C&lt;use&gt; or C&lt;require&gt; a module
for you; you need to do that explicitly yourself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de C&lt;dbmopen&gt;, la función C&lt;tie&gt; no usará C&lt;use&gt; o C&lt;require&gt; de un módulo por usted; necesitará hacerlo de forma explícita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment to C&lt;$@&gt; occurs before restoration of localised variables,
which means a temporary is required if you want to mask some but not all
errors:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La asignación a C&lt;$@&gt; se produce antes de la restauración de las variables localizadas, lo que significa que se requiere un espacio temporal si desea enmascarar algunos pero no todos los errores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\s*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\s*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not a general way to portably store floating-point values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No es una forma general de almacenar de forma portátil los valores de punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IMODE($mode)    the part of $mode containing the permission bits
            and the setuid/setgid/sticky bits</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052048Z" changeid="explorer">
        <seg>S_IMODE($modo)    la parte de $modo conteniendo los bit de permiso
            y los bit setuid/setgid/sticky</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The match operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador de emparejamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function works like the system call by the same name: it makes the
named directory the new root directory for all further pathnames that
begin with a C&lt;/&gt; by your process and all its children.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta funcion trabaja como la llamada del sistema del mismo nombre: hace que el directorio indicado sea el directorio raíz de los siguientes caminos que comiencen por un C&lt;/&gt; en su proceso y todos sus hijos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmroapi		Perl method resolution plugin interface</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmroapi		Interfaz de complementos: resolución de métodos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&lt;=&gt;&quot; returns -1, 0, or 1 depending on whether the left
argument is numerically less than, equal to, or greater than the right
argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&lt;=&gt;&quot; devuelve -1, 0, o 1 dependiendo de si el argumento de la izquierda es numéricamente menor, igual o mayor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TYPE is currently bound to the use of C&lt;fields&gt; pragma,
and attributes are handled using the C&lt;attributes&gt; pragma, or starting
from Perl 5.8.0 also via the C&lt;Attribute::Handlers&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TIPO está vinculado al uso del pragma C&lt;fields&gt;, y los atributos se manejan con el pragma C&lt;attributes&gt;, o a partir de Perl 5.8.0 también a través del módulo C&lt;Attribute::Handlers&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although optimized for
scanning text, Perl can also deal with binary data, and can make dbm
files look like hashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si bien optimizados para el escaneo de texto, Perl también puede tratar con datos binarios, y puede hacer que los archivos dbm parezcan hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything
matching PATTERN is taken to be a delimiter separating the fields.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier cosa concordante con el PATRÓN se toma como un delimitador que separa los campos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%%    a percent sign</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%%    un signo de por ciento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The author of Perl has never felt the need to use this form of C&lt;goto&gt;
(in Perl, that is; C is another matter).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El autor de Perl nunca ha sentido la necesidad de usar esta forma de C&lt;goto&gt; (en Perl, desde luego. C es otra historia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;my&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;my&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Reference Manual</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Manual de referencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may explicitly show which type of
operation you intend by using C&lt;&quot;&quot;&gt; or C&lt;0+&gt;, as in the examples below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede indicar, explícitamente, el tipo de operación que desea realizar utilizando C&lt;&quot;&quot;&gt; o C&lt;0+&gt;, como en los ejemplos siguientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use sort     qw(stable _quicksort _mergesort);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use sort     qw(stable _quicksort _mergesort);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 while s/\t+/' ' x (length($&amp;)*8 - length($`)%8)/e;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 while s/\t+/' ' x (length($&amp;)*8 - length($`)%8)/e;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Additive Operators
X&lt;operator, additive&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234414Z" changeid="explorer">
        <seg>=head2 Operadores aditivos
X&lt;operator, additive&gt; X&lt;operador, aditivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;abs&gt;, C&lt;bless&gt;, C&lt;break&gt;, C&lt;chomp&gt;, C&lt;chr&gt;, C&lt;continue&gt;, C&lt;default&gt;, 
C&lt;exists&gt;, C&lt;formline&gt;, C&lt;given&gt;, C&lt;glob&gt;, C&lt;import&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;,
C&lt;lock&gt;, C&lt;map&gt;, C&lt;my&gt;, C&lt;no&gt;, C&lt;our&gt;, C&lt;prototype&gt;, C&lt;qr//&gt;, C&lt;qw//&gt;, C&lt;qx//&gt;,
C&lt;readline&gt;, C&lt;readpipe&gt;, C&lt;ref&gt;, C&lt;sub&gt;*, C&lt;sysopen&gt;, C&lt;tie&gt;, C&lt;tied&gt;, C&lt;uc&gt;,
C&lt;ucfirst&gt;, C&lt;untie&gt;, C&lt;use&gt;, C&lt;when&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165259Z" changeid="explorer">
        <seg>C&lt;abs&gt;, C&lt;bless&gt;, C&lt;break&gt;, C&lt;chomp&gt;, C&lt;chr&gt;, C&lt;continue&gt;, C&lt;default&gt;, 
C&lt;exists&gt;, C&lt;formline&gt;, C&lt;given&gt;, C&lt;glob&gt;, C&lt;import&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;,
C&lt;lock&gt;, C&lt;map&gt;, C&lt;my&gt;, C&lt;no&gt;, C&lt;our&gt;, C&lt;prototype&gt;, C&lt;qr//&gt;, C&lt;qw//&gt;, C&lt;qx//&gt;,
C&lt;readline&gt;, C&lt;readpipe&gt;, C&lt;ref&gt;, C&lt;sub&gt;*, C&lt;sysopen&gt;, C&lt;tie&gt;, C&lt;tied&gt;, C&lt;uc&gt;,
C&lt;ucfirst&gt;, C&lt;untie&gt;, C&lt;use&gt;, C&lt;when&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlopenbsd 	Perl notes for OpenBSD</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlopenbsd 	Notas para OpenBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match 1 or more times, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide con 1 o más veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you can assign to a list of variables, you can also assign to
an array or hash slice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ya que se puede asignar a una lista de variables, también se puede asignar a un array o una porción de hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\x1B	hex char              (example: ESC)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\x1B		car. hex              (ejemplo: ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Why do we have separate numeric and string comparisons?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225235Z" changeid="explorer">
        <seg>¿Por qué se usa un operador de comparación para números y otro para cadenas?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function is now largely obsolete, mostly because it's very hard to
convert a core file into an executable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función es obsoleta desde hace mucho tiempo, en parte porque es muy difícil convertir un volcado del núcleo en un ejecutable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For portability, when using features that may not be implemented on
every machine, test the construct in an eval to see if it fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la portabilidad, cuando utilice características que pueden no estar implementadas en todas las máquinas, compruebe el código en un eval para ver si falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you can get gcc for 5.3,
you could try that, too, since gcc in IRIX 6 is a known workaround for
at least the shuffle.t and sort.t failures.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005410Z" changeid="explorer">
        <seg>Si puede conseguir gcc para 5.3, podría también intentarlo con él, ya que desde el gcc en IRIX 6 es al menos una solución conocida para los fallos de shuffle.t y sort.t.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rmdir</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item rmdir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef $/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're web-connected, you can even mosey on over to
L&lt;http://www.oreilly.com/&gt; for an online order form.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T233746Z" changeid="explorer">
        <seg>Si puede conectarse por web, puede encontrar un formulario en L&lt;http://www.oreilly.com/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be helpful to check
C&lt;$!&gt; when you are reading from filehandles you don't trust, such as a
tty or a socket.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser útil comprobar C&lt;$!&gt; cuando está leyendo de gestores de archivo en los que no confía, como tty o un socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, if the specified Perl version is greater than or equal to 5.9.5,
C&lt;use VERSION&gt; will also load the C&lt;feature&gt; pragma and enable all
features available in the requested version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, si la versión especificada de Perl es mayor o igual a 5.9.5, C&lt;use VERSIÓN&gt; cargará el pragma C&lt;feature&gt; y activará todas las características disponibles en la versión solicitada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'Now is the time for all' . &quot;\n&quot; .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054505Z" changeid="explorer">
        <seg>'Ahora es el momento de todos' . &quot;\n&quot; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use
a PID of C&lt;0&gt; to get the current process group for the
current process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use un PID de C&lt;0&gt; para obtener el grupo del proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The repeat count gobbles that many values from
the LIST when used with all format types other than C&lt;a&gt;, C&lt;A&gt;, C&lt;Z&gt;, C&lt;b&gt;,
C&lt;B&gt;, C&lt;h&gt;, C&lt;H&gt;, C&lt;@&gt;, C&lt;.&gt;, C&lt;x&gt;, C&lt;X&gt;, and C&lt;P&gt;, where it means
something else, dscribed below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de repeticiones engulle a tantos valores de la LISTA cuando es usada con todos los tipos de formato que no sean C&lt;a&gt;, C&lt;A&gt;, C&lt;Z&gt;, C&lt;b&gt;,
C&lt;B&gt;, C&lt;h&gt;, C&lt;H&gt;, C&lt;@&gt;, C&lt;.&gt;, C&lt;x&gt;, C&lt;X&gt; y C&lt;P&gt;, donde significa otra cosa, descrita abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>once</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>una vez</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VERSION is provided, C&lt;package&gt; sets the C&lt;$VERSION&gt; variable in the given
namespace to a L&lt;version&gt; object with the VERSION provided.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se indica VERSIÓN, C&lt;package&gt; inicializa la variable C&lt;$VERSION&gt; en el espacio de nombres indicado a un objeto L&lt;version&gt; con la VERSIÓN indicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To simplify multi-line substitutions, the &quot;.&quot; character never matches a
newline unless you use the C&lt;/s&gt; modifier, which in effect tells Perl to pretend
the string is a single line--even if it isn't.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para simplificar la sustitución de varias líneas, el carácter &quot;.&quot;  no coincide con una nueva línea a menos que utilice el modificador C&lt;/s&gt;, que en efecto dice a Perl que asuma que la cadena es una sola línea -incluso si no lo es-.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your Perl success stories and testimonials may be of help to others 
who wish to advocate the use of Perl in their applications, 
or if you wish to simply express your gratitude to Larry and the 
Perl developers, please write to perl-thanks@perl.org .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sus historias de éxito y testimonio de Perl puede ser de ayuda a otros que desean abogar por el uso de Perl en sus aplicaciones, o si simplemente desea expresar su gratitud a Larry y los desarrolladores de Perl, por favor escriba a perl-thanks@perl.org .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash    Regex     hash key grep            grep /$b/, keys %$a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hash        Regex      grep clave hash                  grep /$b/, keys %$a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This prints the whole structure,
using the shell-style for() construct to loop across the outer
set of subscripts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193757Z" changeid="explorer">
        <seg>Esto muestra toda la estructura, utilizando la construcción de un bucle al estilo del for() de la shell para ciclar por el conjunto externo de subíndices.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;?&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;!&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even then, it may not be used to
go into any construct that requires initialization, such as a
subroutine or a C&lt;foreach&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso entonces, no se puede usar para ir a cualquier construcción que requiere inicialización, como una subrutina o un bucle C&lt;foreach&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item srand EXPR
X&lt;srand&gt; X&lt;seed&gt; X&lt;randseed&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201259Z" changeid="explorer">
        <seg>=item srand EXPR
X&lt;srand&gt; X&lt;seed&gt; X&lt;randseed&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-hv&gt; ] [ B&lt;-V&gt;[:I&lt;configvar&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-hv&gt; ] [ B&lt;-V&gt;[:I&lt;configvar&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = $ok ? @b : @c;  # oops, that's just a count!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054028Z" changeid="explorer">
        <seg>$a = $ok ? @b : @c;  # oops, ¡esto solo cuenta elementos!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pattern matching the empty string (not to be confused with
an empty pattern C&lt;//&gt;, which is just one member of the set of patterns
matching the epmty string), splits EXPR into individual
characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un patrón de coincidencia con la cadena vacía (que no debe confundirse con un patrón vacío C&lt;//&gt;, que es sólo un miembro del conjunto de patrones coincidentes con la cadena vacía), divide EXPR en caracteres individuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>utime(undef, undef, $file)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>utime(undef, undef, $archivo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Make . match a newline)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054215Z" changeid="explorer">
        <seg>(Hace que . coincida con un car. de nueva línea)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qx/STRING/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item qx/STRING/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die $e if defined $e</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die $e if defined $e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you've used
-OPT:fast_io=ON and this happens, try removing it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003222Z" changeid="explorer">
        <seg>Si ha utilizado -OPT:fast_io=ON y sucede esto, pruebelo de nuevo quitándolo antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In older versions of Perl, if your system had neither DBM nor
ndbm, calling C&lt;dbmopen&gt; produced a fatal error; it now falls back to
sdbm(3).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En las viejas versiones de Perl, si el sistema no tenía ni DBM ni ndbm, llamando a C&lt;dbmopen&gt; producía un error fatal; ahora lo intentaría con sdbm(3).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For further details see L&lt;perltie&gt;, L&lt;&quot;tied VARIABLE&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más detalles, véase L&lt;perltie&gt;, L&lt;&quot;tied VARIABLE&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;find2perl&gt; now assumes C&lt;-print&gt; as a default action.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;find2perl&gt; ahora asume C&lt;-print&gt; como una acción por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>don't panic and just set the sticky bit in your /tmp
directory by doing the following as root:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no entre en pánico y establezca el bit sticky en el directorio /tmp haciendo lo siguiente como root:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;/x&gt; modifier itself needs a little more explanation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El mismo modificador C&lt;/x&gt; necesita un poco más de explicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple C&lt;our&gt; declarations with the same name in the same lexical
scope are allowed if they are in different packages.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Múltiples declaraciones C&lt;our&gt; con el mismo nombre en el mismo ámbito léxico son permitidas si están en diferentes paquetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else {
           return $result;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051235Z" changeid="explorer">
        <seg>} else {
           return $resultado;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($n == 1) ? '' : &quot;s&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053829Z" changeid="explorer">
        <seg>($n == 1) ? '' : &quot;s&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return unless defined wantarray; # don't bother doing more</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return unless defined wantarray; # no nos molestamos más</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also means that modifying
a variable twice in the same statement will lead to undefined behaviour.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto también significa que la modificación de una variable dos veces en la misma declaración dará lugar a un comportamiento indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item untie VARIABLE
X&lt;untie&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210338Z" changeid="explorer">
        <seg>=item untie VARIABLE
X&lt;untie&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;overload&gt; for details about that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;overload&gt; para los detalles sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;grep&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;grep&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a space and a plus sign are given as the flags at once,
a plus sign is used to prefix a positive number.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando un espacio y un signo más se dan como banderas de forma simultánea, un signo más es usado para prefijar un número positivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Comments
X&lt;comment&gt; X&lt;#&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040820Z" changeid="explorer">
        <seg>=head2 Comentarios
X&lt;comment&gt; X&lt;#&gt; X&lt;comentario&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
operator may be any of:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador puede ser cualquiera de:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qr/STRING/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item qr/STRING/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular the following metacharacters have their standard I&lt;egrep&gt;-ish
meanings:
X&lt;metacharacter&gt;
X&lt;\&gt; X&lt;^&gt; X&lt;.&gt; X&lt;$&gt; X&lt;|&gt; X&lt;(&gt; X&lt;()&gt; X&lt;[&gt; X&lt;[]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, los siguientes metacaracteres mantienen su significados estándar heredados del C&lt;egrep&gt;:
X&lt;metacarácter&gt;
X&lt;\&gt; X&lt;^&gt; X&lt;.&gt; X&lt;$&gt; X&lt;|&gt; X&lt;(&gt; X&lt;()&gt; X&lt;[&gt; X&lt;[]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add the sort pragma</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadido el pragma sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Outside the match use &quot;$&quot; instead of &quot;\&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fuera de la coincidencia, use &quot;$&quot; en lugar de &quot;\&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@newAoA = map { [ @{ $AoA[$_] } [ 7..12 ] ] } 4 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T195315Z" changeid="explorer">
        <seg>@newAoA = map { [ @{ $AoA[$_] } [ 7..12 ] ] } 4 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's C&lt;sprintf&gt; permits the following universally-known conversions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl C&lt;sprintf&gt; permite las siguientes conversiones universalmente conocidas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$.\t$_&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$.\t$_&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;next&gt; command starts the next iteration of the loop:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;next&gt; inicia la siguiente iteración del bucle:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language is intended to be practical
(easy to use, efficient, complete) rather than beautiful (tiny,
elegant, minimal).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El lenguaje está pensado para ser práctico (fácil de usar, eficiente, completo) en lugar de hermoso (pequeño, elegante, mínimo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns C&lt;1&gt; for success; on error, returns C&lt;undef&gt; if
the first argument is not a valid filehandle, or returns C&lt;0&gt; and sets
C&lt;$!&gt; for any other failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve C&lt;1&gt; para el éxito; en caso de error, devuelve C&lt;undef&gt; si el primer argumento no es un gestor de archivo válido, o devuelve C&lt;0&gt; y actualiza C&lt;$!&gt; por cualquier otro fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(*) Not all fields are supported on all filesystem types.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(*) No todos los campos están soportados por todos los sistemas de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^$/);
                               # (typically in a loop labeled LINE)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053634Z" changeid="explorer">
        <seg>/^$/);
                               # (típicamente en un bucle etiquetado como LINEA)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a reference to the object underlying VARIABLE (the same value
that was originally returned by the C&lt;tie&gt; call that bound the variable
to a package.)  Returns the undefined value if VARIABLE isn't tied to a
package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una referencia al objeto subyacente en VARIABLE (el mismo valor que fue devuelto originalmente por la llamada C&lt;tie&gt; que unía a la variable a un paquete). Devuelve el valor indefinido si la VARIABLE no está vinculada a un paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default argument to the C&lt;shift&gt; function just happens to be C&lt;@_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T234934Z" changeid="explorer">
        <seg>El argumento predeterminado de la función C&lt;shift&gt; es C&lt;@_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;ok\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;correcto\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$now_string = strftime &quot;%a %b %e %H:%M:%S %Y&quot;, localtime;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ahora = strftime &quot;%a %b %e %H:%M:%S %Y&quot;, localtime;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$output = `cmd 2&gt;&amp;1 1&gt;/dev/null`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$salida = `comando 2&gt;&amp;1 1&gt;/dev/null`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>l           interpret integer as C type &quot;long&quot; or &quot;unsigned long&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>l           interpreta un entero como un &quot;long&quot; o &quot;unsigned long&quot; del C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getservbyname NAME,PROTO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getservbyname NOMBRE,PROTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume ANSI C89 plus the following:
- &lt;stdlib.h&gt;
- rename()
- opendir(), readdir(), closedir() (via dirent.h)
- memchr(), memcmp(), memcpy() (via string.h)
- (a safe) putenv() (via stdlib.h)
- strtoul() (via stdlib.h)
(grep for 'define' in uconfig.sh.)
Also, Perl times() is defined to always return zeroes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040639Z" changeid="explorer">
        <seg>Asumimos ANSI C89 más lo siguiente:
- &lt;stdlib.h&gt;
- rename()
- opendir(), readdir(), closedir() (vía dirent.h)
- memchr(), memcmp(), memcpy() (vía string.h)
- (un seguro) putenv() (via stdlib.h)
- strtoul() (via stdlib.h)
(grep para 'define' en uconfig.sh.)
También, Perl times() está definido para devolver siempre ceros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use warnings;      &quot;$foo&quot;           LINKS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use warnings;      &quot;$foo&quot;           ENLACES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without the braces, Perl would have looked for a $whospeak, a
C&lt;$who::0&gt;, and a C&lt;$who's&gt; variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin las llaves, Perl buscaría por $quien_altavoz, y el paquete C&lt;$quien::0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a corresponding C&lt;no&gt; command that unimports meanings imported
by C&lt;use&gt;, i.e., it calls C&lt;unimport Module LIST&gt; instead of C&lt;import&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existe un correspondiente comando C&lt;no&gt; que des-importa los significados importados por C&lt;use&gt;, es decir, llama a C&lt;unimport Módulo LISTA&gt; en lugar de C&lt;import&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Conditional Operator
X&lt;operator, conditional&gt; X&lt;operator, ternary&gt; X&lt;ternary&gt; X&lt;?:&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001101Z" changeid="explorer">
        <seg>=head2 Operadores condicionales
X&lt;operator, conditional&gt; X&lt;operator, ternary&gt; X&lt;ternary&gt; X&lt;?:&gt; X&lt;operador, condicional&gt; X&lt;operador, ternario&gt; X&lt;ternario&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a bug on FreeBSD, where the
result of reading this symlink is can be wrong in certain circumstances
(see http://www.freebsd.org/cgi/query-pr.cgi?pr=35703 ).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay un bug en FreeBSD, donde el resultado de leer un enlace simbólico puede ser erróneo en determinadas circunstancias (ver http://www.freebsd.org/cgi/query-pr.cgi?pr=35703 ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is a hash, it chomps the hash's values, but not its keys.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE es un hash, recorta los valores del hash, pero no sus claves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to do
so raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intentarlo, lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0x12 0x34 0x56 0x78  # big-endian</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0x12 0x34 0x56 0x78  # big-endian    (byte superior antes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\g1       [5]  Backreference to a specific or previous group,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224409Z" changeid="explorer">
        <seg>\g1       [5]  Contrareferencia a un grupo específico o anterior,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlrepository	Perl source repository</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlrepository	Repositorio fuente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use 3-argument form to open a file with arbitrary weird characters in it,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use la forma de 3 argumentos para abrir un archivo con una cantidad arbitraria de caracteres extraños en él,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare with L&lt;/use&gt;, which can do a similar check at compile time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compare con L&lt;/use&gt;, que puede hacer un control similar en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each chunk
is converted separately to a value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada fragmento se convierte en un valor por separado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$seconds = $3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$segundos = $3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rename lib/unicode to lib/unicore to avoid case-insensitivity problems
with lib/Unicode</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>cambiar el nombre de lib/unicode a lib/unicore para evitar problemas de mayúsculas y minúsculas, con lib/Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, lines after the here-doc syntax
are compared with the terminating string line by line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, las líneas que siguen a la sintaxis del documento incrustado son comparados con la línea de terminación de cadena, una a una.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting from a hash tied to
a DBM file deletes the entry from the DBM file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Borrando de un hash enlazado a un archivo DBM, borra esa entrada del archivo DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, this means that you shouldn't use this
for selecting between two aggregates for assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, esto significa que usted no debería usar esto para seleccionar entre dos agregados para hacer una asignación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MSG must begin with the native long integer message
type, and be followed by the length of the actual message, and finally
the message itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>MSG debe comenzar con un tipo de mensaje, contenido en un entero largo nativo, seguido por la longitud del mensaje, y finalmente el mensaje mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$fh = \*STDIN;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$fh = \*STDIN;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you get tired of remembering which element of the return list
contains which return value, by-name interfaces are provided
in standard modules: C&lt;File::stat&gt;, C&lt;Net::hostent&gt;, C&lt;Net::netent&gt;,
C&lt;Net::protoent&gt;, C&lt;Net::servent&gt;, C&lt;Time::gmtime&gt;, C&lt;Time::localtime&gt;,
and C&lt;User::grent&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está cansado de recordar qué elemento de la lista devuelta contiene qué valor, existen interfaces por nombre, en módulos estándar: C&lt;File::stat&gt;, C&lt;Net::hostent&gt;, C&lt;Net::netent&gt;, C&lt;Net::protoent&gt;, C&lt;Net::servent&gt;, C&lt;Time::gmtime&gt;, C&lt;Time::localtime&gt; y C&lt;User::grent&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>until ( condition ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T003005Z" changeid="zipf">
        <seg>until ( condición ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is C&lt;... || ...&gt;, C&lt;... // ...&gt; or C&lt;... or ...&gt;, the test
is applied recursively to the first argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es C&lt;... || ...&gt;, C&lt;... // ...&gt; o C&lt;... or ...&gt;, el test se aplica recursivamente al primer argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can
combine several regexps like this to process a string part-by-part,
doing different actions depending on which regexp matched.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede combinar varias expresiones regulares como ésta para procesar una cadena parte por parte, haciendo diferentes acciones dependiendo de la expresión regular coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;N&quot;, pack(&quot;B32&quot;, substr(&quot;0&quot; x 32 . shift, -32)));</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050716Z" changeid="explorer">
        <seg>unpack(&quot;N&quot;, pack(&quot;B32&quot;, substr(&quot;0&quot; x 32 . shift, -32)));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;continue&gt; is actually a flow control statement rather than a function.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012349Z" changeid="explorer">
        <seg>C&lt;continue&gt; es realmente una instrucción de control de flujo en lugar de una función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is used by C&lt;AUTOLOAD&gt; subroutines that wish to
load another subroutine and then pretend that the other subroutine had
been called in the first place (except that any modifications to C&lt;@_&gt;
in the current subroutine are propagated to the other subroutine.)
After the C&lt;goto&gt;, not even C&lt;caller&gt; will be able to tell that this
routine was called first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se usa por subrutinas C&lt;AUTOLOAD()&gt; que desean cargar otra subrutina y fingen que ésta otra subrutina ha sido llamada en primer lugar (excepto que cualquier modificación a C&lt;@_&gt; en la subrutina actual se propaga a la otra). Después del C&lt;goto&gt;, ni siquiera C&lt;caller()&gt; será capaz de decir qué rutina fue llamada en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltoot		Perl OO tutorial, part 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perltoot		Seminario de POO Perl, parte 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Building 32-bit Perl in Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002329Z" changeid="explorer">
        <seg>=head2 Compilando Perl de 32 bit en Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll probably first have to say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Probablemente primero querrá escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say '$foo is an odd digit';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>say '$foo es un dígito impar';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(':', split(//,   'hi there!', -1)), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(':', split(//,   'hola aqui!', -1)), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;if&gt; statement is straightforward.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013324Z" changeid="explorer">
        <seg>La instrucción C&lt;if&gt; es sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that characters from 128 to 255 (inclusive) are by default
internally not encoded as UTF-8 for backward compatibility reasons.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que los caracteres de 128 a 255 (inclusive) son, por defecto, internamente no codificados como UTF-8, por razones de compatibilidad hacia atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the delimiters are
bracketing, nested pairs are also skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los delimitadores están entre emparejados, las parejas anidadas también se omiten.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On
unconnected sockets, you must specify a destination to I&lt;send to&gt;, in which
case it does a sendto(2) syscall.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sockets desconectados, debe especificar un destino I&lt;adonde&gt; enviarlo, en cuyo caso hace una llamada del sistema sendto(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the semaphore id, or
the undefined value if there is an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el identificador del semáforo, o el valor indefinido si hay un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of bracket (square
or curly) governs whether it's an array or a hash being looked at.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El tipo de carácter (corchete o llave) indica si se trata de un array o un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>division preserving 64-bit integers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>la división preserva los enteros de 64 bits</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no shell metacharacters in the argument, it is split into
words and passed directly to C&lt;execvp&gt;, which is more efficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay metacaracteres shell en el argumento, es dividido en palabras y pasadas directamente a C&lt;execvp&gt;, que es más eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opens the file whose filename is given by FILENAME, and associates it
with FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204152Z" changeid="explorer">
        <seg>Abre el archivo cuyo nombre viene dado por ARCHIVO, y lo asocia con GESTOR_ARCHIVO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a 13-element list giving the status info for a file, either
the file opened via FILEHANDLE or DIRHANDLE, or named by EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una lista de 13 elementos dando la información de estado de un archivo, tanto si el archivo ha sido abierto a través de GESTOR o GESTOR_DIR, o nombrado por la EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item next</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item next</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item s
X&lt;/s&gt; X&lt;regex, single-line&gt; X&lt;regexp, single-line&gt;
X&lt;regular expression, single-line&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222730Z" changeid="explorer">
        <seg>=item s
X&lt;/s&gt; X&lt;regex, single-line&gt; X&lt;regexp, single-line&gt; X&lt;regular expression, single-line&gt; X&lt;regex, una línea&gt; X&lt;expresión regular, una línea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, the leading symbol ('$' or '@') on the array or
hash indicates whether you are getting back a singular value (a
scalar) or a plural one (a list).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por otra parte, el símbolo principal ('$' o '@') en el array o hash indica si va a obtener un valor singular (un escalar) o uno plural (una lista).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
scalar context, glob iterates through such filename expansions, returning
undef when the list is exhausted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, glob itera a través de la expansión de nombres de archivo, devolviendo undef cuando se agote la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@myarray = (5, 50, 500, 5000);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@miarray = (5, 50, 500, 5000);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack('nN', 42, 4711);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack('nN', 42, 4711);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and here's another.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y aquí otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Win32: 4-arg select was broken</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Win32: el select() de 4 argumentos estaba roto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\w/$&amp; x 2/eg;		# yields 'aabbcc  224466xxyyzz'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/\w/$&amp; x 2/eg;		# queda como 'aabbcc  224466xxyyzz'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Within
character classes C&lt;\b&gt; represents backspace rather than a word
boundary, just as it normally does in any double-quoted string.)
The C&lt;\A&gt; and C&lt;\Z&gt; are just like &quot;^&quot; and &quot;$&quot;, except that they
won't match multiple times when the C&lt;/m&gt; modifier is used, while
&quot;^&quot; and &quot;$&quot; will match at every internal line boundary.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Dentro de las clases carácter, C&lt;\b&gt; representa el retroceso -I&lt;backspace&gt;- en lugar del límite de palabra, tal como lo hace normalmente en cualquier cadena doblemente entrecomillada). Los C&lt;\A&gt; y C&lt;\Z&gt; son como los &quot;^&quot; y &quot;$&quot;, excepto que no coincidirán múltiples veces cuando se use el modificador C&lt;/m&gt;, mientras que &quot;^&quot; y &quot;$&quot; coincidirán en cada límite de línea que contenga la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;address is %*vX\n&quot;, &quot;:&quot;, $addr;   # IPv6 address</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;dirección es %*vX\n&quot;, &quot;:&quot;, $addr;   # dirección IPv6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8.4 23:59:59 GMT, Wednesday March 31st 2004</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5.8.4 23:59:59 GMT miércoles, 31 de marzo 2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/1/) {
            print &quot;$_\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053718Z" changeid="explorer">
        <seg>/1/) {
            print &quot;$_\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,26, 1) = 1   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,26, 1) = 1   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FH, $filename) or die &quot;Can't open $filename: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FH, $archivo) or die &quot;No puedo abrir $archivo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\s+$//;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/\s+$//;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's why you should now invoke
it as C&lt;CORE::dump()&gt;, if you don't want to be warned against a possible
typo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y es por esto que debe invocarlo como C&lt;CORE::dump()&gt;, si no quiere recibir un aviso de que posiblemente ha cometido una falta ortográfica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following lines are equivalent:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las siguientes líneas son equivalentes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Patterns are subject to an additional level of interpretation as a
regular expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los patrones están sujetos a un nivel adicional de interpretación como una expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is an expression, the value is taken as an indirect
filehandle, generally its name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211446Z" changeid="explorer">
        <seg>Si el GESTOR_ARCHIVO es una expresión, el valor es tomado como un gestor indirecto, generalmente su nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each letter may optionally be followed by a number indicating the repeat
count.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada letra puede ser seguida opcionalmente por un número que indica el número de repeticiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are an implementor, see
L&lt;perlapi/PL_keyword_plugin&gt; for the mechanism.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si es usted un implementador, mire L&lt;perlapi/PL_keyword_plugin&gt; para informarse sobre este mecanismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax is a
pair of parentheses with a question mark as the first thing within
the parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La sintaxis es un par de paréntesis con un signo de interrogación como primera cosa dentro de los paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, an identifier within such curlies is forced to be a string,
as is any simple identifier within a hash subscript.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De hecho, un identificador dentro de estos signos, se le fuerza a ser una cadena, como a cualquier identificador dentro del subíndice de un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the compiler will precompute the number which that expression
represents so that the interpreter won't have to.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>el compilador precalculará el número que representa esa expresión para que el intérprete no tenga que hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This doesn't work with C&lt;-t&gt;, and you need to remember
that lstat() and C&lt;-l&gt; leave values in the stat structure for the
symbolic link, not the real file.)  (Also, if the stat buffer was filled by
an C&lt;lstat&gt; call, C&lt;-T&gt; and C&lt;-B&gt; will reset it with the results of C&lt;stat _&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto no funciona con  C&lt;-t&gt;, y necesita recordar que lstat() y C&lt;-l&gt; dejarán valores en la estructura stat para el enlace simbólico, no el archivo real).  (También, si la memoria intermedia de stat se rellenó con una llamada C&lt;lstat&gt;, C&lt;-T&gt; y C&lt;-B&gt; serán reinicializados con los resultados de C&lt;stat _&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$success;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$exito;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the
C&lt;Time::Local&gt; module (to convert the second, minutes, hours, ... back to
the integer value returned by time()), and the L&lt;POSIX&gt; module's strftime(3)
and mktime(3) functions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también el módulo C&lt;Time::Local&gt; (para convertir los segundos, minutos, horas, ... de nuevo al valor entero devuelto por time()), y las funciones strftime(3) y mktime(3) del módulo L&lt;POSIX&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is roughly equivalent to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es casi equivalente a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opens a pair of connected pipes like the corresponding system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Abre un par de tuberías conectadas como lo hace correspondiente llamada al sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the template C&lt;x[L]&gt; skips as many bytes as in a packed long,
and the template C&lt;&quot;$t X[$t] $t&quot;&gt; unpacks twice whatever $t (when
variable-expanded) unpacks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, la plantilla C&lt;x[L]&gt; salta tantos bytes como en un largo empaquetado, y la plantilla C&lt;&quot;$t X[$t] $t&quot;&gt; desempaqueta dos veces lo que $t desempaquete (cuando se expanda la variable).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME
X&lt;syntax&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T232631Z" changeid="explorer">
        <seg>=head1 NOMBRE
X&lt;syntax&gt; X&lt;sintaxis&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval '$answer =';   # sets $@</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval '$respuesta =';   # actualiza $@</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;-&quot; returns the difference of two numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;-&quot; devuelve la diferencia de dos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chop</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;ne&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;ne&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exit 255;                   # last resort</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171215Z" changeid="explorer">
        <seg>exit 255;                   # último recurso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default answers for the rest of the
questions are usually sufficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Suele ser suficiente tomar el valor por defecto para las respuestas del resto de las preguntas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (@an_array) { print &quot;has array elements\n&quot; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (@un_array) { print &quot;tiene elementos array\n&quot; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for real @ARRAYs
X&lt;array&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201027Z" changeid="explorer">
        <seg>=item Funciones para @ARRAY reales
X&lt;array&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(David Billinghurst &lt;David.Billinghurst@riotinto.com.au&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003932Z" changeid="explorer">
        <seg>(David Billinghurst &lt;David.Billinghurst@riotinto.com.au&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($email =~ /([^@]+)@(.+)/) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232652Z" changeid="explorer">
        <seg>if ($email =~ /([^@]+)@(.+)/) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filename passed to 2-argument (or 1-argument) form of open() will
have leading and trailing whitespace deleted, and the normal
redirection characters honored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El nombre del archivo pasado a las formas de dos argumentos (o de un argumento) de open() terminará con los espacios en blanco iniciales y finales eliminados, y la normal redirección de los caracteres activada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unary &amp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item unario &amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eval BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eval BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,14, 2) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,14, 2) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unpack TEMPLATE,EXPR
X&lt;unpack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210333Z" changeid="explorer">
        <seg>=item unpack PLANTILLA,EXPR
X&lt;unpack&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unary *</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item unario *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DBNAME
is the name of the database (without the F&lt;.dir&gt; or F&lt;.pag&gt; extension if
any).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NOMBREDB es el nombre de la base de datos (sin la extensión F&lt;.dir&gt; o F&lt;.pag&gt; si las tuviera).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments are usually formatted to be only as wide as required to
display the given value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los argumentos son por lo general formateados para ser sólo tan amplios como para mostrar el valor dado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># add new columns to an existing row</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T010033Z" changeid="explorer">
        <seg># añadir nuevas columnas a una fila existente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlmodlib&gt; lists the
modules which came with your Perl installation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225619Z" changeid="explorer">
        <seg>L&lt;perlmodlib&gt; enumera los módulos incluidos en la instalación de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from the behavior described above, Perl does not expand
multiple levels of interpolation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de los comportamientos descritos anteriormente, Perl no expande múltiples niveles de interpolación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if
you're expecting a single value from a glob, it is much better to
say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que si está esperando un único valor de una expansión, es mucho mejor escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'1' may actually be any positive integer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'1' puede ser cualquier entero positivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	list operators (rightward)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	operadores de lista (por la derecha)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next if /^$/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232650Z" changeid="explorer">
        <seg>next if /^$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually it gets it right, but if it
doesn't it won't realize something is wrong until it gets to the C&lt;}&gt; and
encounters the missing (or unexpected) comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo general, lo hace bien, pero si no, no se dará cuenta de que algo anda mal hasta que llega a la C&lt;}&gt; y se encuentra con la omisión de (o inesperada) coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They may be used only as separate tokens; they
will not be interpolated into strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo podrán ser utilizados como símbolos aislados; no se interpolarán dentro de cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Builtin operators and functions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002812Z" changeid="zipf">
        <seg>=head2 Funciones y operadores integrados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return &quot;\Q$str&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return &quot;\Q$str&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For rounding to a certain number
of digits, sprintf() or printf() is usually the easiest route.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para redondear a un determinado número de dígitos, sprintf() o printf() suele ser el camino más fácil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions in this section can serve as terms in an expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las funciones de esta sección pueden servir como términos en una expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;Changes&gt; file for exhaustive details on what changed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004041Z" changeid="explorer">
        <seg>El archivo de F&lt;Changes&gt; (Cambios) para obtener más información exhaustiva sobre lo que ha cambiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\B  Match except at a word boundary</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225700Z" changeid="explorer">
        <seg>\B  Coincide con cualquier cosa excepto límite de palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a syntax error or runtime error, or a C&lt;die&gt; statement is
executed, C&lt;eval&gt; returns an undefined value in scalar context
or an empty list in list context, and C&lt;$@&gt; is set to the
error message.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012438Z" changeid="explorer">
        <seg>Si hay algún error de sintaxis o en tiempo de ejecución, o se ejecuta una instrucción C&lt;die&gt;, C&lt;eval&gt; devuelve un valor indefinido en contexto escalar o una lista vacía en contexto lista, y C&lt;$@&gt; es inicializado al mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does the same thing that the listen(2) system call does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace lo mismo que la llamada del sistema listen(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.14&gt; will
return two elements in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3,14&gt; devolverá dos elementos en el contexto lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TIESCALAR classname, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TIESCALAR clase, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>e	Evaluate the right side as an expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>e	Evalúa el lado derecho como una expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an uppercased version of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una versión de EXPR, en mayúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for the reason).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para ver la razón).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
breaking the single input byte C&lt;chr(0x36)&gt; into two groups gives a list
C&lt;(0x6, 0x3)&gt;; breaking it into 4 groups gives C&lt;(0x2, 0x1, 0x3, 0x0)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, rompiendo el byte de entrada C&lt;chr(0x36)&gt; en dos grupos da una lista C&lt;(0x6, 0x3)&gt;; dividiéndolo en 4 grupos da C&lt;(0x2, 0x1, 0x3, 0x0)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 128 ==      32768 00000000000000010000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 128 ==      32768 00000000000000010000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Variable scoping</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181526Z" changeid="zipf">
        <seg>=head2 Ámbito de las variables</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item connect SOCKET,NAME
X&lt;connect&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170328Z" changeid="explorer">
        <seg>=item connect SOCKET,NOMBRE
X&lt;connect&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a      $b        Type of Match Implied    Matching Code</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a          $b         Tipo de Coincidencia             Código similar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first to get the correct constant definitions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>primero para obtener las definiciones de las constantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See example at C&lt;readdir&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vea el ejemplo en C&lt;readdir&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod 0755, @executables;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod 0755, @ejecutables;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also uses filehandle I&lt;ARGV&gt;
internally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Internamente, también utiliza el gestor de archivo &lt;ARGV&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following single statement:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La simple declaración siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^\#   \s*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/^\#   \s*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== 1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== 1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0xff                # hex</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0xff                # hex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qr/STRING/msixpo
X&lt;qr&gt; X&lt;/i&gt; X&lt;/m&gt; X&lt;/o&gt; X&lt;/s&gt; X&lt;/x&gt; X&lt;/p&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003344Z" changeid="explorer">
        <seg>=item qr/CADENA/msixpo
X&lt;qr&gt; X&lt;/i&gt; X&lt;/m&gt; X&lt;/o&gt; X&lt;/s&gt; X&lt;/x&gt; X&lt;/p&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not an integer&quot;       unless /^-?\d+$/;           # rejects +3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es un entero&quot;      unless /^-?\d+$/;           # rechaza +3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.10g&gt;', 1;     # prints &quot;&lt;1&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.10g&gt;', 1;     # imprime &quot;&lt;1&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings created with C&lt;vec&gt; can also be manipulated with the logical
operators C&lt;|&gt;, C&lt;&amp;&gt;, C&lt;^&gt;, and C&lt;~&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cadenas creadas con C&lt;vec&gt; también se pueden manipular con los operadores lógicos C&lt;|&gt;, C&lt;&amp;&gt;, C&lt;^&gt;, y C&lt;~&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlvms		Perl notes for VMS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlvms		Notas para VMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*                   zero or more of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230532Z" changeid="zipf">
        <seg>*                   cero o más coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;$input&gt;) {    # note use of indirection
            if (/^#include &quot;(.*)&quot;/) {
                process($1, $input);
                next;
            }
            #...          # whatever</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050412Z" changeid="explorer">
        <seg>while (&lt;$entrada&gt;) {    # note el uso de la indirección
            if (/^#include &quot;(.*)&quot;/) {
                procesa($1, $input);
                next;
            }
            #...          # cualquier otra cosa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++($foo = 'zz');	# prints 'aaa'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ++($foo = 'zz');	# imprime 'aaa'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\x1b	hex char	(example: ESC)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002925Z" changeid="explorer">
        <seg>\x1b	car. hex	(ejemplo: ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $ref;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef $ref;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chmod LIST
X&lt;chmod&gt; X&lt;permission&gt; X&lt;mode&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170051Z" changeid="explorer">
        <seg>=item chmod LISTA
X&lt;chmod&gt; X&lt;permission&gt; X&lt;mode&gt; X&lt;permisos&gt; X&lt;modo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item /PATTERN/msixpogc</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item /PATRÓN/msixpogc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lowercase of any character
outside the ASCII range is the character itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175226Z" changeid="explorer">
        <seg>La minúscula de cualquier carácter fuera del rango ASCII es el propio carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s|{.*}| |;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s|{.*}| |;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that the C&lt;-x&gt; and C&lt;-X&gt; may
under this pragma return true even if there are no execute permission
bits set (nor any extra execute permission ACLs).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note también que C&lt;-x&gt; y C&lt;-X&gt; pueden, bajo este pragma, devolver valores verdaderos incluso si los bits de permiso de ejecución no están puestos (ni cualquier permiso ACL extra de ejecución).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$result = sprintf(&quot;%08d&quot;, $number);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$resultado = sprintf(&quot;%08d&quot;, $numero);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item print LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item print LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When modified by the C&lt;while&gt; or
C&lt;until&gt; loop modifier, executes the BLOCK once before testing the loop
condition.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se encuentra acompañado por los modificadores de bucle C&lt;while&gt; o C&lt;until&gt;, ejecuta el BLOQUE una vez antes de comprobar la condición del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for list data
X&lt;list&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201200Z" changeid="explorer">
        <seg>=item Funciones para lista de datos
X&lt;list&gt; X&lt;lista&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Item: $item\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Item: $item\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Manual error checking can be done this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comprobación manual de errores se puede hacer así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opening curly on same line as keyword, if possible, otherwise line up.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llave de apertura en la misma línea que la palabra reservada, si es posible, o si no, alineada en vertical con ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>b  A bit string (ascending bit order inside each byte, like vec()).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>b  Una cadena de bit (en orden de bit ascendente dentro de cada byte, como vec()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, mentioning C&lt;/o&gt; constitutes a promise
that you won't change the variables in the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, citar a C&lt;/o&gt; constituye una promesa de que no va a cambiar las variables dentro del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 64  ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 64  ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;.IX bar\n&quot;    if /\bbar\b/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;.IX bar\n&quot;    if /\bbar\b/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 32  ==       8192 00000000000001000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 32  ==       8192 00000000000001000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the undefined value if the array is empty, although this may also
happen at other times.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor indefinido si el array está vacío, aunque esto también puede suceder en otras situaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sentence =~ s{$quoted_substring}{big bad wolf};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012623Z" changeid="explorer">
        <seg>$instruccion =~ s{$subcadena_escapada}{gran lobo malo};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;ARGV&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;ARGV&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the C&lt;&lt; =&gt; &gt;&gt; operator behaves exactly as the comma operator
or list argument separator, according to context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, el operador C&lt;&lt; =&gt; &gt;&gt; se comporta exactamente como el operador coma o separador de lista de argumentos, según el contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;LDLOADLIBS&gt; is an environment variable used by the linker to link modules
C&lt;/ext&gt; modules to glibc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;LDLOADLIBS&gt; es una variable de entorno usada por el enlazador para enlazar módulos C&lt;/ext&gt; a glibc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE
be open with read intent to use LOCK_SH and requires that it be open
with write intent to use LOCK_EX.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211537Z" changeid="explorer">
        <seg>Note que la emulación de fcntl(2) de flock(3) requiere que GESTOR_ARCHIVO sea abierto con intención de leer para usar LOCK_SH y requiere ser abierto con intención de escribir para usar LOCK_EX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)
                or die &quot;Can't set flags for the socket: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050023Z" changeid="explorer">
        <seg>$flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)
                or die &quot;No puedo poner los flags para el socket: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;STDIN&gt;) { last unless $_; ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;STDIN&gt;) { last unless $_; ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls flock(2), or an emulation of it, on FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211506Z" changeid="explorer">
        <seg>Llama a flock(2), o una emulación de ella, sobre GESTOR_ARCHIVO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some systems defined C&lt;pipe&gt; in terms of C&lt;socketpair&gt;, in which a call
to C&lt;pipe(Rdr, Wtr)&gt; is essentially:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos sistemas definen C&lt;pipe&gt; en términos de C&lt;socketpair&gt;, en el que una llamada a C&lt;pipe(Rdr, Wtr)&gt; es esencialmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Nice quads!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;¡quads divertidos!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;*.c&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;*.c&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort(find_records (@key));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort(busca_registros (@claves));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Perl's prefix dereferencing
operators are typed: $, @, %, and &amp;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Los operadores de desreferencia de Perl están tipificados: $, @, %, y &amp;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a += 2) *= 3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a += 2) *= 3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;endprotoent&gt;, C&lt;endservent&gt;, C&lt;gethostbyaddr&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getprotobyname&gt;, C&lt;getprotobynumber&gt;, C&lt;getprotoent&gt;,
C&lt;getservbyname&gt;, C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;sethostent&gt;,
C&lt;setnetent&gt;, C&lt;setprotoent&gt;, C&lt;setservent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T204408Z" changeid="explorer">
        <seg>C&lt;endprotoent&gt;, C&lt;endservent&gt;, C&lt;gethostbyaddr&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getprotobyname&gt;, C&lt;getprotobynumber&gt;, C&lt;getprotoent&gt;,
C&lt;getservbyname&gt;, C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;sethostent&gt;,
C&lt;setnetent&gt;, C&lt;setprotoent&gt;, C&lt;setservent&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example
in L&lt;perlfunc/eof&gt; for how to reset line numbers on each file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vea el ejemplo en L&lt;perlfunc/eof&gt; de cómo restablecer los números de línea en cada archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;^&quot; returns its operands XORed together bit by bit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;^&quot; devuelve la operación XOR, bit a bit, de sus operandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also use a signal name in quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar también nombres de señales entrecomilladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither need
quoting.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ninguno necesita ser entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is handy when you want to do a list assignment in a Boolean
context, because most list functions return a null list when finished,
which when assigned produces a 0, which is interpreted as FALSE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil cuando se quiere hacer una lista de asignación en un contexto booleano, porque la mayoría de funciones que devuelve una lista, devuelven una nula cuando han terminado, que cuando se asignan producen un 0, lo que se interpreta como FALSO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:encoding&gt;
also implicitly pushes on top of itself the C&lt;:utf8&gt; layer because
internally Perl operates on UTF8-encoded Unicode characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;:encoding&gt; también se coloca, implícitamente, por encima de la capa C&lt;:utf8&gt; porque Perl, internamente, opera con caracteres Unicode codificados en UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sub NAME BLOCK
X&lt;sub&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201701Z" changeid="explorer">
        <seg>=item sub NOMBRE BLOQUE
X&lt;sub&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($port, $myaddr) = sockaddr_in($mysockaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($port, $myaddr) = sockaddr_in($mysockaddr);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On insecure systems, these
restrictions may be relaxed, but this is not a portable assumption.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas inseguros, estas restricciones pueden estar más relajadas, pero no es una suposición normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be careful with parentheses:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado con los paréntesis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default is a 16-bit checksum.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor predeterminado es una suma de comprobación de 16-bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the subroutine's prototype is C&lt;($$)&gt;, the elements to be compared
are passed by reference in C&lt;@_&gt;, as for a normal subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el prototipo de la subrutina es C&lt;($$)&gt;, los elementos a ser comparados son pasados por referencia en C&lt;@_&gt;, como en una subrutina normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a subroutine or method call</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>una subrutina o llamada a un método</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DOMAIN, TYPE, and PROTOCOL are specified the same as for
the syscall of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DOMINIO, TIPO, y PROTOCOLO son especificados de la misma manera que la llamada del sistema del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future versions of perl might do something different from the
version of perl you try it out on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Futuras versiones de perl pueden hacer algo diferente de la versión de perl que esté probando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Regex     pattern match            $a =~ /$b/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  Regex      coincidencia de patrones         $a =~ /$b/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a declaration
of the array:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay una declaración del array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlretut/&quot;Using regular expressions in Perl&quot;&gt; for further explanation
of the g and c modifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase L&lt;perlretut/&quot;Usando expresiones regulares en Perl&quot;&gt; para una explicación más detallada de los modificadores g y c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ( ! eof($fh) ) {
            defined( $_ = &lt;$fh&gt; )
                or die &quot;readline failed for $arg: $!&quot;;
            ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050759Z" changeid="explorer">
        <seg>while ( ! eof($fh) ) {
            defined( $_ = &lt;$fh&gt; )
                or die &quot;readline falló para $arg: $!&quot;;
            ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Steve Peters &lt;steve@fisharerojo.org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Steve Peters &lt;steve@fisharerojo.org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-T  File is an ASCII text file (heuristic guess).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-T  Archivo es un archivo de texto ASCII (por una suposición heurística).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the
Internet domain, each address is four bytes long; you can unpack it
by saying something like:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el dominio de Internet, cada dirección son cuatro bytes de longitud; puede desempaquetarlos diciendo algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item warn LIST
X&lt;warn&gt; X&lt;warning&gt; X&lt;STDERR&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211021Z" changeid="explorer">
        <seg>=item warn LISTA
X&lt;warn&gt; X&lt;warning&gt; X&lt;STDERR&gt; X&lt;avisos&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is often useful if you need to check the current Perl version before
C&lt;use&gt;ing library modules that won't work with older versions of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Suele ser útil si necesita comprobar la versión actual de Perl antes de que C&lt;use&gt; módulos que no funcionarán con versiones anteriores de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No Configure is needed to build microperl,
on the other hand this means that interfaces between Perl and your
operating system are left very -- minimal.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se necesita Configure para construir microperl, por otra parte esto significa que las interfaces entre Perl y su sistema operativo se quedan en muy, muy, muy mínimas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a bug in FreeBSD's
C&lt;readdir_r&gt; function in versions 4.5 and earlier that can cause a SEGV when
reading large directories.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay un bug en la función C&lt;readdir_r&gt; de FreeBSD en la versión 4.5 y anteriores que pueden provocar un SEGV al leer grandes directorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Files and I/O</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T232159Z" changeid="zipf">
        <seg>=head2 Archivos y E/S</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parentheses
enclose the argument list for C&lt;print&gt; which is evaluated (printing
the result of C&lt;$foo &amp; 255&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los paréntesis encierran la lista de argumentos para C&lt;print&gt; que se evalúa (imprimir el resultado de C&lt;$foo &amp; 255&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you can't remember what mnemonic means,
you've got a problem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no puede recordar lo que significa un mnemónico, usted tiene un problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5122delta	Perl changes in version 5.12.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5122delta	Cambios en la versión 5.12.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a comprehensive date and time representation look at the
L&lt;DateTime&gt; module on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una completa y actualizada representación del tiempo mire en el módulo L&lt;DateTime&gt; en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is where the notation
C&lt;${arr[$bar]}&gt; comes handy: C&lt;/${arr[0-9]}/&gt; is interpreted as
array element C&lt;-9&gt;, not as a regular expression from the variable
C&lt;$arr&gt; followed by a digit, which would be the interpretation of
C&lt;/$arr[0-9]/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí es donde la notación C&lt;${arr[$bar]}&gt; es muy útil: C&lt;/${arr[0-9]}/&gt; es interpretada como un elemento de array C&lt;-9&gt;, no como una expresión regular desde la variable C&lt;$arr&gt; seguida por un dígito, que puede ser la interpretación de C&lt;/$arr[0-9]/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;string, concatenation&gt; X&lt;concatenation&gt;
X&lt;cat&gt; X&lt;concat&gt; X&lt;concatenate&gt; X&lt;.&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234455Z" changeid="explorer">
        <seg>X&lt;string, concatenation&gt; X&lt;concatenation&gt;
X&lt;cat&gt; X&lt;concat&gt; X&lt;concatenate&gt; X&lt;.&gt; X&lt;cadena&gt; X&lt;concatenación&gt; X&lt;concatenar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the database does not exist, it is created with protection
specified by MASK (as modified by the C&lt;umask&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la base de datos no existe, se crea con la protección especificada por MÁSCARA (y modificada por C&lt;umask&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '%2$d %1$d', 12, 34;      # prints &quot;34 12&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '%2$d %1$d', 12, 34;      # imprime &quot;34 12&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%u    an unsigned integer, in decimal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%u    un entero sin signo, en decimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, OO Perl is largely beyond the scope of this document.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T234942Z" changeid="explorer">
        <seg>Sin embargo, este tema queda fuera del ámbito de este documento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
takes cosine of C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, devuelve el coseno de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># no compile-time or run-time warnings before here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># no advertencias en compilación o ejecución antes de aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.7/8.x for DG/UX ix86 R4.20MU0x</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl 5.7/8.x para DG/UX ix86 R4.20MU0x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the opposite way, to resolve a hostname to the IP address
you can write this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sentido contrario, para resolver un nombre de host a la dirección IP puede escribir lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The null list is represented by ().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La lista nula se representa por ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since voting among different estimators may occur,
the result is not predictable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que la promoción puede ocurrir desde distintos estimadores, el resultado no es predecible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%O    a synonym for %lo</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%O    un sinónimo para %lo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $Config{longsize},     &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $Config{longsize},     &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;tr///&gt;, C&lt;y///&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item C&lt;tr///&gt;, C&lt;y///&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it nice for initializing hashes:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto hace que sea algo agradable para inicializar los hashes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 102.111.111;        # same</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print 102.111.111;        # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef %hash;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef %hash;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 'p N$' ^ &quot; E&lt;H\n&quot;;		# prints &quot;Perl\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print 'p N$' ^ &quot; E&lt;H\n&quot;;		# imprime &quot;Perl\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the independent subexpression C&lt;&lt; (?&gt;...) &gt;&gt; for more details;
possessive quantifiers are just syntactic sugar for that construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver la subexpresión independiente C&lt;&lt; (?&gt;...) &gt;&gt; para obtener más detalles; los cuantificadores posesivos son el edulcorante sintáctico para esta construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl may compile the pattern at the moment of execution of qr()
operator, using qr() may have speed advantages in some situations,
notably if the result of qr() is used standalone:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde que Perl puede compilar el patrón en el momento de la ejecución del operador qr(), usarlo puede tener ventajas de velocidad en algunas situaciones, notablemente si el resultado de qr() se utiliza de forma independiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For integer
conversions (C&lt;d u o x X b i D U O&gt;), numbers are usually assumed to be
whatever the default integer size is on your platform (usually 32 or 64
bits), but you can override this to use instead one of the standard C types,
as supported by the compiler used to build Perl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las conversiones de entero (C&lt;d u o x X b i D U O&gt;), se asume que los números son, por lo general, de un tamaño, por defecto, de un entero de su plataforma (normalmente 32 or 64 bits), pero esto se puede reemplazar usando en su lugar uno de los tipos estándares de C, soportados por el compilador usado para construir Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item bless REF</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item bless REF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;$/&gt; is set to C&lt;undef&gt;, when C&lt;readline&gt; is in scalar
context (i.e., file slurp mode), and when an empty file is read, it
returns C&lt;''&gt; the first time, followed by C&lt;undef&gt; subsequently.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando C&lt;$/&gt; tenga un valor de C&lt;undef&gt;, cuando C&lt;readline&gt; esté en contexto escalar (es decir, modo de absorción completa de archivo), y cuando se esté leyendo un archivo vacío, devuelve C&lt;''&gt; la primera vez, seguido a continuación de C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@array  = delete @hash{qw(foo bar baz)}; # @array  is (undef,undef,33)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@array  = delete @hash{qw(foo bar baz)}; # @array es (undef,undef,33)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To check for that,
use eval:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para comprobar esto, use eval:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception to this is when writing files that should be
kept private: mail files, web browser cookies, I&lt;.rhosts&gt; files, and
so on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La excepción a esto es cuando se escriben archivos que deben mantenerse de forma privada: archivos de correo, los cookies del navegador web, archivos I&lt;rhosts&gt;, y así sucesivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If they happen
to be in the same package, Perl will emit warnings if you have asked
for them, just like multiple C&lt;my&gt; declarations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si están en el mismo paquete, Perl emitirá mensajes de advertencia si los tiene activados, al igual que múltiples declaraciones de C&lt;my&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (1..15) { print &quot;Merry Christmas\n&quot;; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (1..15) { print &quot;Feliz Navidad\n&quot;; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;..&quot; is the range operator, which is really two different
operators depending on the context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;..&quot; es el operador rango, que en realidad son dos operadores diferentes en función del contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens anywhere the arrow operator is used, including even here:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto sucede en cualquier parte en que se use el operador flecha, incluso aquí:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir ($foo)  || die;	# (chdir $foo) || die</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir ($foo)  || die;	# (chdir $foo) || die</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;readline&gt; (or the operator form, C&lt;&lt; &lt;EXPR&gt; &gt;&gt;) as the
conditional of a C&lt;for&gt; loop is shorthand for the following.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando C&lt;readline&gt; (o el operador C&lt;&lt; &lt;EXPR&gt; &gt;&gt;) como condición de un bucle C&lt;for&gt;, es una forma abreviada de escribir lo siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Perl supports passing of up to only 14 arguments to your syscall,
which in practice should (usually) suffice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que Perl soporta pasar sólo hasta 14 argumentos a su syscall, que en la práctica debería (generalmente) ser suficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may charge any fee you choose for support of this
Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede reclamar un canon decidido por usted para el soporte de este Paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, on 32-bit machines
an integer may be represented by a sequence of 4 bytes, which  will in
Perl be presented as a string that's 4 characters long.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192025Z" changeid="explorer">
        <seg>Por ejemplo, en máquinas de 32 bits, un entero puede ser representado por una secuencia de 4 bytes, que en Perl se presentará como una cadena de cuatro caracteres de longitud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Bitwise String Operators
X&lt;operator, bitwise, string&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185911Z" changeid="explorer">
        <seg>=head2 Operadores de bit en cadenas
X&lt;operator, bitwise, string&gt; X&lt;operador, binario, cadena&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;boolean&gt; X&lt;bool&gt; X&lt;true&gt; X&lt;false&gt; X&lt;truth&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;boolean&gt; X&lt;bool&gt; X&lt;true&gt; X&lt;false&gt; X&lt;truth&gt; X&lt;booleano&gt; X&lt;verdadero&gt; X&lt;falso&gt; X&lt;verdad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most systems supporting
fork(), great care has gone into making it extremely efficient (for
example, using copy-on-write technology on data pages), making it the
dominant paradigm for multitasking over the last few decades.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de los sistemas que soportan fork(), se ha tenido gran cuidado en hacerlo extremadamente eficiente (por ejemplo, usando la tecnología copy-on-write en páginas de datos), haciendo de él el paradigma dominante de la multitarea en las últimas décadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that using the v-strings for IPv4
addresses is not portable unless you also use the
inet_aton()/inet_ntoa() routines of the Socket package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el uso de v-strings para las direcciones IPv4 no es portable a menos que también utilice las rutinas del paquete Socket inet_aton()/inet_ntoa().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print v9786;              # prints SMILEY, &quot;\x{263a}&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print v9786;              # imprime SONRISA, &quot;\x{263a}&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $bar;    # prints 30</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $bar;    # pinta 30</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Format number with up to 8 leading zeroes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Formatea número con un máximo de 8 ceros iniciales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substr($name, 7) = 'gap';        # raises an exception</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>substr($nombre, 7) = 'gap';       # lanza una excepción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a value is duplicated in the original hash, only one of those
can be represented as a key in the inverted hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si un valor está duplicado en el hash original, sólo uno de ellos puede ser representado como clave en el hash invertido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;unpack&gt; does the reverse of C&lt;pack&gt;: it takes a string
and expands it out into a list of values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;unpack&gt; hace lo contrario de C&lt;pack&gt;: toma una cadena y se expande hacia fuera en una lista de valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { unimplemented() };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { no_implementado() };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines can also return values:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las subrutinas también pueden devolver valores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlartistic - the Perl Artistic License</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlartistic - la Licencia Artística</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlink &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlink &quot;alfa&quot;, &quot;beta&quot;, &quot;gamma&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This packing may be opened with C&lt;unpack(&quot;l!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este empaquetado se puede abrir con C&lt;unpack(&quot;l!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 4) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 4) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;~~&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;~~&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select STDERR; $| = 1;  # make unbuffered</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select STDERR; $| = 1;  # hacerlo sin buffers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my( $self ) = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my( $self ) = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if you have programmed in another language
you will see familiar pieces in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que si ha programado en otro lenguaje verá partes en Perl que le serán familiares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the &quot;^&quot; character is guaranteed to match only the
beginning of the string, the &quot;$&quot; character only the end (or before the
newline at the end), and Perl does certain optimizations with the
assumption that the string contains only one line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto, el carácter &quot;^&quot; garantiza que coincidirá solo con el principio de la cadena, el carácter &quot;$&quot; solo con el final (o antes del nueva línea del final) y Perl hará ciertas optimizaciones asumiendo que la cadena solo contiene una línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-d  File is a directory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004644Z" changeid="explorer">
        <seg>-d  Archivo es un directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effect of the 'o'
modifier has is not propagated, being restricted to those patterns
explicitly using it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El efecto del modificador 'o' no es propagado, se limita a los patrones que lo utilicen de forma explícita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To sort a hash by value, you'll need to use a C&lt;sort&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ordenar un hash por valor, necesitará usar la función C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my(@AoA, @tmp);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my(@AoA, @tmp);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array   =&gt;  {
                     description =&gt; &quot;ordered list of items&quot;,
                     sigil =&gt; '@',
                    },</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055514Z" changeid="explorer">
        <seg>array   =&gt;  {
                     description =&gt; &quot;lista ordenada de elementos&quot;,
                     sigil =&gt; '@',
                    },</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* C&lt;sub&gt; was a keyword in Perl 4, but in Perl 5 it is an
operator, which can be used in expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>* C&lt;sub&gt; era una palabra clave en Perl 4, pero en Perl 5 es un operador, por lo cual puede ser usado con paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a bit exotic, that last one</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Un poco exótico, este último</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function semctl(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC semctl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the slash that terminated C&lt;m//&gt; was followed by a C&lt;SPACE&gt;,
the example above is not C&lt;m//x&gt;, but rather C&lt;m//&gt; with no C&lt;/x&gt;
modifier.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que la barra que terminó C&lt;m//&gt; fue seguida por un C&lt;SPACE&gt;, el ejemplo anterior no es C&lt;m//x&gt;, sino más bien C&lt;m//&gt;, sin el modificador C&lt;/x&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically you will want to C&lt;use I&lt;Module::Name&gt;&gt;, which will then give
you access to exported functions or an OO interface to the module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225612Z" changeid="explorer">
        <seg>Normalmente agregará a su programa la línea C&lt;use I&lt;Nombre::Módulo&gt;&gt;, que le proporcionará acceso a las funciones exportadas o a una interfaz orientada a objetos del módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's all!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¡Eso es todo!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Future Directions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Direcciones futuras</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Really means this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En realidad significa lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also extend an array
by assigning to an element that is off the end of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También se puede extender un array haciendo una asignación a un elemento que esté más allá del final del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End_Lines</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fin_Lineas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;keys @array&gt; in an lvalue context is a syntax
error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;keys @array&gt; en un contexto a la izquierda es un error de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Bigger Numbers
X&lt;number, arbitrary precision&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011326Z" changeid="explorer">
        <seg>=head2 Grandes números
X&lt;number, arbitrary precision&gt; X&lt;número, precisión arbitraria&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>q  A signed quad (64-bit) value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>q  Un valor cuádruplo con signo (64 bit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $w (0..3) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $w (0..3) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item  C&lt;m''&gt;, the pattern of C&lt;s'''&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item  C&lt;m''&gt;, y el patrón de C&lt;s'''&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty leading fields are produced when there are positive-width matches at
the beginning of the string; a zero-width match at the beginning of
the string does not produce an empty field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Campos vacíos antecedentes son producidos cuando hay coincidencias de ancho positivas al principio de la cadena; una coincidencia de ancho cero al principio de la cadena no produce un campo vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a failed C&lt;m//gc&gt; match doesn't reset the offset,
the return from C&lt;pos&gt; won't change either in this case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que una coincidencia C&lt;m//gc&gt; fallida no reinicia el desplazamiento, el retorno de C&lt;pos&gt; no cambiará en ese caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value C&lt;LVALUE&gt; indicates a reference to an lvalue that is not
a variable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T202415Z" changeid="explorer">
        <seg>El valor de retorno C&lt;LVALUE&gt; indica una referencia a un I&lt;ivalor&gt; (valor que se pone a la izquierda) que no es una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string =~ /foo${re}bar/;	# can be interpolated in other patterns</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cadena =~ /foo${re}bar/;	# puede ser interpolado en otros patrones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parent directory (/tmp/) is not safe (sticky bit not set</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Parent directory (/tmp/) is not safe (sticky bit not set</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($key, $value) = each %hash) {
          print $key, &quot;\n&quot;;
          delete $hash{$key};   # This is safe</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044056Z" changeid="explorer">
        <seg>while (($clave, $valor) = each %hash) {
          print $clave, &quot;\n&quot;;
          delete $hash{$clave};   # Esto es seguro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ord(&quot;\N{omega}&quot;) );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ord(&quot;\N{omega}&quot;) );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @greek_small =  map { chr } ( ord(&quot;\N{alpha}&quot;) ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @griegas_minusculas =  map { chr } ( ord(&quot;\N{alpha}&quot;) ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rand 10 * 20;	# rand (10 * 20)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>rand 10 * 20;	# rand (10 * 20)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[]    anon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[]    array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember the following important rule: There is B&lt;no rule&gt; that relates
the behavior of an expression in list context to its behavior in scalar
context, or vice versa.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recuerde la siguiente regla importante: B&lt;No hay regla&gt; que relacione el comportamiento de una expresión en contexto lista a su comportamiento en contexto escalar, o viceversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;my&gt; in combination with a C&lt;use strict;&gt; at the top of
your Perl scripts means that the interpreter will pick up certain common
programming errors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225051Z" changeid="explorer">
        <seg>Si escribe C&lt;use strict;&gt; al principio de los scripts de Perl y usa C&lt;my&gt;, el intérprete detectará determinados errores frecuentes de programación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array is given scalar context,
and instead of using the 0th element of the array as the format, Perl will
use the count of elements in the array as the format, which is almost never
useful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El array se le da en contexto escalar, y en lugar de utilizar el elemento 0 del array como el formato, Perl usará el número de elementos del array como el formato, que casi nunca es útil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} elsif ( other condition ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002934Z" changeid="zipf">
        <seg>} elsif ( otra condición ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For WHENCE you may use the constants C&lt;SEEK_SET&gt;,
C&lt;SEEK_CUR&gt;, and C&lt;SEEK_END&gt; (start of the file, current position, end
of the file) from the Fcntl module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para DONDE puede usar las constantes C&lt;SEEK_SET&gt;,
C&lt;SEEK_CUR&gt;, y C&lt;SEEK_END&gt; (inicio de archivo, posición actual, y fin de archivo) desde el módulo Fcntl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the mostly deeply nested array or hash will not spring into
existence just because its existence was tested, any intervening ones will.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015116Z" changeid="explorer">
        <seg>Aunque el array o hash más profundamente anidado no se autovivifique sólo por que su existencia sea comprobada, cualquiera de los niveles intermedios sí que lo hará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Parentheses for capturing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T183354Z" changeid="zipf">
        <seg>=item Paréntesis de captura</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is supported it usually encodes some
administrative comment about the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está soportado usualmente codifica algún comentario administrativo sobre el usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Double quotes or single quotes may be used around literal strings:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224741Z" changeid="explorer">
        <seg>Las cadenas literales se pueden escribir entre comillas dobles o simples:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Will raise an exception if used on a machine that
doesn't implement getpgrp(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elevará una excepción si se usa en una máquina que no implemente getpgrp(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the outer bracket type has changed, and so our access syntax
has also changed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Observe que el paréntesis más exterior ha cambiado, por lo que nuestra sintaxis de acceso ha cambiado también.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tr///</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item tr///</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sb = stat($filename);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$sb = stat($archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># sort using explicit subroutine name</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ordena usando un nombre de una subrutina explícita</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is intended to give you a quick overview of the Perl
programming language, along with pointers to further documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224521Z" changeid="explorer">
        <seg>Este documento proporciona una introducción rápida al lenguaje de programación Perl e incluye referencias a documentación adicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sequence   Note    Description</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110220T230159Z" changeid="explorer">
        <seg>Secuencia  Nota    Descripción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item alarm</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item alarm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's here so that modules, programs, etc., that want to declare
this as their distribution license can link to it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es aquí, si desea declarar esto como su licencia de distribución, donde los módulos, programas, etc, pueden enlazarse con ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of EXPR indicates how many call frames
to go back before the current one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de EXPR indica cuántos marcos de llamada se ha de retroceder antes del actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item splice ARRAY,OFFSET,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item splice ARRAY,DESPLAZAMIENTO,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;while&gt; repeats the statement I&lt;while&gt; the condition is true.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013126Z" changeid="explorer">
        <seg>C&lt;while&gt; repite la instrucción I&lt;mientras&gt; la condición sea cierta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlwin32		Perl notes for Windows</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlwin32		Notas para Windows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;lt&quot; returns true if the left argument is stringwise less than
the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;lt&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente menor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behaves like wait(2) on your system: it waits for a child
process to terminate and returns the pid of the deceased process, or
C&lt;-1&gt; if there are no child processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se comporta como wait(2) de su sistema: espera a que un proceso hijo termine y devuelve el PID del proceso que ha fallecido, o C&lt;-1&gt; si no hay procesos hijos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the length in I&lt;characters&gt; of the value of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la longitud en I&lt;caracteres&gt; del valor de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's 
because strings that aren't numbers count as 0, just as they do in B&lt;awk&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es porque las cadenas que no son números cuentan como 0, igual a como se comportan en B&lt;awk&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use if WANT_WARNINGS, warnings =&gt; qw(all);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use if WANT_WARNINGS, warnings =&gt; qw(all);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(EXPR should be positive.)  If EXPR is
omitted, the value C&lt;1&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(EXPR debe ser positiva). Si EXPR se omite, se usa el valor C&lt;1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/$rex/foo/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/$rex/foo/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %h = ( FOO =&gt; 23 );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my %h = ( FOO =&gt; 23 );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backslashed metacharacters in Perl are alphanumeric, such as C&lt;\b&gt;,
C&lt;\w&gt;, C&lt;\n&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Metacaracteres escapados en Perl son alfanuméricos, como C&lt;\b&gt;, C&lt;\w&gt;, C&lt;\n&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughout the previous section all the examples have used the syntax:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T231620Z" changeid="zipf">
        <seg>En todos los ejemplos de la sección anterior se utilizó esta sintaxis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every C&lt;when&gt; block is implicitly ended with
a C&lt;break&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada bloque C&lt;when&gt; se termina, implícitamente, con un C&lt;break&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;caller&gt;, C&lt;import&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;, C&lt;state&gt;, C&lt;package&gt;,
C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;caller&gt;, C&lt;import&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;, C&lt;package&gt;, C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shuts down a socket connection in the manner indicated by HOW, which
has the same interpretation as in the syscall of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cierra una conexión de socket en la manera indicada por el CÓMO, que tiene la misma interpretación que en la llamada del sistema del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Causes the script to sleep for (integer) EXPR seconds, or forever if no 
argument is given.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace que el programa duerman EXPR segundos (entero), o para siempre si se da ningún argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In IRIX 5.3 and with Perl 5.8.1 (Perl 5.8.0 didn't compile in IRIX 5.3)
the following failures are known.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004901Z" changeid="explorer">
        <seg>En IRIX 5.3 y con Perl 5.8.1 (Perl 5.8.0 no compila en IRIX 5.3) se conocen los siguientes fallos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values are returned in an apparently random order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores son devueltos en un aparente orden aleatorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good error messages should
go to C&lt;STDERR&gt;, include which program caused the problem, what the failed
system call and arguments were, and (VERY IMPORTANT) should contain the
standard system error message for what went wrong.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los buenos mensajes de error deben ir al C&lt;STDERR&gt;, incluyendo qué programa causó el problema, qué función del sistema y qué argumentos fueron, y (MUY IMPORTANTE) debe contener el mensaje de error estándar del sistema por el cual falló.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/wantarray&gt; for more on how the evaluation context can be 
determined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/wantarray&gt; para saber cómo determinar el contexto de la evaluación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C&lt;exec&gt;, C&lt;system&gt; allows you to lie to a program about its name if
you use the C&lt;system PROGRAM LIST&gt; syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que C&lt;exec&gt;, C&lt;system&gt; permite reposar a un programa bajo un nombre, si se utiliza la sintaxis C&lt;system PROGRAMA LISTA&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment to a
scalar evaluates the right-hand side in scalar context, while
assignment to an array or hash evaluates the righthand side in list
context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La asignación a un escalar evalúa lo que hay en el lado derecho en contexto escalar, mientras que la asignación a un array o a un hash evalúa el lado derecho en contexto de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use IPC::SysV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use IPC::SysV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;format l is %d, l!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;formato l es %d, l!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%10.5s&gt;', &quot;truncated&quot;; # prints &quot;&lt;     trunc&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%10.5s&gt;', &quot;truncado&quot;; # imprime &quot;&lt;     trunc&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's the
same, however, in that it does reparse the file every time you call it,
so you probably don't want to do this inside a loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es lo mismo, sin embargo, en que vuelve a interpretar el archivo cada vez que lo llama, así que, probablemente, no querrá hacer esto dentro de un bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
$quota is unsupported, it is an empty scalar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la $cuota no está soportada, es un escalar vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -le '$a = &quot;NaN&quot;; print &quot;NaN support here&quot; if $a != $a'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl -le '$a = &quot;NaN&quot;; print &quot;tiene soporte NaN&quot; if $a != $a'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DELETE this, key</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DELETE este, clave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other escape sequences such as C&lt;\200&gt; and C&lt;\t&gt; and backslashed
characters such as C&lt;\\&gt; and C&lt;\-&gt; are converted to appropriate literals.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las otras secuencias de escape, como C&lt;\200&gt; y C&lt;\t&gt; y caracteres escapados con contrabarras, como C&lt;\\&gt; y C&lt;\-&gt;, son convertidas a literales apropiados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To learn how to use a particular module, use C&lt;perldoc I&lt;Module::Name&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225608Z" changeid="explorer">
        <seg>Para aprender a usar un módulo específico, ejecute C&lt;perldoc I&lt;Nombre::Módulo&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@chars = map(chr, @nums);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@caracteres = map(chr, @numeros);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the current process group for the specified PID, C&lt;0&gt; for the current
process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Establece el grupo de procesos en curso para el PID especificado, C&lt;0&gt; para el proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The oct() function is commonly used when a string such as C&lt;644&gt; needs
to be converted into a file mode, for example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función oct() es de uso común cuando una cadena como C&lt;644&gt; tiene que ser convertida en un modo de archivo, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that some command shells may place restrictions on the length
of the command line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que algunos shell de comandos puede imponer restricciones a la longitud de la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chown LIST
X&lt;chown&gt; X&lt;owner&gt; X&lt;user&gt; X&lt;group&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170216Z" changeid="explorer">
        <seg>=item chown LISTA
X&lt;chown&gt; X&lt;owner&gt; X&lt;user&gt; X&lt;group&gt; X&lt;propietario&gt; X&lt;usuario&gt; X&lt;grupo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Waits for a particular child process to terminate and returns the pid of
the deceased process, or C&lt;-1&gt; if there is no such child process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espera que termine un proceso hijo en particular y devuelve el PID del proceso que ha fallecido, o C&lt;-1&gt; si no existe tal proceso hijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc/&quot;SysV IPC&quot;&gt;,
C&lt;IPC::SysV&gt; documentation, and the C&lt;IPC::Shareable&gt; module from CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también la documentación L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, y el módulo C&lt;IPC::Shareable&gt; en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get a hexadecimal digit, or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para obtener un dígito hexadecimal o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead it is
primarily used to check if two pieces of text are the same without
having to transmit or store the text itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En cambio se usa principalmente para comprobar si dos trozos de textos son el mismo sin tener que transmitirlo o almacenarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the peculiar C&lt;use VERSION&gt; form, VERSION may be either a positive
decimal fraction such as 5.006, which will be compared to C&lt;$]&gt;, or a v-string
of the form v5.6.1, which will be compared to C&lt;$^V&gt; (aka $PERL_VERSION).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la forma peculiar C&lt;use VERSION&gt;, VERSION puede ser tanto un número fraccionario decimal positivo, como 5.006, que será comparado con C&lt;$]&gt;, o como una v-cadena de la forma v5.6.1, que será comparado con C&lt;$^V&gt; (también conocido como $PERL_VERSION).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#  5          6          7            8       9         10</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165947Z" changeid="explorer">
        <seg>#  5          6          7            8       9         10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Despite the funny
names, precedence is the same as any other named unary operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A pesar de los nombres graciosos, la precedencia es la misma que cualquier otro operador unario con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Fall-through</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Atravesar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takes the same flags as the system call of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toma las mismas banderas que la llamada al sistema del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.pm.org/         the Perl Mongers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://www.pm.org/         los Perl Mongers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sysopen FILEHANDLE,FILENAME,MODE,PERMS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204142Z" changeid="explorer">
        <seg>=item sysopen GESTOR_ARCHIVO,ARCHIVO,MODO,PERMISOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you were into Schwartzian Transforms, you would probably
have selected map for that</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T195313Z" changeid="explorer">
        <seg>Si está en una transformada Schwartziana, es probable que haya elegido map para esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item i
X&lt;/i&gt; X&lt;regex, case-insensitive&gt; X&lt;regexp, case-insensitive&gt;
X&lt;regular expression, case-insensitive&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222805Z" changeid="explorer">
        <seg>=item i
X&lt;/i&gt; X&lt;regex, case-insensitive&gt; X&lt;regexp, case-insensitive&gt; X&lt;regular expression, case-insensitive&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ -pthread]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ -pthread]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,11, 2) = 2   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,11, 2) = 2   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     undef     undefined                !defined $a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  undef      indefinido                       !defined $a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So don't do that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que no lo haga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die q(I don't know what to do with $foo);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die q(No sé qué hacer con $foo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.apollo - Perl version 5 on Apollo DomainOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.apollo - Perl versión 5 sobre Apollo DomainOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if there were a C&lt;continue&gt; block on the above, it would get
executed even on discarded lines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que si hubiera un bloque C&lt;continue&gt; a continuación del anterior, se ejecutaría incluso en las líneas descartadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has three main variable types: scalars, arrays, and hashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224803Z" changeid="explorer">
        <seg>En Perl hay tres tipos de variables principales: escalares, arrays y hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sound principle is to use only ranges
that begin from and end at either alphabets of equal case (a-e, A-E),
or digits (0-4).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un buen principio es el de usar rangos que sólo comiencen y terminen, en cualquier alfabeto, con un mismo tamaño de caja (a-e, A-E), o dígitos (0-4).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function cannot be used on an entire array or hash to find out how
many elements these have.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función no puede utilizarse en un array o hash para averiguar cuántos elementos tienen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Builtin types have all uppercase names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tipos incluidos tienen todos sus nombres en mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;import&gt; is not a builtin; it's just an ordinary static method
call into the C&lt;Module&gt; package to tell the module to import the list of
features back into the current package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;import&gt; no es una orden interna; es sólo una llamada al método estático ordinario en el paquete C&lt;Módulo&gt; para indicar al módulo que importe la lista de características en el paquete actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;RE&gt; in C&lt;?RE?&gt;, C&lt;/RE/&gt;, C&lt;m/RE/&gt;, C&lt;s/RE/foo/&gt;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item C&lt;RE&gt; en C&lt;?RE?&gt;, C&lt;/RE/&gt;, C&lt;m/RE/&gt;, C&lt;s/RE/foo/&gt;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;defined&gt; X&lt;undefined&gt; X&lt;undef&gt; X&lt;null&gt; X&lt;string, null&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;defined&gt; X&lt;definido&gt; X&lt;undefined&gt; X&lt;indefinido&gt; X&lt;undef&gt; X&lt;null&gt; X&lt;nulo&gt; X&lt;string, null&gt; X&lt;cadena, nulo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shutdown SOCKET,HOW
X&lt;shutdown&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200639Z" changeid="explorer">
        <seg>=item shutdown SOCKET,CÓMO
X&lt;shutdown&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; =&gt; &gt;&gt; operator is a synonym for the comma except that it causes
its left operand to be interpreted as a string if it begins with a letter
or underscore and is composed only of letters, digits and underscores.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador C&lt;&lt; =&gt; &gt;&gt; es un sinónimo de la coma, salvo que causa que su operando izquierdo debe interpretarse como una cadena si comienza con una letra o un subrayado y está exclusivamente integrado por letras, dígitos y subrayados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\z  Match only at end of string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225912Z" changeid="explorer">
        <seg>\z  Coincide solo con el final de la cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef   Hash      always false (undef can't be a key)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef       Hash       siempre falso (undef no puede ser una clave)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/Warning on \1 Instead of $1&gt; below for details.)
Referring back to another part of the match is called a
I&lt;backreference&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203935Z" changeid="explorer">
        <seg>Véase L&lt;/Atención a \1 en lugar de $1&gt; a continuación, para los detalles)
Referirse a otra parte de la coincidencia se llama I&lt;contrareferencia&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The file is included via the do-FILE
mechanism, which is essentially just a variety of C&lt;eval&gt; with the
caveat that lexical variables in the invoking script will be invisible
to the included code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El archivo es incluido a través del mecanismo do ARCHIVO, que es esencialmente lo mismo que una variedad de C&lt;eval&gt; con la advertencia de que las variables léxicas en la secuencia de comandos del programa serán invisibles para el código incluido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open STDOUT, &quot;&gt;&amp;&quot;, $oldout or die &quot;Can't dup \$oldout: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open STDOUT, &quot;&gt;&amp;&quot;, $oldout or die &quot;No puedo duplicar \$oldout: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should seldom if ever use C&lt;0644&gt; as argument to C&lt;sysopen&gt;, because
that takes away the user's option to have a more permissive umask.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Rara vez o nunca debe utilizar C&lt;0644&gt; como argumento a C&lt;sysopen&gt;, porque eso le quita al usuario la opción de tener un umask más permisivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl 5 smart match and C&lt;given&gt;/C&lt;when&gt; constructs are not
absolutely identical to their Perl 6 analogues.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La coincidencia inteligente de Perl 5 y las construcciones C&lt;given&gt;/C&lt;when&gt; no son completamente idénticas a sus análogas en Perl 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At other times, a simple comparison to C&lt;0&gt; or C&lt;&quot;&quot;&gt; is
what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras ocasiones, una simple comparación con C&lt;0&gt; o C&lt;&quot;&quot;&gt; es lo que necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically these are arguments such as might be passed
to the C&lt;dbm_open()&gt; function of C.  The object returned by the C&lt;new&gt;
method is also returned by the C&lt;tie&gt; function, which would be useful
if you want to access other methods in CLASSNAME.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo general estos son argumentos que pudieran ser transmitidos a la función del C C&lt;dbm_open()&gt;. El objeto devuelto por el método C&lt;new&gt; también es devuelto por la función C&lt;tie&gt;, que será útil si desea tener acceso a otros métodos en CLASE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmodinstall	Perl modules: how to install from CPAN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmodinstall	Módulos Perl: cómo instalar desde CPAN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the Perlish post-condition way</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T182219Z" changeid="zipf">
        <seg># ahora con una condición posterior, al estilo Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gethostbyname NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gethostbyname NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print (...) interpreted as function at - line 1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print (...) interpreted as function at - line 1.
(print (...) interpretado como función en - línea 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values for WHENCE are C&lt;0&gt; to set the new position
I&lt;in bytes&gt; to POSITION, C&lt;1&gt; to set it to the current position plus
POSITION, and C&lt;2&gt; to set it to EOF plus POSITION (typically
negative).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores de DONDE son C&lt;0&gt; para poner la nueva posición I&lt;en bytes&gt; a POSICIÓN, C&lt;1&gt; para poner la posición actual más POSICIÓN, y C&lt;2&gt; para ponerlo a EOF más POSICIÓN (normalmente negativo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perllocale&gt; for discussion of additional considerations that apply
when C&lt;use locale&gt; is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perllocale&gt; para la discusión de consideraciones adicionales que se aplican cuando el C&lt;use locale&gt; está en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything else is unsafe.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier otro caso no es seguro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The right operand is not evaluated while the operator is in the
&quot;false&quot; state, and the left operand is not evaluated while the
operator is in the &quot;true&quot; state.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operando de la derecha no es evaluado, mientras que el operador esté en el estado &quot;falso&quot;, y el operando de la izquierda no es evaluado mientras que el operador se encuentre en el estado &quot;verdadero&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are multiple cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay múltiples casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$^ = 'report1_top';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$^ = 'informe1_top';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the hook is an array reference, its first element must be a subroutine
reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el enganche es una referencia de array, su primer elemento debe ser una referencia a una subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%3\$d %d %d\n&quot;, 12, 34, 56;    # will print &quot;56 12 34\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%3\$d %d %d\n&quot;, 12, 34, 56;    # imprimirá &quot;56 12 34\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That
means that, if you don't use binmode() on these systems, C&lt;\cM\cJ&gt;
sequences on disk will be converted to C&lt;\n&gt; on input, and any C&lt;\n&gt; in
your program will be converted back to C&lt;\cM\cJ&gt; on output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que, si no usas binmode() en estos sistemas, las secuencias C&lt;\cM\cJ&gt; en disco serán convertidas a C&lt;\n&gt; en la entrada y cualquier C&lt;\n&gt; en tu programa será convertido de nuevo en C&lt;\cM\cJ&gt; en la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override that with an explicit C&lt;last&gt; if you're only
interested in the first match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede invalidar esto con un explícito C&lt;last&gt; si solo está interesado en la primera coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning to C&lt;$#days&gt; actually changes the length of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Asignar un valor a C&lt;$#días&gt; cambia realmente la longitud del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every variable type has its own namespace, as do several
non-variable identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada tipo de variable tiene su propio espacio de nombres, y ocurre igual con otros tipos de identificadores que no designan variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item index STR,SUBSTR,POSITION
X&lt;index&gt; X&lt;indexOf&gt; X&lt;InStr&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173951Z" changeid="explorer">
        <seg>=item index STRING,SUBSTR,POSICIÓN
X&lt;index&gt; X&lt;indexOf&gt; X&lt;InStr&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># ASCII-based examples</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Ejemplo basados en ASCII</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are documented at great length in L&lt;perlre&gt;, but for
the meantime, here's a quick cheat sheet:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225424Z" changeid="explorer">
        <seg>Estas se describen de forma detallada en L&lt;perlre&gt;. A continuación se incluye una guía rápida:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $tmp, &quot;+&gt;&quot;, undef) or die ...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $tmp, &quot;+&gt;&quot;, undef) or die ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Be aware&gt;
that calling exists on array values is deprecated and likely to be removed in
a future version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;Queda avisado&gt; que borrar elementos de un array mediante delete() es una funcionalidad obsoleta y es probable que sea eliminada en una futura versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During this search no attention is paid to the semantics of the construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Durante esta búsqueda no se presta atención a la semántica de la construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can
see whether using C&lt;!&gt; makes any difference this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede ver si usando C&lt;!&gt; provoca alguna diferencia, de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shutdown(SOCKET, 0);    # I/we have stopped reading data</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shutdown(SOCKET, 0);    # Hemos dejado de leer datas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my($what,$where,$howmuch) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my($que,$donde,$cuanto) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt; (possibly paired with C&lt;\E&gt;) are
converted to corresponding Perl constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt; (posiblemente emparejado con C&lt;\E&gt;) son convertidas a las correspondientes construcciones Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instead, it has C&lt;\Q&gt;, C&lt;\\&gt;, and C&lt;E&gt;, so the
result is the same as for C&lt;&quot;\\\\E&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>en cambio, tiene a C&lt;\Q&gt;, C&lt;\\&gt;, y C&lt;E&gt;, por lo que el resultado es el mismo que para C&lt;&quot;\\\\E&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># SYNTAX ERROR HERE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ERROR DE SINTAXIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Perls 5.8.0 and later, PerlIO is
most often the default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para Perls v5.8.0 y posteriores, PerlIO suele ser el predeterminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the new C&lt;and&gt; and C&lt;or&gt; operators to avoid having to parenthesize
list operators so much, and to reduce the incidence of punctuation
operators like C&lt;&amp;&amp;&gt; and C&lt;||&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use los nuevos operadores C&lt;and&gt; y C&lt;or&gt; para evitar poner demasiados paréntesis en listas de operadores y para reducir la incidencia de puntuación de operadores como C&lt;&amp;&amp;&gt; y C&lt;||&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are
I&lt;strongly&gt; advised to follow this introduction with more information
from the full Perl manual, the table of contents to which can be found
in L&lt;perltoc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224548Z" changeid="explorer">
        <seg>Es I&lt;muy&gt; recomendable complementar esta introducción con información del manual de Perl completo, cuya tabla de contenido se encuentra en L&lt;perltoc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitstrings of any size may be manipulated by the bitwise operators
(C&lt;~ | &amp; ^&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cadenas de bits de cualquier tamaño pueden ser manipulados por los operadores binarios (C&lt;~ | &amp; ^&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ah, but what if you wanted a I&lt;two-dimensional slice&gt;, such as having
$x run from 4..8 and $y run from 7 to 12?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194932Z" changeid="explorer">
        <seg>¡Ah!, pero ¿qué pasa si yo quisiera un I&lt;porción bidimensional&gt;, ¿cómo hacer que $x vaya de 4 al 8 y $y de 7 al 12?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>no strict 'refs';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no strict 'refs';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the expression (which is itself
determined within scalar context) is first parsed, and if there weren't any
errors, executed in the lexical context of the current Perl program, so
that any variable settings or subroutine and format definitions remain
afterwards.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de la expresión (que es en sí mismo determinada en contexto escalar) es primero interpretada, y si no hay ningún error, ejecutada en el contexto léxico del actual programa Perl, por lo que no se mantienen después ningún valor de variable o definiciones de subrutinas o formatos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/binmode&gt;, L&lt;/open&gt;, and the C&lt;open&gt; pragma, L&lt;open&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/binmode&gt;, L&lt;/open&gt;, y el pragma C&lt;open&gt;, L&lt;open&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only
universally recognized values for EXPR are C&lt;0&gt; for success and C&lt;1&gt;
for error; other values are subject to interpretation depending on the
environment in which the Perl program is running.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los únicos valores universalmente reconocidos para EXPR son C&lt;0&gt; para éxito y C&lt;1&gt; para error; otros valores están sujetos a interpretación dependiendo del entorno en que el programa Perl está corriendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At other times, you
might prefer to determine whether string data can be used numerically
by calling the POSIX::strtod() function or by inspecting your string
with a regular expression (as documented in L&lt;perlre&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras ocasiones, podría ser preferible determinar si una cadena de datos puede ser usada numéricamente llamando a la función POSIX::strtod() o inspeccionando la cadena con una expresión regular (las cuales están documentadas en L&lt;perlre&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Devel::PPPort</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Devel::PPPort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't rely on the alarm causing the system call to
fail with C&lt;$!&gt; set to C&lt;EINTR&gt; because Perl sets up signal handlers to
restart system calls on some systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede confiar que la alarma que llama a la llamada del sistema falle y ponga C&lt;$!&gt; a C&lt;EINTR&gt; porque Perl activa gestores de señal para reiniciar llamadas al sistema en algunos sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;p&gt; and C&lt;P&gt; formats should be used with care.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los formatos C&lt;p&gt; y C&lt;P&gt; deben ser utilizados con cuidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like all Perl character operations, length() normally deals in logical
characters, not physical bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que todas las operaciones Perl, de caracteres, length() normalmente trata con caracteres lógicos, no bytes físicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that there is no comma after VERSION!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¡Tenga en cuenta que no hay ninguna coma después de VERSIÓN!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;   sSiIlLqQ   Force little-endian byte-order on the type.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;   sSiIlLqQ   Fuerza un orden de bytes en little-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item abs</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item abs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, C&lt;stat&gt; returns a boolean value indicating success
or failure, and, if successful, sets the information associated with
the special filehandle C&lt;_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, C&lt;stat&gt; devuelve un valor booleano que indica el éxito o el fracaso y, si tiene éxito, establece la información asociada con el gestor de archivo especial C&lt;_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true for
success, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero en caso de éxito, o falso en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;not&gt; for a lower
precedence version of this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también C&lt;not&gt; para una versión de menor prioridad que ésta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A backslash represents a backslash
unless followed by the delimiter or another backslash, in which case
the delimiter or backslash is interpolated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una barra invertida representa una barra invertida a menos que esté seguida por el delimitador u otra barra invertida, en cuyo caso el delimitador o la barra invertida son interpolados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A semicolon is still encouraged if the
block takes up more than one line, because you may eventually add
another line.)  Note that there are some operators like C&lt;eval {}&gt; and
C&lt;do {}&gt; that look like compound statements, but aren't (they're just
TERMs in an expression), and thus need an explicit termination if used
as the last item in a statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012953Z" changeid="explorer">
        <seg>(Un punto y coma es aún así recomendable si el bloque tiene más de una línea, porque, eventualmente, puede añadir alguna línea más). Note que algunos operadores como C&lt;eval {}&gt; y C&lt;do {}&gt; parecen instrucciones compuestas, pero no lo son (son sólo TÉRMINOS en una expresión) y es necesario una terminación explícita si se usa como el último punto de una instrucción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the filehandle came from a piped open, C&lt;close&gt; returns false if one of
the other syscalls involved fails or if its program exits with non-zero
status.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el gestor proviene de una tubería abierta, C&lt;close&gt; adicionalmente devolverá falso si alguna de las otras llamadas del sistema implicadas falla, o si el programa termina con un valor de estado distinto de cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get somewhat similar but locale dependent date strings, set up your
locale environment variables appropriately (please see L&lt;perllocale&gt;) and
try for example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener algo similar, pero con cadenas de fecha dependiente de la configuración región, ajuste apropiadamente sus variables de entorno a la región (véase L&lt;perllocale&gt;) e intente, por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.*?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>.*?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does not attempt to do titlecase mapping on initial letters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No intentará hacer un mapeo de mayúsculas con tilder en las letras iniciales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also a simple rule that works
consistently with C&lt;VAR_NAMES_LIKE_THIS&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es una regla que funciona también con C&lt;VAR_NOMBRES_COMO_ESTE&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two elements of the list must be the NUMERICAL access
and modification times, in that order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los dos primeros elementos de la lista deben ser el tiempo de acceso y modificación, NUMÉRICOS, y en ese orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sin</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl by default is very forgiving.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T000941Z" changeid="zipf">
        <seg>Por su diseño, Perl es un lenguaje muy indulgente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\e		escape          (ESC)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002835Z" changeid="explorer">
        <seg>\e		escape           (ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;SCALAR&gt; method is now available for tied hashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un método C&lt;SCALAR&gt; está ahora disponible para los hash enlazados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return map {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053109Z" changeid="explorer">
        <seg>return map {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not form legal quoted expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no forman expresiones legales de entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {$a cmp $b} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {$a cmp $b} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ .= &lt;&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ .= &lt;&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bart</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>bart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#        produces 123456789123456784</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#        produce 123456789123456784</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $file (&quot;/share/prog/defaults.rc&quot;,
               &quot;$ENV{HOME}/.someprogrc&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043927Z" changeid="explorer">
        <seg>for $file (&quot;/share/prog/defaults.rc&quot;,
               &quot;$ENV{HOME}/.someprogrc&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example, the third line above produces:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, la tercera línea de arriba produce:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows a 2 level hash of hash
structure using anonymous hash references.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224956Z" changeid="explorer">
        <seg>En el ejemplo siguiente se muestra una estructura de hash de hashes de 2 niveles en la que se usan referencias de hash anónimas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 mode     file mode  (type and permissions)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2 mode     modo de archivo (tipo y permisos)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2: 'q', pos=8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2: 'q', pos=8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Warning&gt;: If the filehandle is marked C&lt;:utf8&gt;, Unicode characters
encoded in UTF-8 are written instead of bytes, and the LENGTH, OFFSET, and
return value of syswrite() are in (UTF-8 encoded Unicode) characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;Advertencia&gt;: Si el gestor está marcado como C&lt;:utf8&gt;, caracteres Unicode codificados en UTF-8 son escritos en lugar de bytes, y la LONGITUD, DESPLAZAMIENTO y el valor de retorno de syswrite() estarán codificados en caracteres (en Unicode UTF-8).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2: 'q', pos=5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2: 'q', pos=5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support fchown(2), passing filehandles raises
an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que no admiten fchown(2), pasarle un gestor de archivo lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item truncate FILEHANDLE,LENGTH
X&lt;truncate&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T205959Z" changeid="explorer">
        <seg>=item truncate GESTOR_ARCHIVO,LONGITUD
X&lt;truncate&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So instead of</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que en lugar de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$in_header =   1  ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$en_cabecera =   1  ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ld:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004644Z" changeid="explorer">
        <seg>ld:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>56 tests and 474 subtests skipped.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005013Z" changeid="explorer">
        <seg>56 tests y 474 subtests omitidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if it succeeded, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tiene éxito; de lo contrario, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$path =~ s|/usr/bin|/usr/local/bin|;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ruta =~ s|/usr/bin|/usr/local/bin|;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only one timer may be counting at once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo un temporizador puede estar contando cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, '|-', &quot;tr '[a-z]' '[A-Z]'&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, '|-', &quot;tr '[a-z]' '[A-Z]'&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HASH is the name of the hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>HASH es el nombre del hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, if
you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, si dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can order it and other Perl books from O'Reilly &amp;
Associates, 1-800-998-9938.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T233741Z" changeid="explorer">
        <seg>Puede pedir éste y otros libros Perl a O'Reilly &amp; Asociados, 1-800-998-9938.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $nodelay = unpack(&quot;I&quot;, $packed);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $nodelay = unpack(&quot;I&quot;, $empaquetado);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrecharclass/Backslash sequences&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225142Z" changeid="explorer">
        <seg>Véase L&lt;perlrecharclass/Secuencias con contrabarra&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, while searching for terminating C&lt;/&gt;,
combinations of C&lt;\\&gt; and C&lt;\/&gt; are skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, mientras se busca por el C&lt;/&gt; final, las combinaciones de C&lt;\\&gt; y C&lt;\/&gt; son omitidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UNTIE this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>UNTIE este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are intending to manipulate bitstrings, be certain that
you're supplying bitstrings: If an operand is a number, that will imply
a B&lt;numeric&gt; bitwise operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si tiene la intención de manipular cadenas de bits, asegúrese de que está suministrando cadenas de bits: si un operando es un número, esto implicará una operación binaria B&lt;numérica&gt; bit a bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to pass switches into your script, you can use one of the
Getopts modules or put a loop on the front like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea pasar opciones en su programa, puede utilizar uno de los módulos Getopts o poner un bucle, al principio, de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows the constructs
such as C&lt;open(my $fh, ...)&gt; and C&lt;open(local $fh,...)&gt; to be used to
create filehandles that will conveniently be closed automatically when
the scope ends, provided there are no other references to them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005720Z" changeid="explorer">
        <seg>Esto permite que instrucciones como C&lt;open(my $fh, ...)&gt; y C&lt;open(local $fh,...)&gt; se utilizan para crear gestores de archivo que convenientemente se cerrarán automáticamente cuando termine el ámbito de aplicación, siempre que no haya otras referencias a ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only interpolation is removal of C&lt;\&gt; from pairs of C&lt;\\&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La única interpolación es la eliminación de C&lt;\&gt; a partir de pares de C&lt;\\&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $ref;  # prints HASH(0x80d3d5c)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T020201Z" changeid="explorer">
        <seg>print $ref;  # imprime HASH(0x80d3d5c)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^def/) { $def = 1; last SWITCH; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^def/) { $def = 1; last SWITCH; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Capture buffers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Memoria de captura</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unsupported in lookbehind.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No soportado en búsquedas de coincidencias previas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is all
very above-board and honest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo esto trata sobre la honradez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$+&gt; returns whatever the last bracket match matched.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$+&gt; devuelve cualquiera que sea el último paréntesis de captura coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmodlib&gt; for a list of standard modules and pragmas.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmodlib&gt; para una lista de módulos y pragmas estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note for Linux users: on Linux, the C functions C&lt;getpid()&gt; and
C&lt;getppid()&gt; return different values from different threads.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota para usuarios Linux: en Linux, las funciones C C&lt;getpid()&gt; y C&lt;getppid()&gt; devuelven valores diferentes para hilos (threads) diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s {foo}  # Replace foo</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s {foo}  # Reemplaza foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of EXPR with the first character in uppercase
(titlecase in Unicode).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor de EXPR con el primer carácter en mayúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print HANDLE &quot;stuff $$\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print HANDLE &quot;algo $$\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;Copyright Holder&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Titular del Copyright&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlreapi		Perl regular expression plugin interface</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlreapi		Interfaz de complementos: expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This call is actually implemented in terms of recvfrom(2) system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta llamada está implementada actualmente en términos de la llamada del sistema recvfrom(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the message queue
id, or the undefined value if there is an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el identificador de una cola de mensaje, o el valor indefinido si hay un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following efficiently counts the number of set bits in a bit vector:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A continuación, de manera eficiente, cuenta el número de bits establecidos en un vector de bits:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're looking for the information on how to use here-documents,
which used to be here, that's been moved to
L&lt;perlop/Quote and Quote-like Operators&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T184803Z" changeid="explorer">
        <seg>Si está buscando por información de cómo usar documentos embebidos, que solía estar aquí, ha sido trasladada a L&lt;perlop/Comillas y Operadores de comillas&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can double the braces to make them such, though.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque puede doblar las llaves para crearlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Knuth, volume II, for a more robust treatment of
this topic.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver Knuth, volumen II, para un tratamiento más fuerte de este tema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only C&lt;??&gt;
patterns local to the current package are reset.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo son reinicializados los patrones locales C&lt;??&gt; del paquete actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/&quot;$/&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/&quot;$/&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chdir GESTOR_ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the # flag and a precision are given in the %o conversion,
the precision is incremented if it's necessary for the leading &quot;0&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando la bandera # y una precisión se dan en la conversión %o, la precisión es incrementada si es necesario para el &quot;0&quot; inicial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;prove&gt; is part of Test::Harness, which users of earlier
Perl versions can install from CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;prove&gt; es parte de Test::Harness, que los usuarios de versiones anteriores de Perl pueden instalar desde CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then the sort operation provides list context for &lt;&gt;, which
will proceed to read every line available up to the end of file, and
pass that list of lines back to the sort routine, which will then
sort those lines and return them as a list to whatever the context
of the sort was.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004128Z" changeid="explorer">
        <seg>entonces la operación sort establece un contexto de lista para &lt;&gt;, el cual procede a leer todas las líneas disponibles hasta alcanzar el final del archivo, y envía de vuelta esa lista de líneas a la subrutina sort, que entonces ordena las líneas y las devuelve como una lista o lo que sea dependiendo de cuál sea el contexto en que esté sort.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LFS (large file support) tests (C&lt;t/op/lfs&gt; and C&lt;xt/Fcntl/t/syslfs&gt;) are
disabled as seeking beyond 2 GB is broken according to jhi@iki.fi who was the
last one checking the BeOS port and updating this file before me.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los test para LFS (I&lt;large file support&gt;, soporte para archivos grandes) (C&lt;t/op/lfs&gt; y C&lt;xt/Fcntl/t/syslfs&gt;) están deshabilitados, debido a que el posicionamiento a más de 2 GB falla, según jhi@iki.fi, que fue el último que controló la adaptación de BeOS y la actualización de este archivo antes de mí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In scalar context, it returns merely the first value produced.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En contexto escalar, devuelve sólo el primer valor producido).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub backwards ($$) { $_[1] cmp $_[0]; }  # $a and $b are not set here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub al_reves ($$) { $_[1] cmp $_[0]; }  # $a y $b no se usan aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically this is used like the normal
piped open when you want to exercise more control over just how the
pipe command gets executed, such as when running setuid and
you don't want to have to scan shell commands for metacharacters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Habitualmente esto se usa como el open entubado cuando quiere ejercer más control sobre cómo el comando entubado es ejecutado, como cuando se ejecuta con setuid y no quiero tener que escanear comandos del shell buscando metacaracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is usually pretty
good about this, but some pathological cases might trigger this, such as
C&lt;$a///&gt; (is that C&lt;($a) / (//)&gt; or C&lt;$a // /&gt;?) and C&lt;print $fh //&gt;
(C&lt;print $fh(//&gt; or C&lt;print($fh //&gt;?).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl es, por lo general, bastante bueno sobre esto, pero algunos casos patológicos podrían dar lugar a esto, como en, C&lt;$a///&gt; (es C&lt;($a) / (//)&gt; o C&lt;$a // /&gt;?) y C&lt;print $fh //&gt; (C&lt;print $fh(//&gt; o C&lt;print($fh //&gt;?).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future versions of Perl are likely
to eliminate these arbitrary limitations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las futuras versiones de Perl probablemente eliminarán estas limitaciones arbitrarias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; &lt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; &lt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($shift=0; $shift &lt; $width; ++$shift) {
            for ($off=0; $off &lt; 32/$width; ++$off) {
                $str = pack(&quot;B*&quot;, &quot;0&quot;x32);
                $bits = (1&lt;&lt;$shift);
                vec($str, $off, $width) = $bits;
                $res = unpack(&quot;b*&quot;,$str);
                $val = unpack(&quot;V&quot;, $str);
                write;
            }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052524Z" changeid="explorer">
        <seg>for ($shift=0; $shift &lt; $width; ++$shift) {
            for ($off=0; $off &lt; 32/$width; ++$off) {
                $str = pack(&quot;B*&quot;, &quot;0&quot;x32);
                $bits = (1&lt;&lt;$shift);
                vec($str, $off, $width) = $bits;
                $res = unpack(&quot;b*&quot;,$str);
                $val = unpack(&quot;V&quot;, $str);
                write;
            }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;We use ${who}speak when ${who}'s here.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Usamos un ${quien}_altavoz cuando $quien está aquí.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our $bar = 30; # declares $Bar::bar for rest of lexical scope</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>our $bar = 30; # declara $Bar::bar para el resto del ámbito léxico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;h&gt; and C&lt;H&gt; formats pack a string that many nybbles (4-bit groups,
representable as hexadecimal digits, C&lt;&quot;0&quot;..&quot;9&quot;&gt; C&lt;&quot;a&quot;..&quot;f&quot;&gt;) long.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El formato C&lt;h&gt; y C&lt;H&gt; empaqueta una cadena con tantos nibles (grupos de 4 bits, representables como dígitos hexadecimales, C&lt;&quot;0&quot; .. &quot;9&quot;&gt; C&lt;&quot;a&quot; .. &quot;f&quot;&gt;) contenga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this means that its contents will be interpolated twice, so</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que esto significa que su contenido será interpolado dos veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsec		Perl security</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsec		Seguridad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the prototype of a function as a string (or C&lt;undef&gt; if the
function has no prototype).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el prototipo de una función como una cadena (o C&lt;undef&gt; si la función no tiene ningún prototipo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;~0&gt; usually evaluates to a large
integral value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;~0&gt; por lo general se evalúa como un valor entero de gran tamaño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All further unqualified dynamic identifiers will be in this namespace.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todos los identificadores dinámicos no cualificados estarán en este espacio de nombres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, an C&lt;eof()&gt; after C&lt;&lt; &lt;&gt; &gt;&gt; has returned
end-of-file will assume you are processing another C&lt;@ARGV&gt; list,
and if you haven't set C&lt;@ARGV&gt;, will read input from C&lt;STDIN&gt;;
see L&lt;perlop/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma semejante, un C&lt;eof()&gt; después de que un C&lt;&lt; &lt;&gt; &gt;&gt; haya devuelto un fin-de-archivo asumirá que está procesando otra lista C&lt;@ARGV&gt;, y si no ha puesto un nuevo C&lt;@ARGV&gt;, leerá la entrada desde C&lt;STDIN&gt;; ver L&lt;perlop/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_MTIME;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_MTIME;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>seek($fh, 0, SEEK_END) or die &quot;Cannot seek - $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>seek($fh, 0, SEEK_END) or die &quot;No puedo posicionarme - $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you enable warnings,
you'll be notified of an uninitialized value whenever you treat
C&lt;undef&gt; as a string or a number.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ha activado los avisos (warnings), será notificado de un valor no inicializado cada vez que trate a C&lt;undef&gt; como si fuera una cadena o número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may use C&lt;&amp;&gt; after C&lt;&lt; &gt; &gt;&gt;,
C&lt;&lt;&lt; &gt;&gt; &gt;&gt;&gt;, C&lt;&lt; &lt; &gt;&gt;, C&lt;&lt; +&gt; &gt;&gt;, C&lt;&lt;&lt; +&gt;&gt; &gt;&gt;&gt;, and C&lt;&lt; +&lt; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191851Z" changeid="explorer">
        <seg>Puede usar C&lt;&amp;&gt; después de C&lt;&lt; &gt; &gt;&gt;, C&lt;&lt;&lt; &gt;&gt; &gt;&gt;&gt;, C&lt;&lt; &lt; &gt;&gt;, C&lt;&lt; +&gt; &gt;&gt;, C&lt;&lt;&lt; +&gt;&gt; &gt;&gt;&gt;, y C&lt;&lt; +&lt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then there's</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y luego está</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case you can do:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En este caso puede hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open IN, '&lt;', $ARGV[0];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open IN, '&lt;', $ARGV[0];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($BSD_STYLE) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($BSD_STYLE) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item srand</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item srand</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x_hi;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200434Z" changeid="explorer">
        <seg>$x_hi;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Definitions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Definiciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x  A null byte (a.k.a ASCII NUL, &quot;\000&quot;, chr(0))</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>x  Un byte nulo (es decir, ASCII NUL, &quot;\000&quot;, chr(0))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># foo eq &quot;\xe2\x92\xb6\xe2\x92\xb7\xe2\x92\xb8\xe2\x92\xb9&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># foo es &quot;\xe2\x92\xb6\xe2\x92\xb7\xe2\x92\xb8\xe2\x92\xb9&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir $foo    || die;	# (chdir $foo) || die</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir $foo    || die;	# (chdir $foo) || die</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the tangent operation, you may use the C&lt;Math::Trig::tan&gt;
function, or use the familiar relation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la operación tangente, puede usar la función C&lt;Math::Trig::tan&gt;, o usar la conocidad relación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make LDLOADLIBS=&quot;-lnet -lflock&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make LDLOADLIBS=&quot;-lnet -lflock&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NOTES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 NOTAS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl combines (in the author's opinion, anyway) some of the best
features of C, B&lt;sed&gt;, B&lt;awk&gt;, and B&lt;sh&gt;, so people familiar with
those languages should have little difficulty with it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl combina (en opinión del autor, de todos modos), algunas de las mejores características de B&lt;C&gt;, B&lt;sed&gt;, B&lt;awk&gt;, y B&lt;sh&gt;, así que la gente que conozca estos lenguajes no deberían tener dificultades con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you're done with your filehandles, you should C&lt;close()&gt; them
(though to be honest, Perl will clean up after you if you forget):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225358Z" changeid="explorer">
        <seg>Cuando termine de trabajar con los identificadores de archivo, debe cerrarlos con C&lt;close()&gt; (de todos modos, Perl se encargará de ello si se le olvida):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (&quot;foo&quot;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (&quot;foo&quot;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next if m#^/usr/spool/uucp#;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next if m#^/usr/spool/uucp#;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with EXPR      %ENV  environment</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>con EXPR       %ENV  entorno</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;use locale&gt; is in effect,
and POSIX::setlocale() has been called, the character used for the
decimal separator is affected by the LC_NUMERIC locale.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;use locale&gt; está activo, y POSIX::setlocale() ha sido llamada, el carácter utilizado para el separador decimal se ve afectado por la configuración regional de LC_NUMERIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getgrgid($num);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$name  = getgrgid($num);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Pod::Perldoc</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Pod::Perldoc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful
for modifying a copy of something, like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para modificar una copia de algo, como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpacktut	Perl pack() and unpack() tutorial</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlpacktut	Seminario sobre pack() y unpack()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print vec($foo, 0, 8);  # prints 80 == 0x50 == ord('P')</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print vec($foo, 0, 8);  # imprime 80 == 0x50 == ord('P')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*+     Match 0 or more times and give nothing back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>*+     Coincide 0 o más veces y no devuelve nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators can be overloaded for objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Muchos operadores pueden ser sobrecargados por objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 9, 2) = 1   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 9, 2) = 1   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mkdir 'tmp',   0777	or die &quot;can't mkdir $tmpdir/tmp: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>mkdir 'tmp',   0777	or die &quot;no puedo hacer mkdir $tmpdir/tmp: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_ISUID S_ISGID S_ISVTX S_ISTXT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_ISUID S_ISGID S_ISVTX S_ISTXT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl informally
reserves lowercase module names for &quot;pragma&quot; modules like C&lt;integer&gt; and
C&lt;strict&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl, de forma informal, reserva nombres de módulos en minúscula para módulos &quot;pragma&quot; como C&lt;integer&gt; y C&lt;strict&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>c	Complement the SEARCHLIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>c	Complementa la LISTA_BÚSQUEDA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes the file or pipe associated with the filehandle, flushes the IO
buffers, and closes the system file descriptor.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cierra el archivo o tubería asociada con el gestor, limpiando los buffers IO, y cierra el descriptor del archivo en el sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(P) The substitution was looping infinitely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(P) The substitution was looping infinitely.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-standard extensions in your local sprintf(3) are 
therefore unavailable from Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Extensiones no estándares en su sprintf(3) regional, por lo tanto, no estará disponible desde Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You really probably want to be using C&lt;my&gt; instead, because C&lt;local&gt; isn't
what most people think of as &quot;local&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo que realmente querrá usar es C&lt;my&gt;, debido a que C&lt;local&gt; no es lo que la mayoría de la gente piensa en algo &quot;local&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no
Daylight Saving Time in GMT.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay horario de verano en el horario GMT.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item each HASH
X&lt;each&gt; X&lt;hash, iterator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171522Z" changeid="explorer">
        <seg>=item each HASH
X&lt;each&gt; X&lt;hash, iterator&gt; X&lt;hash, iterador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supplying a C&lt;*&gt; for the repeat count
instead of a number means to use however many items are left, except for:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El suministro de un C&lt;*&gt; para el número de repeticiones en lugar de un número significa usar tantos elementos como queden, a excepción de:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're trying to develop an
@AoA array containing all these, here's the right way to do that:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está tratando de desarrollar un array @AoA conteniendo todo eso, esta es la manera correcta de hacerlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = [ split ' ', &lt;&gt; ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$i] = [ split ' ', &lt;&gt; ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbs2000		Perl notes for POSIX-BC BS2000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlbs2000		Notas para POSIX-BC BS2000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach LIST</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item say</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it does both, scalar arguments 
come first and list argument follow, and there can only ever
be one such list argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si aparecen ambos, los argumentos escalares van antes que el argumento de lista, y solo puede existir un argumento de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The curly brackets are optional, however omitting them is less
safe as the meaning of the pattern can be changed by text (such as digits)
following it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las llaves son opcionales, pero sin embargo, al omitirles, es menos seguro que el significado del patrón pueda ser cambiado por el texto (por ejemplo, dígitos) que le siga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, always pass
C&lt;srand&gt; an integer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para estar seguros, siempre pase un entero a C&lt;srand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The
filehandles C&lt;stdin&gt;, C&lt;stdout&gt;, and C&lt;stderr&gt; will also work except
in packages, where they would be interpreted as local identifiers
rather than global.)  Additional filehandles may be created with
the open() function, amongst others.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Los gestores de archivo C&lt;stdin&gt;, C&lt;stdout&gt;, y C&lt;stderr&gt; también funcionarán, excepto en paquetes en el que podrían ser interpretados como identificadores locales en lugar de globales). Gestores de archivo adicionales pueden ser creados con la función open(), entre otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the actual exit value, shift right by eight (see
below).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener el valor real de la salida, se debe desplazar ocho a la derecha (ver más abajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C Operators Missing From Perl
X&lt;operator, missing from perl&gt; X&lt;&amp;&gt; X&lt;*&gt;
X&lt;typecasting&gt; X&lt;(TYPE)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002318Z" changeid="explorer">
        <seg>=head2 Operadores de C que faltan en Perl
X&lt;operator, missing from perl&gt; X&lt;&amp;&gt; X&lt;*&gt;
X&lt;typecasting&gt; X&lt;(TYPE)&gt; X&lt;operador, faltan en Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that it short-circuits: i.e., the right expression is evaluated
only if the left expression is false.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que cortocircuita: es decir, la expresión de la derecha sólo se evalúa si la expresión de la izquierda es falsa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort { find_records() } @key;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort { busca_registros() } @claves;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;shift&gt; and C&lt;unshift&gt; do the
same thing to the left end of an array that C&lt;pop&gt; and C&lt;push&gt; do to the
right end.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;shift&gt; y C&lt;unshift&gt; hacen lo mismo con el extremo izquierdo de un array que C&lt;pop&gt; y C&lt;push&gt; hacen para el extremo derecho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Reporting Bugs</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Informar de errores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are actually two varieties of null strings (sometimes referred
to as &quot;empty&quot; strings), a defined one and an undefined one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay en realidad dos tipos de cadenas nulas (a las que algunas veces nos referimos como cadenas &quot;vacías&quot;); una definida, y otra, indefinida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,10, 2) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,10, 2) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./Configure -Dusethreads -Duseithreads -Dusedevel -des</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>./Configure -Dusethreads -Duseithreads -Dusedevel -des</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is exactly equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es exactamente equivalente a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Void context just means the value has been discarded, such as a
statement containing only C&lt;&quot;fred&quot;;&gt; or C&lt;getpwuid(0);&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El contexto vacío significa simplemente que el valor ha sido descartado, como en una instrucción que contenga solamente C&lt;&quot;fred&quot;;&gt; o C&lt;getpwuid(0);&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, '|-') || exec 'tr', '[a-z]', '[A-Z]';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, '|-') || exec 'tr', '[a-z]', '[A-Z]';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 2) = 2   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 2) = 2   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has most of the usual conditional and looping constructs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234722Z" changeid="zipf">
        <seg>Perl ofrece las estructuras condiciones y de bucle habituales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the braces are required in Perl, even if you've only got one
line in the block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225132Z" changeid="explorer">
        <seg>Tenga en cuenta que en Perl es obligatorio usar las llaves, aunque sólo haya una línea en el bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're particularly concerned with this, search the CPAN for
random number generator modules instead of rolling out your own.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201600Z" changeid="explorer">
        <seg>Si está especialmente preocupado por esto, busque en CPAN por módulos generadores de números aleatorios en lugar de desarrollar el suyo propio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this doesn't
mean everything is only an integer, merely that Perl may use integer
operations if it is so inclined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que esto no significa que todo es sólo un número entero, sino simplemente que Perl puede utilizar operaciones de enteros si así lo desea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exists &amp;sub;    # OK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exists &amp;sub;    # OK</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item syscall NUMBER, LIST
X&lt;syscall&gt; X&lt;system call&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204106Z" changeid="explorer">
        <seg>=item syscall NÚMERO, LISTA
X&lt;syscall&gt; X&lt;system call&gt; X&lt;llamada del sistema&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of Perl's syntactic elements are B&lt;optional&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Muchos de los elementos sintácticos de Perl son B&lt;opcionales&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlfaq&gt; contains questions and answers related to many common
tasks, and often provides suggestions for good CPAN modules to use.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225615Z" changeid="explorer">
        <seg>L&lt;perlfaq&gt; contiene preguntas y respuestas relacionadas con muchas tareas comunes, y en muchos casos sugiere los módulos de CPAN adecuados para cada tarea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@newAoA = ();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194942Z" changeid="explorer">
        <seg>@newAoA = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converts a time as returned by the time function to a 9-element list
with the time analyzed for the local time zone.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Convierte un tiempo devuelto por la función time() en una lista de 9 elementos según la zona horaria local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no builtin C&lt;import&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe la función C&lt;import&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldebug		Perl debugging</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldebug		Depurando Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The comments show the string after each step.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los comentarios ponen de manifiesto la cadena después de cada etapa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise use a C&lt;foreach()&gt; loop or
the C&lt;system()&gt; function instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De otra forma, use un bucle C&lt;foreach()&gt; o la función C&lt;system()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise you create non-Y2K-compliant programs--and you wouldn't want
to do that, would you?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario está creando programas Y2K no compatibles -y usted no querría hacer eso, ¿verdad?-</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that lexical variables--those
declared with C&lt;my&gt;--will not work for this purpose; so if you're
using C&lt;my&gt;, specify EXPR in your call to open.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Note que las variables léxicas -las declaradas con C&lt;my&gt;- no servirán para este propósito; así que si está usando C&lt;my&gt;, especifique EXPR en su llamada a open).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( condition ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002929Z" changeid="zipf">
        <seg>if ( condición ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@c = (0,1)[2,3];        # @c has no elements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@c = (0,1)[2,3];        # @c no tiene elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produce, respectively</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce, respectivamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-X  File is executable by real uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004558Z" changeid="explorer">
        <seg>-X  Archivo es ejecutable por el uid/gid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-o  File is owned by effective uid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004528Z" changeid="explorer">
        <seg>-o  Archivo es propiedad del uid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because backticks do not affect standard error, use shell file descriptor
syntax (assuming the shell supports this) if you care to address this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como las comillas invertidas no afectan a la salida de error estándar, use la sintaxis del shell del descriptor de archivos (asumiendo que el shell soporte esto) si es que quiere tenerlo en cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below for more details
and see C&lt;sprintf(3)&gt; or C&lt;printf(3)&gt; on your system for an explanation of
the general principles.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver abajo para más detalles y ver C&lt;sprintf(3)&gt; o C&lt;printf(3)&gt; en su sistema para obtener una explicación de los principios generales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># or going the other way</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># o de otra manera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;split&gt; on C&lt;/\s+/&gt; is like a S&lt;C&lt;split(' ')&gt;&gt; except that any leading
whitespace produces a null first field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;split&gt; con C&lt;/\s+/&gt; es como un S&lt;C&lt;split(' ')&gt;&gt; excepto que cualquier espacio en blanco inicial produce un primer campo nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $var = &quot;value&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $var = &quot;valor&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last example should print:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El último ejemplo debería imprimir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chops off the last character of a string and returns the character
chopped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recorta el último carácter de un string y devuelve el carácter recortado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (s|{.*| |) {
            $front = $_;
            while (&lt;STDIN&gt;) {
                if (/}/) {  # end of comment?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050838Z" changeid="explorer">
        <seg>if (s|{.*| |) {
            $frente = $_;
            while (&lt;STDIN&gt;) {
                if (/}/) {  # ¿fin de comentario?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IRWXO S_IROTH S_IWOTH S_IXOTH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_IRWXO S_IROTH S_IWOTH S_IXOTH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;WWWW&quot;,65,66,67,68);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;WWWW&quot;,65,66,67,68);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;seekdir&gt; also has the same caveats
about possible directory compaction as the corresponding system library
routine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;seekdir&gt; también tiene las mismas advertencias sobre la posible compactación del directorio como la correspondiente rutina del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;characters&gt;: depending on the status of the socket, either
(8-bit) bytes or characters are received.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note los I&lt;caracteres&gt;: dependiendo del estado del socket, son leídos bytes (8-bit) o caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When of the form C&lt;\N{NAME}&gt;, it matches the
character whose name is C&lt;NAME&gt;; and similarly when of the form
C&lt;\N{U+I&lt;wide hex char&gt;}&gt;, it matches the character whose Unicode ordinal is
I&lt;wide hex char&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando es de la forma C&lt;\N{NOMBRE}&gt;, coincide con el carácter cuyo nombre es C&lt;NOMBRE&gt;; y de manera similar cuando es de la forma C&lt;\N{U+I&lt;car. hex. ancho&gt;}&gt;, coincide con el carácter cuyo ordinal Unicode es I&lt;car. hex. ancho&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl modules provide a range of features to help you avoid reinventing
the wheel, and can be downloaded from CPAN ( http://www.cpan.org/ ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T230050Z" changeid="explorer">
        <seg>No pierda tiempo reinventando la rueda. Los módulos de Perl disponibles en CPAN (http://www.cpan.org/) proporcionan funcionalidad que puede utilizar en sus programas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($port, $iaddr) = sockaddr_in($hersockaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($port, $iaddr) = sockaddr_in($hersockaddr);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%d    a signed integer, in decimal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%d    un entero con signo, en decimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit
the PERMS argument to C&lt;sysopen&gt;, Perl uses the octal value C&lt;0666&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite el argumento PERMISOS a C&lt;sysopen&gt;, Perl utiliza el valor octal C&lt;0666&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Text from a C&lt;&quot;#&quot;&gt; character until the end of the line is a comment,
and is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El texto desde un carácter C&lt;&quot;#&quot;&gt; hasta el fin de la línea es un comentario y es ignorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x	Use extended regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>x	Usa expresiones regulares extendidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the transliteration table is built at compile time, neither
the SEARCHLIST nor the REPLACEMENTLIST are subjected to double quote
interpolation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que la tabla de transliteración se construye en tiempo de compilación, ni la LISTA_BÚSQUEDA ni la LISTA_REEMPLAZO están sujetas a la interpolación del doble entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(1+2) + 4;   # Prints 3.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(1+2) + 4;	# Imprime 3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is a syntax error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es un error de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($Config{uselongdouble} eq &quot;define&quot;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($Config{uselongdouble} eq &quot;define&quot;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: when called in list context, $isdst, the last value
returned by gmtime is always C&lt;0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota: cuando se le llama en contexto lista, $isdst, el último valor devuelto por gmtime siempre es C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$nothing = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$nada = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>STDERR-&gt;autoflush(1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>STDERR-&gt;autoflush(1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlapio		Perl internal IO abstraction interface</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlapio		Interfaz de la abstracción interna IO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's all!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¡Eso es todo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=secret stuff</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=material secreto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readpipe EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item readpipe EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&amp;&amp;&quot; performs a short-circuit logical AND operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&amp;&amp;&quot; realiza una operación lógica AND abreviada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use&gt; function calls the C&lt;import&gt; method
for the package used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función C&lt;use&gt; llama al método C&lt;import&gt; del paquete a usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If omitted, FILENAME defaults
to C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite, por defecto ARCHIVO se toma desde &lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (substr($x,1,2)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (substr($x,1,2)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Arrays</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232609Z" changeid="explorer">
        <seg>=item Arrays</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use v5.6.1;     # compile time version check</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use v5.6.1;     # comprobación en tiempo de compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this to find out whether two handles refer to the
same underlying descriptor:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar esto para encontrar cuándo dos gestores se refieren al mismo descriptor subyacente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,14, 1) = 1   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,14, 1) = 1   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!/usr/bin/perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#!/usr/bin/perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[2][2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[2][2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sets mode to
                                             # --w----r-T</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043648Z" changeid="explorer">
        <seg>pone el modo a
                                             # --w----r-T</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, any file
containing a zero byte in the first block is considered a binary file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También, cualquier archivo conteniendo bytes cero en el primer bloque es considerado como un archivo binario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.irix - Perl version 5 on Irix systems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.irix - Perl version 5 on Irix systems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primarily this is so that you can use the B&lt;undump&gt; program (not
supplied) to turn your core dump into an executable binary after
having initialized all your variables at the beginning of the
program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Principalmente esto se utiliza en conjunción con el programa B&lt;undump&gt; (no suministrado) para convertir tu volcado del núcleo en un binario ejecutable después de haber inicializado todas las variables al comienzo del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl qw(:flock SEEK_END); # import LOCK_* and SEEK_END constants</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl qw(:flock SEEK_END); # importa constantes LOCK_* y SEEK_END</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you want your program to be readable, consider supplying the argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted quiere que su programa sea legible, considere suplir el argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The restriction lasts to the
end of the enclosing block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La restricción dura hasta el final del bloque que lo alberga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the last element of LIST does not end in a newline, the current
script line number and input line number (if any) are also printed,
and a newline is supplied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el último elemento de LISTA no acaba en el carácter de nueva línea, se imprimen también el valor actual del número de línea y el actual número de línea de entrada (si existe), junto con un carácter de nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I can't say anything with regard to PPC.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puedo decir nada con respecto a PPC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># this would print with a linebreak in the middle</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230747Z" changeid="zipf">
        <seg># esto imprimirá un salto de línea en la mitad de la frase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no current package
(due to an empty C&lt;package;&gt; directive), __PACKAGE__ is the undefined
value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay paquete actual (debido a una directiva C&lt;package;&gt; vacía), __PACKAGE__ tiene el valor indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo, 21,  4) = 7;      # 'PerlPerlPer'
                                   # 'r' is &quot;\x72&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052414Z" changeid="explorer">
        <seg>vec($foo, 21,  4) = 7;      # 'PerlPerlPer'
                                   # 'r' es &quot;\x72&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All operations above are performed simultaneously, left to right.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todas las operaciones anteriores se realizan simultáneamente, de izquierda a derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># symbolic dereferencing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># desreferencia simbólica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LENGTH is omitted, returns
everything to the end of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite LONGITUD, devuelve todo hasta el final de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;*&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;*&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\v        [3]  Vertical whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224928Z" changeid="explorer">
        <seg>\v        [3]  Espacio en blanco vertical</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accepts an incoming socket connect, just as accept(2) 
does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Acepta una conexión socket entrante, como lo hace la llamada del sistema accept(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ [B&lt;-e&gt;|B&lt;-E&gt;] I&lt;'command'&gt; ] [ B&lt;--&gt; ] [ I&lt;programfile&gt; ] [ I&lt;argument&gt; ]...&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ [B&lt;-e&gt;|B&lt;-E&gt;] I&lt;'comando'&gt; ] [ B&lt;--&gt; ] [ I&lt;programa&gt; ] [ I&lt;argumento&gt; ]...&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This usage (which also works fine with system()) forces
interpretation of the arguments as a multivalued list, even if the
list had just one argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este uso (que también funciona bien con system()) fuerza la interpretación de los argumentos como una lista multievaluada, incluso si la lista sólo tiene un argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some C macros have been tidied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas macros C se han arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use integer;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use integer;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to make it more robust
it is recommended to start every program with the following lines:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224702Z" changeid="explorer">
        <seg>Sin embargo, para trabajar de manera más segura se recomienda iniciar cada programa con las líneas siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{3}                 matches exactly 3 of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230607Z" changeid="zipf">
        <seg>{3}                 detecta exactamente 3 coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How
are you going to do that?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193203Z" changeid="explorer">
        <seg>¿Cómo va a hacer eso?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlopentut&gt; for a kinder, gentler explanation of opening files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlopentut&gt; para una más amable, más suave explicación de apertura de los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Byteorders C&lt;&quot;1234&quot;&gt; and C&lt;&quot;12345678&quot;&gt; are little-endian; C&lt;&quot;4321&quot;&gt;
and C&lt;&quot;87654321&quot;&gt; are big-endian.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las ordenaciones C&lt;&quot;1234&quot;&gt; y C&lt;&quot;12345678&quot;&gt; son little-endian; C&lt;&quot;4321&quot;&gt; y C&lt;&quot;87654321&quot;&gt; son big-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Okay, that's I&lt;definitely&gt; enough hype.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bueno, esto ya es I&lt;definitivamente&gt; suficiente autobombo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class::Struct: allow recursive classes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Class::Struct: permite clases recursivas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;+&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;+&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perllol - Manipulating Arrays of Arrays in Perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perllol - Manipulación de array de array en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\u		uppercase next char</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003120Z" changeid="explorer">
        <seg>\u		siguiente car. en mayúscula</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, C&lt;localtime()&gt; returns the ctime(3) value:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, C&lt;localtime()&gt; devuelve el valor de ctime(3):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;delete local EXPR&gt; construct localizes the deletion to the current
block at run time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La construcción C&lt;delete local EXPR&gt; localiza la eliminación al actual bloque en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@alphabet = ('A' ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@alfabeto = ('A' ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$symlink_exists = eval { symlink(&quot;&quot;,&quot;&quot;); 1 };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$symlink_existe = eval { symlink(&quot;&quot;,&quot;&quot;); 1 };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No variable interpolation occurs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se produce interpolación de variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;tr&gt; operator is not equivalent to
the tr(1) utility.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador C&lt;tr&gt; no es equivalente a la utilidad tr(1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a real struct tm (on my system anyway)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># una auténtica struct tm (en mi sistema)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For GMT
instead of local time use the L&lt;/gmtime&gt; builtin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para GMT, en lugar de la hora local, use la primitiva L&lt;/gmtime&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlop/Terms and List Operators (Leftward)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T190239Z" changeid="explorer">
        <seg>Véase L&lt;perlop/Términos y Operadores de listas (por la izquierda)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Arithmetic</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120350Z" changeid="zipf">
        <seg>=item Aritmética</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $key (keys %HASH) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $clave (keys %HASH) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>down from the door where it began.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>detrás de la puerta que lo comenzó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns a list value consisting of the elements
of LIST in the opposite order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, devuelve una lista de valores consistente en los elementos de LISTA en el orden opuesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlreftut		Perl references short introduction</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlreftut		Perl references short introduction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, on POSIX-conforming systems, zero will
signal the current process group and -1 will signal all processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, en los sistemas conformes a POSIX, un cero señalará al grupo del proceso actual y -1 señalará todos los procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If I&lt;sequence-item&gt; refers to a string type (C&lt;&quot;A&quot;&gt;, C&lt;&quot;a&quot;&gt;, or C&lt;&quot;Z&quot;&gt;),
the I&lt;length-item&gt; is the string length, not the number of strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si I&lt;secuencia-item&gt; se refiere a un tipo de cadena de caracteres (C&lt;&quot;A&quot;&gt;, C&lt;&quot;a&quot;&gt;, o C&lt;&quot;Z&quot;&gt;), la I&lt;longitud-item&gt; es la longitud de la cadena, no el número de cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treats ARRAY as a stack, and pushes the values of LIST
onto the end of ARRAY.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considera a ARRAY como una pila, e inserta los valores de LISTA al final de ARRAY.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here
are commonly expected conventions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Están son las convenciones más usadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl comes with a wide selection of builtin functions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002819Z" changeid="zipf">
        <seg>Perl incluye una amplia selección de funciones y operadores integrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># prints AbelCaincatdogx</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># prints AbelCaincatdogx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pack(&quot;@1A((@2A)@3A)&quot;, qw[X Y Z])</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pack(&quot;@1A((@2A)@3A)&quot;, qw[X Y Z])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failed Test  Status Wstat Total Fail  Failed  List of failed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Failed Test  Status Wstat Total Fail  Failed  List of failed</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The shared object /usr/lib/libm.so did not resolve any symbols.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004715Z" changeid="explorer">
        <seg>El objeto compartido /usr/lib/libm.so no resuelve a ningún símbolo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Irix 6.2 Posix 1003.1b man pages</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004239Z" changeid="explorer">
        <seg>Irix 6.2 Posix 1003.1b páginas man</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$input++;    # this is a string increment</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$entrada++;    # esto es un incremento de cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out the old STDERR:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intercambiar el STDOUT y STDERR de un comando para capturar el STDERR pero dejando que su STDOUT salga por el anterior STDERR:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;-&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;-&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlebcdic		Considerations for running Perl on EBCDIC platforms</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlebcdic		Consideraciones para ejecutar Perl en plataformas EBCDIC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval $search;        # this screams</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval $buscar;        # esto aúlla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$is_setuid     =  $mode &amp; S_ISUID;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$es_setuid     =  $modo &amp; S_ISUID;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># This will expand any embedded scalar variable</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Esto expandirá cualquier variables escalar incrustada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endservent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endservent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, you can match
on just about anything you could dream of by using more complex regular
expressions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225422Z" changeid="explorer">
        <seg>De hecho, puede detectar coincidencias donde quiera con expresiones regulares más complejas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$age{$a} &lt;=&gt; $age{$b};  # presuming numeric</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$edad{$a} &lt;=&gt; $edad{$b};  # presumimos numéricos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the new binary is executed it will begin by executing
a C&lt;goto LABEL&gt; (with all the restrictions that C&lt;goto&gt; suffers).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando el nuevo binario es ejecutado, comenzará ejecutando un C&lt;goto ETIQUETA&gt; (con todas las restricciones que C&lt;goto&gt; padece).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and              []    character class  .  == [^\n]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043439Z" changeid="explorer">
        <seg>and              []    clase carácter   .  == [^\n]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $i++ while $i &lt;= 10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $i++ while $i &lt;= 10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/map&gt; for a list composed of the results of the BLOCK or EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/map&gt; para una lista compuesta de los resultados del BLOQUE o EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlreftut&gt;
and L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlreftut&gt; y L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If NUMBER is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite NÚMERO, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can open a file for input or output using the C&lt;open()&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T182736Z" changeid="zipf">
        <seg>La función C&lt;open()&gt; abre un archivo para entrada o salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item List::Util</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item List::Util</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nNvV       Treat integers as signed instead of unsigned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>nNvV       Trata a enteros como con signo, en lugar de sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/Version: *([0-9.]*)/) { $version = $1; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/Version: *([0-9.]*)/) { $version = $1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>list      %hash     element: $array[0]     $hash{'a'}
            &amp;sub
            *glob    SCALAR VALUES
                     number, string, reference, glob, undef</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T233946Z" changeid="explorer">
        <seg>lista     %hash    elemento: $array[0]     $hash{'a'}
            &amp;sub
            *glob    VALORES ESCALARES
                     número, cadena, referencia, glob, undef</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\Z  Match only at end of string, or before newline at the end</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225745Z" changeid="explorer">
        <seg>\Z  Coincide solo con el final de la cadena, o antes de un nueva línea al final</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As one example, the C&lt;type&gt; command under
the POSIX shell is very different from the C&lt;type&gt; command under DOS.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como ejemplo, el comando C&lt;type&gt; en el shell POSIX es muy diferente del comando C&lt;type&gt; en DOS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir($tmpdir)      or die &quot;can't chdir $tmpdir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir($tmpdir)      or die &quot;no puede chdir $tmpdir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exit</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exit 0 if $ans =~ /^[Xx]/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exit 0 if $ans =~ /^[Xx]/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or, more directly,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o, más directamente,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most systems do not bother to return anything useful in $timeleft, so
calling select() in scalar context just returns $nfound.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de los sistemas no se molestan en devolver nada útil en $tiempo_restante, así que llamando select() en contexto escalar sólo devuelve $n_encontrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use C&lt;BE&lt;lt&gt;E&lt;gt&gt;&gt; for commands names like B&lt;cat&gt; or B&lt;grep&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use C&lt;BE&lt;lt&gt;E&lt;gt&gt;&gt; para nombres de comandos como B&lt;cat&gt; o B&lt;grep&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The yada yada cannot stand in for an expression that is part of a
larger statement since the C&lt;...&gt; is also the three-dot version of the
range operator (see L&lt;Range Operators&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T190657Z" changeid="explorer">
        <seg>El blablablá no puede sustituir a una expresión que forma parte de una instrucción más grande debido a que C&lt;...&gt; es también la versión de tres puntos del operador rango (véase L&lt;Operadores de rango&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;Permissions are %04o\n&quot;, $mode &amp; 07777;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Permisos son %04o\n&quot;, $modo &amp; 07777;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both forms, the value returned is the value of the last expression
evaluated inside the mini-program; a return statement may be also used, just
as with subroutines.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012428Z" changeid="explorer">
        <seg>En ambas formas, el valor devuelto es el valor de la última expresión evaluada dentro del mini-programa; una instrucción return se puede usar también, como si fuera una subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a useful
optimization when you want to see only the first occurrence of
something in each file of a set of files, for instance.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es una optimización útil cuando se desea ver sólo la primera aparición de algo en cada archivo de un conjunto de archivos, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They include variables,
quote and quote-like operators, any expression in parentheses,
and any function whose arguments are parenthesized.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto incluye a las variables, comillas y operadores de comillas, cualquier expresión entre paréntesis, y cualquier función cuyos argumentos estén entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### last always comes here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>### last siempre viene aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final sequence number
in a range has the string &quot;E0&quot; appended to it, which doesn't affect
its numeric value, but gives you something to search for if you want
to exclude the endpoint.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de secuencia final en un rango tiene la cadena &quot;E0&quot; añadida, que no afecta a su valor numérico, pero le da algo para poder buscar si desea excluir el punto final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default { $nothing = 1; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>default { $nada = 1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getlogin
X&lt;getlogin&gt; X&lt;login&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173510Z" changeid="explorer">
        <seg>=item getlogin
X&lt;getlogin&gt; X&lt;login&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $SIG{'__DIE__'} =
              sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044145Z" changeid="explorer">
        <seg>local $SIG{'__DIE__'} =
              sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(ARTICLE, &quot;caesar &lt;$article |&quot;)      # ditto</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(ARTICLE, &quot;caesar &lt;$article |&quot;)      # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for propagating exceptions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para propagar excepciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of lines remaining on the current page is in
variable C&lt;$-&gt;, which can be set to C&lt;0&gt; to force a new page.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de líneas restantes de la página actual está en la variable C&lt;$-&gt;, que se puede fijar a C&lt;0&gt; para forzar una nueva página.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entire hashes are denoted by '%':
X&lt;hash&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los hashes enteros se designan por '%': X&lt;hash&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolated scalars and arrays are converted internally to the C&lt;join&gt; and
C&lt;.&gt; catenation operations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Escalares interpolados y arrays son convertidos internamente a las operaciones de concatenación C&lt;join&gt; y C&lt;.&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VARIABLE is the name of the variable
to be enchanted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VARIABLE es el nombre de la variable que será enlazada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Johann Klasek &lt;jk@auto.tuwien.ac.at&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Johann Klasek &lt;jk@auto.tuwien.ac.at&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is a unary operator, not a list operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que se trata de un operador unario, no un operador de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($rin,fileno(STDIN),1) = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($rin,fileno(STDIN),1) = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SCALAR will be grown or shrunk to the length actually read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESCALAR crecerá o se reducirá a la longitud de la lectura actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do { my $n; ...; print 'Hurrah!' };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do { my $n; ...; print '¡Hurra!' };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For delays of finer granularity than one second, the Time::HiRes module
(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides usleep().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para lapsos de tiempo inferiores a un segundo, el módulo Time::HiRes (en CPAN, y desde Perl 5.8 parte de la distribución estándar) ofrece usleep().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlos400		Perl notes for OS/400</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlos400		Notas para OS/400</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to indicate that an option is to be
interpreted by the TCP protocol, LEVEL should be set to the protocol
number of TCP, which you can get using C&lt;getprotobyname&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, para indicar que una opción a de ser interpretada por el protocolo TCP, NIVEL debe ser puesto al número de protocolo del TCP, que puede obtener usando C&lt;getprotobyname&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What's that C&lt;shift&gt;?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T233431Z" changeid="zipf">
        <seg>¿Qué hace C&lt;shift&gt;?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although strings and numbers
are considered pretty much the same thing for nearly all purposes,
references are strongly-typed, uncastable pointers with builtin
reference-counting and destructor invocation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque las cadenas y los números son consideradas prácticamente la misma cosa para la mayoría de los propósitos, las referencias son punteros no convertibles y fuertemente tipificados, que llevan un contador de referencias incorporado y una invocación al destructor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@array = split(/:/);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@array = split(/:/);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parentheses in Perl 6
are always optional in a control construct such as C&lt;if()&gt;,
C&lt;while()&gt;, or C&lt;when()&gt;; they can't be made optional in Perl
5 without a great deal of potential confusion, because Perl 5
would parse the expression</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los paréntesis en Perl 6 son siempre opcionales en construcciones de control, como en C&lt;if()&gt;, C&lt;while()&gt;, o C&lt;when()&gt;; no pueden ser opcionales en Perl 5, sin ganar una gran confusión, porque Perl 5 interpretaría la expresión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item redo LABEL
X&lt;redo&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194511Z" changeid="explorer">
        <seg>=item redo ETIQUETA
X&lt;redo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IFREG S_IFDIR S_IFLNK S_IFBLK S_IFCHR S_IFIFO S_IFSOCK S_IFWHT S_ENFMT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_IFREG S_IFDIR S_IFLNK S_IFBLK S_IFCHR S_IFIFO S_IFSOCK S_IFWHT S_ENFMT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While running Configure and when building, you are likely to get
quite a few of these warnings:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004643Z" changeid="explorer">
        <seg>Mientras ejecuta Configure y cuando compile, es probable que obtenga un buen número de estas advertencias:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $foo = 10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $foo = 10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the input string is longer than one described by the TEMPLATE,
the remainder of that input string is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena de entrada es superior a lo descrito por la PLANTILLA, el resto de la cadena de entrada se ignora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the multiplicity of floating-point formats and the lack of a
standard &quot;network&quot; representation for them, no facility for interchange has been
made.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a la multiplicidad de formatos de punto flotante y la falta de una norma de representación en la &quot;red&quot; para ellos, no hay ninguna facilidad para el intercambio de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are
responsible to make sure a string is pre-extended long enough to
receive any result that might be written into a string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es responsable de asegurarse de que una cadena sea pre-extendida el largo suficiente como para recibir cualquier resultado que pueda ser escrito en una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($who, $home)  = @ENV{&quot;USER&quot;, &quot;HOME&quot;};      # hash slice</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($quien, $home) = @ENV{&quot;USER&quot;, &quot;HOME&quot;};      # porción hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the Camel Book for why.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el Libro del Camello para ver por qué.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wanted there I&lt;not&gt; to be an @AoA,
but rather just a reference to it, you could do something more like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si I&lt;no&gt; quiere que sea un @AoA, sino una referencia a él, puede hacer algo más parecido a esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;homer&quot;, &quot;marge&quot;, &quot;bart&quot; ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;homer&quot;, &quot;marge&quot;, &quot;bart&quot; ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;identifier, case sensitivity&gt;
X&lt;case&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;identifier, case sensitivity&gt; X&lt;case&gt; X&lt;identificador, sensible al tamaño de caja&gt; X&lt;tamaño de caja&gt; X&lt;mayúsculas y minúsculas&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will have exactly the opposite restrictions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tendrá exactamente las restricciones contrarias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $file, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $archivo, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a really hairy regular expression, use the C&lt;/x&gt; modifier and
put in some whitespace to make it look a little less like line noise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si tiene una expresión regular especialmente complicada, use el modificador C&lt;/x&gt; y ponga algunos espacios en blanco para que no parezca una línea telefónica con ruido de fondo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to position the file for C&lt;sysread&gt; or C&lt;syswrite&gt;, don't use
C&lt;seek&gt;, because buffering makes its effect on the file's read-write position
unpredictable and non-portable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea posicionar el archivo para las funciones C&lt;sysread&gt; o C&lt;syswrite&gt;, no utilice C&lt;seek&gt;, porque hace impredecible y no portátil la posición de lectura/escritura del archivo a causa del efecto del buffer del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replace C&lt;5.12.3&gt; with your respective version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040415Z" changeid="explorer">
        <seg>Reemplace C&lt;5.12.3&gt; con su respectiva versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir +($foo) * 20;	# chdir ($foo * 20)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir +($foo) * 20;	# chdir ($foo * 20)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@array) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@array) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic linker flags have been tweaked for Solaris and OS X, which should
solve problems seen while building some XS modules.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las banderas del enlazador dinámico han sido modificados para Solaris y OS X, lo que debería solucionar los mismos problemas que aparecen en la construcción de algunos módulos XS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Haven't
checked this myself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No lo he comprobado por mí mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item study SCALAR
X&lt;study&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201643Z" changeid="explorer">
        <seg>=item study ESCALAR
X&lt;study&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Warning: syntactical care is required when sorting the list returned from
a function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Advertencia: es requerido un cuidado sintáctico cuando se ordena la lista devuelta desde una función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;s///&gt; substitution operator is documented in L&lt;perlop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233345Z" changeid="zipf">
        <seg>El operador de sustitución, C&lt;s///&gt;, se describe en L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl operators are documented in full in L&lt;perlop&gt;, but here are a few
of the most common ones:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225222Z" changeid="explorer">
        <seg>Encontrará información detallada sobre los operadores de Perl en L&lt;perlop&gt;; algunos de los más comunes son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlvar/$SIG{expr}&gt; for details on setting C&lt;%SIG&gt; entries, and
L&lt;&quot;eval BLOCK&quot;&gt; for some examples.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015456Z" changeid="explorer">
        <seg>Ver L&lt;perlvar/$SIG{expr}&gt; para los detalles sobre cómo colocar entradas C&lt;%SIG&gt; y L&lt;&quot;eval BLOQUE&quot;&gt; para algunos ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hash represents a set of key/value pairs:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234302Z" changeid="zipf">
        <seg>Un hash representa un conjunto de pares clave-valor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it useful for control flow</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto lo hace útil para el control de flujo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line numbers
displayed by diagnostics are internally stored as short integers,
so they are limited to a maximum of 65535 (higher numbers usually being
affected by wraparound).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los números de línea mostrados por los diagnósticos se almacenan internamente como enteros cortos, por lo que se limita a un máximo de 65535 (cifras más altas quedarán afectadas por el desbordamiento).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;W4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;W4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's regular expression support is both broad and deep, and is the
subject of lengthy documentation in L&lt;perlrequick&gt;, L&lt;perlretut&gt;, and
elsewhere.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225403Z" changeid="explorer">
        <seg>El soporte de Perl para las expresiones regulares es amplio y profundo, y se describe en gran detalle en los documentos L&lt;perlrequick&gt; y L&lt;perlretut&gt;, entre otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is mainly useful for constructing
bitmaps for C&lt;select&gt; and low-level POSIX tty-handling operations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es principalmente útil para construir bitmaps para C&lt;select&gt; y operaciones POSIX de bajo nivel sobre tty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For much more detailed
information, please see the documentation for C&lt;stat&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información más detallada, por favor consulte la documentación de C&lt;stat&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;&lt;EOF                 here-doc            yes*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;&lt;EOF               doc-empotrado	  sí*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last LINE if /^$/;	# exit when done with header</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last LINEA if /^$/;	# salir cuando se termine la cabecera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open STDERR, &quot;&gt;&amp;OLDERR&quot;    or die &quot;Can't dup OLDERR: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open STDERR, &quot;&gt;&amp;OLDERR&quot;    or die &quot;No puedo duplicar OLDERR: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this was not true of
versions of Perl before 5.004, so if your script will run under older
Perl versions, it should call C&lt;srand&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, esto no fue cierto para las versiones de Perl anteriores a la 5.004, así que si su programa se va a ejecutar en versiones anteriores de Perl, debería llamar a C&lt;srand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may charge a reasonable copying fee for any distribution of this
Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede cobrar una cuota razonable por las copias por cualquier distribución de este Paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is done as a second pass, after variables are
interpolated, so that regular expressions may be incorporated into the
pattern from the variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se hace como un segundo paso, después de que las variables son interpoladas, así las expresiones regulares pueden ser incorporadas en patrones desde las variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't fall into the trap of using a C&lt;printf&gt; when a simple
C&lt;print&gt; would do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No caiga en la trampa de utilizar un C&lt;printf&gt; cuando un simple C&lt;print&gt; valdría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;and&quot; returns the logical conjunction of the two surrounding
expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;and&quot; devuelve la conjunción lógica de las dos expresiones que la rodean.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be careful if you put double quotes around the picture, because an C&lt;@&gt;
character may be taken to mean the beginning of an array name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado si pone dobles comillas alrededor del cuadro, porque un carácter C&lt;@&gt; puede ser tomado como el comienzo del nombre de un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This strangeness is
due to the underlying system calls' definitions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comportamiento tan extraño es debido a las definiciones subyacentes de las llamadas del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise \11 is a
backreference only if at least 11 left parentheses have opened
before it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Asimismo, \11 es una contrareferencia sólo si, antes, y por lo menos, se han abierto 11 paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TEMPLATE is a sequence of characters that give the order and type
of values, as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La PLANTILLA es una secuencia de caracteres que dan el orden y el tipo de los valores, de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$aref = $AoA[$i];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052933Z" changeid="explorer">
        <seg>$aref = $AoA[$i];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;each&gt;, C&lt;values&gt; and C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;each&gt;, C&lt;values&gt; y C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following
computes the same number as the System V sum program:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, lo siguiente calcula el mismo número que el programa sum de System V:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with 5.8.3 we intend to make more frequent maintenance releases,
with a smaller number of changes in each.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de 5.8.3 tenemos la intención de hacer el mantenimiento más frecuente, con un menor número de cambios en cada uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($@) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($@) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And C&lt;$^N&gt; contains whatever was matched by
the most-recently closed group (submatch).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y C&lt;$^N&gt; contiene aquello que coincidía con el más reciente grupo de captura (sub coincidencia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;use locale&gt; is in effect and POSIX::setlocale() has been called,
the character used for the decimal separator in formatted floating-point
numbers is affected by the LC_NUMERIC locale.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;use locale&gt; está en vigor y POSIX::setlocale() ha sido llamado, el carácter utilizado para el separador decimal en formato de punto flotante de los números se ve afectada por la configuración regional LC_NUMERIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the natural logarithm (base I&lt;e&gt;) of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el logaritmo natural (base I&lt;e&gt;) de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = ( $key =&gt; $value );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = ( $clave =&gt; $valor );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resetting C&lt;&quot;A-Z&quot;&gt; is not recommended because you'll wipe out your
C&lt;@ARGV&gt; and C&lt;@INC&gt; arrays and your C&lt;%ENV&gt; hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El restablecimiento de C&lt;&quot;A-Z&quot;&gt; no es recomendable porque limpiará sus arrays C&lt;@ARGV&gt; y C&lt;@INC&gt; y su hash C&lt;%ENV&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step is performed over the finite
automaton that was generated during the previous pass.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este paso se realiza en el autómata finito que se generó durante la pasada anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;/x&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;/x&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 8, 2) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 8, 2) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (&quot;foo&quot;) { ++$count }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (&quot;foo&quot;) { ++$cuenta }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most
handlers must therefore arrange to actually display the
warnings that they are not prepared to deal with, by calling C&lt;warn&gt;
again in the handler.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de los controladores, por lo tanto, deben hacer los arreglos necesarios para mostrar las advertencias de las que no están preparados para hacer frente, llamando a C&lt;warn&gt; de nuevo en el controlador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpolicy		Perl development policies</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlpolicy		Políticas de desarrollo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@animals[0,1];                  # gives (&quot;camel&quot;, &quot;llama&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T213952Z" changeid="explorer">
        <seg>@animales[0,1];            # devuelve (&quot;camello&quot;, &quot;llama&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;!&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;!&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a BLOCK it's just a forward declaration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin un BLOQUE es sólo una declaración previa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first character of the name tells you to what sort of data
structure it refers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer carácter del nombre nos dice a qué tipo de estructura de datos se está accediendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider... oh, never mind.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere... ¡oh!, olvídelo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the log of another base, use basic algebra:
The base-N log of a number is equal to the natural log of that number
divided by the natural log of N.  For example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener el logaritmo de otra base, uso álgebra básica: el logaritmo de base N de un número es igual al logaritmo natural de ese número dividido por el logaritmo natural de N. Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getpwent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>implement IV/UV/NV/long double un/packing with j/J/F/D</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>implementar des/empaquetado de IV/UV/NV/long double con j/J/F/D</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format of the intervening
text is described in L&lt;perlpod&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El formato del texto intermedio está descrito en L&lt;perlpod&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*d&gt;',  0, 0;   # prints &quot;&lt;&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*d&gt;',  0, 0;   # imprime &quot;&lt;&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#{$AoA[$i]} ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052915Z" changeid="explorer">
        <seg>$#{$AoA[$i]} ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @animals = (&quot;camel&quot;, &quot;llama&quot;, &quot;owl&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T185348Z" changeid="zipf">
        <seg>my @animales = (&quot;camello&quot;, &quot;llama&quot;, &quot;búho&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GLOB</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>GLOB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item keys ARRAY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item keys ARRAY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = (</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = (</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually,
the C&lt;sprintf&gt;, C&lt;printf&gt;, or the C&lt;POSIX::floor&gt; and C&lt;POSIX::ceil&gt;
functions will serve you better than will int().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usualmente, las funciones C&lt;sprintf&gt;, C&lt;printf&gt;, o C&lt;POSIX::floor&gt; y C&lt;POSIX::ceil&gt; le servirán mejor que int().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item socket SOCKET,DOMAIN,TYPE,PROTOCOL
X&lt;socket&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200811Z" changeid="explorer">
        <seg>=item socket SOCKET,DOMINIO,TIPO,PROTOCOLO
X&lt;socket&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 KNOWN PROBLEMS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 PROBLEMAS CONOCIDOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With format C&lt;b&gt;,
the first character of the 8-tuple determines the least-significant bit of a
character; with format C&lt;B&gt;, it determines the most-significant bit of
a character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con el formato C&lt;b&gt;, el primer carácter de la 8-tupla determina el bit menos significativo de un carácter; con el formato C&lt;B&gt;, se determina el bit más significativo de un carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it's a common mistake to use C&lt;exec&gt; instead of C&lt;system&gt;, Perl
warns you if there is a following statement that isn't C&lt;die&gt;, C&lt;warn&gt;,
or C&lt;exit&gt; (if C&lt;-w&gt; is set--but you always do that, right?).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012449Z" changeid="explorer">
        <seg>Como es un error normal usar C&lt;exec&gt; en lugar de C&lt;system&gt;, Perl le avisará si hay alguna instrucción a continuación que no sea C&lt;die&gt;, C&lt;warn&gt; o C&lt;exit&gt; (si C&lt;-w&gt; está puesto -pero usted, siempre lo tiene así, ¿verdad?-).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 4) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 4) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlnetware 	Perl notes for NetWare</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlnetware 	Notas para NetWare</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can, without fear
of conflict, use the same name for a scalar variable, an array, or
a hash--or, for that matter, for a filehandle, a directory handle, a
subroutine name, a format name, or a label.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que usted puede, sin temor a conflictos, utilizar el mismo nombre para una variable escalar, un array o un hash; o, por la misma razón, para un gestor de archivo, un gestor de directorio, el nombre de una subrutina, un nombre de formato o una etiqueta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item x
X&lt;/x&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222812Z" changeid="explorer">
        <seg>=item x
X&lt;/x&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl actually stands for Pathologically Eclectic Rubbish Lister, but
don't tell anyone I said that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl, en realidad significa Recolector de basura patológicamente ecléctico (Pathologically Eclectic Rubbish Lister), pero no le diga a nadie que se lo he dicho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = &quot;0644&quot;; chmod $mode, &quot;foo&quot;;      # !!!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = &quot;0644&quot;; chmod $modo, &quot;foo&quot;;      # !!!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as we know that if the final quote does not match, backtracking will not
help.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ya que sabemos que si la doble comilla final no coincide, no ayudará el dar marcha atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># prints xdogcatCainAbel</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># prints xdogcatCainAbel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting from the beginning of the input string, each 8-tuple
of characters is converted to 1 character of output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir del comienzo de la cadena de entrada, cada 8-tupla de caracteres se convierte en un carácter de la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's easiest to make a local copy of the reference
before any manipulations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más fácil hacer una copia local de la referencia antes de cualquier manipulación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-line BLOCK may be put on one line, including curlies.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un BLOQUE de una sola línea puede ser puesto en una sola línea, incluyendo sus llaves.o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IREAD S_IWRITE S_IEXEC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_IREAD S_IWRITE S_IEXEC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the null filehandle uses the two argument form of L&lt;perlfunc/open&gt;
it interprets special characters, so if you have a script like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que el gestor de archivos nulo utiliza el formato de dos argumentos de L&lt;perlfunc/open&gt;, interpreta los caracteres especiales, así que si tiene un script como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close ARGV if eof;             # reset $.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close ARGV if eof;             # reinicia $.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub snazzle($) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub snazzle($) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq8		System Interaction</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq8		Interacción con el sistema</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information see L&lt;perlipc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información ver L&lt;perlipc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;PASSWD&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;PASSWD&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qw/STRING/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item qw/STRING/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not as bad as it sounds--what this means is that Perl will no longer be
part of the B&lt;kernel build system&gt; of FreeBSD.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-No tan malo como suena- quiere decir que Perl ya no formará parte del B&lt;sistema de construcción del kernel&gt; de FreeBSD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;User: &quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Usuario: &quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want your here-docs to be indented with the rest of the code,
you'll need to remove leading whitespace from each line manually:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere que su documento incrustado esté indentado con el resto del código, tendrá que quitar los espacios en blanco sobrantes de cada línea manualmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = grep(!/^#/, @bar);    # weed out comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = grep(!/^#/, @bar);    # quitar los comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no match has
previously succeeded, this will (silently) act instead as a genuine
empty pattern (which will always match).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hubo una coincidencia exitosa, actuará (silenciosamente) como un verdadero patrón vacío (que siempre coincidirá con cualquier cadena).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same
PLAINTEXT and SALT will always return the same string, but there is no
(known) way to get the original PLAINTEXT from the hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los mismos TEXTOPLANO y SALTO siempre devolverán el mismo string, pero no hay una forma (conocida) de obtener el TEXTOPLANO original desde el hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the C-style operators that would have been written like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con los operadores del estilo del C esto se hubiera escrito así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See C&lt;tie&gt;.)
Has no effect if the variable is not tied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver C&lt;tie&gt;). No tiene efecto si la variable no está enlazada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that GCC-2.95.x rev(DG/UX) knows the switch
-pthread which allows it to link correctly DG/UX's
-lthread library.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que GCC-2.95.x revisión DG/UX sabe de la opción -pthread, que le permite vincular correctamente la biblioteca -lthread de DG/UX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $HASH{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $HASH{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar values can be strings, integers or floating point numbers, and Perl
will automatically convert between them as required.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224818Z" changeid="explorer">
        <seg>Los valores escalares pueden ser cadenas, enteros o números de punto flotante, y Perl los convertirá de un tipo a otro cuando sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;% d&gt;',  12;   # prints &quot;&lt; 12&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;% d&gt;',  12;   # imprime &quot;&lt; 12&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exceptions include C&lt;&quot;#&quot;&gt; inside a string or regular
expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Excepciones a esto son la inclusión de C&lt;&quot;#&quot;&gt; dentro de una cadena o una expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unescaped C&lt;$&gt; or C&lt;@&gt; interpolates the corresponding variable,
while escaping will cause the literal string C&lt;\$&gt; to be inserted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;$&gt; o C&lt;@&gt; no escapado interpola la correspondiente variable, mientras que escapándolo hará que la cadena literal C&lt;\$&gt; sea insertada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+ - .                   for    (LIST) { }, for (a;b;c) { }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043352Z" changeid="explorer">
        <seg>+ - .                   for    (LIST) { }, for (a;b;c) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEE ALSO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VER TAMBIÉN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 2) = 1   ==          4 00100000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 2) = 1   ==          4 00100000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's some advice: supply a creation mode of C&lt;0666&gt; for regular
files (in C&lt;sysopen&gt;) and one of C&lt;0777&gt; for directories (in
C&lt;mkdir&gt;) and executable files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He aquí algunos consejos: suministre un modo de creación de C&lt;0666&gt; para archivos regulares (en C&lt;sysopen&gt;) y uno de C&lt;0777&gt; para directorios (en C&lt;mkdir&gt;) y los archivos ejecutables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns from a subroutine, C&lt;eval&gt;, or C&lt;do FILE&gt; with the value
given in EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Regresa de una subrutina, C&lt;eval&gt; o C&lt;do ARCHIVO&gt;, con el valor indicado en EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $answer = 42;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230806Z" changeid="zipf">
        <seg>my $respuesta = 42;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Any       string equality          $a eq $b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  Cualquiera igualdad de cadenas              $a eq $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item closedir DIRHANDLE
X&lt;closedir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211333Z" changeid="explorer">
        <seg>=item closedir GESTOR_DIR
X&lt;closedir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\PP       [3]  Match non-P</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223802Z" changeid="explorer">
        <seg>\PP	 [3]  Coincide con una no-P</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator makes that kind
of operation work on some other string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este operador hace que este tipo de operación trabaje en alguna otra cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certain operations
search or modify the string $_ by default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ciertas operaciones buscan o modifican la cadena $_ por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### next always comes here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>### next siempre viene aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Permissions: read, write, execute, for user, group, others.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Permisos: leer, escribir, ejecutar, por usuario, grupo, otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is more than one argument in LIST, or if LIST is an array
with more than one value, calls execvp(3) with the arguments in LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay más de un argumento en LISTA, o si LISTA es un array con más de un valor, se llama a execvp(3) con los argumentos de LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Juerd Waalboer &lt;#####@juerd.nl&gt;, with the help of many Perl Monks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Juerd Waalboer &lt;#####@juerd.nl&gt;, con la ayuda de muchos Perl Monks.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last; # can't go to outer :-(</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last; # no puedo volver al bucle más externo :-(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$line = readline(*STDIN);    # same thing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$linea = readline(*STDIN);    # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die @_ if $^S;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die @_ if $^S;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/etc/games is no good, stopped at canasta line 123.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/etc/games no está bien, parado at canasta line 123.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,29, 1) = 1   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,29, 1) = 1   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll assume that there's a flat file in which
each line is a row and each word an element.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vamos a suponer que hay un archivo de texto plano en el que cada línea es una fila y cada palabra un elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is whatever you can justify on the basis
of media cost, duplication charges, time of people involved, and so on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es lo que puede justificar en función de los costes medios de comunicación, gastos de duplicación, tiempo de las personas involucradas, y así sucesivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receives a message on a socket.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recibe un mensaje de un socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>q{foo{bar}baz}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>q{foo{bar}baz}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a reciprocal fashion, an operation provides either a scalar or a
list context to each of its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma recíproca, cualquier operación establece un contexto escalar o un contexto de lista para cada uno de sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$addrtype,$length,@addrs) = gethost*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($name,$aliases,$addrtype,$length,@addrs) = gethost*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1645 Irix 6.2 &amp; 6.3 POSIX header file updates</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004256Z" changeid="explorer">
        <seg>1645 Irix 6.2 &amp; 6.3 POSIX actualizaciones de los ficheros cabecera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting string is the concatenation of
the converted values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La cadena resultante es la concatenación de los valores convertidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 4) = 2   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 4) = 2   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;[$ix])   { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;[$i])      { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a) the GNU General Public License as published by the Free</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a) la Licencia General Pública GNU, publicada por la Free</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%g&gt;', 1;        # prints &quot;&lt;1&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%g&gt;', 1;        # imprime &quot;&lt;1&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only kind of simple statement is an expression evaluated for its
side effects.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012918Z" changeid="explorer">
        <seg>La única clase de instrucción simple que existe es una expresión evaluada para obtener unos efectos colaterales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@fhlist) {
            vec($bits,fileno($_),1) = 1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051332Z" changeid="explorer">
        <seg>for (@fhlist) {
            vec($bits,fileno($_),1) = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stat      localtime    caller         SPECIAL VARIABLES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>stat      localtime    caller         SPECIAL VARIABLES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset 'X';      # reset all X variables</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>reset 'X';      # reinicia todas las variables X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar values can be used in various ways:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230948Z" changeid="zipf">
        <seg>Los valores escalares se pueden usar de varias maneras:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, inside C&lt;(?{BLOCK})&gt;, C&lt;(?# comment )&gt;, and
a C&lt;#&gt;-comment in a C&lt;//x&gt;-regular expression, no processing is
performed whatsoever.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por otra parte, dentro de C&lt;(?{BLOQUE})&gt;, C&lt;(?# comentario )&gt;, y un C&lt;#&gt;-comentario en una C&lt;//x&gt;-expresión regular, no se realiza ningún tipo de procesamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proper
way to handle such calls is to assign C&lt;$!=0;&gt; before the call and
check the value of C&lt;$!&gt; if syscall returns C&lt;-1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma correcta de manejar llamadas de ese tipo es el de asignar C&lt;$!=0;&gt; antes de la llamada y comprobar el valor de C&lt;$!&gt; si syscall devuelve C&lt;-1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldoc		Look up Perl documentation in Pod format</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldoc		Mostrar documentación Perl en formato POD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a*&quot;, $type, $message)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a*&quot;, $tipo, $mensaje)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This can happen if the bracketing group is optional, or
in a different branch of an alternation.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto puede ocurrir si el grupo entre paréntesis es opcional, o en una rama diferente de la alternancia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The status is returned in C&lt;$?&gt;
and C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El estado se devuelve en C&lt;$?&gt; y C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;\x{...}&gt; can't have spaces because hexadecimal
numbers don't have spaces in them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;\x{...}&gt; no puede tener espacios porque los números hexadecimales no contienen espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Care should be taken when using the C&lt;no VERSION&gt; form of C&lt;no&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210647Z" changeid="explorer">
        <seg>Se debe tener cuidado cuando se usa la forma C&lt;no VERSIÓN&gt; de C&lt;no&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a NAME,
it's an anonymous function declaration, and does actually return
a value: the CODE ref of the closure you just created.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin un NOMBRE, es una declaración de una función anónima, y devuelve un valor: la referencia al CÓDIGO de la clausura que acaba de crear.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add perlpodspec</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadido perlpodspec</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But both are slower than assigning the empty list
or undefining %HASH or @ARRAY, which is the customary 
way to empty out an aggregate:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero estos dos son más lentos que simplemente asignar una lista vacía o indefiniendo %HASH o @ARRAY, que es la forma normal de vaciar un agregado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A slice of an empty list is still an empty list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una porción de una lista vacía es también una lista vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use warnings&gt; pragma (and the B&lt;-w&gt; switch) produces some 
lovely diagnostics.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El pragma C&lt;use warnings&gt; (y la opción B&lt;-w&gt;) produce algunos diagnósticos encantadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $animal;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232606Z" changeid="explorer">
        <seg>print $animal;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?(homer)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>?(homer)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you really wanted to do so, however, you could use
the construction C&lt;@{[ (some expression) ]}&gt;, but usually a simple
C&lt;(some expression)&gt; suffices.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si realmente quiere hacer eso, puede usar la construcción  C&lt;@{[ (una expresión) ]}&gt;, pero por lo general un simple C&lt;(una expresión)&gt; basta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open FILEHANDLE,MODE,EXPR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211649Z" changeid="explorer">
        <seg>=item open GESTOR_ARCHIVO,MODO,EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>format Something =</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>format Algo =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rmdir FILENAME
X&lt;rmdir&gt; X&lt;rd&gt; X&lt;directory, remove&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T195950Z" changeid="explorer">
        <seg>=item rmdir NOMBRE_DIRECTORIO
X&lt;rmdir&gt; X&lt;rd&gt; X&lt;directory, remove&gt; X&lt;directorio, eliminar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of packing can be achieved with
C&lt;pack(&quot;l!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este tipo de empaquetado se puede lograr con C&lt;pack(&quot;l!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then you can do a non-blocking wait for all pending zombie processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>entonces usted puede hacer una espera no bloqueante para todos los procesos zombie pendientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takes the
same flags as the system call of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toma las mismas banderas que la llamada al sistema del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar(@whatever) == $#whatever + 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>scalar(@loquesea) == $#loquesea + 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such
desperate behavior triggers a warning if you use the C&lt;use warnings&gt;
pragma or the B&lt;-w&gt; flag.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal desesperado comportamiento lanzará un aviso si usa el pragma C&lt;use warnings&gt; o la opción B&lt;-w&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./Configure -Dusethreads -Duseithreads</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>./Configure -Dusethreads -Duseithreads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpretation of the file permission operators C&lt;-r&gt;, C&lt;-R&gt;,
C&lt;-w&gt;, C&lt;-W&gt;, C&lt;-x&gt;, and C&lt;-X&gt; is by default based solely on the mode
of the file and the uids and gids of the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La interpretación de los operadores de permisos de archivo C&lt;-r&gt;, C&lt;-R&gt;, C&lt;-w&gt;, C&lt;-W&gt;, C&lt;-x&gt; y C&lt;-X&gt; es por defecto basado sólamente en el modo del archivo y en los uid y gid del usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 8   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 8   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless (EXPR) BLOQUE elsif (EXPR) BLOQUE ... else BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Darwin's First Name is &quot;, $scientists{&quot;Darwin&quot;}, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El nombre de Darwin &quot;, $cientificos{&quot;Darwin&quot;}, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a lowercased version of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una versión de EXPR, en minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since the publishing of this
book, by many known as &quot;Camel III&quot;, the consensus of the naming of this
functionality has moved from &quot;discipline&quot; to &quot;layer&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, desde la publicación de este libro, conocido por muchos como &quot;Camel III&quot;, el consenso sobre el nombre de esta funcionalidad se ha movido desde &quot;disciplina&quot; a &quot;capa&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\C             Match a single C-language char (octet) even if that is part
                    of a larger UTF-8 character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224047Z" changeid="explorer">
        <seg>\C             Coincide con un char (octeto, en lenguaje C) incluso si es parte
                    de un carácter UTF-8 más grande.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An exception to this is the C&lt;:encoding&gt; layer that
changes the default character encoding of the handle, see L&lt;open&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una excepción a esto es la capa C&lt;:encoding&gt; que cambia la codificación por defecto del gestor; ver L&lt;open&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Regular expressions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't normally need to worry about this unless
you are writing a Perl debugger.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No necesita preocuparse de esto a menos que esté escribiendo un depurador Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $SIG{ALARM} = sub { die &quot;Alarm!\n&quot; };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local $SIG{ALARM} = sub { die &quot;¡Alarma!\n&quot; };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhaiku		Perl notes for Haiku</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlhaiku		Notas para Haiku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item syswrite FILEHANDLE,SCALAR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211856Z" changeid="explorer">
        <seg>=item syswrite GESTOR_ARCHIVO,ESCALAR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;`STRING`&quot;&gt;
for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop/&quot;`STRING`&quot;&gt; para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the inclusion system
walks through @INC and encounters a subroutine, this subroutine gets
called with two parameters, the first a reference to itself, and the
second the name of the file to be included (e.g., &quot;F&lt;Foo/Bar.pm&gt;&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando el sistema de inclusión recorre C&lt;@INC&gt; y se encuentra con una subrutina, esta subrutina es llamada con dos parámetros; el primero, una referencia a sí mismo; y el segundo, el nombre del archivo que se incluirá (por ejemplo, &quot;F&lt;Foo/Bar.pm&gt;&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item telldir DIRHANDLE
X&lt;telldir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204752Z" changeid="explorer">
        <seg>=item telldir GESTOR_DIR
X&lt;telldir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Optimization of regular expressions
X&lt;regexp, optimization&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010535Z" changeid="explorer">
        <seg>=item Optimización de expresiones regulares
X&lt;regexp, optimization&gt; X&lt;regexp, optimización&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n}?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n}?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hashes have no particular internal order, though you can sort the keys
and loop through them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224935Z" changeid="explorer">
        <seg>En los hashes no hay un orden interno específico, aunque puede ordenar las claves antes de recorrerlas en un bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When reading, VAR must be a variable that will
hold the data read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al leer, VAR debe ser una variable que contendrá los datos leídos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlport&gt; for notes on the portability of this construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport&gt; para notas sobre la portabilidad de esta construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 4) = 4   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 4) = 4   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;||&gt;, C&lt;//&gt; and C&lt;&amp;&amp;&gt; operators return the last value evaluated
(unlike C's C&lt;||&gt; and C&lt;&amp;&amp;&gt;, which return 0 or 1).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los operadores C&lt;||&gt;, C&lt;//&gt; y C&lt;&amp;&amp;&gt; devuelven el último valor evaluado (a diferencia de los operadores del C C&lt;||&gt; y C&lt;&amp;&amp;&gt;, que devuelve 0 o 1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uses the value of EXPR as a filename and executes the contents of the
file as a Perl script.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usa el valor de EXPR como el nombre de un archivo y ejecuta los contenidos del archivo como un script Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpodspec 	Perl plain old documentation format specification</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlpodspec 	Especificación de la documentación en texto llano</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no way
to retrieve the file number of the other end.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay manera de recuperar el número de archivo del otro extremo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or you might have had a temporary variable sitting around with the
array in it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>O podría haber usado una variable temporal con el array en ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Exists\n&quot;    if exists $array[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Existe\n&quot;    if exists  $array[$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?(barney)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>?(pablo)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>read-only hashes (user-level interface is Hash::Util)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hashes de solo lectura (el interfaz de usuario es Hash::Util)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may use the three-argument form of open to specify I/O layers
(sometimes referred to as &quot;disciplines&quot;) to apply to the handle
that affect how the input and output are processed (see L&lt;open&gt; and
L&lt;PerlIO&gt; for more details).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar la forma de tres argumentos de open() para especificar capas  E/S (algunas veces referidas como &quot;disciplinas&quot;) para aplicar al gestor que afecta al modo en que la entrada y salida son procesadas (véase L&lt;open&gt; y L&lt;PerlIO&gt; para más detalles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 1) = 1   ==          4 00100000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 1) = 1   ==          4 00100000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these cases perl will fall back to the old behaviour of using C's
argv[0] value for C&lt;$^X&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estos casos perl volverá al anterior comportamiento de usar el valor del C argv[0] para C&lt;$^X&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More complex data types can be constructed using references, which allow
you to build lists and hashes within lists and hashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224947Z" changeid="explorer">
        <seg>Se pueden crear tipos de datos más complejos mediante referencias, que permiten generar listas y hashes dentro de listas y hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmpeix		Perl notes for MPE/iX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmpeix		Notas para MPE/iX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In I&lt;getpw*()&gt; the fields $quota, $comment, and $expire are special
in that they are unsupported on many systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En I&lt;getpw*()&gt; los campos $cuota, $comentario y $expiracion son casos especiales en el sentido que en muchos sistemas no están soportados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lists may be assigned to only when each element of the list
is itself legal to assign to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las listas pueden ser asignados a ella sólo cuando cada elemento de la lista en sí es legal para asignar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ make miniperl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ make miniperl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is just an ordinary
method (subroutine) defined (or inherited) by modules that wish to export
names to another module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es sólo un método (subrutina) ordinario definido (o heredado) por módulos que desean exportar nombres a otro módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to trap errors when loading an XS module, some problems with
the binary interface (such as Perl version skew) may be fatal even with
C&lt;eval&gt; unless C&lt;$ENV{PERL_DL_NONLAZY}&gt; is set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea capturar los errores cuando se carga un módulo XS, algunos problemas con la interfaz binaria (como el sesgo de versión de Perl) puede ser fatal, incluso con C&lt;eval&gt; a menos que C&lt;$ENV{PERL_DL_NONLAZY}&gt; esté puesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Final: '$1', pos=&quot;,pos,&quot;\n&quot; if /\G(.)/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Final: '$1', pos=&quot;,pos,&quot;\n&quot; if /\G(.)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or from the command line:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o desde la línea de comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $y (1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $y (1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get dates with leading zeros.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para obtener fechas con ceros a la izquierda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($foo = $bar) =~ s/this/that/;	# copy first, then change</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($foo = $bar) =~ s/este/aquel/;	# primero copiar, luego cambiar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To keep the string the same
length, you may need to pad or chop your value using C&lt;sprintf&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para mantener la cadena de la misma longitud, puede ser necesario rellenar o recortar su valor con C&lt;sprintf&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary compatibility with 5.8.0 has been restored in 5.8.2, which
necessitates breaking compatibility with 5.8.1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La compatibilidad binaria con 5.8.0 ha sido restaurada en 5.8.2, que requiere romper la compatibilidad con 5.8.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># No direct -X operator counterpart, but for the first one</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># No tiene un operador -X parejo, pero para el primero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omit redundant punctuation as long as clarity doesn't suffer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Omitir la puntuación redundante mientras no se reduzca la claridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The snazzle() function will behave in the most spectacular</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función snazzle() se convertirá en la más espectacular</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matching operations can have various modifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las operaciones de coincidencia pueden tener varios modificadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpretation of operations and values in Perl sometimes depends
on the requirements of the context around the operation or value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La interpretación de las operaciones y los valores en Perl depende a veces de las necesidades del contexto en el que se encuentra la operación o el valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The null list contains no elements, so when the password file is
exhausted, the result is 0, not 2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La lista vacía no contiene elementos, así que cuando el archivo de contraseñas se acaba, el resultado es 0, no 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ($foo &amp; 255) + 1, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ($foo &amp; 255) + 1, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Categories of modules range from text manipulation to network protocols
to database integration to graphics.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225600Z" changeid="explorer">
        <seg>Las categorías de módulos abarcan desde la manipulación de texto hasta protocolos de red, integración de bases de datos o gráficos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Miscellaneous</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T225219Z" changeid="zipf">
        <seg>=item Otros operadores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%2\$d %d %d\n&quot;, 12, 34;        # will print &quot;34 12 34\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%2\$d %d %d\n&quot;, 12, 34;        # imprimirá &quot;34 12 34\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FUNCTION is a string starting with C&lt;CORE::&gt;, the rest is taken as a
name for a Perl builtin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si FUNCIÓN es una cadena que comienza con C&lt;CORE::&gt;, el resto es tomado como un nombre para una orden interna de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item stat</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item stat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>i  A signed integer value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>i  Un valor entero con signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport/localtime&gt; for portability concerns.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport/localtime&gt; para las problemas sobre portabilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Searches a string for a pattern match, and in scalar context returns
true if it succeeds, false if it fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Busca una cadena para una coincidencia de patrones, y en un contexto escalar devuelve verdadero si tiene éxito, falso si falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;ARTICLE&gt;) {...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;ARTICULO&gt;) {...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If what the angle brackets contain is a simple scalar variable (e.g.,
&lt;$foo&gt;), then that variable contains the name of the
filehandle to input from, or its typeglob, or a reference to the
same.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si lo que los ángulos contienen es una variable escalar simple (por ejemplo, &lt;$foo&gt;), entonces esa variable contiene el nombre del gestor de archivo desde el qué recibir la entrada, o su I&lt;typeglob&gt;, o una referencia al mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>utime $atime, $mtime, @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>utime $atime, $mtime, @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following escape sequences are available in constructs that interpolate
and in transliterations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las siguientes secuencias de escape están disponibles en construcciones que interpolan y en transliteraciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operations return C&lt;undef&gt; to indicate failure, end of file,
system error, uninitialized variable, and other exceptional
conditions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Muchas operaciones devuelven C&lt;undef&gt; para indicar un fallo, fin de archivo, error del sistema, variable no inicializada u otras condiciones excepcionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
SEARCHLIST is delimited by bracketing quotes, the REPLACEMENTLIST has
its own pair of quotes, which may or may not be bracketing quotes,
e.g., C&lt;tr[A-Z][a-z]&gt; or C&lt;tr(+\-*/)/ABCD/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la LISTA_BÚSQUEDA está delimitada por sus propios delimitadores, la LISTA_REEMPLAZO tiene su propio par de delimitadores, que pueden o no ser los mismos delimitadores que los primeros. Por ejemplo, C&lt;tr[A-Z][a-z]&gt; o C&lt;tr(+\\-*/)/ABCD/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item substr EXPR,OFFSET,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item substr EXPR,DESPLAZAMIENTO,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlnumber		Perl number semantics</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlnumber		Semántica de los números en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;spat&quot;&gt; or C&lt;2.18 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;spat&quot;&gt; oo C&lt;2.18 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Issuing a &quot;make test&quot; will run all the tests.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La ejecución de un &quot;make test&quot; ejecutará todas las pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/readline&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase L&lt;perlfunc/readline&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @$ref_to_AoA, [ split ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @$ref_to_AoA, [ split ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add perlpacktut</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadido perlpacktut</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to read LENGTH I&lt;characters&gt; of data into variable SCALAR
from the specified FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intento de leer LONGITUD I&lt;caracteres&gt; de datos en la variable ESCALAR del GESTOR_ARCHIVO especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But with C&lt;&lt; open(A, '&gt;&gt;&amp;=B') &gt;&gt; the filehandles will share
the same file descriptor.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero con C&lt;&lt; open(A, '&gt;&gt;&amp;=B') &gt;&gt; los gestores de archivo de compartirán el mismo descriptor de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the test lib/ftmp-security gives you as a result
something like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la prueba lib/ftmp-security da como resultado algo como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is
I&lt;only&gt; meant to be used to assert that the running perl is of a earlier
version than its argument and I&lt;not&gt; to undo the feature-enabling side effects
of C&lt;use VERSION&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210734Z" changeid="explorer">
        <seg>I&lt;Sólo&gt; es para ser usado para afirmar que el perl que se está ejecutando es de una versión anterior a su argumento y I&lt;no&gt; para deshacer los efectos secundarios activados por C&lt;use VERSION&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value of -1 in either position is interpreted by most
systems to leave that value unchanged.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un valor de -1 en cualquier posición es interpretado en la mayoría de los sistemas como que se deja el actual valor sin cambiar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, despite what may be implied in I&lt;&quot;Programming Perl&quot;&gt; (the
Camel, 3rd edition) or elsewhere, C&lt;:raw&gt; is I&lt;not&gt; simply the inverse of C&lt;:crlf&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que, a pesar de estar implícito en I&lt;&quot;Programming Perl&quot;&gt; (el dromedario, 3ª edición) o en otro lugar, C&lt;:raw&gt; I&lt;no&gt; es el simplemente el inverso de C&lt;:crlf&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item map BLOCK LIST
X&lt;map&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191337Z" changeid="explorer">
        <seg>=item map BLOQUE LISTA
X&lt;map&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%s&gt;', &quot;a&quot;;       # prints &quot;&lt;a&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%s&gt;', &quot;a&quot;;       # imprime &quot;&lt;a&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because $x is a simple scalar variable, but C&lt;$hash{key}&gt; is
not--it's a hash element.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se debe a que C&lt;$x&gt; es una variable escalar simple, pero C&lt;$hash{clave}&gt; no lo es: es un elemento de un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But see also
L&lt;Bitwise String Operators&gt;.)  However, C&lt;use integer&gt; still has meaning for
them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185922Z" changeid="explorer">
        <seg>(Pero véase también L&lt;Operadores de bit en cadenas&gt;). Sin embargo, C&lt;use integer&gt; todavía tiene sentido para ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
C&lt;int(-6.725/0.025)&gt; produces -268 rather than the correct -269; that's
because it's really more like -268.99999999999994315658 instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;int(-6.725/0.025)&gt; produce -268 en vez del valor correcto -269; esto es porque el valor realmente es -268.99999999999994315658.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This set of
characters is just a recommendation; the characters allowed in
the salt depend solely on your system's crypt library, and Perl can't
restrict what salts C&lt;crypt()&gt; accepts.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este conjunto de caracteres es sólo una recomendación; los caracteres permitidos en el salto dependen solamente de la función crypt del sistema y Perl no puede restringir el salto que C&lt;crypt()&gt; acepte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item package NAMESPACE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item package ESPACIO_NOMBRES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 4) = 8   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 4) = 8   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar may contain one single value in any of three
different flavors: a number, a string, or a reference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T001241Z" changeid="explorer">
        <seg>Un escalar puede contener un único valor perteneciente a un tipo de entre tres distintos: un número, una cadena o una referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq2		Obtaining and Learning about Perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq2		Obteniendo y aprendiendo sobre Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ref</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item ref</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a description
of this, see L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una descripción de ésto, véase L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;\N&gt; has two meanings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que C&lt;\N&gt; tiene dos significados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;the sort pragma|sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;el pragma sort|sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlobj&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlobj&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($some_condition) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181650Z" changeid="zipf">
        <seg>if ($una_condicion) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/warn&gt;, L&lt;perlvar&gt;, L&lt;warnings&gt; and L&lt;perllexwarn&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/warn&gt;, L&lt;perlvar&gt;, L&lt;warnings&gt; y L&lt;perllexwarn&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most important thing is to run your programs under the B&lt;-w&gt;
flag at all times.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo más importante es ejecutar siempre sus programas con la opción B&lt;-w&gt; puesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takes a LIST of values and converts it into a string using the rules
given by the TEMPLATE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toma una LISTA de valores y la convierte en una cadena usando las reglas dadas por la PLANTILLA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support fchdir(2), you may pass a filehandle or
directory handle as argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soportan fchdir(2), puede pasarle un gestor de archivo o un gestor de directorio como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike i, m, s and x, these two flags affect the way the regex is used
rather than the regex itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de i, m, s y x, estos dos indicadores afectan a la forma en que se utiliza la expresión regular en lugar de la propia expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($Config{doublesize} == $Config{longdblsize}) &amp;&amp;
                print &quot;doubles are long doubles\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051812Z" changeid="explorer">
        <seg>($Config{doublesize} == $Config{longdblsize}) &amp;&amp;
                print &quot;doubles son long doubles\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates an unnamed pair of sockets in the specified domain, of the
specified type.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea un par de sockets anónimos en el dominio especificado, del tipo especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $i++;  # prints 0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $i++;  # imprime 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;eval&gt;/C&lt;die&gt; always works,
modulo the caveats given in L&lt;perlipc/&quot;Signals&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando C&lt;eval&gt;/C&lt;die&gt; siempre funciona, teniendo en cuenta las advertencias dadas en L&lt;perlipc/&quot;Señales&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the argument
to push() must be a real array, not just a reference to such.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que el argumento de push() debe ser un array real, no sólo una referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlapollo		Perl notes for Apollo DomainOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlapollo		Notas para Apollo DomainOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perluniintro&gt;, L&lt;perllocale&gt; and L&lt;Locale::Maketext&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descrito en L&lt;perluniintro&gt;, L&lt;perllocale&gt; y L&lt;Locale::Maketext&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @INC, Foo-&gt;new(...);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @INC, Foo-&gt;new(...);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl583delta - what is new for perl v5.8.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl583delta - Qué hay de nuevo para perl v5.8.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LENGTH is
not specified, writes whole SCALAR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LONGITUD no se especifica, escribe todo el ESCALAR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>======  =====     =====================    =============</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>==========  =========  ===============================  =============</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a precision obtained through C&lt;*&gt; is negative, it counts
as having no precision at all.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si una precisión obtenida a través de C&lt;*&gt; es negativa, se cuenta como no tener precisión en absoluto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;last&gt;, you have to be more elaborate:
X&lt;last&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T041229Z" changeid="explorer">
        <seg>Para C&lt;last&gt;, ha de ser un poco más elegante
X&lt;last&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Input and output functions
X&lt;I/O&gt; X&lt;input&gt; X&lt;output&gt; X&lt;dbm&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201256Z" changeid="explorer">
        <seg>=item Funciones de Entrada y Salida
X&lt;I/O&gt; X&lt;input&gt; X&lt;output&gt; X&lt;dbm&gt; X&lt;entrada&gt; X&lt;salida&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and I&lt;not&gt;
Mac OS X.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando decimos bajo &quot;Mac OS&quot;, queremos decir Mac OS 7, 8 y 9, y I&lt;no&gt; Mac OS X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$filename =~ s/(.*\.gz)\s*$/gzip -dc &lt; $1|/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$archivo =~ s/(.*\.gz)\s*$/gzip -dc &lt; $1|/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A filehandle, from which the file will be read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un gestor de archivo, desde el cual, el archivo será leído.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If EXPR happens to start off with C&lt;0x&gt;, interprets it as a
hex string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si EXPR comienza con C&lt;0x&gt;, se interpreta como una cadena en hexadecimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>THAT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To capture a command's STDOUT but discard its STDERR:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para capturar el STDOUT de un comando pero descartar su STDERR:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the current position to the beginning of the directory for the
C&lt;readdir&gt; routine on DIRHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194730Z" changeid="explorer">
        <seg>Establece la posición actual al comienzo del directorio para la rutina C&lt;readdir&gt; en GESTOR_DIR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete() may also be used on arrays and array slices, but its behavior is less
straightforward.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete() puede usarse también en lo arrays y porciones de array, pero su comportamiento es menos claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Did we mention that you should definitely consider using the B&lt;-w&gt;
switch?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Mencionamos que debe considerar, definitivamente, el usar la opción B&lt;-w&gt;?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 FILES</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004026Z" changeid="explorer">
        <seg>=head1 ARCHIVOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In almost all cases like this, it's usually a far, far better idea to use the
structured control flow mechanisms of C&lt;next&gt;, C&lt;last&gt;, or C&lt;redo&gt; instead of
resorting to a C&lt;goto&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En casi todos los casos como este, es usualmente una mejor, mucho mejor idea, usar los mecanismos de control de flujo de C&lt;next&gt;, C&lt;last&gt; o C&lt;redo&gt; en vez de recurrir a C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($_ = &lt;STDIN&gt;) { print; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($_ = &lt;STDIN&gt;) { print; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SCALAR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SCALAR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may not be a space between the C&lt;&lt; &lt;&lt; &gt;&gt; and the identifier,
unless the identifier is explicitly quoted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No es necesario un espacio entre el C&lt;&lt; &lt;&lt; &gt;&gt; y el identificador, a menos que el identificador esté explícitamente entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as B&lt;Do What I
Mean&gt;, abbreviated B&lt;DWIM&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es conocido como B&lt;Do What I Mean&gt; (haz lo que te digo), abreviado como B&lt;DWIM&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the entry doesn't exist you get the undefined value.)  For example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si la entrada no existe obtendrá el valor indefinido). Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I said bar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He dicho bar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we usually think of quotes as literal values, in Perl they
function as operators, providing various kinds of interpolating and
pattern matching capabilities.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras solemos solemos pensar de lo entrecomillado como si fueran valores literales, en Perl funcionan como operadores, ofreciendo diversos tipos de interpolación y capacidades de coincidencia de patrones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the absolute value of the right operand (C&lt;abs($b)&gt;) is greater than
or equal to C&lt;(UV_MAX + 1)&gt;, &quot;%&quot; computes the floating-point remainder
C&lt;$r&gt; in the equation C&lt;($r = $a - $i*$b)&gt; where C&lt;$i&gt; is a certain
integer that makes C&lt;$r&gt; have the same sign as the right operand
C&lt;$b&gt; (B&lt;not&gt; as the left operand C&lt;$a&gt; like C function C&lt;fmod()&gt;)
and the absolute value less than that of C&lt;$b&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el valor absoluto del operando derecho (C&lt;abs($b)&gt;) es mayor o igual a C&lt;(UV_MAX + 1)&gt;, &quot;%&quot; computa el resto en punto flotante C&lt;$r&gt; en la ecuación C&lt;($r = $a - $i*$b)&gt; donde C&lt;$i&gt; es un cierto entero que hace que C&lt;$r&gt; tenga el mismo signo que el operando de la derecha C&lt;$b&gt; (B&lt;no&gt; como el operando izquierdo C&lt;$a&gt; como la función C C&lt;fmod()&gt;)
y el valor absoluto menor que el de C&lt;$b&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@newAoA = splice_2D( \@AoA, 4 =&gt; 8, 7 =&gt; 12 );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200350Z" changeid="explorer">
        <seg>@newAoA = splice_2D( \@AoA, 4 =&gt; 8, 7 =&gt; 12 );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string =~ $re;		# or used standalone</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cadena =~ $re;		# o usar de forma aislada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = q!I said, &quot;You said, 'She said it.'&quot;!;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = q!Yo dije, &quot;Tu dijiste, 'Ella dijo.'&quot;!;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most platforms, you will have to protect
shell metacharacters if you want them treated literally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de plataformas, tendrá que proteger los metacaracteres de shell, si quiere que ellos sean tratados literalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dbmopen(%HIST,'/usr/lib/news/history',0666);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dbmopen(%HIST,'/usr/lib/news/history',0666);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># code</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># código</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This introductory document does not aim to be complete.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T180100Z" changeid="zipf">
        <seg>Es un documento introductorio, no una guía completa,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A continue block is often used to reset line counters
or C&lt;?pat?&gt; one-time matches:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un bloque C&lt;continue&gt; se usa a menudo para reiniciar contadores de línea o patrones de un sólo uso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing, but without any temps</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, pero sin usar ninguna variable temporal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general,
conversion from one form to another is transparent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, la conversión entre uno y otro tipo es transparente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators can be combined with a C&lt;=&gt; as follows:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225256Z" changeid="explorer">
        <seg>Muchos operadores se pueden combinar con un signo C&lt;=&gt; de la manera siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say 'a complicated check for $foo is true';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>say 'una confirmación complicada para $foo es cierta';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keys(%users) = 1000;		# allocate 1024 buckets</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>keys(%usuarios) = 1000;		# reserva 1024 cajones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DOMAIN, TYPE, and PROTOCOL are specified the same as
for the syscall of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DOMINIO, TIPO, y PROTOCOLO son especificados de la misma manera que la llamada del sistema del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In place of a SUBNAME, you can provide a BLOCK as
an anonymous, in-line sort subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En lugar de un NOMBRE_SUB, puede proporcionar un BLOQUE como si fuera una subrutina de ordenación anónima.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a list may consist of any combination
of scalar arguments or list values; the list values will be included
in the list as if each individual element were interpolated at that
point in the list, forming a longer single-dimensional list value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal lista puede consistir en cualquier combinación de argumentos escalares o valores de lista; los valores de lista serán incluidos en la lista como si cada elemento individual fuera interpolado en ese punto en la lista, formando un largo y unidimensional valor de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; &lt;= &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; &lt;= &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values for WHENCE are C&lt;0&gt; to set the new
position to POSITION, C&lt;1&gt; to set the it to the current position plus
POSITION, and C&lt;2&gt; to set it to EOF plus POSITION (typically
negative).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores de DESDEDÓNDE son C&lt;0&gt; para establecer la nueva posición a POSICIÓN, C&lt;1&gt; para establecer la posición actual más POSICIÓN, y C&lt;2&gt; para establecerlo a EOF más POSICIÓN (normalmente negativo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What about adding new columns?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Qué pasa con la adición de nuevas columnas?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item semctl ID,SEMNUM,CMD,ARG
X&lt;semctl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200433Z" changeid="explorer">
        <seg>=item semctl ID,SEMNUM,CMD,ARG
X&lt;semctl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># for speed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># para aumentar la velocidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most implementations of C&lt;srand&gt; take an integer and will silently
truncate decimal numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de las implementaciones de C&lt;srand&gt; toman un número entero y silenciosamente truncará los números decimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``	qx{}	      Command		  yes*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>``	qx{}	      Comando		  sí*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(':', split(//, 'hi there')), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(':', split(//, 'hola por aqui')), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 OO Perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Perl orientado a objetos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the packed address if it succeeded, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la dirección empaquetada si ha tenido éxito, de lo contrario, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these loop constructs, the assigned value (whether assignment
is automatic or explicit) is then tested to see whether it is
defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estas construcciones de bucle, el valor asignado (tanto si la asignación es automática o explícita) es examinado para ver si está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@new = sort other::backwards @old;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@nuevo = sort otro::al_reves @viejo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Constant Folding
X&lt;constant folding&gt; X&lt;folding&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010957Z" changeid="explorer">
        <seg>=head2 Plegado de constantes
X&lt;constant folding&gt; X&lt;folding&gt; X&lt;plegado de constantes&gt; X&lt;plegado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POSITION and the return value are based at C&lt;0&gt; (or whatever
you've set the C&lt;$[&gt; variable to--but don't do that).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>POSICIÓN y el valor devuelto están basados en C&lt;0&gt; (o al valor indicado por la variable C&lt;$[&gt;, pero no lo haga, por favor).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: C&lt;unlink&gt; will not attempt to delete directories unless you are
superuser and the B&lt;-U&gt; flag is supplied to Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota: C&lt;unlink&gt; no intentará eliminar directorios a menos que usted sea superusuario y la bandera B&lt;-U&gt; se suministre a Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function implementing the C&lt;&lt; &lt;EXPR&gt; &gt;&gt;
operator, but you can use it directly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es la función interna que implementa el operador C&lt;&lt; &lt;EXPR&gt; &gt;&gt;, pero puede usarla directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;echo @ARGV&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;echo @ARGV&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, Perl attempts to flush all files opened for
output before forking the child process, but this may not be supported
on some platforms (see L&lt;perlport&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de la versión v5.6.0, Perl intentará vaciar todos los archivos abiertos para salida antes de crear un proceso hijo, pero esto puede no estar soportado en algunas plataformas (ver L&lt;perlport&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because
this promotes strange action at a distance, this counterintuitive
behavior may be fixed in a future release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que provoca una acción extraña a gran distancia, este comportamiento no intuitivo puede ser arreglado en una distribución futura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does the same thing as the C&lt;stat&gt; function (including setting the
special C&lt;_&gt; filehandle) but stats a symbolic link instead of the file
the symbolic link points to.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hace lo mismo que la función C&lt;stat&gt; (incluyendo el establecimiento del gestor especial C&lt;_&gt;) pero de un enlace simbólico en lugar del archivo apuntado por el enlace simbólico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last if $x = $y**2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last if $x = $y**2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Plain Old Comments (Not!)
X&lt;comment&gt; X&lt;line&gt; X&lt;#&gt; X&lt;preprocessor&gt; X&lt;eval&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043215Z" changeid="explorer">
        <seg>=head2 Viejos comentacios sencillos (¡No!)
X&lt;comment&gt; X&lt;line&gt; X&lt;#&gt; X&lt;preprocessor&gt; X&lt;eval&gt; X&lt;comentario&gt; X&lt;línea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Regular expressions and pattern matching
X&lt;regular expression&gt; X&lt;regex&gt; X&lt;regexp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043542Z" changeid="explorer">
        <seg>=item Expresiones regulares y coincidencia de patroner
X&lt;regular expression&gt; X&lt;regex&gt; X&lt;regexp&gt; X&lt;expresión regular&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all child processes are
gone BeOS' waitpid(-1,...) returns 0 instead of -1 (as it should).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Después de que todos los procesos hijo hayan terminado, el waitpid(-1, ...) de BeOS devuelve 0 en lugar de -1 (como debería).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlport&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también L&lt;perlport&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ((1+2)+4);  # Prints 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ((1+2)+4);	# Imprime 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># (including lexicals) in $_ : First $1 is interpolated</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># (incluyendo léxicas) en $_ : Primero $1 es interpolado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The days of just flinging strings around are over.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T060221Z" changeid="explorer">
        <seg>Actualmente ya no es posible trabajar con cadenas de texto de manera irreflexiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($uno,$cinco,$quince) = (`uptime` =~ /(\d+\.\d+)/g);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\U		uppercase till \E (think vi)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\U		mayúscula hasta \E (como en vi)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Exists\n&quot;    if exists $hash{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Existe\n&quot;    if exists  $hash{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may substantially slow your program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto puede ralentizar sustancialmente el programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl591delta	Perl changes in version 5.9.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl591delta	Cambios en la versión 5.9.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;r is not a reference at all.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;r no es una referencia.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @{$ref-&gt;[$x][$y]}[$index1, $index2, @moreindices];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @{$ref-&gt;[$x][$y]}[$indice1, $indice2, @masindices];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0x56 0x78 0x12 0x34</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0x56 0x78 0x12 0x34</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -Dcc='cc -64' -Duse64bitall</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002623Z" changeid="explorer">
        <seg>sh Configure -Dcc='cc -64' -Duse64bitall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $ref-&gt;[$x][$y][$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $ref-&gt;[$x][$y][$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cases 1 and 2 above behave identically: they run the code contained in
the variable $x.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los casos 1 y 2 se comportan idénticamente: ejecutan el código contenido en la variable $x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that unlike C&lt;split&gt;, C&lt;join&gt; doesn't take a pattern as its
first argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuidado que, a diferencia de C&lt;split&gt;, C&lt;join&gt; no toma un patrón como su primer argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next call following that one restarts iteration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La siguiente llamada reinicia la iteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} 0..$#old</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} 0..$#viejo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, see L&lt;/exec&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una vez más, véase L&lt;/exec&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $passwd and $shell, user's encrypted password and
login shell, are also tainted, because of the same reason.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La $contrasena y el $shell, la contraseña codificada del usuario y el shell del login, están también contaminados, por la misma razón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># parse mail messages</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># analizar mensajes de correo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 New Documentation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Nueva documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default all
filehandles operate on bytes, but for example if the filehandle has
been opened with the C&lt;:utf8&gt; I/O layer (see L&lt;/open&gt;, and the C&lt;open&gt;
pragma, L&lt;open&gt;), the I/O will operate on UTF-8 encoded Unicode
characters, not bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto todos los gestores de archivo operan en bytes, pero por ejemplo, si el gestor ha sido abierto con la capa de E/S C&lt;:utf8&gt; (ver L&lt;/open&gt;, y el pragma C&lt;open&gt;, L&lt;open&gt;), la E/S operará en caracteres codificados en UTF-8, no bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item read FILEHANDLE,SCALAR,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item read GESTOR_ARCHIVO,ESCALAR,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;given(EXPR)&gt; will assign the value of EXPR to C&lt;$_&gt;
within the lexical scope of the block, so it's similar to</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042711Z" changeid="explorer">
        <seg>C&lt;given(EXPR)&gt; asignará el valor de EXPR a C&lt;$_&gt; dentro del ámbito léxico del bloque, algo similar a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = ('cc', '-E', $bar);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = ('cc', '-E', $bar);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># In the main program</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># En el programa principal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the hook is an object, it must provide an INC method that will be
called as above, the first parameter being the object itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el enganche es un objeto, debe proporcionar un método INC que será llamado como antes, el primer parámetro siendo el objeto mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Send omissions or corrections to &lt;F&lt;perlbug@perl.org&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Envíe omisiones o correcciones a &lt;F&lt;perlbug@perl.org&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Bitwise Or and Exclusive Or
X&lt;operator, bitwise, or&gt; X&lt;bitwise or&gt; X&lt;|&gt; X&lt;operator, bitwise, xor&gt;
X&lt;bitwise xor&gt; X&lt;^&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235427Z" changeid="explorer">
        <seg>=head2 Or y exclusivo or binarios
X&lt;operator, bitwise, or&gt; X&lt;bitwise or&gt; X&lt;|&gt; X&lt;operator, bitwise, xor&gt; X&lt;operador, binario, or&gt; X&lt;binario or&gt; X&lt;operador, binario, xor&gt; X&lt;binario xor&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12345.67</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>12345.67</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is an expression, the value is
taken as the name of the filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211224Z" changeid="explorer">
        <seg>Si GESTOR_ARCHIVO es una expresión, el valor es tomado como el nombre del gestor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chown $uid, $gid, @ary;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chown $uid, $gid, @ary;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every simple statement must be terminated with a
semicolon, unless it is the final statement in a block, in which case
the semicolon is optional.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012933Z" changeid="explorer">
        <seg>Cada instrucción simple debe terminarse en un punto y coma excepto si es la última instrucción de un bloque, en cuyo caso el punto y coma es opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$obj ~~ X</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$obj ~~ X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, C&lt;@DB::args&gt; might have information from the
previous time C&lt;caller&gt; was called.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, C&lt;@DB::args&gt; podría tener información de la llamada a la anterior llamada a C&lt;caller&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the entry doesn't exist you get an empty list.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si la entrada no existe, obtendrá una lista vacía).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/vec&gt; for information on how to manipulate individual bits
in a bit vector.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase L&lt;perlfunc/vec&gt; para obtener información sobre cómo manipular bits individuales de un vector de bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sort() returns aliases into the original list, much as a for loop's index
variable aliases the list elements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sort() devuelve alias en la lista original, como lo hace la variable de índice de los bucles for(), que hace un alias de los elementos de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options may exist at multiple protocol levels depending on the socket
type, but at least the uppermost socket level SOL_SOCKET (defined in the
C&lt;Socket&gt; module) will exist.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Opciones pueden existir en múltiples niveles de protocolo dependiendo del tipo de socket, pero al menos existirá el más alto nivel de socket SOL_SOCKET (definido en el módulo C&lt;Socket&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-defined subroutines may choose to care whether they are being
called in a void, scalar, or list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las subrutinas definidas por el usuario tienen la opción de considerar si están siendo llamadas en contexto vacío, escalar o de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@result = sort { $a &lt;=&gt; $b } grep { $_ == $_ } @input;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@resultado = sort { $a &lt;=&gt; $b } grep { $_ == $_ } @entrada;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LAYER is present it is a single string, but may contain multiple
directives.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si CAPA está presente es un único string, pero puede contener múltiples directivas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ **= $_ , / {$_} / for 2 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ **= $_ , / {$_} / for 2 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reads or writes the System V shared memory segment ID starting at
position POS for size SIZE by attaching to it, copying in/out, and
detaching from it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lee o escribe en el segmento ID de memoria compartida System V a partir de la posición POSICIÓN para el tamaño TAMAÑO, añadiéndose a ella, copiando la entrada/salida, y desuniéndose de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,m}+ Match at least n but not more than m times and give nothing back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n,m}+ Coincide al menos n pero no más de m veces y no devuelve nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each such format generates 1 bit of the result.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada uno de estos formatos genera un bit del resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some platforms (notably DOS-like ones), the shell may not be
capable of dealing with multiline commands, so putting newlines in
the string may not get you what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunas plataformas (especialmente las de tipo DOS), el shell quizás no pueda ser capaz de tratar con los comandos de múltiples líneas, así que poner saltos de línea quizás no le permita obtener lo que quiere.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of a symbolic link, if symbolic links are
implemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor de un enlace simbólico, si los enlaces simbólicos están implementados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Subscripts</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Subíndices</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item study</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item study</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may find the length
of array @days by evaluating C&lt;$#days&gt;, as in B&lt;csh&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede conocerse la longitud del array @días evaluando C&lt;$#días&gt;, como en B&lt;csh&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an expression that specifies an element of a hash, returns true if the
specified element in the hash has ever been initialized, even if the
corresponding value is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dada una expresión que especifica un elemento de un hash, devuelve verdadero si el elemento especificado en el hash ha sido inicializado, incluso si el correspondiente valor está indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlre&gt; for further explanation on these.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlre&gt; para una explicación más detallada sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pack(&quot;n/a* w/a&quot;,&quot;hello,&quot;,&quot;world&quot;)       gives &quot;\000\006hello,\005world&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pack(&quot;n/a* w/a&quot;,&quot;hello,&quot;,&quot;world&quot;)       da &quot;\000\006hello,\005world&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!   not</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055533Z" changeid="explorer">
        <seg>!   not</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might also have loaded that from a function:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es posible que también lo haya cargado a partir de una función:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opendir(my $dh, $some_dir) || die;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>opendir(my $dh, $algun_dir) || die;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also
C&lt;POSIX::setsid()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Véase también C&lt;POSIX::setsid()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, &quot;&lt;&quot;, &quot;foo&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $fh, &quot;&lt;&quot;, &quot;foo&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;abcdefg\0\0\0\0\0\0\0&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># &quot;abcdefg\0\0\0\0\0\0\0&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a subroutine that does substring:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay una subrutina que parte cadenas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without flock() support:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin soporte de flock():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $logmessage = $_[0];                 # uncommon, and ugly</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110204T165728Z" changeid="zipf">
        <seg>my $mensaje_registro = $_[0];            # poco común (y poco estético)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 'Hello, world';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233623Z" changeid="zipf">
        <seg>print 'Hola a todos';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$passwd,$uid,$gid,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($nombre,$contrasena,$uid,$gid,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negation of a true value by C&lt;!&gt; or C&lt;not&gt; returns a special false value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La negación del valor de verdadero con C&lt;!&gt; o C&lt;not&gt; devuelve un valor falso especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treats the string in EXPR as a bit vector made up of elements of
width BITS, and returns the value of the element specified by OFFSET
as an unsigned integer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se usa para tratar la cadena en EXPR como un vector de bits compuesta de elementos de tantos BITS de ancho, y devuelve el valor del elemento especificado por el DESPLAZAMIENTO como un entero sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, if you wish to run Configure non-interactively (see the INSTALL
document for details), to have it select the correct hint file, you'll
need to provide the argument -Dhintfile=riscos on the Configure
command-line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que, si desea ejecutar Configure de forma no interactiva (ver el documento INSTALL para más detalles), a su sugerencia de seleccionar el archivo correcto, tendrá que proporcionar el argumento -Dhintfile=riscos en la línea de comando para Configure.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>THIS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESTE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B  A bit string (descending bit order inside each byte).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B  Un cadena de bit (en orden de bit descendente dentro de cada byte).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recursion is of
unlimited depth.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La recursividad es de profundidad ilimitada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt; modifiers can only be used on floating-point
formats on big- or little-endian machines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los modificadores C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt; solo pueden ser usados con formatos de punto flotante en máquinas con ordenación big-endian o little-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,24, 1) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,24, 1) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apple  =&gt; &quot;red&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025826Z" changeid="explorer">
        <seg>manzana =&gt; &quot;rojo&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item close</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item close</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldgux - Perl under DG/UX.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldgux - Perl bajo DG/UX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hexadecimal, octal, or binary, representations in string literals
(e.g. '0xff') are not automatically converted to their integer
representation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hexadecimal, octal o binario, representaciones en cadenas literales (por ejemplo, '0xff') no se convierten automáticamente en su representación en entero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rounds up the allocated buckets to the next power of two:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto redondea el número de cajones reservados a la siguiente potencia de dos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$arg = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$arg = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use IO::Handle;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use IO::Handle;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return true if successful, or false if there is an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Regresa verdadero si tiene éxito, o falso si hay un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlre&gt; for additional information on valid syntax for STRING, and
for a detailed look at the semantics of regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlre&gt; para obtener información adicional sobre la sintaxis válida para CADENA, y para una vista detallada de la semántica de las expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @HASH{keys %HASH};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @HASH{keys %HASH};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = &quot;ppooqppqq&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = &quot;ppooqppqq&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use charnames 'greek';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use charnames 'greek';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $foo;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef $foo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't shrink the number of buckets allocated for the hash using
C&lt;keys&gt; in this way (but you needn't worry about doing this by accident,
as trying has no effect).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede reducir el número de alojamientos reservados para el hash usando C&lt;keys&gt; de esta manera (pero no necesita preocuparse si hace esto por accidente; intentarlo no tiene ningún efecto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 4) = 8   ==        128 00000001000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 4) = 8   ==        128 00000001000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, it returns a
list of values counting (up by ones) from the left value to the right
value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, devuelve una lista de valores contando (de uno en uno) desde el valor de la izquierda al valor de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines declarations can also be loaded up with the C&lt;require&gt; statement
or both loaded and imported into your namespace with a C&lt;use&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012812Z" changeid="explorer">
        <seg>Las declaraciones de subrutinas pueden cargarse también con la instrucción C&lt;require&gt; o cargadas e importadas en su espacio de nombres con la instrucción C&lt;use&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using
this, one can control Perl's idea of filenames and line numbers in
error or warning messages (especially for strings that are processed
with C&lt;eval()&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando esto, uno puede controlar la idea que tiene Perl de los nombres de archivos y número de líneas en los mensajes de avisos y errores (especialmente para las cadenas procesadas con C&lt;eval()&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or for using call-by-named-parameter to complicated functions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o para utilizar llamadas con parámetros por nombre para funciones complicadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lowercase lowercase line-noise lowercase lowercase line-noise</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>minúsculas minúsculas línea-ruidosa minúsculas minúsculas línea-ruidosa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3 nlink  3 day        3 subroutine   $\    output separator</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3 nlink  3 día        3 subrutina    $\    sep. salida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VMS: fix perl -P</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VMS: arreglado perl -P</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># These examples are subject to system-specific variation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Estos ejemplos están sujetos a variaciones específicas del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar in spirit to, but not the same as, grep(1) and its
relatives.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es similar en espíritu, pero no lo mismo, que con grep(1) y sus hermanos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>testing...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>comprobando...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
returns sine of C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, devuelve el seno de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DIRHANDLE may be an expression whose value can be used as an indirect
dirhandle, usually the real dirhandle name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>GESTOR_DIR puede ser una expresión cuyo valor puede ser usado como un gestor indirecto, normalmente el nombre real del gestor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($win,fileno(STDOUT),1) = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($win,fileno(STDOUT),1) = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;fred&quot;, &quot;barney&quot; ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;pedro&quot;, &quot;pablo&quot; ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LOOP:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LOOP:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;2: '&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;2: '&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or how about sorted by key:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o de forma ordenada por la clave:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the following
will not match forever:
X&lt;\G&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, lo siguiente no coincidirá nunca:
X&lt;\G&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;newline&gt; X&lt;line terminator&gt; X&lt;eol&gt; X&lt;end of line&gt;
X&lt;\n&gt; X&lt;\r&gt; X&lt;\r\n&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003258Z" changeid="explorer">
        <seg>X&lt;newline&gt; X&lt;line terminator&gt; X&lt;eol&gt; X&lt;end of line&gt;
X&lt;\n&gt; X&lt;\r&gt; X&lt;\r\n&gt; X&lt;nueva línea&gt; X&lt;fin de línea&gt; X&lt;terminador de línea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	+ - .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	+ - .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most visible
difference is that, in Perl 5, parentheses are required around
the argument to C&lt;given()&gt; and C&lt;when()&gt; (except when this last
one is used as a statement modifier).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013525Z" changeid="explorer">
        <seg>La diferencia más visible es que, en Perl 5, los paréntesis son requeridos alrededor del argumento en C&lt;given()&gt; y C&lt;when()&gt; (excepto cuando éste último se usa como modificador de instrucciones)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that myname() functions as a list operator, not as a unary operator;
so be careful to use C&lt;or&gt; instead of C&lt;||&gt; in this case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que minombre() funciona como un operador de lista, no como un operador unario; cuidado al usar C&lt;or&gt; en vez de C&lt;||&gt; en este caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Einstein&quot; =&gt; &quot;Albert&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;Einstein&quot; =&gt; &quot;Albert&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{3,6}               matches between 3 and 6 of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230619Z" changeid="zipf">
        <seg>{3,6}               detecta entre 3 y 6 coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $value (LIST) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $valor (LISTA) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Along the same lines, just because you I&lt;CAN&gt; omit parentheses in many
places doesn't mean that you ought to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De la misma forma, sólo porque usted I&lt;PUEDA&gt; omitir paréntesis en muchos lugares no significa que deba hacerlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of
processes successfully signaled (which is not necessarily the
same as the number actually killed).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de procesos señalados exitosamente (que no es necesariamente el mismo número de los llamados).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perllocale		Perl locale support</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perllocale		Soporte de localización</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A warning
is emitted if the C&lt;use warnings&gt; pragma or the B&lt;-w&gt; command-line flag
(that is, the C&lt;$^W&gt; variable) was set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una advertencia es emitida si están activos el pragma C&lt;use warnings&gt; o la opción en línea de comandos B&lt;-w&gt; (es decir, la variable C&lt;$^W&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Exponentiation
X&lt;**&gt; X&lt;exponentiation&gt; X&lt;power&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234201Z" changeid="explorer">
        <seg>=head2 Exponenciación
X&lt;**&gt; X&lt;exponentiation&gt; X&lt;power&gt; X&lt;exponenciación&gt; X&lt;elevado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^=(\w+)/pod($1)/ge;	# use function call</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^=(\w+)/pod($1)/ge;           # usa una función de llamada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
unpack(), nybbles are converted to a string of hexadecimal digits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para unpack(), los nibles se convierten en una cadena de dígitos hexadecimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, it may
be a chain of identifiers, separated by C&lt;::&gt; (or by the slightly
archaic C&lt;'&gt;); all but the last are interpreted as names of packages,
to locate the namespace in which to look up the final identifier
(see L&lt;perlmod/Packages&gt; for details).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En ciertos casos, puede ser una serie de identificadores separados por C&lt;::&gt; (o por el ligeramente arcaico C&lt;'&gt;); donde todos los identificadores menos el último se interpretan como nombres de paquetes que determinan el espacio de nombres en el que se buscará el identificador final (véase L&lt;perlmod/Packages&gt; para obtener los detalles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this code:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, este código:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the last two digits of the year (e.g., '01' in 2001) do:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener los dos últimos dígitos del año (ej., '01' en 2001) hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If symbolic links are unimplemented on
your system, a normal C&lt;stat&gt; is done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los enlaces simbólicos no están implementados en su sistema, se hace un C&lt;stat&gt; normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item mkdir FILENAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item mkdir ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4 - either a real number, or a string that looks like a number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>4 - o un número real, o una cadena que se parezca a un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push(@a,$x,$y)      splice(@a,@a,0,$x,$y)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push(@a,$x,$y)      splice(@a,@a,0,$x,$y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare L&lt;/split&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compare con L&lt;/split&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is a language optimized for scanning arbitrary
text files, extracting information from those text files, and printing
reports based on that information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004016Z" changeid="explorer">
        <seg>Perl es un lenguaje optimizado para el escaneo de archivos de texto, extraer información de estos archivos de texto, e impresión de informes basados en esa información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When searching for the terminating line of a here-doc, nothing
is skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Durante la búsqueda de la línea de terminación de un documento incrustado, nada se omite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perluniintro	Perl Unicode introduction</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perluniintro	Introducción a Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%2\$*3\$d %d\n&quot;, 12, 34, 3;    # will print &quot; 34 12\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%2\$*3\$d %d\n&quot;, 12, 34, 3;    # imprimirá &quot; 34 12\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;JA&quot; | &quot;  ph\n&quot;;          	# prints &quot;japh\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;JA&quot; | &quot;  ph\n&quot;;          	# imprime &quot;japh\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = scalar(@b) || @c;	# really meant this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@a = scalar(@b) || @c;	# quiere realmente decir esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$off, $width, $bits, $val, $res</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$despl, $ancho, $bits, $val, $res</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If package name is omitted, the C&lt;main&gt;
package as assumed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el nombre del paquete se omite, se asume que es C&lt;main&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has a mechanism for intermixing documentation with source code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl tiene un mecanismo para entremezclar documentación y código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;number, literal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;number, literal&gt; X&lt;número, literal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The full list of these is in
L&lt;perlop/Quote and Quote-like Operators&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T184816Z" changeid="explorer">
        <seg>The full list of these is in
L&lt;perlop/Quote and Quote-like Operators&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 $^X doesn't always contain a full path in FreeBSD</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 $^X no siempre contiene el camino completo en FreeBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cd /boot/common/lib; ln -s perl5/5.12.3/BePC-haiku/CORE/libperl.so .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040351Z" changeid="explorer">
        <seg>cd /boot/common/lib; ln -s perl5/5.12.3/BePC-haiku/CORE/libperl.so .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is another step where the presence of the C&lt;//x&gt; modifier is
relevant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este es otro paso donde la presencia del modificador C&lt;//x&gt; es relevante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a regular expression match, i.e. C&lt;/REGEX/&gt; or C&lt;$foo =~ /REGEX/&gt;,
or a negated regular expression match (C&lt;!/REGEX/&gt; or C&lt;$foo !~ /REGEX/&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>una coincidencia con una expresión regular, es decir, C&lt;/REGEX/&gt; o C&lt;$foo =~ /REGEX/&gt;, o una negación de una coincidencia con una expresión regular (C&lt;!/REGEX/&gt; o C&lt;$foo !~ /REGEX/&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;string, literal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;string, literal&gt; X&lt;cadena, literal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to use long longs for the 64-bit integer type, in case you don't
have a 64-bit CPU.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002856Z" changeid="explorer">
        <seg>para usar enteros largos para los tipos enteros de 64 bit, en caso de que no tenga una CPU de 64 bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item split /PATTERN/,EXPR,LIMIT
X&lt;split&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201131Z" changeid="explorer">
        <seg>=item split /PATRÓN/,EXPR,LÍMITE
X&lt;split&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;last&gt; can be used to effect an early
exit out of such a block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, C&lt;last&gt; puede ser usado para salir prematuramente de este bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>u  A uuencoded string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>u  Una cadena codificada con uuencode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fcntl FILEHANDLE,FUNCTION,SCALAR
X&lt;fcntl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211428Z" changeid="explorer">
        <seg>=item fcntl GESTOR_ARCHIVO,FUNCIÓN,ESCALAR
X&lt;fcntl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators will assume a bit
vector operation is desired when both operands are strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos operadores asumirán una operación de vector de bits cuando ambos operandos sean cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#  0    1    2     3     4    5     6     7     8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#  0    1    2     3     4    5     6     7     8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this promotes action at a distance, this counterintuitive behavior
may be fixed in a future release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que provoca una acción extraña a gran distancia, este comportamiento no intuitivo puede ser arreglado en una futura distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, calling keys() in void context resets
the iterator with no other overhead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma particular, llamando a keys() en contexto nulo (void) resetea el iterador sin otro efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns
the number of characters replaced or deleted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de caracteres sustituidos o eliminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;undef&gt; is always treated as numeric, and in particular is changed
to C&lt;0&gt; before incrementing (so that a post-increment of an undef value
will return C&lt;0&gt; rather than C&lt;undef&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;undef&gt; es tratado siempre como numérico, y, en particular, es cambiado a C&lt;0&gt; antes de incrementar (de modo que un post-incremento de un valor undef devolverá C&lt;0&gt; en lugar de C&lt;undef&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my(@a) = splice(@_,0,shift);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my(@a) = splice(@_,0,shift);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax following the keyword
is defined entirely by the extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La sintasix que sigue al identificador se define enteramente por la expansión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| (gripe(), next LINE);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>|| (gripe(), next LINEA);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a scalar operator:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como operador escalar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; =&gt; &gt;&gt; operator is mostly just a more visually distinctive
synonym for a comma, but it also arranges for its left-hand operand to be
interpreted as a string if it's a bareword that would be a legal simple
identifier.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005302Z" changeid="explorer">
        <seg>El operador C&lt;&lt; =&gt; &gt;&gt; es más que nada un distintivo visual sinónimo de una coma, además de que también se encarga de que su operando de la izquierda sea interpretado como una cadena, si es un palabra suelta que pudiera ser un simple identificador legal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For ease of access, the Perl manual has been split up into several sections.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para facilitar el acceso, el manual de perl se ha dividido en varias secciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\l		lowercase next char (think vi)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\l		a minúscula sig. car. (como en vi)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$var = &quot;value&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$var = &quot;valor&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,22, 1) = 1   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,22, 1) = 1   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its rather blunt control of the
underlying algorithm may not persist into future Perls, but the
ability to characterize the input or output in implementation
independent ways quite probably will.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su contundente control del algoritmo subyacente quizás no persista en versiones futuras de Perl, pero la capacidad para caracterizar la entrada o salida en implementaciones independientes muy probablemente lo hará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, their results are interpreted as unsigned integers, but
if C&lt;use integer&gt; is in effect, their results are interpreted
as signed integers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma predeterminada, los resultados se interpretan como enteros sin signo, pero si C&lt;use integer&gt; está en efecto, sus resultados se interpretan como enteros con signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;use locale&gt; is in effect, the case map used by C&lt;\l&gt;, C&lt;\L&gt;,
C&lt;\u&gt; and C&lt;\U&gt; is taken from the current locale.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;use locale&gt; está en vigor, el mapeo de tamaños de caja usado por C&lt;\l&gt;, C&lt;\L&gt;, C&lt;\u&gt; y C&lt;\U&gt; es tomado de la localización actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right	! ~ \ and unary + and -</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053224Z" changeid="explorer">
        <seg>right	! ~ \ unarios + y -</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@b = (@a)[0,1];         # @b has no elements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@b = (@a)[0,1];         # @b no tiene elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An inner block may countermand this
by saying C&lt;no strict 'subs'&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un bloque interno puede revocar esto diciendo C&lt;no strict 'subs'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns C&lt;1&gt; on success, C&lt;0&gt;
otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve C&lt;1&gt; en caso de éxito; de otra manera, C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because you have to
read a file to do the C&lt;-T&gt; test, on most occasions you want to use a C&lt;-f&gt;
against the file first, as in C&lt;next unless -f $file &amp;&amp; -T $file&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que tiene que leer el archivo para hacer el test C&lt;-T&gt;, en la mayoría de las ocasiones querrá usar primero C&lt;-f&gt;, como en C&lt;next unless -f $archivo &amp;&amp; -T $archivo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item send SOCKET,MSG,FLAGS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item send SOCKET,MSG,FLAGS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, C&lt;&quot;span&quot; ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por otra parte, C&lt;&quot;span&quot; ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item send SOCKET,MSG,FLAGS,TO
X&lt;send&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200448Z" changeid="explorer">
        <seg>=item send SOCKET,MSG,FLAGS,TO
X&lt;send&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shutdown(SOCKET, 1);    # I/we have stopped writing data</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shutdown(SOCKET, 1);    # Hemos dejado de escribir datos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$atime = $mtime = time;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$atime = $mtime = time;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl
bug database at http://bugs.perl.org/.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted encuentra algo que piensa que es un error, podría verificar los artículos publicados recientemente en el grupo de noticias comp.lang.perl.misc y la base de datos de errores de perl en http://bugs.perl.org/.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;/etc/games is no good, stopped&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;/etc/games no está bien, parado&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl573delta	Perl changes in version 5.7.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl573delta	Cambios en la versión 5.7.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ones = (1) x 80;		# a list of 80 1's</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@unos = (1) x 80;		# una lista de 80 unos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$packed_ip = gethostbyname(&quot;www.perl.org&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$packed_ip = gethostbyname(&quot;www.perl.org&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a random fractional number greater than or equal to C&lt;0&gt; and less
than the value of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve un número decimal aleatorio mayor o igual a C&lt;0&gt; y menor que el valor de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is different from the C interfaces,
which return C&lt;-1&gt; on failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es diferente de las interfaces en C, que devuelven C&lt;-1&gt; en caso de fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any simple statement may optionally be followed by a I&lt;SINGLE&gt; modifier,
just before the terminating semicolon (or block ending).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013020Z" changeid="explorer">
        <seg>Cualquier instrucción simple puede ser seguida opcionalmente por un I&lt;ÚNICO&gt; modificador, justo antes del punto y coma final (o del final del bloque).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDERR &quot;This is your final warning.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235449Z" changeid="zipf">
        <seg>print STDERR &quot;Ésta es la última advertencia.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return *FH;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return *FH;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments can be embedded in a TEMPLATE using C&lt;#&gt; through the end of line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comentarios pueden ser integrados en una PLANTILLA usando C&lt;#&gt; hasta el final de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;feature&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015527Z" changeid="explorer">
        <seg>Ver L&lt;feature&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%e&gt;', 10;   # prints &quot;&lt;1.000000e+01&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%e&gt;', 10;   # imprime &quot;&lt;1.000000e+01&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If POSITION is specified, returns the
last occurrence beginning at or before that position.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sí POSICIÓN es especificada, devuelve la última ocurrencia comenzando en o antes de esta posición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So you
should use C&lt;defined&gt; only when questioning the integrity of what
you're trying to do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que puede usar C&lt;defined&gt; sólo cuando está cuestionando la integridad de lo que está intentando hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It didn't really fail to match anything.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No ha fallado al corresponder con cualquier cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$salida = `comando 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;use locale&gt; is in effect, C&lt;sort LIST&gt; sorts LIST according to the
current collation locale.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando C&lt;use locale&gt; esté activo, C&lt;sort LIST&gt; ordena LISTA de acuerdo con la actual configuración regional de intercalación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach my $file ( @goners ) {
         unlink $file or warn &quot;Could not unlink $file: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052353Z" changeid="explorer">
        <seg>foreach my $archivo ( @goners ) {
         unlink $archivo or warn &quot;No puedo borrar $archivo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example showing the behavior for boundary cases:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí un ejemplo que muestra el comportamiento para los casos límite:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Breaks the binding between a DBM file and a hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Rompe la ligadura entre un archivo DBM y un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8.5 23:59:59 GMT, Wednesday June 30th 2004</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5.8.5 23:59:59 GMT miércoles, 30 de junio 2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'31');  print $z2[$mday];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'31');  print $z2[$dmes];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The file is created with permissions of C&lt;0666&gt;
modified by the process's C&lt;umask&gt; value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El archivo se crea con permisos de C&lt;0666&gt; modificados por el valor de C&lt;umask&gt; del proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Character Classes and other Special Escapes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Clase carácter y otros escapados especiales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;delete local EXPR&gt; construct can also be used to localize the deletion
of array/hash elements to the current block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La construcción C&lt;delete local EXPR&gt; también se puede utilizar para localizar la supresión de elementos de un array o hash en el bloque actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$retval = ioctl(...) || -1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$retval = ioctl(...) || -1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;$_&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;$_&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns like C&lt;ioctl&gt;: the undefined value for error,
C&lt;&quot;0 but true&quot;&gt; for zero, or the actual return value otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve lo mismo que C&lt;ioctl&gt;: el valor indefinido para error, C&lt;&quot;0 but true&quot;&gt; para el cero, o el valor de retorno real, en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int( &lt;STDIN&gt; )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>int( &lt;STDIN&gt; )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl test suite may still report some errors on the Hurd.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El conjunto de test Perl seguirá informando de algunos errores sobre Hurd.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhack		Perl hackers guide</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlhack		Guía para hackers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open 'dbase.mine' for update: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir 'dbase.mine' para actualizar: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most text file processing
can be done a line at a time with Perl's looping constructs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225347Z" changeid="explorer">
        <seg>Gran parte de las tareas de procesamiento de archivos de texto se puede hacer de línea en línea con las estructuras de bucle de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item PodParser</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item PodParser</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It really does shift the @ARGV array and put the current filename
into the $ARGV variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Realmente, desplaza el array @ARGV y pone el nombre del archivo actual en la variable $ARGV.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function isn't all that useful for
cryptography (for that, look for F&lt;Crypt&gt; modules on your nearby CPAN
mirror) and the name &quot;crypt&quot; is a bit of a misnomer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función no es muy útil para criptografía (para esto, mire en los módulos F&lt;Crypt&gt; en su espejo CPAN más cercano) y el nombre &quot;crypt&quot; es un poco equívoco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because variable references always start with '$', '@', or '%', the
&quot;reserved&quot; words aren't in fact reserved with respect to variable
names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puesto que los nombres de variables siempre empiezan por '$', '@', o '%', las palabras &quot;reservadas&quot;, de hecho, no están reservadas con respecto a los nombres de variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the packed sockaddr address of this end of the SOCKET connection,
in case you don't know the address because you have several different
IPs that the connection might have come in on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la dirección de socket empaquetada de este final de la conexión SOCKET, en el caso de que no conozca la dirección porque tenga diferentes IP por las que la conexión se pudo haber realizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ne  inequality</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120440Z" changeid="zipf">
        <seg>ne  distinto que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%scientists =</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%cientificos =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp;  # avoid \n on last field</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170141Z" changeid="explorer">
        <seg>chomp;  # evitar \n en el último campo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a leading underscore to indicate that a variable or
function should not be used outside the package that defined it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar un guión bajo inicial para indicar que una variable o función no debe ser usado fuera del paquete que lo define.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Logical or, Defined or, and Exclusive Or
X&lt;operator, logical, or&gt; X&lt;operator, logical, xor&gt;
X&lt;operator, logical, defined or&gt; X&lt;operator, logical, exclusive or&gt;
X&lt;or&gt; X&lt;xor&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002241Z" changeid="explorer">
        <seg>=head2 Or, Defined y Or exclusivos lógicos
X&lt;operator, logical, or&gt; X&lt;operator, logical, xor&gt;
X&lt;operator, logical, defined or&gt; X&lt;operator, logical, exclusive or&gt;
X&lt;or&gt; X&lt;xor&gt; X&lt;operador, lógico, or&gt; X&lt;operador, lógico, xor&gt; X&lt;operador, lógico, or exclusivo&gt; X&lt;operador, lógico, definido&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the two-argument (and one-argument) form, one should
replace dash (C&lt;'-'&gt;) with the command.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la forma de dos argumentos (y un argumento), debe sustituir el guión (C&lt;'-'&gt;) con el comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>goto (&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>goto (&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has three built-in data types: scalars, arrays of scalars, and
associative arrays of scalars, known as &quot;hashes&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl tiene tres estructuras de datos incorporadas al lenguaje: Los escalares, los arrays de escalares, y los arrays asociativos de escalares, también conocidos como &quot;hashes&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for processes and process groups
X&lt;process&gt; X&lt;pid&gt; X&lt;process id&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201820Z" changeid="explorer">
        <seg>=item Funciones para procesos y grupos de procesos
X&lt;process&gt; X&lt;pid&gt; X&lt;process id&gt; X&lt;proceso&gt; X&lt;id proceso&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $out, &quot;&gt;&quot;,  &quot;output.txt&quot;) or die &quot;Can't open output.txt: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T031019Z" changeid="explorer">
        <seg>open(my $salida,   &quot;&gt;&quot;,  &quot;salida.txt&quot;)  or die &quot;No se puede abrir salida.txt: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is at the mercy of your machine's definitions of various
operations such as type casting, atof(), and floating-point
output with sprintf().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl está a merced de las definiciones de su máquina en diversas operaciones, como la conversión de tipos, atof(), y salida en punto flotante con sprintf ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
scalar context it reads a single line from the filehandle, and in list
context it reads the whole file in, assigning each line to an element of
the list:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225314Z" changeid="explorer">
        <seg>En contexto escalar, este operador lee una sola línea del identificador de archivo, mientras que en contexto de lista lee todo el archivo y asigna cada línea a un elemento de la lista:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pesto</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pisto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last LINE if /^$/;  # exit when done with header</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last LINE if /^$/;  # salir cuando se termine la cabecera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item stat FILEHANDLE
X&lt;stat&gt; X&lt;file, status&gt; X&lt;ctime&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201626Z" changeid="explorer">
        <seg>=item stat GESTOR_ARCHIVO
X&lt;stat&gt; X&lt;file, status&gt; X&lt;ctime&gt; X&lt;archivo, estado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 SEE ALSO</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T155609Z" changeid="zipf">
        <seg>=head1 VEA TAMBIÉN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will never match, as the C&lt;a++&gt; will gobble up all the C&lt;a&gt;'s in the
string and won't leave any for the remaining part of the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>nunca coincidirá, porque el C&lt;a++&gt; devorará todas las C&lt;a&gt; en la cadena y no dejará ninguna para el resto del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item vector flag</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item vector de banderas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item do EXPR
X&lt;do&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171438Z" changeid="explorer">
        <seg>=item do EXPR
X&lt;do&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;C&lt;&lt; -&gt; &gt;&gt;&quot; is an infix dereference operator, just as it is in C
and C++.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;C&lt;&lt; -&gt; &gt;&gt;&quot; es un operador infijo de desreferencia, tal como es en C y C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exchanging signed integers between different platforms works only 
when all platforms store them in the same format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intercambiando enteros con signo entre distintas plataformas funciona sólo cuando todas las plataformas los almacenan en el mismo formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>no integer;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no integer;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From each search string,
the rarest character is selected, based on some static frequency tables
constructed from some C programs and English text.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De cada cadena de búsqueda, se selecciona el carácter más raro, en función de algunas tablas de frecuencia estática construidas a partir de algunos programas en C y texto en Inglés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hash{get_a_key_for($_)} = $_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$hash{una_clave_para($_)} = $_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It refers to the pseudo file
formed from the files listed on the command line and accessed via the
C&lt;&lt; &lt;&gt; &gt;&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se refiere a un pseudo archivo formado por los archivos listados en la línea de comandos y accedidos vía el operador C&lt;&lt; &lt;&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldata - Perl data types</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldata - Perl data types</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value is unaffected by any forward
declarations of C&lt;&amp;func&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto no es afectado por ninguna declaración posterior de C&lt;&amp;func&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;strict&gt; is highly recommended.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es muy recomendable usar C&lt;strict&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>integer values _and_ if Perl has been compiled to support those.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>enteros de 64 bits __y__ si Perl ha sido compilado para soportarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be nice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sea amable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sysopen FILEHANDLE,FILENAME,MODE
X&lt;sysopen&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204130Z" changeid="explorer">
        <seg>=item sysopen GESTOR_ARCHIVO,ARCHIVO,MODO
X&lt;sysopen&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec { $args[0] } @args;  # safe even with one-arg list</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec { $args[0] } @args;  # seguro incluso con una lista de un argumento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step is listed for completeness only.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este paso está aquí descrito solo por completar la documentación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$i = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$i = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = ();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, string
concatenation happens at compile time between literals that don't do
variable substitution.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, concatenación de cadenas que sucede en tiempo de compilación entre literales que no hacen sustitución de variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Socket qw(IPPROTO_TCP TCP_NODELAY);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Socket qw(IPPROTO_TCP TCP_NODELAY);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$nums[$b] &lt;=&gt; $nums[$a]
            ||</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051440Z" changeid="explorer">
        <seg>$numeros[$b] &lt;=&gt; $numeros[$a]
            ||</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't know what to do with microperl
you probably shouldn't.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no sabe qué hacer con microperl probablemente no debería construirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,m}  Match at least n but not more than m times</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n,m}  Coincide al menos n veces, pero no más de m veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be sure to trim your bug down
to a tiny but sufficient test case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Asegúrese de reducir la aparición del error en un programa que sea pequeño, pero suficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry Wall &lt;larry@wall.org&gt;, with the help of oodles of other folks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Larry Wall &lt;larry@wall.org&gt;, con ayuda de montones de otras personas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also want to call srand() after a fork() to
avoid child processes sharing the same seed value as the parent (and
consequently each other).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201411Z" changeid="explorer">
        <seg>También puede llamar a srand() después de un fork() para evitar que los procesos hijos compartan la misma semilla de inicialización que con el padre (y por lo tanto entre sí).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No interpolation is performed at this stage.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se realiza interpolación en esta etapa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true on success,
otherwise it returns C&lt;undef&gt; and sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero en éxito; de lo contrario devuelve C&lt;undef&gt; y pone C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($a =~ /foo/) { ... }  # true if $a contains &quot;foo&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T212800Z" changeid="zipf">
        <seg>if ($a =~ /foo/) { ... }  # verdadero si $a contiene &quot;foo&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The
string specified with =~ must be a scalar variable, an array element, a
hash element, or an assignment to one of those, i.e., an lvalue.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203630Z" changeid="explorer">
        <seg>(La cadena especificada con C&lt;=~&gt; debe ser una variable escalar, un elemento de un array, un elemento de un hash, o una asignación a una de éstos, es decir, un I&lt;ivalor&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since C&lt;&lt; &lt;&gt; &gt;&gt; isn't explicitly opened,
as a normal filehandle is, an C&lt;eof()&gt; before C&lt;&lt; &lt;&gt; &gt;&gt; has been
used will cause C&lt;@ARGV&gt; to be examined to determine if input is
available.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como C&lt;&lt; &lt;&gt; &gt;&gt; no es explícitamente abierto, como lo sería un gestor de archivo, un C&lt;eof()&gt; antes de que un C&lt;&lt; &lt;&gt; &gt;&gt; sea usado, causará que C&lt;@ARGV&gt; sea examinado para determinar si la entrada está disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns a (possibly empty) list of filename expansions on
the value of EXPR such as the standard Unix shell F&lt;/bin/csh&gt; would do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contecto lista, devuelve una (posiblemente vacía) lista de la expansión de nombres de archivo del valor de EXPR como si el shell estandar Unix F&lt;/bin/csh&gt; lo hiciera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item grep BLOCK LIST
X&lt;grep&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173907Z" changeid="explorer">
        <seg>=item grep BLOQUE LISTA
X&lt;grep&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note
that the meanings don't change, just the &quot;greediness&quot;:
X&lt;metacharacter&gt; X&lt;greedy&gt; X&lt;greediness&gt;
X&lt;?&gt; X&lt;*?&gt; X&lt;+?&gt; X&lt;??&gt; X&lt;{n}?&gt; X&lt;{n,}?&gt; X&lt;{n,m}?&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuanta que los significador no cambian, solo la &quot;avaricia&quot;:
X&lt;metacarácter&gt; X&lt;codicia&gt; X&lt;avaricia&gt;
X&lt;?&gt; X&lt;*?&gt; X&lt;+?&gt; X&lt;??&gt; X&lt;{n}?&gt; X&lt;{n,}?&gt; X&lt;{n,m}?&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Between the C&lt;%&gt; and the format letter, you may specify several
additional attributes controlling the interpretation of the format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entre el C&lt;%&gt; y la letra de formato, puede especificar varios atributos adicionales controlando la interpretación del formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is free software; you can redistribute it and/or modify
it under the terms of either:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl es software libre, puede redistribuirlo y/o modificarlo bajo los términos de:</seg>
      </tuv>
    </tu>
  </body>
</tmx>
