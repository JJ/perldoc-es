<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.3.0"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>If things aren't broken, upgrading perl may break them (or at least issue
new warnings).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200714Z" changeid="explorer">
        <seg>Si todo funciona bien, la situación puede cambiar al actualizar perl (como mínimo pueden surgir nuevas advertencias).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( /^\D*(?!123)/ ) {                # Wrong!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170017Z" changeid="explorer">
        <seg>if ( /^\D*(?!123)/ ) {                # ¡Incorrecto!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example takes advantage that C&lt;NaN != NaN&gt; to
eliminate any C&lt;NaN&gt;s from the input list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el ejemplo siguiente se aprovecha de que C&lt;NaN != NaN&gt; para eliminar cualquier C&lt;NaN&gt; de la lista de entrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl58delta has been added: it is the perldelta of 5.8.0, detailing
the differences between 5.6.0 and 5.8.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011855Z" changeid="explorer">
        <seg>perl58delta ha sido añadido: es el perldelta de 5.8.0, detallando las diferencias entre 5.6.0 y 5.8.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the search for the end, backslashes that escape delimiters
are removed (exactly speaking, they are not copied to the safe location).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Durante la búsqueda del final, las barras invertidas que escapan delimitadores son eliminados (hablando más exactamente, no se copian al lugar seguro).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The integer formats C&lt;s&gt;, C&lt;S&gt;, C&lt;i&gt;, C&lt;I&gt;, C&lt;l&gt;, C&lt;L&gt;, C&lt;j&gt;, and C&lt;J&gt; are
inherently non-portable between processors and operating systems because
they obey native byteorder and endianness.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los formatos enteros C&lt;s&gt;, C&lt;S&gt;, C&lt;i&gt;, C&lt;I&gt;, C&lt;l&gt;, C&lt;L&gt;, C&lt;j&gt;, y C&lt;J&gt; inherentemente no portátiles entre procesadores y sistemas operativos porque siguen el orden nativo de los bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because Configure relies on:
1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102554Z" changeid="explorer">
        <seg>Esto se debe a que Configure se basa en: 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Modifiers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Modificadores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#[ \t]*(?![ \t])</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002946Z" changeid="explorer">
        <seg>#[ \t]*(?![ \t])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Increment the version number for every change, no matter how small</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014254Z" changeid="explorer">
        <seg>Incremente el número de versión para cada cambio, por pequeño que sea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item say LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item say LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T010845Z" changeid="explorer">
        <seg>&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T010643Z" changeid="explorer">
        <seg>#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlintern		Perl internal functions (autogenerated)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000528Z" changeid="explorer">
        <seg>perlintern		Funciones internas de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000444Z" changeid="explorer">
        <seg>$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000459Z" changeid="explorer">
        <seg>*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Vile</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item Vile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These special variables are used for all
kinds of purposes, and are documented in L&lt;perlvar&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224832Z" changeid="explorer">
        <seg>Estas variables especiales se usan para diversos fines y se describen en L&lt;perlvar&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-00027-1  [3rd edition July 2000]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003006Z" changeid="explorer">
        <seg>ISBN 978-0-596-00027-1  [3ª edición - Julio de 2000]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002221Z" changeid="explorer">
        <seg>1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Devel::Peek: display UTF-8 SVs also as \x{...}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devel::Peek: muestra SVs UTF-8 como \x{...}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004946Z" changeid="explorer">
        <seg>0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item quotemeta</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item quotemeta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232559Z" changeid="explorer">
        <seg>;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that lexical 
variables--those declared with C&lt;my&gt; or C&lt;state&gt;--will not work for this
purpose; so if you're using C&lt;my&gt; or C&lt;state&gt;, specify EXPR in your
call to open.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T001655Z" changeid="explorer">
        <seg>(Tenga en cuenta que las variables léxicas -las declaradas con C&lt;my&gt; o C&lt;state&gt;- no servirán para este propósito; así que si está usando C&lt;my&gt; o C&lt;state&gt;, especifique EXPR en su llamada a open.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%f    a floating-point number, in fixed decimal notation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%f    un número en punto flotante, en notación decimal fija</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>E</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;readline&gt; X&lt;&lt; &lt;&gt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;readline&gt; X&lt;&lt; &lt;&gt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl582delta	Perl changes in version 5.8.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl582delta	Cambios en la versión 5.8.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the platform
effectively becomes a Unicode platform, hence, for example, C&lt;\w&gt; will
match any of the more than 100_000 word characters in Unicode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T171740Z" changeid="explorer">
        <seg>Así, la plataforma se convierte efectivamente en una plataforma Unicode, y por lo tanto, por ejemplo, C&lt;\w&gt; coincidirá con cualquiera de los más de 100_000 caracteres en Unicode que pueden formar parte de una &quot;palabra&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these
cases, it probably pays not to trust whichever system rounding is
being used by Perl, but to instead implement the rounding function you
need yourself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estos casos, es mejor no confiar en el sistema de redondeo que está siendo utilizado por Perl, sino que en su lugar deba implementar la función de redondeo que necesite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/ExtUtils/t/basic.t         #26813</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T053454Z" changeid="explorer">
        <seg>lib/ExtUtils/t/basic.t         #26813</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Comma Operator
X&lt;comma&gt; X&lt;operator, comma&gt; X&lt;,&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001331Z" changeid="explorer">
        <seg>=head2 Operador coma
X&lt;comma&gt; X&lt;operator, comma&gt; X&lt;,&gt; X&lt;coma&gt; X&lt;operador, coma&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The comparison function is required to behave.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se requiere que la función de comparación se comporte de forma correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
addition, some of the modules shipped with Perl include C or XS code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014315Z" changeid="explorer">
        <seg>Además, algunos de los módulos distribuidos con Perl incluyen código C o XS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>^</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000342Z" changeid="explorer">
        <seg>^</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the user
interface is not fully stabilized yet, and it may change until the 5.10.0
release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142803Z" changeid="explorer">
        <seg>Tenga en cuenta que la interfaz de usuario no está totalmente estabilizada, y puede cambiar hasta la versión 5.10.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;We're really serious about reinventing everything that needs reinventing.&quot;
--Larry Wall</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230155Z" changeid="explorer">
        <seg>&quot;Cuando hablamos de reinventar todo lo que sea necesario, no lo decimos en broma.&quot;
--Larry Wall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Perl developer should be able to use modules to put together the
building blocks of their application.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014825Z" changeid="explorer">
        <seg>Un programador de Perl debe ser capaz de utilizar módulos para armar los bloques de construcción de su aplicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>b</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050118Z" changeid="explorer">
        <seg>b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>package other;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>package otro;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlepoc		Perl notes for EPOC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlepoc		Notas para EPOC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T221012Z" changeid="explorer">
        <seg>a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%*s&gt;&quot;, 6, &quot;a&quot;;   # prints &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014607Z" changeid="explorer">
        <seg>printf &quot;&lt;%*s&gt;&quot;, 6, &quot;a&quot;;   # imprime &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note I&lt;character&gt;, not byte.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T001718Z" changeid="explorer">
        <seg>(Note que es un I&lt;carácter&gt;, no un byte.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your input lines might end in backslashes to indicate continuation, you
want to skip ahead and get the next record.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si las líneas de entrada acaban en contra barras para indicar continuación, querrá saltarlo y obtener el siguiente registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/foo/bar/g;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234213Z" changeid="explorer">
        <seg>s/foo/bar/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(PASSWD, '/etc/passwd');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(PASSWD, '/etc/passwd');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T015402Z" changeid="explorer">
        <seg>}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000658Z" changeid="explorer">
        <seg>|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;aa0&quot; =~ /${b}0/;    # True</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191729Z" changeid="explorer">
        <seg>&quot;aa0&quot; =~ /${b}0/;    # Verdadero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qq/STRING/
X&lt;qq&gt; X&lt;quote, double&gt; X&lt;&quot;&gt; X&lt;&quot;&quot;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010140Z" changeid="explorer">
        <seg>=item qq/CADENA/
X&lt;qq&gt; X&lt;quote, double&gt; X&lt;&quot;&gt; X&lt;&quot;&quot;&gt; X&lt;comilla, doble&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exceptions to this rule include C&lt;wait&gt;,
C&lt;waitpid&gt;, and C&lt;syscall&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152104Z" changeid="explorer">
        <seg>Excepciones a esta regla incluyen a C&lt;wait&gt;, C&lt;waitpid&gt; y C&lt;syscall&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlstyle		Perl style guide</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000221Z" changeid="explorer">
        <seg>perlstyle		Guía de estilo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-e  File exists.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004612Z" changeid="explorer">
        <seg>-e  Archivo existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub set_vec {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225604Z" changeid="explorer">
        <seg>sub set_vec {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Matching in list context</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Coincidencia en contexto de lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to close FILEHANDLE if you are immediately going to do
another C&lt;open&gt; on it, because C&lt;open&gt; closes it for you.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005622Z" changeid="explorer">
        <seg>No tiene porqué cerrar el IDENTIFICADOR_ARCHIVO si inmediatamente va a hacer otro C&lt;open&gt; sobre él mismo, porque C&lt;open&gt; lo cierra por usted.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next if $x == $y;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next if $x == $y;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to
be portable, this behavior is not reflected by the Perl-level function
C&lt;getppid()&gt;, that returns a consistent value across threads.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ser portable, este comportamiento no está reflejado en la función  C&lt;getppid()&gt;, que devuelve un valor consistente a través de los hilos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used to force the
engine to backtrack.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T143709Z" changeid="explorer">
        <seg>Se puede utilizar para forzar al motor a que haga una vuelta atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;(condition)&gt; should be either an integer in
parentheses (which is valid if the corresponding pair of parentheses
matched), a look-ahead/look-behind/evaluate zero-width assertion, a
name in angle brackets or single quotes (which is valid if a group
with the given name matched), or the special symbol (R) (true when
evaluated inside of recursion or eval).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213144Z" changeid="explorer">
        <seg>C&lt;(condición)&gt; debe ser: un número entero entre paréntesis (que es válido si coincide con su correspondiente par de paréntesis); una aserción antecedente/consiguiente/evaluación de tamaño cero; un nombre entre ángulos o comillas simples (que es válido si el nombre coincide con un grupo con el mismo nombre), o el símbolo especial (R) (verdadero cuando es evaluado dentro de una recursión o eval).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This describes how to access the perl source using the I&lt;git&gt; version
control system.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152554Z" changeid="explorer">
        <seg>Describe cómo acceder al código fuente de perl con el sistema de control de versiones I&lt;git&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use integer constants provided by the C&lt;Socket&gt; module for
LEVEL and OPNAME.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilice constantes enteras proporcionadas por el módulo C&lt;Socket&gt; para NIVEL y OPCIÓN_NOMBRE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AV *(*resolve)(pTHX_ HV *stash, U32 level);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T113948Z" changeid="explorer">
        <seg>AV *(*resolve)(pTHX_ HV *stash, U32 level);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Equality Operators
X&lt;equality&gt; X&lt;equal&gt; X&lt;equals&gt; X&lt;operator, equality&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235041Z" changeid="explorer">
        <seg>=head2 Operadores de igualdad
X&lt;equality&gt; X&lt;equal&gt; X&lt;equals&gt; X&lt;operator, equality&gt; X&lt;igualdad&gt; X&lt;operador, igualdad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the
previous example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el ejemplo anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Separate functionality from output</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013540Z" changeid="explorer">
        <seg>Separe la funcionalidad de la salida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item The empty pattern //</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item El patrón vacío //</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;aa\x08&quot; =~ /${b}0/;  # False</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191759Z" changeid="explorer">
        <seg>&quot;aa\x08&quot; =~ /${b}0/;  # Falso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Time::Piece;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225522Z" changeid="explorer">
        <seg>use Time::Piece;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will uppercase &quot;bar&quot;, but the C&lt;/l&gt; does not affect how the C&lt;\U&gt;
operates.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T164042Z" changeid="explorer">
        <seg>pondrá en mayúsculas &quot;bar&quot;, pero la C&lt;/l&gt; no afecta a la forma en que C&lt;\U&gt; funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declare a picture format for use by the C&lt;write&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Declara una imagen de formato para usar con la función C&lt;write&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item snazzle($)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item snazzle($)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the C&lt;$REGMARK&gt; variable will be set to FALSE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T010209Z" changeid="explorer">
        <seg>Además, la variable C&lt;$REGMARK&gt;  se establecerá a FALSE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12 blocks   actual number of blocks allocated</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>12 blocks   número actual de bloques reservados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232610Z" changeid="explorer">
        <seg>Esta documentación es libre; puede redistribuirla o modificarla en los mismos términos que Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntax error indicates that the lexer couldn't find the final
delimiter of a C&lt;?PATTERN?&gt; construct.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051225Z" changeid="explorer">
        <seg>Este error de sintaxis indica que el analizador léxico no pudo encontrar el delimitador final de una construcción C&lt;?PATRÓN?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you just want to know how to use the utilities described here,
F&lt;pod2usage&gt; will just extract the &quot;USAGE&quot; section; some of
the utilities will automatically call F&lt;pod2usage&gt; on themselves when
you call them with C&lt;-help&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233428Z" changeid="explorer">
        <seg>Si sólo quiere saber cómo se usan las utilidades aquí descritas, F&lt;pod2usage&gt; solo extraerá la sección &quot;USAGE&quot; (USO); algunas de estas utilidades llamarán automáticamente a F&lt;pod2usage&gt; si las llama con el modificador C&lt;-help&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 2) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 2) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9, &quot;a&quot; ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224409Z" changeid="explorer">
        <seg>9, &quot;a&quot; ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The internal state of the random number generator should
contain more entropy than can be provided by any seed, so calling
C&lt;srand()&gt; again actually I&lt;loses&gt; randomness.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183453Z" changeid="explorer">
        <seg>El estado interno del generador de números aleatorios debería contener más entropía que la ofrecida por cualquier semilla, así que volver a llamar a srand() realmente hace I&lt;perder&gt; la aleatoriedad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># make divide-by-zero nonfatal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># hace la división-por-cero no fatal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the arguments C&lt;debug&gt;/C&lt;debugcolor&gt;
in the C&lt;use L&lt;re&gt;&gt; pragma, as well as Perl's B&lt;-Dr&gt; command-line
switch documented in L&lt;perlrun/&quot;Command Switches&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver los argumentos C&lt;debug&gt;/C&lt;debugcolor&gt; en el pragma C&lt;use L&lt;re&gt;&gt;, así como la opción en línea de comandos de Perl B&lt;-Dr&gt; documentado en L&lt;perlrun/&quot;Opciones de comando&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document will help you Configure, build, test and install Perl
on VM/ESA.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T064745Z" changeid="explorer">
        <seg>Este documento le ayudará a configurar, compilar, probar e instalar Perl en VM/ESA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might look around the net for a pre-built binary of Perl (or a
C compiler!) that meets your needs, though:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225826Z" changeid="explorer">
        <seg>También puede buscar en Internet un binario precompilado de Perl (o un compilador de C) adecuado para sus necesidades:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># you don't have to use the default $_ either...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002742Z" changeid="zipf">
        <seg># tampoco tiene que usar la variable $_ predeterminada...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>package Bar;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>package Bar;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| warn &quot;couldn't touch $file: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>|| warn &quot;no puedo tocar $archivo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if a regular
expression is interpolated into a larger one, the original's rules
continue to apply to it, and only it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163841Z" changeid="explorer">
        <seg>Y si una expresión regular se interpola en una más grande, las normas originales siguen siendo aplicables a ella, y solo a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this is a wide-open interface, pragmas (compiler directives)
are also implemented this way.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que esta es una interfaz ampliamente abierta, pragmas (directivas del compilador), también son implementadas de esta manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Symbolic Unary Operators
X&lt;unary operator&gt; X&lt;operator, unary&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234225Z" changeid="explorer">
        <seg>=head2 Operadores unarios simbólicos
X&lt;unary operator&gt; X&lt;operator, unary&gt; X&lt;operador unario&gt; X&lt;operador, unario&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($_ = &lt;STDIN&gt;) ne '0') { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (($_ = &lt;STDIN&gt;) ne '0') { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;$*&gt; variable controlling multi-line matching has been deprecated
and will be removed after 5.8.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011533Z" changeid="explorer">
        <seg>La variable C&lt;$*&gt; que controla la coincidencia multi-línea ha sido desaprobada y será eliminada después de 5.8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise it matches any character but C&lt;\n&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, equivale a cualquier carácter, excepto C&lt;\n&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hello</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050147Z" changeid="explorer">
        <seg>hola</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is omitted, chops C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE se omite, recorta C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First character is at
offset C&lt;0&gt; (or whatever you've set C&lt;$[&gt; to (but B&lt;&lt;don't do that&gt;)).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015439Z" changeid="explorer">
        <seg>El primer carácter está en la posición C&lt;0&gt; (o lo que sea que haya configurado en C&lt;$[&gt; (pero B&lt;no lo haga&gt;)).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can modify @ARGV before the first &lt;&gt; as long as the array ends up
containing the list of filenames you really want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede modificar @ARGV antes del primer &lt;&gt; siempre que el array termine conteniendo la lista de nombres de archivos que realmente quiere.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#idx ];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>$#idx ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Older programs did this by setting C&lt;$*&gt;,
but this option was removed in perl 5.9.)
X&lt;^&gt; X&lt;$&gt; X&lt;/m&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T000708Z" changeid="explorer">
        <seg>(Antiguos programas hacían esto estableciendo C&lt;$*&gt;, pero esta opción ha sido eliminada en perl 5.9.)
X&lt;^&gt; X&lt;$&gt; X&lt;/m&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not use this function for rounding: one because it truncates
towards C&lt;0&gt;, and two because machine representations of floating-point
numbers can sometimes produce counterintuitive results.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No debe usar esta función para redondear: primero, porque trunca hacia C&lt;0&gt; y segundo, porque las representaciones máquina de números en punto flotante puede producir, algunas veces, resultados dispares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @new = sort {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @nuevo = sort {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 128 == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 128 == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its major
features are that it's easy to use, supports both procedural and
object-oriented (OO) programming, has powerful built-in support for text
processing, and has one of the world's most impressive collections of
third-party modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T213715Z" changeid="explorer">
        <seg>Se caracteriza principalmente por su facilidad de uso (permite programar tanto de manera procedural como orientada a objetos (OO)), su magnífica capacidad integrada para procesamiento de texto y por tener una de las colecciones de módulos de terceros más impresionantes del mundo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># didn't</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># no hacer nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run
into resistance, figure out what those people get out of the other
choice and how Perl might satisfy that requirement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232445Z" changeid="explorer">
        <seg>Si le oponen resistencia, averigüe qué necesitan y hágales ver en qué medida Perl podría cubrir sus necesidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(3,4,3);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>set_vec(3,4,3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This used to be the preferred way to
pass arrays and hashes by reference into a function, but now that
we have real references, this is seldom needed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005333Z" changeid="explorer">
        <seg>Esta es la forma preferida para pasar arrays y hashes por referencia, a una función, pero como ahora tenemos referencias de verdad, esto es raramente necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (@keys) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (@claves) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LOCK_SH
requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN
releases a previously requested lock.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LOCK_SH solicita un bloqueo compartido, LOCK_EX solicita un bloqueo exclusivo y LOCK_UN devuelve un bloqueo solicitado previamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose wisely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elija con cuidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for representing
Unicode strings, and for comparing version &quot;numbers&quot; using the string
comparison operators, C&lt;cmp&gt;, C&lt;gt&gt;, C&lt;lt&gt; etc.  If there are two or
more dots in the literal, the leading C&lt;v&gt; may be omitted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para la representación de cadenas Unicode, y para comparar la versión &quot;en números&quot; que utilizan los operadores de comparación de cadenas, C&lt;cmp&gt;, C&lt;gt&gt;, C&lt;lt&gt;, etc. Si hay dos o más puntos en el literal, el prefijo C&lt;v&gt; puede omitirse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar values are always named with '$', even when referring to a
scalar that is part of an array or a hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores escalares se nombran siempre con '$', incluso cuando se accede a un escalar que es parte de un array o un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mode you specify should match the mode of the original filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020632Z" changeid="explorer">
        <seg>El modo que especifique debe coincidir con el modo del identificador de archivo original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.6 and earlier used a quicksort algorithm to implement sort.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl v5.6 y anteriores usaban un algoritmo quicksort para implementar sort.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-B  File is a &quot;binary&quot; file (opposite of -T).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-B  archivo es un archivo &quot;binario&quot; (opuesto de -T).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Irix 6.2 with perl threads, you have to have the following
patches installed:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T012315Z" changeid="explorer">
        <seg>En Irix 6.2 con hilos perl, tiene que tener los siguientes parches instalados:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated to version 1.77</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052656Z" changeid="explorer">
        <seg>Actualizado a la versión 1.77</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Running Perl programs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T000713Z" changeid="zipf">
        <seg>=head2 Ejecución de programas Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlinterp&gt; for more details on the files that make up the Perl
interpreter, as well as details on how it works.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014324Z" changeid="explorer">
        <seg>En L&lt;perlinterp&gt; encontrará más información sobre los archivos que integran el intérprete de Perl y detalles sobre el funcionamiento del intérprete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our($bar, $baz);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>our($bar, $baz);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Slices</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Porciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the delimiter is C&lt;/&gt;, one cannot get
the combination C&lt;\/&gt; into the result of this step.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el delimitador es C&lt;/&gt;, no se puede obtener la combinación C&lt;\/&gt; en el resultado de este paso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item s/PATTERN/REPLACEMENT/msixpodualgcer
X&lt;substitute&gt; X&lt;substitution&gt; X&lt;replace&gt; X&lt;regexp, replace&gt;
X&lt;regexp, substitute&gt; X&lt;/m&gt; X&lt;/s&gt; X&lt;/i&gt; X&lt;/x&gt; X&lt;/p&gt; X&lt;/o&gt; X&lt;/g&gt; X&lt;/c&gt; X&lt;/e&gt; X&lt;/r&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T212417Z" changeid="explorer">
        <seg>=item s/PATRÓN/REEMPLAZO/msixpodualgcer
X&lt;substitute&gt; X&lt;substitution&gt; X&lt;replace&gt; X&lt;regexp, replace&gt;
X&lt;regexp, substitute&gt; X&lt;/m&gt; X&lt;/s&gt; X&lt;/i&gt; X&lt;/x&gt; X&lt;/p&gt; X&lt;/o&gt; X&lt;/g&gt; X&lt;/c&gt; X&lt;/e&gt; X&lt;/r&gt;
X&lt;sustitución&gt; X&lt;reemplazo&gt; X&lt;regexp, reemplazo&gt; X&lt;reemplazo, sustitución&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most generic form possible is usually a
Perl data structure which can then be used to generate a text report,
HTML, XML, a database query, or whatever else your users require.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020755Z" changeid="explorer">
        <seg>La forma más genérica posible, es por lo general una estructura de datos Perl, que puede ser utilizado para generar un informe de texto, HTML, XML, una consulta de base de datos o cualquier otra cosa que necesiten los usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
obtained perl isn't binary compatible with a regular perl 5.9.4, and has
space and speed penalties; moreover not all regression tests still pass
with it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005207Z" changeid="explorer">
        <seg>El perl obtenido no es compatible a nivel binario con una versión normal de perl 5.9.4, y tiene problemas de espacio y velocidad; además, todavía no pasa todas las pruebas de regresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For various reasons C&lt;\K&gt; may be significantly more efficient than the
equivalent C&lt;&lt; (?&lt;=...) &gt;&gt; construct, and it is especially useful in
situations where you want to efficiently remove something following
something else in a string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212533Z" changeid="explorer">
        <seg>Por diversas razones C&lt;\K&gt; puede ser significativamente más eficiente que la construcción equivalente C&lt;&lt; (?&lt;=...) &gt;&gt;, y esto es especialmente útil en situaciones donde usted quiere, eficientemente, quitar algo que siga a otra cosa, dentro de una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The four C&lt;filter_*&gt; methods shown above are available in all the DBM
modules that ship with Perl, namely DB_File, GDBM_File, NDBM_File,
ODBM_File and SDBM_File.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110812T144919Z" changeid="zipf">
        <seg>Los cuatro métodos C&lt;filter_*&gt; mostrados arriba están disponibles en todos los módulos DBM incluidos en Perl: DB_File, GDBM_File, NDBM_File,
ODBM_File y SDBM_File.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sleep;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sleep;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying an assignment is equivalent to doing the assignment and
then modifying the variable that was assigned to.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Modificando una asignación es equivalente a realizar la asignación y luego modificando la variable que le fue asignada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($folks[0], $folks[-1]) = ($folks[-1], $folks[0]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($gente[0], $gente[-1]) = ($gente[-1], $gente[0]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$shell = '/bin/csh';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$shell = '/bin/csh';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it
returns the empty string, use C&lt;getpwuid&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si devuelve la cadena vacía, utilice C&lt;getpwuid&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Perl has never guaranteed any ordering of the hash keys&gt;, and the
ordering has already changed several times during the lifetime of
Perl 5.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135223Z" changeid="explorer">
        <seg>B&lt;Perl nunca ha garantizado ningún tipo de ordenación de las claves de un hash&gt;, y esa ordenación ya ha cambiado varias veces a lo largo de la vida útil de Perl 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C3.8E.C2.B1.C3.8F.C2.89</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003624Z" changeid="explorer">
        <seg>C3.8E.C2.B1.C3.8F.C2.89</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Regular Expressions Cookbook&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003518Z" changeid="explorer">
        <seg>=item I&lt;Regular Expressions Cookbook&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics of C&lt;use feature :5.10*&gt; have changed slightly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T185247Z" changeid="explorer">
        <seg>La semántica de C&lt;use feature :5.10*&gt; ha cambiado ligeramente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The binary operators C&lt;+&gt; C&lt;-&gt; C&lt;*&gt; C&lt;/&gt; C&lt;%&gt; C&lt;==&gt; C&lt;!=&gt; C&lt;E&lt;gt&gt;&gt; C&lt;E&lt;lt&gt;&gt;
C&lt;E&lt;gt&gt;=&gt; C&lt;E&lt;lt&gt;=&gt; and the unary operators C&lt;-&gt; C&lt;abs&gt; and C&lt;--&gt; will
attempt to convert arguments to integers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T233852Z" changeid="explorer">
        <seg>Los operadores binarios C&lt;+&gt; C&lt;-&gt; C&lt;*&gt; C&lt;/&gt; C&lt;%&gt; C&lt;==&gt; C&lt;!=&gt; C&lt;E&lt;gt&gt;&gt; C&lt;E&lt;lt&gt;&gt; C&lt;E&lt;gt&gt;=&gt; y C&lt;E&lt;lt&gt;=&gt;, y los operadores unarios C&lt;abs&gt; y C&lt;--&gt;, intentan convertir los argumentos en enteros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bugs in OS/2 sockets and tmpfile have been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Errores corregidos en sockets en OS/2 y tmpfile.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>document that use utf8 is not the right way most of the time</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>documentar que el uso de UTF-8 no es la manera correcta en la mayoría de las ocasiones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4: got ABC</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170358Z" changeid="explorer">
        <seg>2: tenemos ABC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If multiple parentheses have
the same name, then it recurses to the leftmost.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T191833Z" changeid="explorer">
        <seg>Si múltiples paréntesis tienen el mismo nombre, entonces re-ejecuta el que esté más a la izquierda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Test: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt;
              $str,     $%,    '$' . int($num)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050028Z" changeid="explorer">
        <seg>Test: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt;
              $str,     $%,    '$' . int($num)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timeout, if specified, is
in seconds, which may be fractional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El tiempo de espera, si se especifica, en segundos, puede ser decimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Braces are safer when creating a regex by
concatenating smaller strings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T164950Z" changeid="explorer">
        <seg>Las llaves son más seguras al crear una expresión regular mediante la concatenación de cadenas más pequeñas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -e &quot;print &quot;&quot;Hello world\n&quot;&quot;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225505Z" changeid="explorer">
        <seg>perl -e &quot;print &quot;&quot;Hello world\n&quot;&quot;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>alias fmt=&quot;perl -i -MText::Autoformat -n0777 \</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225534Z" changeid="explorer">
        <seg>alias fmt=&quot;perl -i -MText::Autoformat -n0777 \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, &quot;echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;pod2usage|pod2usage&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233418Z" changeid="explorer">
        <seg>=item L&lt;pod2usage|pod2usage&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Look-behind matches text up to the current match position,
look-ahead matches text following the current match position.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T204449Z" changeid="explorer">
        <seg>Lo antecedente (I&lt;Look-behind&gt;) coincide con texto hasta la actual posición de coincidencia, lo consiguiente (I&lt;look-ahead&gt;) coincide con texto que sigue a la actual posición de coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;next&gt; will exit such a block early.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto C&lt;next&gt; saldrá del primer bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond that, you have to consider several things and decide which is best
for you.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200649Z" changeid="explorer">
        <seg>Si desea usar otras versiones, para decidir cuál es la que más le conviene debe tener en cuenta varias cosas, como las siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.8.0 forgot to add
some deprecation warnings, these warnings have now been added.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T010350Z" changeid="explorer">
        <seg>Perl 5.8.0 olvidó añadir algunas advertencias de desaprobación, estas advertencias han sido ahora añadidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsyn		Perl syntax</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000252Z" changeid="explorer">
        <seg>perlsyn		Sintaxis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation fix</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Arreglo en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code such as</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110307Z" changeid="explorer">
        <seg>Código como este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can also have C&lt;Content-Length&gt; to indicate the
number of I&lt;bytes&gt;, which is always a good idea to supply if the number is
known.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235358Z" changeid="explorer">
        <seg>También se puede utilizar C&lt;Content-Length&gt; para indicar el número de I&lt;bytes&gt;, un dato que siempre viene bien conocer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative to the above, you may prefer to throw exceptions using 
the Error module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023555Z" changeid="explorer">
        <seg>Como alternativa a lo anterior, es posible que prefiera lanzar excepciones utilizando el módulo Error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For full details
see the file F&lt;README.win32&gt;, particularly if you're running Win95.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215134Z" changeid="explorer">
        <seg>Para más detalles vea el archivo F&lt;README.win32&gt;, sobre todo si está ejecutando Win95.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of
C&lt;open&gt; with more than three arguments for non-pipe modes is not yet
defined, but experimental &quot;layers&quot; may give extra LIST arguments
meaning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El significado de C&lt;open&gt; con más de tres argumentos para modos no entubados aún no está definido, pero &quot;capas&quot; experimentales puede dar significados adicionales a la LISTA de argumentos adicionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;Writing Perl Modules for CPAN&gt;: http://www.apress.com/resource/freeebook/9781590590188</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003709Z" changeid="explorer">
        <seg>I&lt;Writing Perl Modules for CPAN&gt;: http://www.apress.com/resource/freeebook/9781590590188</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Experimental Support for Sun Studio Compilers for Linux OS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Soporte Experimental para compiladores Sun Studio para sistemas operativos Linux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The character after the question mark indicates
the extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El carácter situado detrás del signo de interrogación indica la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map {  &quot;\L$_&quot; =&gt; 1  } @array  # perl guesses EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map {  &quot;\L$_&quot; =&gt; 1  } @array  # perl lee mal la EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cd /
chmod +t /tmp (=set the sticky bit to /tmp).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040230Z" changeid="explorer">
        <seg>cd /
chmod +t /tmp (=pone el sticky bit a /tmp).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to release a 'beta' or 'alpha' version of a module but
don't want CPAN.pm to list it as most recent use an '_' after the
regular version number followed by at least 2 digits, eg.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025629Z" changeid="explorer">
        <seg>Si desea liberar una versión 'beta' o 'alfa' de un módulo, pero no quiere que CPAN.pm lo liste, use un '_' después del número de versión normal seguido por al menos dos dígitos, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REFERENCES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>REFERENCIAS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are typically followed
by a repeat count like C&lt;B8&gt; or C&lt;B64&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T002522Z" changeid="explorer">
        <seg>Estos suelen ser seguidos por un número de repetición, como C&lt;B8&gt; o C&lt;B64&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this means that Perl is now more &quot;correct&quot;, it is
possible that some existing code will break that happens to rely on
the faulty behaviour.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010449Z" changeid="explorer">
        <seg>Aunque esto significa que Perl es más &quot;correcto&quot;, es posible que algún código existente se rompa, por confiar en el comportamiento defectuoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar for
two matches for C&lt;T&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235641Z" changeid="explorer">
        <seg>Similar para las dos coincidencias de C&lt;T&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push $AoA[0], &quot;wilma&quot;, &quot;betty&quot;;        # implicit deref</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030539Z" changeid="explorer">
        <seg>push $AoA[0], &quot;wilma&quot;, &quot;betty&quot;;        # desreferencia implícita</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$now_string = strftime &quot;%a %b %e %H:%M:%S %Y&quot;, gmtime;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ahora = strftime &quot;%a %b %e %H:%M:%S %Y&quot;, gmtime;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either way, the implementation isn't going to generate results
larger than the size of the integer type Perl was built with (32 bits
or 64 bits).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De cualquier manera, la aplicación no va a generar resultados más grandes que el tamaño del tipo entero con el que Perl fue construido (32 o 64 bits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;tr/$oldlist/$newlist/&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;tr/$viejalista/$nuevalista/&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no C&lt;(*MARK)&gt; of that name was
encountered, then the C&lt;(*SKIP)&gt; operator has no effect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T011536Z" changeid="explorer">
        <seg>Si no se encontró ningún C&lt;(*MARK)&gt;, entonces el operador C&lt;(*SKIP)&gt; no tiene ningún efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;prefix_pattern&gt; has now been complemented by a new configuration
option C&lt;long_prefix_pattern&gt; that allows the user to specify what
prefix patterns should have long option style semantics applied.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032539Z" changeid="explorer">
        <seg>C&lt;prefix_pattern&gt; ha sido complementado por una nueva opción de configuración, C&lt;long_prefix_pattern&gt;, que permite al usuario especificar qué patrones de prefijo deben tener aplicado un estilo semántico para opciones largas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &quot;input line number&quot; (also
known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to
be currently in effect, and is also available as the special variable
C&lt;$.&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que el &quot;número de línea de entrada&quot; (también conocido como &quot;chunk&quot; -tarugo-) está sujeto a cualquier noción de &quot;línea&quot; que sea efectiva en ese momento, y también está disponible en la variable especial C&lt;$.&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldos		Perl notes for DOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldos		Notas para DOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An inner BLOCK may countermand this by saying</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un BLOQUE interno puede revocar esto diciendo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ( ! eof($fh) ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050731Z" changeid="explorer">
        <seg>while ( ! eof($fh) ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Filter::Simple&gt; upgraded to version 0.82</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032159Z" changeid="explorer">
        <seg>C&lt;Filter::Simple&gt; actualizado a la versión 0.82</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mark Kettenis &lt;kettenis@gnu.org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mark Kettenis &lt;kettenis@gnu.org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Open Perl IDE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>=item Open Perl IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @lines = &lt;$in&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T003557Z" changeid="zipf">
        <seg>my @lineas = &lt;$entrada&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think about reusability.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Piense en la reutilización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or two.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very useful for
providing default values for variables.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T184915Z" changeid="explorer">
        <seg>Esto es muy útil para proporcionar valores por defecto a las variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of elements in the array following
the completed C&lt;push&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de elementos en el ARRAY tras la llamada a C&lt;push&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Zero-length matches at the end of the previous match are ignored
during C&lt;split&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T233336Z" changeid="explorer">
        <seg>Coincidencias de longitud cero al final de la coincidencia anterior son ignoradas durante C&lt;split&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type of arg 1 to push must be array (not array element) at /tmp/a line 8, near &quot;&quot;betty&quot;;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031617Z" changeid="explorer">
        <seg>Type of arg 1 to push must be array (not array element) at /tmp/a line 8, near &quot;&quot;betty&quot;;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fork</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item fork</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space around a &quot;complex&quot; subscript (inside brackets).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio alrededor de un subíndice &quot;complejo&quot; (entre corchetes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (R&amp;NAME)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195446Z" changeid="explorer">
        <seg>=item (R&amp;NOMBRE)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl - The Perl 5 language interpreter</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T140831Z" changeid="explorer">
        <seg>perl - El intérprete del lenguaje Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lcfirst</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item lcfirst</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $log $logmessage;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T225647Z" changeid="zipf">
        <seg>print $registro $mensaje_registro;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;autodie&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005427Z" changeid="explorer">
        <seg>=item C&lt;autodie&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Will cause C&lt;$sentence&gt; to become C&lt;'The big bad wolf jumped over...'&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012602Z" changeid="explorer">
        <seg>Hará que C&lt;$instruccion&gt; se convierta en C&lt;'El gran lobo malo saltó sobre ...'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that the globbing is actually done internally using the standard
C&lt;File::Glob&gt; extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>salvo que la expansión realmente se hace internamente usando la extensión estándar C&lt;File::Glob&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL
X&lt;socketpair&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200826Z" changeid="explorer">
        <seg>=item socketpair SOCKET1,SOCKET2,DOMINIO,TIPO,PROTOCOLO
X&lt;socketpair&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, you can write:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, puede escribir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = '150' | '105';	# yields string '155' (under ASCII)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = '150' | '105';	# produce la cadena '155' (bajo ASCII)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lock() is a &quot;weak keyword&quot; : this means that if you've defined a function
by this name (before any calls to it), that function will be called
instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lock() es una &quot;palabra clave débil&quot;: significa que si usted ha definido una función con este nombre (antes de cualquier llamada a ella), esa función es la que se llamará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may combine several flags
using the C&lt;|&gt;-operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede combinar varias banderas con el operador C&lt;|&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $foo   = decode('UTF-8', get 'http://example.com/');</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235147Z" changeid="explorer">
        <seg>my $foo   = decode('UTF-8', get 'http://ejemplo.com/');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 16  ==         16 00001000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 16  ==         16 00001000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can test the right operand and become false on the
same evaluation it became true (as in B&lt;awk&gt;), but it still returns
true once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador rango puede probar el operando de la derecha y convertirse en falso en la misma evaluación en que se hizo verdadero (como en B&lt;awk&gt;), pero aún así devuelve verdadero al menos una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the referenced object has been blessed into a package, then that package
name is returned instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el objeto referenciado ha sido bendecido en un paquete, entonces es el nombre de este paquete el que es devuelto en su lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $x (1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $x (1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Unix standard Perl location, F&lt;/usr/bin/perl&gt;, is no longer
overwritten by default if it exists.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T181119Z" changeid="explorer">
        <seg>La ubicación estándar de Perl en Unix, F&lt;/usr/bin/perl&gt;, ya no es, por defecto, sobreescrita, si existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With EXPR, it returns some extra information that the debugger uses to
print a stack trace.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con EXPR, devuelve alguna información extra que el depurador usa para imprimir un rastreo de la pila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On ASCII platforms, the native rules are ASCII, and on EBCDIC platforms
(at least the ones that Perl handles), they are Latin-1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001037Z" changeid="explorer">
        <seg>En plataformas ASCII, las reglas nativas son ASCII, y en plataformas EBCDIC (por lo menos las que Perl maneja), son Latin-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But wait, there's more...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001130Z" changeid="explorer">
        <seg>Pero esto no es todo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/exp&gt; for the inverse operation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215406Z" changeid="explorer">
        <seg>Vea también L&lt;/exp&gt; para la operación inversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>INNER:   for my $jet (@ary2) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>INTERNO:   for my $jet (@ary2) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates BLOCK or EXPR in
list context, so each element of LIST may produce zero, one, or
more elements in the returned value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa BLOQUE o EXPR en contexto lista, de manera que cada elemento de la LISTA puede producir cero, uno o más elementos en el valor devuelto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Support C&lt;[2,-3pi/8]&gt; in C&lt;emake&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033341Z" changeid="explorer">
        <seg>Soporte de C&lt;[2,-3pi/8]&gt; en C&lt;emake&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>logger(&quot;We have a logger subroutine!&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T233913Z" changeid="zipf">
        <seg>registrador(&quot;Tenemos una subrutina para registrar.&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 ino      inode number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 ino      número de inodo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not a natural number&quot; unless /^\d+$/;             # rejects -3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es número natural&quot; unless /^\d+$/;             # rechaza -3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case you are wondering about 5.6.1, it was bug-fix-wise rather
identical to the development release 5.7.1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005551Z" changeid="explorer">
        <seg>En caso de que usted se está preguntando sobre 5.6.1, fue una corrección de errores, idéntica a la versión de desarrollo 5.7.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be careful not to follow the print keyword with a left
parenthesis unless you want the corresponding right parenthesis to
terminate the arguments to the print; put parentheses around all arguments
(or interpose a C&lt;+&gt;, but that doesn't look as good).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T010046Z" changeid="explorer">
        <seg>Tenga cuidado de no seguir la palabra clave print con un paréntesis de apertura a menos que desee que el correspondiente paréntesis de cierre ponga fin a los argumentos de la impresión; ponga paréntesis alrededor de todos los argumentos (o interponga un C&lt;+&gt;, pero esto no parece tan bonito).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to send the scalar MSG to the SOCKET
filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012418Z" changeid="explorer">
        <seg>Intenta enviar el escalar MSG al identificador de archivo SOCKET.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Perl Template Toolkit&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003603Z" changeid="explorer">
        <seg>=item I&lt;Perl Template Toolkit&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a workaround for this problem, Perl 5.10.0 introduces C&lt;${^PREMATCH}&gt;,
C&lt;${^MATCH}&gt; and C&lt;${^POSTMATCH}&gt;, which are equivalent to C&lt;$`&gt;, C&lt;$&amp;&gt;
and C&lt;$'&gt;, B&lt;except&gt; that they are only guaranteed to be defined after a
successful match that was executed with the C&lt;/p&gt; (preserve) modifier.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como solución a este problema, Perl Perl 5.10.0 introduce C&lt;${^PREMATCH}&gt;, C&lt;${^MATCH}&gt; y C&lt;${^POSTMATCH}&gt;, que son equivalentes a C&lt;$`&gt;, C&lt;$&amp;&gt; y C&lt;$'&gt;, B&lt;excepto&gt; que solo se tiene garantizado que estarán definidos después de una coincidencia exitosa, ejecutada con un modificador C&lt;/p&gt; (preserva).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of C&lt;goto-LABEL&gt; or C&lt;goto-EXPR&gt; to jump into a construct is
deprecated and will issue a warning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de C&lt;goto-LABEL&gt; o C&lt;goto-EXPR&gt; para saltar en una construcción es obsoleto y emitirá una advertencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decimal strings may have an exponential notation part, as in C&lt;&quot;12.34e-56&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232436Z" changeid="explorer">
        <seg>Las cadenas decimales pueden tener una parte en notación exponencial (por ejemplo, C&lt;&quot;12.34e-56&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using gcc, just</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002920Z" changeid="explorer">
        <seg>Si está empleando gcc, entonces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(To view the differences between the 5.6.0 release and the 5.7.0
release, see L&lt;perl570delta&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215105Z" changeid="explorer">
        <seg>(Para ver las diferencias entre la versión 5.6.0 y la versión 5.7.0, vea L&lt;perl570delta&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perllol		Perl data structures: arrays of arrays</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perllol		Estructuras de datos: arrays de arrays</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options are as described in C&lt;qr//&gt; above; in addition, the following match
process modifiers are available:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T232811Z" changeid="explorer">
        <seg>Las opciones son como se describe anteriormente en C&lt;qr//&gt;; además, los siguientes modificadores de coincidencia están disponibles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 2) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 2) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dereference-address operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operador de Desreferencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Encode</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Encode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sends a message on a socket.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Envía un mensaje sobre un socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Vim</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\W                  a non-word character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230259Z" changeid="zipf">
        <seg>\W                  un carácter que no sea de palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %h = (&quot;something&quot;, 23);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my %h = (&quot;algo&quot;, 23);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A statement sequence may contain declarations of lexically-scoped
variables, but apart from declaring a variable name, the declaration acts
like an ordinary statement, and is elaborated within the sequence of
statements as if it were an ordinary statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012842Z" changeid="explorer">
        <seg>Una secuencia de instrucciones pueden contener declaraciones de variables en ámbito léxico (privado), pero, aparte de declarar un nombre de variable, la declaración actúa como una instrucción normal y es elaborada dentro de la secuencia de instrucciones como si fuera una instrucción normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$^ = 'report2_top';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$^ = 'informe2_top';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; Capitalized&quot;),  redo LOOP if /\G\p{Lu}\p{Ll}+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030052Z" changeid="explorer">
        <seg>print(&quot; Capitalizado&quot;), redo LOOP if /\G\p{Lu}\p{Ll}+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This warning has been removed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005806Z" changeid="explorer">
        <seg>Esta advertencia ha sido eliminada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl only supports single-byte locales.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T165241Z" changeid="explorer">
        <seg>Perl sólo soporta reglas regionales de bytes simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Problem with partial characters and C&lt;&lt; encoding(utf-8-strict) &gt;&gt; fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031004Z" changeid="explorer">
        <seg>Arreglado un problema con caracteres no completos y C&lt;&lt; encoding(utf-8-strict) &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the syntax descriptions that follow, list operators that expect a
list (and provide list context for elements of the list) are shown
with LIST as an argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En las descripciones sintácticas que siguen a continuación, los operadores de listas que esperan una lista (y proveen de un contexto lista para los elementos de la lista) se muestran con un argumento así: LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of the beginner-level books, too, go over basic features and
techniques that are still valid today.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003828Z" changeid="explorer">
        <seg>Muchos de los libros para principiantes describen características y técnicas básicas que mantienen su vigencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is assumed that you already
know the difference between bytes and characters, and realise (and accept!)
that there are many different character sets and encodings, and that your
program has to be explicit about them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T233603Z" changeid="explorer">
        <seg>Se supone que ya conoce la diferencia entre bytes y caracteres, y comprende (y acepta) que hay muchos juegos de caracteres y codificaciones distintos, que debe utilizar explícitamente en su programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can always include optional parameters or routines for 
more complex or non-standard behaviour.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021200Z" changeid="explorer">
        <seg>Siempre puede incluir parámetros opcionales o rutinas para un comportamiento más complejo o no estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
&quot;lib/anydbm&quot; and &quot;pragma/warnings&quot; tests will almost certainly fail.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020022Z" changeid="explorer">
        <seg>Es muy probable que no se superen las pruebas &quot;lib/anydbm&quot; y &quot;pragma/warnings&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item strict</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item strict</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.12.3 represents approximately four months of development since
Perl 5.12.2 and contains approximately 2500 lines of changes across
54 files from 16 authors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T231109Z" changeid="explorer">
        <seg>Perl 5.12.3 representa aproximadamente cuatro meses de desarrollo desde Perl 5.12.2 y contiene aproximadamente 2500 líneas de cambios en 54 archivos de 16 autores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = (1)[1,0];          # @a has two elements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@a = (1)[1,0];          # @a tiene dos elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial Haiku port was done by Ingo Weinhold &lt;ingo_weinhold@gmx.de&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La primera adaptación de Haiku fue realizada por Ingo Weinhold &lt;ingo_weinhold@gmx.de&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># extract hours, minutes, seconds</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113515Z" changeid="explorer">
        <seg># extraer horas, minutos, segundos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;bless&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;package&gt;, C&lt;ref&gt;, C&lt;tie&gt;, C&lt;tied&gt;,
C&lt;untie&gt;, C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202058Z" changeid="explorer">
        <seg>C&lt;bless&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;package&gt;, C&lt;ref&gt;, C&lt;tie&gt;, C&lt;tied&gt;,
C&lt;untie&gt;, C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$^O&gt; could sometimes become tainted.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031903Z" changeid="explorer">
        <seg>C&lt;$^O&gt; podría estar, algunas veces, pringada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The debugger now traces correctly execution in eval(&quot;&quot;)uated code that
contains #line directives.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045753Z" changeid="explorer">
        <seg>El depurador, ahora, sigue la traza correctamente en la ejecución de código eval(&quot;&quot;)uado que contenga directivas #line.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>char   c;    /* one signed, 8-bit character */</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>char   c;    /* uno con signo, carácter 8-bit */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hex strings may only represent integers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Strings hexadecimales sólo pueden representar enteros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Could not determine the protocol number for tcp&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo determinar el número de protocolo para tcp&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but that makes no difference compared with the -Duse64bitint because
of the C&lt;cc -64&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002712Z" changeid="explorer">
        <seg>pero no genera diferencias comparado con -Duse64bitint debido al C&lt;cc -64&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl ':mode';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl ':mode';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;@INC&gt; is also printed as
part of the output of</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225920Z" changeid="explorer">
        <seg>C&lt;@INC&gt; también se imprime en pantalla como parte de la salida de </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An explicit format parameter index, such as C&lt;2$&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un explícito índice de parámetros de formato, tales como C&lt;2$&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%HASH = ();     # completely empty %HASH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%HASH = ();     # vaciar completamente %HASH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in the example above, a bare C&lt;l&gt; means
exactly 32 bits, although the native C&lt;long&gt; as seen by the local C compiler
may be larger.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como se muestra en el ejemplo anterior, una simple C&lt;l&gt; significa exactamente 32 bits, aunque el C&lt;long&gt; nativo, tal como lo ve el compilador de C local, puede ser mayor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're not on a Unix system, access to the documentation
will be different; for example, documentation might only be in HTML format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230248Z" changeid="explorer">
        <seg>Si no utiliza un sistema Unix, el acceso a la documentación será distinto; por ejemplo, la documentación puede estar disponible en formato HTML únicamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list C&lt;1,,3&gt; is a
concatenation of two lists, C&lt;1,&gt; and C&lt;3&gt;, the first of which ends
with that optional comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La lista C&lt;1,,3&gt; es una concatenación de dos listas, C&lt;1,&gt; y C&lt;3&gt;, la primera de las cuales termina con una coma opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.linux - Perl version 5 on Linux systems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.linux - Perl versión 5 sobre sistemas Linux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item caller EXPR
X&lt;caller&gt; X&lt;call stack&gt; X&lt;stack&gt; X&lt;stack trace&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165937Z" changeid="explorer">
        <seg>=item caller EXPR
X&lt;caller&gt; X&lt;call stack&gt; X&lt;stack&gt; X&lt;stack trace&gt; X&lt;llamador&gt; X&lt;pila de llamdas&gt; X&lt;pila&gt; X&lt;traza de pila&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rindex STR,SUBSTR,POSITION
X&lt;rindex&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194751Z" changeid="explorer">
        <seg>=item rindex CADENA,SUBCADENA,POSICIÓN
X&lt;rindex&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>uses C&lt;$a&gt; for the width, C&lt;$b&gt; for the precision, and C&lt;$c&gt;
as the value to format; while:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>usa C&lt;$a&gt; para el ancho, C&lt;$b&gt; para la precisión, y C&lt;$c&gt; como el valor a formatear; mientras:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(errno) properly
when there were errors in the underlying call.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001228Z" changeid="explorer">
        <seg>(errno) correctamente cuando se han producido errores en la llamada subyacente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some people get too used to writing things like:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T224735Z" changeid="explorer">
        <seg>Algunas personas están demasiado acostumbradas a escribir cosas como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq2 - Obtaining and Learning about Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225307Z" changeid="explorer">
        <seg>perlfaq2 - Cómo obtener Perl y dónde buscar información sobre Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, C&lt;\c\I&lt;X&gt;&gt; yields C&lt; chr(28) . &quot;I&lt;X&gt;&quot;&gt; for any I&lt;X&gt;, but cannot come at the
end of a string, because the backslash would be parsed as escaping the end
quote.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204907Z" changeid="explorer">
        <seg>Además, C&lt;\c\I&lt;X&gt;&gt; es igual a C&lt; chr(28) . &quot;I&lt;X&gt;&quot;&gt; para cualquier I&lt;X&gt;, pero no puede estar al final de una cadena, porque la contrabarra se interpretaría como que se estaría escapando la comilla final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,16, 1) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,16, 1) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$array[1] = &lt;STDIN&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225547Z" changeid="explorer">
        <seg>$array[1] = &lt;STDIN&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and the C&lt;S_IF*&gt; functions are</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y las funciones C&lt;S_IF*&gt; son</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, each call reads and
returns the next line until end-of-file is reached, whereupon the
subsequent call returns C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, cada llamada lee y devuelve la siguiente línea hasta que se alcance el final del archivo, en cuyo caso la ulterior llamada devuelve C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/Time: (..):(..):(..)/) {   # parse out values</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/Tiempo: (..):(..):(..)/) {   # extrae valores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>WRITE this, scalar, length, offset</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>WRITE este, escalar, longitud, desplazamiento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 No-ops
X&lt;no-op&gt; X&lt;nop&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011026Z" changeid="explorer">
        <seg>=head2 No-operaciones
X&lt;no-op&gt; X&lt;nop&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It operates on
C&lt;$_&gt; by default, or can be bound to another variable using the C&lt;=~&gt;
binding operator (also documented in L&lt;perlop&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225413Z" changeid="explorer">
        <seg>Opera en C&lt;$_&gt; de manera predeterminada, o se puede enlazar a otra variable con el operador de enlace C&lt;=~&gt; (que también se describe en L&lt;perlop&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the owner (and group) of a list of files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia el propietario (y grupo) de una lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for a seed can fall prey to the mathematical property that</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014957Z" changeid="explorer">
        <seg>pero la semilla puede caer presa en la propiedad matemática</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ARTICLE = 100;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ARTICULO = 100;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 DATE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 FECHA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item OpenVMS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015403Z" changeid="explorer">
        <seg>=item OpenVMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of Perl 5.10.0, one can create custom regular expression engines.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001123Z" changeid="explorer">
        <seg>A partir de Perl 5.10.0, uno puede crear sus propios motores de expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL foreach VAR (LIST) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA foreach VAR (LIST) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following items are now deprecated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235619Z" changeid="explorer">
        <seg>Los siguientes artículos son ahora obsoletos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; gt &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; gt &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once those changes
are applied and released, the new version of the module will be incorporated
into the core.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014506Z" changeid="explorer">
        <seg>Cuando se hayan aplicado y publicado estos cambios, la nueva versión del módulo se incorporará al núcleo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include such functions as C&lt;time&gt;
and C&lt;endpwent&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas incluyen funciones como C&lt;time&gt; y C&lt;endpwent&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because
C&lt;*HANDLE{IO}&gt; only works if HANDLE has already been used as a handle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015935Z" changeid="explorer">
        <seg>Esto es porque C&lt;*HANDLE{IO}&gt; sólo funciona si HANDLE ya se ha utilizado como un identificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$fh = *STDOUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$fh = *STDOUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FH, &quot;&gt;&gt;&amp;=&quot;, OLDFH)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FH, &quot;&gt;&gt;&amp;=&quot;, OLDFH)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;C&lt;rand()&gt; is not cryptographically secure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T180944Z" changeid="explorer">
        <seg>B&lt;C&lt;rand()&gt; no es criptográficamente seguro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As this behavior is currently considered a bug,
compatible behavior may be re-introduced in a future release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T005154Z" changeid="explorer">
        <seg>Ya que este comportamiento se considera actualmente un error, un comportamiento compatible puede ser re-introducido en una futura versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Pod::Html&gt; upgraded to version 1.0504</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034144Z" changeid="explorer">
        <seg>C&lt;Pod::Html&gt; actualizado a la versión 1.0504</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pragma allows you to lexically disable or enable overloading
for some or all operations.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T194317Z" changeid="explorer">
        <seg>Este pragma le permite desactivar o activar localmente la sobrecarga de algunas o todas las operaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for an example of how to use the &quot;eval exec&quot; trick to ask the shell to
have perl run your scripts for you.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T111909Z" changeid="explorer">
        <seg>para ver un ejemplo de cómo utilizar el truco del &quot;eval exec&quot; para hacer que el shell ejecute por usted los scripts perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then give &quot;make&quot; to compile.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Luego ejecute &quot;make&quot; para compilar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, exits with C&lt;0&gt; status.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es omitida, sale con estado C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>++$q while $idx[$p-1] &gt; $idx[$q];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>++$q while $idx[$p-1] &gt; $idx[$q];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/Memoize/t/array................ok</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214823Z" changeid="explorer">
        <seg>lib/Memoize/t/array................ok</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, there is a distinction between omitting LIST (C&lt;import&gt; called
with no arguments) and an explicit empty LIST C&lt;()&gt; (C&lt;import&gt; not
called).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una vez más, hay una distinción entre omitir LISTA (C&lt;import&gt; llamado sin argumentos) y una explícita LISTA vacía C&lt;()&gt; (C&lt;import&gt; no se llama).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use only these specific hex 
characters with this format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T002809Z" changeid="explorer">
        <seg>Utilice sólo estos caracteres hexadecimales con este formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With or without parentheses, an empty list is returned upon
failure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001941Z" changeid="explorer">
        <seg>Con o sin paréntesis, se devuelve una lista vacía en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 64  ==      16384 00000000000000100000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 64  ==      16384 00000000000000100000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlvos		Perl notes for Stratus VOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlvos		Notas para Stratus VOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time it goes all the way until the next occurrence
of &quot;foo&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T151909Z" changeid="explorer">
        <seg>Esta vez hace todo el camino hasta la siguiente ocurrencia de &quot;come&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some systems may have even weirder byte orders such as</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos sistemas pueden tener ordenaciones de byte aún más raras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form is typically used to
delay parsing and subsequent execution of the text of EXPR until run time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma es típicamente usada para retrasar el interpretado subsecuente ejecución del texto de EXPR hasta el momento de la ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property, known as &quot;magic open&quot;,
can often be used to good effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta propiedad, conocida como &quot;open() mágico&quot;, a menudo se puede utilizar con buenos resultados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($user,$system,$cuser,$csystem) = times;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($usuario,$sistema,$husuario,$hsistema) = times;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $z = substr $s, 14, 7, &quot;jumped from&quot;;    # climbed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $z = substr $s, 14, 5, &quot;saltó desde&quot;;    # subió</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $ALL = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $TODO = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a &quot;real&quot; C C&lt;open&gt; (see C&lt;open(2)&gt; on your system), then you
should use the C&lt;sysopen&gt; function, which involves no such magic (but may
use subtly different filemodes than Perl open(), which is mapped to C
fopen()).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235743Z" changeid="explorer">
        <seg>Si busca un &quot;auténtico&quot; C&lt;open&gt; como en C (ver C&lt;open(2)&gt; en su sistema), entonces debe usar la función C&lt;sysopen&gt;, que no incluye ninguna magia (pero puede utilizar, sutilmente, diferentes modos de archivo que el open() de Perl, que es asignado a la función del C fopen()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the address
of the sender if SOCKET's protocol supports this; returns an empty
string otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la dirección del remitente si el protocolo del SOCKET lo soporta; de otra manera, devuelve una cadena vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result C&lt;Regexp&gt; indicates that the argument is a regular expression
resulting from C&lt;qr//&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resultado C&lt;Regexp&gt; indica que el argumento es una expresión regular como resultado de C&lt;qr//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print uc(scalar(&amp;foo,$bar)),$baz;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print uc(scalar(&amp;foo,$bar)),$baz;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example uses the operator form of
C&lt;readline&gt; and dies if the result is not defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el ejemplo siguiente se utiliza la forma del operador de C&lt;readline&gt; y muere si el resultado no está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment to C&lt;$^R&gt; above is properly localized, so the old
value of C&lt;$^R&gt; is restored if the assertion is backtracked; compare
L&lt;&quot;Backtracking&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T222309Z" changeid="explorer">
        <seg>La asignación a C&lt;$^R&gt; anterior está apropiadamente localizada, por lo que el valor anterior de C&lt;$^R&gt; es restaurado si la aserción es retrotraída; ver
L&lt;&quot;Retrotraer&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the C&lt;a&gt;, C&lt;d&gt;, C&lt;l&gt;, C&lt;p&gt;, and C&lt;u&gt; modifiers are special in
that they can only be enabled, not disabled, and the C&lt;a&gt;, C&lt;d&gt;, C&lt;l&gt;, and
C&lt;u&gt; modifiers are mutually exclusive: specifying one de-specifies the
others, and a maximum of one (or two C&lt;a&gt;'s) may appear in the
construct.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T193803Z" changeid="explorer">
        <seg>Note que los modificadores C&lt;a&gt;, C&lt;d&gt;, C&lt;l&gt;, C&lt;p&gt;, y C&lt;u&gt; son especiales, en el sentido en que solo pueden ser activados, no desactivados, y los modificadores C&lt;a&gt;, C&lt;d&gt;, C&lt;l&gt;, y C&lt;u&gt; son mutuamente excluyentes: especificando uno de ellos de-especifica a los otros, y un máximo de uno (o dos C&lt;a&gt;) pueden aparecer en la construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C source code and header files mostly live in the root of the source
tree.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014308Z" changeid="explorer">
        <seg>La mayor parte del código C y los archivos de encabezado se encuentran en el directorio raíz del árbol de código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--prefix=/boot/home/config</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>--prefix=/boot/home/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The handling of authors' names that had apostrophes has been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041748Z" changeid="explorer">
        <seg>El manejo de los nombres de los autores que tenían apóstrofes se ha solucionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Break out of a C&lt;given()&gt; block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sale de un bloque C&lt;given()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>P  A pointer to a structure (fixed-length string).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>P  Un puntero a una estructura (una cadena de longitud fija).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In much better shape than it used to be.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031000Z" changeid="explorer">
        <seg>En una forma mucho mejor de lo que solía ser.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A negative OFFSET specifies
placement at that many characters counting backwards from the end of
the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DESPLAZAMIENTO negativo especifica el desplazamiento en número de caracteres contando desde el final de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The null filehandle &lt;&gt; is special: it can be used to emulate the
behavior of B&lt;sed&gt; and B&lt;awk&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014127Z" changeid="explorer">
        <seg>El identificador de archivo nulo &lt;&gt; es especial: puede ser utilizado para emular el comportamiento de B&lt;sed&gt; y B&lt;awk&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In perl 5.12.x and earlier, because the regex engine was not re-entrant,
delayed code could not safely invoke the regex engine either directly with
C&lt;m//&gt; or C&lt;s///&gt;), or indirectly with functions such as C&lt;split&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T202250Z" changeid="explorer">
        <seg>En perl 5.12.x y anteriores, debido a que el motor regex es, actualmente, no re-entrante, el código interpolado no podrá invocar de forma segura el motor regex, tanto directamente con C&lt;m//&gt; o C&lt;s///&gt;, o indirectamente con funciones, como C&lt;split&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:-)
If I were you, I'd put that in a function:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200348Z" changeid="explorer">
        <seg>:-)
Si yo fuera usted, lo pondría en una función:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If some particular order is really
important, use tied hashes: for example the Tie::IxHash module
which by default preserves the order in which the hash elements
were added.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135658Z" changeid="explorer">
        <seg>Si un determinado orden es muy importante, utilice hashes enlazados: por ejemplo, el módulo Tie::IxHash, que por defecto preserva el orden en que los elementos de un hash han sido añadidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since C&lt;system&gt; does a C&lt;fork&gt; and C&lt;wait&gt; it may affect a C&lt;SIGCHLD&gt;
handler.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204458Z" changeid="explorer">
        <seg>Debido a que C&lt;system&gt; hace un C&lt;fork&gt; y un C&lt;wait&gt; puede afectar al controlador C&lt;SIGCHLD&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Following a C&lt;&lt; &lt;&lt; &gt;&gt; you specify a string to terminate
the quoted material, and all lines following the current line down to
the terminating string are the value of the item.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siguiendo a C&lt;&lt; &lt;&lt; &gt;&gt; especifica una cadena que termine el material entrecomillado, y todas las líneas siguientes a la actual hacia abajo hasta la cadena de terminación, son el valor del elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is being ported to Symbian OS.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T033916Z" changeid="explorer">
        <seg>Perl ha sido portado a Symbian OS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ord &quot;\N{omega}&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224654Z" changeid="explorer">
        <seg>ord &quot;\N{omega}&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bits = unpack(&quot;b*&quot;, $vector);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bits = unpack(&quot;b*&quot;, $vector);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't call a class method or an ordinary function on a class that
has been collected that way.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T140120Z" changeid="explorer">
        <seg>No puede llamar a un método de clase o a una función ordinaria en una clase que se haya destruido de esa manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because there
are so many different ways to split a long string into several
substrings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T214137Z" changeid="explorer">
        <seg>Eso es porque hay tantas maneras diferentes de dividir una larga cadena en varias subcadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?=(b))            # zero-width assertion</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231837Z" changeid="explorer">
        <seg>(?=(b))            # aserción de ancho cero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pipe READHANDLE,WRITEHANDLE
X&lt;pipe&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192555Z" changeid="explorer">
        <seg>=item pipe CONTROLADOR_LECTURA,CONTROLADOR_ESCRITURA
X&lt;pipe&gt; X&lt;tubería&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read all about it (and other special variables) in
L&lt;perlvar&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224942Z" changeid="explorer">
        <seg>Encontrará información sobre este hash (y sobre otras variables especiales) en L&lt;perlvar&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>WinCE: integrate the port</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>WinCE: integrar su versión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One level of double-quote interpretation is done first, but you can't
say C&lt;&lt; &lt;$foo&gt; &gt;&gt; because that's an indirect filehandle as explained
in the previous paragraph.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014523Z" changeid="explorer">
        <seg>Se hace en primer lugar una interpretación por comilla doble, pero no puede escribir C&lt;&lt; &lt;$foo&gt; &gt;&gt; porque eso es un identificador de archivo indirecto, como se ha explicado en el párrafo anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL until (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA until (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$gid   = getgrnam($name);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$gid   = getgrnam($name);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;re/&quot;'/flags' mode&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T192845Z" changeid="explorer">
        <seg>Vea L&lt;re/&quot;modo '/banderas'&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;sysopen&gt; depends on the fdopen() C library function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que C&lt;sysopen&gt; depende de la función de biblioteca C fdopen().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't really want to execute the first argument, but want to lie
to the program you are executing about its own name, you can specify
the program you actually want to run as an &quot;indirect object&quot; (without a
comma) in front of the LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si realmente no quiere ejecutar el primer argumento, pero quiere engañar al programa que está ejecutando sobre su propio nombre, puede especificar el programa que quiera ejecutar como un &quot;objeto indirecto&quot; (sin la coma) enfrente de la LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For integer conversions, specifying a precision implies that the
output of the number itself should be zero-padded to this width,
where the 0 flag is ignored:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las conversiones de entero, especificando una precisión implica que la salida del número en sí mismo debería ser rellenado con ceros a este ancho, donde se pasa por alto a la bandera 0:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note
that the use of these six specific operators to verify if some operation
is possible is usually a mistake, because it may be open to race
conditions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que el uso de seis operadores específicos para verificar si cierta operación es posible, es usualmente una equivocación, porque puede ser el inicio de bloqueos de carrera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A comment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If used in list context, returns all the rest of the entries in the
directory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se usa en contexto de lista, devuelve el resto de las entradas en el directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item bless REF,CLASSNAME
X&lt;bless&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165811Z" changeid="explorer">
        <seg>=item bless REF,NOMBRECLASE
X&lt;bless&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use diagnostics;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use diagnostics;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
buckets will be retained even if you do C&lt;%hash = ()&gt;, use C&lt;undef
%hash&gt; if you want to free the storage while C&lt;%hash&gt; is still in scope.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos alojamientos serán mantenidos incluso si hace C&lt;%hash = ()&gt;. Use C&lt;undef %hash&gt; si quiere liberar el almacenamiento mientras mantiene a C&lt;%hash&gt; en el ámbito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implements C&lt;dl_unload_file&gt; on Win32</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030649Z" changeid="explorer">
        <seg>Implementa C&lt;dl_unload_file&gt; en Win32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;UNIVERSAL&gt; class has a new method, C&lt;DOES()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T000802Z" changeid="explorer">
        <seg>La clase C&lt;UNIVERSAL&gt; tiene un nuevo método, C&lt;DOES()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned earlier, Perl can store a number in any one of three formats,
but most operators typically understand only one of those formats.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232630Z" changeid="explorer">
        <seg>Como se mencionó antes, Perl puede almacenar un número en uno de tres formatos distintos, pero la mayoría de los operadores suelen admitir solo uno de esos formatos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The table of smart matches is not identical to that proposed by the
Perl 6 specification, mainly due to the differences between Perl 6's
and Perl 5's data models.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La tabla de coincidencias inteligentes no es idéntica a la propuesta por la especificación Perl 6, principalmente debido a las diferencias entre los modelos de datos entre Perl 6 y Perl 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\        Quote the next metacharacter</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042505Z" changeid="explorer">
        <seg>\	Escapa al siguiente metacarácter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item no MODULE VERSION LIST
X&lt;no declarations&gt;
X&lt;unimporting&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item no MÓDULO VERSIÓN LISTA
X&lt;no declarations&gt; X&lt;unimporting&gt; X&lt;declaraciones no&gt; X&lt;desimportando&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to print the whole thing, though, you can't
say</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193242Z" changeid="explorer">
        <seg>Si desea imprimir toda el conjunto, sin embargo, no se puede decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded newlines
will not be matched by &quot;^&quot; or &quot;$&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los caracteres de nueva línea incrustados dentro de la cadena no coincidirán con &quot;^&quot; o &quot;$&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>55607.2961226851</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>55607.2961226851</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%-10.6d&gt;', 1;   # prints &quot;&lt;000001    &gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%-10.6d&gt;', 1;   # imprime &quot;&lt;000001    &gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item AIX</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005634Z" changeid="explorer">
        <seg>=item AIX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One or more modifiers below may optionally follow certain letters in the
TEMPLATE (the second column lists letters for which the modifier is valid):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Uno o más de los modificadores siguientes pueden, opcionalmente, seguir a ciertas letras en la PLANTILLA (la segunda columna enumeran las letras para las cuales el modificador es válido):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For future releases our goal is to
make PerlIO go even faster.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014149Z" changeid="explorer">
        <seg>Para futuras versiones nuestro objetivo es hacer que PerlIO vaya aún más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is what C has that Perl doesn't:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es lo que C tiene que Perl no:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Tied hashes in scalar context</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031656Z" changeid="explorer">
        <seg>=head2 Hashes enlazados en contexto escalar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:unique&gt; attribute has been made a no-op, since its current
implementation was fundamentally flawed and not threadsafe.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192448Z" changeid="explorer">
        <seg>El atributo C&lt;:unique&gt; se ha convertido en una no-operación, debido a que su implementación era, fundamentalmente, defectuosa y no multi-hilo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this is useful and supported,
it can cause bizarre results if the elements of LIST are not variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras que esto suele ser útil, puede causar resultados extraños si los elementos de la LISTA no son variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;local&gt; to localize changes to them to a specific scope if necessary.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T010721Z" changeid="explorer">
        <seg>Use C&lt;local&gt; para fijar cambios en ellas en un determinado ámbito, si fuera necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;This element is $_\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234902Z" changeid="zipf">
        <seg>print &quot;Este elemento es $_\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@AoA = (</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@AoA = (</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GNU make for VM/ESA, which may be required for the build of perl,
is available from:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101627Z" changeid="explorer">
        <seg>GNU make para VM/ESA, que puede ser requerido para la compilación de perl, está disponible desde:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,}        Match at least n times</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042659Z" changeid="explorer">
        <seg>{n,}	Coincide al menos n veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 4) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 4) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a failed C&lt;m//gc&gt; match doesn't reset the offset, the return
from C&lt;pos&gt; won't change either in this case.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T180424Z" changeid="explorer">
        <seg>Debido a que una coincidencia C&lt;m//gc&gt; fallida no reinicia el desplazamiento, el retorno de C&lt;pos&gt; no cambiará en ningún caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item utf8</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014857Z" changeid="explorer">
        <seg>=item utf8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now
network socket support should remain enabled on BONE systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora, el soporte para red debe permanecer habilitado en los sistemas BONE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4-column indent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sangrado a 4 columnas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Socket qw(:all);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Socket qw(:all);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ( condition ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234837Z" changeid="zipf">
        <seg>while ( condición ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This calls the select(2) syscall with the bit masks specified, which
can be constructed using C&lt;fileno&gt; and C&lt;vec&gt;, along these lines:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto llama a la función del sistema select(2) con las máscaras de bits especificadas, que pueden ser construidas usando C&lt;fileno&gt; y C&lt;vec&gt;, como muestran estas líneas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Num       numeric equality         $a == $b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  Número     igualdad numérica                $a == $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if the context of the currently executing subroutine or
C&lt;eval&gt; is looking for a list value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si el contexto de ejecución de la subrutina actual o C&lt;eval&gt; está buscando por una lista de valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But it's better just to put the C&lt;1;&gt;, in case you add more
statements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012100Z" changeid="explorer">
        <seg>Pero es mejor sólo para poner C&lt;1;&gt;, en caso de que añada más instrucciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before C&lt;require&gt; looks for a &quot;F&lt;.pm&gt;&quot; extension, it will
first look for a similar filename with a &quot;F&lt;.pmc&gt;&quot; extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Antes de C&lt;require&gt; busque una extensión &quot;F&lt;.pm&gt;&quot;, en primer lugar, buscará un nombre de archivo similar con una extensión &quot;F&lt;.pmc&gt;&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;\w&gt; will match the &quot;word&quot; characters of that
locale, and C&lt;&quot;/i&quot;&gt; case-insensitive matching will match according to
the locale's case folding rules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T164833Z" changeid="explorer">
        <seg>Por ejemplo, C&lt;\w&gt; coincidirá con los caracteres &quot;palabra&quot; de esa localidad, y la insensibilidad al tamaño de caja C&lt;&quot;/i&quot;&gt; coincidirá de acuerdo a las normas regionales de plegado de caja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item map EXPR,LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item map EXPR,LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;hash&gt; X&lt;merge&gt; X&lt;slice, hash&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225606Z" changeid="explorer">
        <seg>X&lt;hash&gt; X&lt;merge&gt; X&lt;slice, hash&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;my&gt; is actually not required; you could just use:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181535Z" changeid="zipf">
        <seg>En realidad no es obligatorio usar C&lt;my&gt;; se puede usar simplemente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;$+{NAME_PAT}&gt; would not be defined even though
C&lt;$+{NAME}&gt; would be.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T204116Z" changeid="explorer">
        <seg>Así C&lt;$+{NOMBRE_PAT}&gt; no será definido a pesar de que C&lt;$+{NOMBRE}&gt; sí lo será.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you read this file _as_is_, just ignore the equal signs on the left.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T011136Z" changeid="explorer">
        <seg>Si lee este archivo _tal_como_es_, ignore los caracteres extraños que vea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During compilation you will see this warning from toke.c:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004815Z" changeid="explorer">
        <seg>Durante la compilación, verá esta advertencia de toke.c:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl motto is &quot;There's more than one way to do it.&quot;  Divining
how many more is left as an exercise to the reader.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001855Z" changeid="explorer">
        <seg>El lema de Perl es &quot;Se puede hacer de varias maneras&quot;. Dejamos como ejercicio para el lector averiguar de cuántas maneras se puede hacer  :-).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$yday&gt; is the day of the year, in the range C&lt;0..364&gt;
(or C&lt;0..365&gt; in leap years.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$ydia&gt; es el día del año, en el rango C&lt;0..364&gt; (o C&lt;0..365&gt; en los años bisiestos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ARG must consist of a vector of native
short integers, which may be created with C&lt;pack(&quot;s!&quot;,(0)x$nsem)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El ARG debe consistir en un vector de enteros cortos nativos, que pueden ser creados con C&lt;pack(&quot;s!&quot;,(0)x$nsem)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$hasargs&gt; is true if a new instance of C&lt;@_&gt; was set up for the frame.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$hasargs&gt; es verdadero si una nueva instancia de C&lt;@_&gt; fue creada para este marco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Building 64-bit Perl in Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002540Z" changeid="explorer">
        <seg>=head2 Compilando Perl de 64 bit en Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
comes with a bundled version of zlib, so having a working zlib is not a
prerequisite to install it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T201045Z" changeid="explorer">
        <seg>Viene con una versión integrada de zlib, así que tener un zlib funcional no es un requisito previo para instalarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UNSHIFT this, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>UNSHIFT este, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sleep EXPR
X&lt;sleep&gt; X&lt;pause&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200756Z" changeid="explorer">
        <seg>=item sleep EXPR
X&lt;sleep&gt; X&lt;pause&gt; X&lt;pausa&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The position after the last match can be read or set using the C&lt;pos()&gt;
function; see L&lt;perlfunc/pos&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220147Z" changeid="explorer">
        <seg>La posición después de la última coincidencia puede ser leída o establecida mediante la función C&lt;pos()&gt;; vea L&lt;perlfunc/pos&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 42;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232604Z" changeid="explorer">
        <seg>print 42;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.2g&gt;', 100.01; # prints &quot;&lt;1e+02&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.2g&gt;', 100.01; # imprime &quot;&lt;1e+02&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, C&lt;(?:...)&gt; can't have a space between the C&lt;?&gt; and C&lt;:&gt;,
but can between the C&lt;(&gt; and C&lt;?&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, C&lt;(?:...)&gt; no puede tener ningún espacio entre C&lt;?&gt; y C&lt;:&gt;, pero puede tenerlos entre C&lt;(&gt; y C&lt;?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ARGV = @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ARGV = @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to write LENGTH bytes of data from variable SCALAR to the
specified FILEHANDLE, using write(2).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013107Z" changeid="explorer">
        <seg>Intenta escribir LONGITUD bytes de datos desde la variable ESCALAR al IDENTIFICADOR_ARCHIVO especificado, utilizando write(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = $bar =~ s/this/that/r
                =~ s/that/the other/r;	# Chained substitutes using /r</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034950Z" changeid="explorer">
        <seg>$foo = $bar =~ s/este/aquel/r
                =~ s/ese/el otro/r;		# Sustituciones encadenadas usando /r</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Source code distributions have an
automated &quot;make install&quot; step that means you do not need to extract
the source code below /usr/local (though that is where it will be
installed by default).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101310Z" changeid="explorer">
        <seg>Las distribuciones de código fuente tiene un sistema automatizado de &quot;make install&quot; que significa que no es necesario extraer el código fuente en /usr/local (que es, sin embargo, donde se instala por defecto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This was fixed by Nicholas Clark.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T050427Z" changeid="explorer">
        <seg>Esto fue corregido por Nicholas Clark.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...		# code for each line</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T040333Z" changeid="explorer">
        <seg>...			# código por cada línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's no longer true.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030708Z" changeid="explorer">
        <seg>Que ya no es cierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The usual idiom is:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El modismo habitual es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlform&gt; for many details and examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlform&gt; para más detalles y ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.xray.mpe.mpg.de/mailing-lists/perl-mvs/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220629Z" changeid="explorer">
        <seg>http://www.xray.mpe.mpg.de/mailing-lists/perl-mvs/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional feature, C&lt;:hireswallclock&gt;, now allows for high
resolution wall clock times (uses Time::HiRes).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171553Z" changeid="explorer">
        <seg>Una característica opcional, C&lt;hireswallclock&gt;, permite ahora tiempos de alta resolución de reloj (utiliza Time::HiRes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A WHENCE of C&lt;1&gt; (C&lt;SEEK_CUR&gt;) is useful for not moving the file position:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DONDE de C&lt;1&gt; (C&lt;SEEK_CUR&gt;) es útil para no mover la posición del archivo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = &quot;Food is on the foo table.&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T151515Z" changeid="explorer">
        <seg>$_ = &quot;En el Comedor Principal el niño come espinacas.&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl continues to flourish into its third decade thanks to a vibrant
community of users and developers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T231138Z" changeid="explorer">
        <seg>Perl sigue floreciendo en su tercera década gracias a una vibrante comunidad de usuarios y desarrolladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://groups.google.com/group/comp.lang.perl.misc/topics</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225440Z" changeid="explorer">
        <seg>http://groups.google.com/group/comp.lang.perl.misc/topics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tests whether the bitwise AND of $x and $y is zero,
you will like this warning.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002549Z" changeid="explorer">
        <seg>comprueba si el enmascaramiento AND de $x e $y son cero, le gustará esta advertencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &quot;|&quot; and &quot;^&quot; have lower priority than relational operators, so
for example the brackets are essential in a test like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que &quot;|&quot; y &quot;^&quot; tienen menor prioridad que los operadores relacionales, así que, por ejemplo, los paréntesis son esenciales en una prueba como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Following the normal C&lt;Configure&gt;, you have to run make as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siguiendo el tradicional C&lt;Configure&gt;, tiene que ejecutar make de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Simple substitution</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T232319Z" changeid="zipf">
        <seg>=item Sustitución simple</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item grep EXPR,LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item grep EXPR,LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, let's look at reading it in from a file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En primer lugar, echemos un vistazo a la lectura desde un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a string formatted by the usual C&lt;printf&gt; conventions of the C
library function C&lt;sprintf&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una cadena formateada por los habituales convenios de C&lt;printf&gt; de la función de biblioteca C&lt;sprintf&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>anything else           that number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>otra cosa          ese número</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encode and output</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235032Z" changeid="explorer">
        <seg>Codificar y emitir los resultados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $string = '0644';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225510Z" changeid="explorer">
        <seg>my $string = '0644';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;,&quot; is the comma operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;,&quot; es el operador coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T001222Z" changeid="explorer">
        <seg>$!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item /PATTERN/msixpodualgc</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T232717Z" changeid="explorer">
        <seg>=item /PATRÓN/msixpodualgc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '%*4$vX %*4$vX %*4$vX', @addr[1..3], &quot;:&quot;;   # 3 IPv6 addresses</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '%*4$vX %*4$vX %*4$vX', @addr[1..3], &quot;:&quot;;   # 3 direcciones IPv6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 4) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 4) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The correct
answer is either one of these:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T221646Z" changeid="explorer">
        <seg>La respuesta correcta es una de estas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have to use C&lt;sysread&gt; instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tiene que usar en su lugar C&lt;sysread&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;*&gt; for the repeat count uses all characters of the input field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;*&gt; como contador de repetición utiliza todos los caracteres del campo de entrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run C&lt;perl
Porting/Maintainers -M Module::Name&gt; to find out more information about a
dual-life module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014836Z" changeid="explorer">
        <seg>Ejecute C&lt;perl Porting/Maintainers -M Nombre::Módulo&gt; para obtener más información sobre un módulo de evolución dual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If umask(2) is not implemented on your system and you are trying to
restrict access for I&lt;yourself&gt; (i.e., C&lt;&lt; (EXPR &amp; 0700) &gt; 0 &gt;&gt;), 
raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si umask(2) no está implementada en su sistema y está tratando de restringir el acceso por I&lt;sí mismo&gt; (es decir, C&lt;&lt; (EXPR &amp; 0700) &gt; 0 &gt;&gt;), se lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;podchecker&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031955Z" changeid="explorer">
        <seg>=item L&lt;podchecker&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Data Munging with Perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003618Z" changeid="explorer">
        <seg>=item I&lt;Data Munging with Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>seek(TEST,0,1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>seek(TEST,0,1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takis Psarogiannakopoulos
University of Cambridge
Centre for Mathematical Sciences
Department of Pure Mathematics
Wilberforce road
Cambridge CB3 0WB , UK
email &lt;takis@XFree86.Org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150613Z" changeid="explorer">
        <seg>Takis Psarogiannakopoulos
Universidad de Cambridge
Centro para las Ciencias Matemáticas
Departamento de Matemáticas Puras
Wilberforce road
Cambridge CB3 0WB , UK
email &lt;takis@XFree86.Org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compilation errors will tell you the line number of the error, with an
indication of the next token or token type that was to be examined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001632Z" changeid="explorer">
        <seg>Los errores de compilación le indicarán el número de línea del error, además del siguiente símbolo o tipo de símbolo que iba a ser examinado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improved compatibility with older versions of perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031126Z" changeid="explorer">
        <seg>Mejorada la compatibilidad con versiones anteriores de perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$checksum = do {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$checksum = do {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Case 4 is preferred for
purely visual reasons, but it also has the advantage of compiling at
compile-time instead of at run-time.)  Case 5 is a place where
normally you I&lt;would&gt; like to use double quotes, except that in this
particular situation, you can just use symbolic references instead, as
in case 6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(El caso 4 es el preferido por razones puramente visuales, pero también tiene la ventaja de la compilación en tiempo de compilación en lugar de en tiempo de ejecución). Caso 5 es aquel donde normalmente I&lt;debería&gt; usar dobles comillas, excepto que en esta situación en particular, puede usar en su lugar referencias simbólicas instead, como en el caso 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The piping implementation now uses local rather than global DCL
symbols for inter-process communication.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000656Z" changeid="explorer">
        <seg>La implementación de tuberías ahora utiliza más locales que símbolos DCL globales para la comunicación entre procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is omitted, it chomps C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE se omite, usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Later operations that treat
$VERSION as a number will then be able to do so without provoking a
warning about $VERSION not being a number.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025936Z" changeid="explorer">
        <seg>Operaciones ulteriores que traten con $VERSION como un número, podrán hacerlo sin provocar una advertencia sobre si $VERSION no es un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Perl value which may be used instead of the
corresponding C&lt;/STRING/msixpodual&gt; expression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222746Z" changeid="explorer">
        <seg>Devuelve un valor de Perl que puede utilizarse en lugar de la correspondiente expresión C&lt;/CADENA/msixpodual&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension modules can also hook into the Perl parser to define new
kinds of keyword-headed expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay módulos con expansiones que también pueden engancharse en el intérprete Perl para definir nuevas clases de expresiones basadas en palabras clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variable C&lt;$,&gt; may now be tied.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003319Z" changeid="explorer">
        <seg>La variable C&lt;$,&gt; ahora puede ser enlazada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\s                  a whitespace character (space, tab, newline, ...)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T221938Z" changeid="zipf">
        <seg>\s                  un espacio en blanco (espacio, tabulación, nueva línea, ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one or more of:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>uno o más de:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str = '\t';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$str = '\t';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{ ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{ ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a block by itself is semantically identical to a loop
that executes once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que un bloque por sí mismo es semánticamente idéntico a un bucle que se ejecuta una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000340Z" changeid="explorer">
        <seg>&amp;&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub foo {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub foo {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset if eof;	    # clear m??</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205945Z" changeid="explorer">
        <seg>reset if eof;	    # limpiar el estado de m??</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$/x</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$/x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 8   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 8   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But a minus sign is not legal with it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T193443Z" changeid="explorer">
        <seg>Sin embargo, un signo menos no es legal con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@fields = split(/\b(a|b|c)\b/)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232059Z" changeid="explorer">
        <seg>@campos = split(/\b(a|b|c)\b/)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item write</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item write</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perldebtut&gt;, L&lt;perldebug&gt; and L&lt;perldebguts&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001432Z" changeid="explorer">
        <seg>Se describe en L&lt;perldebtut&gt;, L&lt;perldebug&gt; y L&lt;perldebguts&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When searching for single-character delimiters, escaped delimiters
and C&lt;\\&gt; are skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Durante la búsqueda de caracteres delimitadores individuales, los delimitadores escapados y los C&lt;\\&gt; son omitidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;\G&gt; without C&lt;/g&gt; on a target string that has
not previously had a C&lt;/g&gt; match applied to it is the same as using
the C&lt;\A&gt; assertion to match the beginning of the string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205137Z" changeid="explorer">
        <seg>Usando C&lt;\G&gt; sin C&lt;/g&gt; en una cadena objetivo que no haya tenido anteriormente aplicada una coincidencia C&lt;/g&gt; es lo mismo que usar la aserción C&lt;\A&gt; para que coincida con el principio de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;x&quot; is the repetition operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;x&quot; es el operador de repetición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item each EXPR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T160028Z" changeid="explorer">
        <seg>=item each EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052307Z" changeid="explorer">
        <seg>return (wantarray ? (undef, $errmsg) : undef) if $lo_hizo_estallar;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to single quoted
strings except that backslashes have no special meaning, with C&lt;\\&gt;
being treated as two backslashes and not one as they would in every
other quoting construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es similar a las cadenas con comillas simples, excepto que las barras invertidas no tienen ningún significado especial, siendo entonces que C&lt;\\&gt; es tratado como dos barras invertidas y no una como lo harían en cualquier otra construcción entrecomillada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>green chile</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chile verde</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>11 blksz  POSIX::      3..9 only      @_    subroutine args</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224354Z" changeid="explorer">
        <seg>11 blksz  POSIX::      3..9 solo         @_    args subrutina</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;&lt; &gt;&gt;                   while  ( ) { }, until ( ) { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;&lt; &gt;&gt;                   while  ( ) { }, until ( ) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next section details more changes brought to the semantics to
the smart match operator, that naturally also modify the behaviour
of the switch statements where smart matching is implicitly used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102850Z" changeid="explorer">
        <seg>La próxima sección detalla más cambios introducidos en la semántica del operador de coincidencia inteligente, que, naturalmente, también modifica el comportamiento de las instrucciones switch donde se utilice de forma implícita la coincidencia inteligente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/comp/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014617Z" changeid="explorer">
        <seg>=item * F&lt;t/comp/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also some non-standard modules that
provide faster implementations via external C libraries.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033701Z" changeid="explorer">
        <seg>También hay algunos módulos no estándares que ofrecen implementaciones más rápidas a través de bibliotecas de C externas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto&gt;-&amp;NAME form is highly magical, and substitutes a call to the
named subroutine for the currently running subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-&amp;NOMBRE es muy mágica, y sustituye a una llamada a una subrutina con nombre desde la actual subrutina que se está ejecutando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>later version, or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>versión posterior, o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the input string is longer than needed, extra characters are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena de entrada es más larga de lo necesario, los caracteres sobrantes se ignoran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$port,$proto) = getserv*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($name,$aliases,$port,$proto) = getserv*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {$FooPack::b &lt;=&gt; $FooPack::a} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {$FooPack::b &lt;=&gt; $FooPack::a} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($i=5; $i &lt;= 500_005; $i++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225519Z" changeid="explorer">
        <seg>for ($i=5; $i &lt;= 500_005; $i++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$line = &lt;&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$linea = &lt;&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlvar		Perl predefined variables</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlvar		Variables predefinidas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$elem *= 2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$elemento *= 2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 UNIVERSAL::DOES()</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112027Z" changeid="explorer">
        <seg>=head2 UNIVERSAL::DOES()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some variants, most of which don't work:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233741Z" changeid="explorer">
        <seg>Aquí hay algunas variantes más, la mayoría de los cuales tampoco funcionan:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These days, it's considered cleaner to call the
internal function directly as C&lt;glob($foo)&gt;, which is probably the right
way to have done it in the first place.)  For example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estos días, se considera más limpio llamar a la función interna directamente como C&lt;glob($foo)&gt;, que es probablemente la forma correcta de haberlo hecho desde el principio) Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are web archives of the mailing list at:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225121Z" changeid="explorer">
        <seg>Hay archivos web de la lista de correo en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Converters</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234134Z" changeid="explorer">
        <seg>=head2 Conversores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want it to match the
minimum number of times possible, follow the quantifier with a &quot;?&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea que coincida con el mínimo número de veces posible, siga el cuantificador con un &quot;?&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying VERSION as a literal of the form v5.6.1 should generally be
avoided, because it leads to misleading error messages under earlier
versions of Perl (that is, prior to 5.6.0) that do not support this
syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Especificando VERSIÓN como un literal de la forma v5.6.1, debe, generalmente, evitarse, porque lleva a crear mensajes de error equívocos en las versiones anteriores de Perl (esto es, anteriores a 5.6.0) que no admiten esta sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?{ $cnt = 0 })                   # Initialize $cnt.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T051005Z" changeid="explorer">
        <seg>(?{ $cnt = 0 })			  # Inicializa $cnt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Searches a string for a pattern, and if found, replaces that pattern
with the replacement text and returns the number of substitutions
made.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Busca un patrón en una cadena, y si se encuentra, sustituye este patrón con el texto de reemplazo y devuelve el número de sustituciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;print&gt; is more efficient and less
error prone.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;print&gt; es más eficiente y menos propenso a errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-b  File is a block special file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004735Z" changeid="explorer">
        <seg>-b  Archivo es un archivo especial por bloques.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 &quot;safe signals&quot; optimization</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052517Z" changeid="explorer">
        <seg>=head2 Optimización de &quot;señales de seguridad&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scripts which happen to rely on previously
erroneous behaviour will consider these fixes as incompatible changes :-)
You are advised to perform sufficient acceptance testing on this release
to satisfy yourself that this does not affect you, before putting this
release into production.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T102644Z" changeid="explorer">
        <seg>Scripts que puedan depender de conductas erróneas previas deberán tener en cuenta estas correcciones como cambios incompatibles :-) Se recomienda realizar pruebas de aceptación suficientes para esta versión para estar seguro de que esto no les afecta, antes de poner esa versión en producción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $count = 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $cuenta = 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several I/O operators you should know about.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay varios operadores de E/S que debe conocer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Haiku specific problems contact the HaikuPorts developers:
L&lt;http://ports.haiku-files.org/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150836Z" changeid="explorer">
        <seg>Para problemas específicos de Haiku, póngase en contacto con los desarrolladores HaikuPorts: L&lt;http://ports.haiku-files.org/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the last element of LIST does
not end in a newline, it appends the same file/line number text as C&lt;die&gt;
does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el último elemento de LISTA no termina en un salto de línea, se añade el archivo/número de línea de texto igual como lo hace C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You
can say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcheat - Perl 5 Cheat Sheet</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T214941Z" changeid="explorer">
        <seg>perlcheat - Hoja resumen de Perl 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nicholas Clark &lt;nick@ccl4.org&gt;, collating wisdom supplied by Slaven Rezic
and Tim Bunce.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nicholas Clark &lt;nick@ccl4.org&gt;, recopilando la sabiduría proporcionada por Slaven Rezic y Tim Bunce.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#o&gt;',  12;   # prints &quot;&lt;014&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#o&gt;',  12;   # imprime &quot;&lt;014&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result
of evaluation is considered a regular expression and matched as
if it were inserted instead of this construct.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T202005Z" changeid="explorer">
        <seg>El resultado de la evaluación es considerada como una expresión regular y combinada como si fuera insertada en lugar de esta construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\E&gt;) are useful when interpolating strings into
regular expressions, because by default an interpolated variable will be
considered a mini-regular expression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192941Z" changeid="explorer">
        <seg>C&lt;\E&gt;) son útiles cuando se interpolan cadenas en expresiones regulares, porque por defecto una variable interpolada será considerada una mini expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This modifier is useful for people who only incidentally use Unicode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T212008Z" changeid="explorer">
        <seg>Este modificador es útil para personas que usan, solo de forma accidental, Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T001007Z" changeid="explorer">
        <seg>$_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only question is whether
it saves you more time than it took to build the linked list in the
first place.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La única pregunta es si ahorra más tiempo que en lo que se tardó en construir la lista enlazada, al principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># expand variables in $_, but dynamics only, using</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># expandir variables en $_, pero solo dinámicamente, usando</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are package globals.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Son variables globales del paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/apples?/) {
            print &quot;I like apples.&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T235512Z" changeid="explorer">
        <seg>when (/manzanas?/) {
            print &quot;Me gustan las manzanas.&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Scalars begin with a $variables-&gt;{'scalar'}-&gt;{'sigil'}\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T214437Z" changeid="explorer">
        <seg>print &quot;Los escalares empiezan por $variables-&gt;{'scalar'}-&gt;{'sigilo'}\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For date and time processing look at the many related modules on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para el procesado de fechas y tiempos mire en los módulos relaccionados en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item state TYPE EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item state TIPO EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;ExtUtils::CBuilder&gt; and C&lt;ExtUtils::ParseXS&gt; have been added.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013223Z" changeid="explorer">
        <seg>Han sido añadidos C&lt;ExtUtils::CBuilder&gt; y C&lt;ExtUtils::ParseXS&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar in $a</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T030455Z" changeid="explorer">
        <seg>$a =~ s/foo/bar/g;        # reemplaza todas las coincidencias de foo por bar en $a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Where can I get a list of Larry Wall witticisms?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232048Z" changeid="explorer">
        <seg>=head2 ¿Dónde puedo obtener una lista de citas ingeniosas de Larry Wall?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise any object destructors that need to
be called are called before the real exit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Igualmente cualquier destructor de objetos que necesite ser llamado es llamado antes de la salida real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>*?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = $bar =~ s/this/that/r;	# Same as above using /r</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213032Z" changeid="explorer">
        <seg>$foo = $bar =~ s/este/aquel/r;		# Lo mismo que antes usando /r</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Assignment to C&lt;$0&gt; sets the legacy process name with C&lt;prctl()&gt; on Linux</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T053403Z" changeid="explorer">
        <seg>=head2 Asignación a C&lt;$0&gt; establece el nombre del proceso con C&lt;prctl()&gt; en Linux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$is_directory  =  S_ISDIR($mode);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$es_directorio =  S_ISDIR($modo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forms C&lt;(?'NAME'pattern)&gt; and C&lt;&lt; (?&lt;NAME&gt;pattern) &gt;&gt; are equivalent.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T213544Z" changeid="explorer">
        <seg>Las formas C&lt;(?'NOMBRE'patrón)&gt; y C&lt;&lt; (?&lt;NOMBRE&gt;patrón) &gt;&gt; son equivalentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can refer to
identifiers in other packages than the current one by prefixing the identifier
with the package name and a double colon, as in C&lt;$SomePack::var&gt;
or C&lt;ThatPack::INPUT_HANDLE&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacer referencia a los identificadores de otros paquetes distintos del actual anteponiendo el identificador con el nombre del paquete y un dos puntos doble, como en C&lt;$AlgunPaquete::var&gt; o C&lt;EstePaquete::CONTROLADOR_ENTRADA&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some systems the $quota
field may be $change or $age, fields that have to do with password
aging.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas el campo $cuota puede ser $cambio o $edad, campos que tienen que ver con la caducidad de la contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is exactly equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Eso es exactamente equivalente a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000028Z" changeid="explorer">
        <seg>**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 4   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 4   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some encodings, like the C&lt;iso-8859&gt; (&quot;latin&quot;) range, do not support the full
Unicode standard; characters that can't be represented are lost in the
conversion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234721Z" changeid="explorer">
        <seg>Algunas codificaciones, como las de la familia C&lt;iso-8859&gt; (&quot;alfabeto latino&quot;), no cubren el estándar Unicode completo; los caracteres que no se pueden representar se perderán durante la conversión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backslashed characters are either replaced with corresponding
literal strings (as with C&lt;\{&gt;), or else they generate special nodes
in the finite automaton (as with C&lt;\b&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los caracteres escapados con contrabarra son sustituidos por sus correspondientes cadenas de texto literales (como en C&lt;\{&gt;), o sino generan nodos especiales en el autómata finito (como en C&lt;\b&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>+?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the particular test case a C&lt;system(&quot;perl -e 0&quot;)&gt; flushes the
stdout pipe of another child process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el caso particular del test C&lt;system(&quot;perl -e 0&quot;)&gt; vacía la tubería de salida estándar de otro proceso hijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases perfection has been
sacrificed in the goal of getting the general idea across.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224543Z" changeid="explorer">
        <seg>En algunos casos se ha sacrificado la precisión para transmitir la idea general.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPTVAL might either be a packed string or an integer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>OPCIÓN_VALOR podría ser una cadena empaquetada o un entero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE:&gt; In order to make things easier for programmers with experience
with the Python or PCRE regex engines the pattern C&lt;&lt; (?P&gt;NAME) &gt;&gt;
may be used instead of C&lt;&lt; (?&amp;NAME) &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T192028Z" changeid="explorer">
        <seg>B&lt;NOTA:&gt; Con el fin de facilitar las cosas a los programadores con experiencia en Python o motores regex PCRE, el patrón C&lt;&lt; (?P&gt;NOMBRE) &gt;&gt;
puede ser usado en lugar de C&lt;&lt; (?&amp;NOMBRE) &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
is now fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto ha sido arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 2) = 2   ==          8 00010000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 2) = 2   ==          8 00010000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its effect used to be global.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192618Z" changeid="explorer">
        <seg>Su efecto solía ser global.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (fileno(THIS) == fileno(THAT)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (fileno(THIS) == fileno(THAT)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NOTE: Some sites have redefined the way uname works, and if yours
does this, special steps must be taken so that Configure can
recognize your system as a UTS system.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T213935Z" changeid="explorer">
        <seg>NOTE: Algunos sitios han redefinido la forma en que uname funciona, y si en el suyo lo hace así, se debe tener en cuenta una serie de pasos especiales, para que el Configure puede reconocer su sistema como un sistema UTS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;feature&gt; and L&lt;perlsyn/&quot;Switch statements&quot;&gt; for more
information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023956Z" changeid="explorer">
        <seg>Vea L&lt;feature&gt; y L&lt;perlsyn/&quot;Instrucciones switch&quot;&gt; para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The text copied gets delimiter-independent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El texto copiado es independiente de los delimitadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These examples often reflect the style and preference of the author of
that piece of the documentation, and may be briefer than a corresponding
line of code in a real program.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004507Z" changeid="explorer">
        <seg>Los ejemplos de las distintas partes de la documentación reflejan el estilo y las preferencias de sus autores, y pueden ser más escuetos que una línea de código equivalente en un programa real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;DB_File&gt; for other flock() examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;DB_File&gt; para otros ejemplos de flock().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub invalid { die &quot;/$_[0]/: invalid escape '\\$_[1]'&quot;}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002034Z" changeid="explorer">
        <seg>sub invalido { die &quot;/$_[0]/: escape inválido '\\$_[1]'&quot;}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl regexps also support backreferences, lookaheads, and all kinds of
other complex details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225510Z" changeid="explorer">
        <seg>Las expresiones regulares de Perl también ofrecen referencias a capturas previas, inspección hacia adelante, y muchas otras funcionalidades complejas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sysread FILEHANDLE,SCALAR,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012835Z" changeid="explorer">
        <seg>=item sysread IDENTIFICADOR_ARCHIVO,ESCALAR,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>go_outside() and play() unless $is_raining;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vete_fuera() and juega() unless $este_lloviendo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$key = getc(STDIN);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$tecla = getc(STDIN);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>char   cc[2];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>char   cc[2];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check your control flow.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004327Z" changeid="explorer">
        <seg>Compruebe su control de flujo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the expression (which is itself
determined within scalar context) is first parsed, and if there were no
errors, executed in the lexical context of the current Perl program, so
that any variable settings or subroutine and format definitions remain
afterwards.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T233511Z" changeid="explorer">
        <seg>El valor de la expresión (que es en sí mismo determinada en contexto escalar) es primero interpretada, y si no hay ningún error, ejecutada en el contexto léxico del actual programa Perl, por lo que se mantienen después los valores de las variables o definiciones de subrutinas o formatos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)*</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T221043Z" changeid="explorer">
        <seg>)*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(STDIN, &quot;&lt;&amp;SPLAT&quot;) || die &quot;can't dupe SPLAT: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031309Z" changeid="explorer">
        <seg>open(STDIN, &quot;&lt;&amp;SPLAT&quot;) || die &quot;no puedo duplicar SPLAT: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names that start with a
letter or underscore may also contain digits and underscores.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres que empiezan por una letra o el símbolo de subrayado pueden incluir también dígitos y subrayados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/regexp_qr_embed_thr.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010030Z" changeid="explorer">
        <seg>=item t/op/regexp_qr_embed_thr.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the word C&lt;while&gt; is replaced by the word C&lt;until&gt;, the sense of the
test is reversed, but the conditional is still tested before the first
iteration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la palabra C&lt;while&gt; se reemplaza por la palabra C&lt;until&gt;, el sentido del test se invierte, pero la condición es comprobada siempre antes de la primera iteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can avoid
the ambiguity by always using C&lt;\g{}&gt; or C&lt;\g&gt; if you mean capturing groups;
and for octal constants always using C&lt;\o{}&gt;, or for C&lt;\077&gt; and below, using 3
digits padded with leading zeros, since a leading zero implies an octal
constant.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191030Z" changeid="explorer">
        <seg>Puede evitar la ambigüedad usando siempre C&lt;\g{}&gt; o C&lt;\g&gt; si se refiere a los grupos de captura; y para las constantes octales siempre con C&lt;\o{}&gt;, o para C&lt;\077&gt; e inferiores, usando 3 dígitos rellenados con ceros a la izquierda, ya que un cero a la izquierda implica una constante octal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\x7q&quot;      &quot;\x07q&quot;   yes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204112Z" changeid="explorer">
        <seg>&quot;\x7q&quot;      &quot;\x07q&quot;      sí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ans = &lt;STDIN&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ans = &lt;STDIN&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opens the UTF8-encoded file containing Unicode characters;
see L&lt;perluniintro&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003401Z" changeid="explorer">
        <seg>abre el archivo codificado en UTF-8 que contiene caracteres Unicode; vea L&lt;perluniintro&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=cut back to the compiler, nuff of this pod stuff!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=cut devuelta al compilador, ¡lejos de este material pod!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr{}{}	  Transliteration	  no (but see below)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr{}{}    Transliteración	  no (pero vea abajo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, some special instructions for building Perl with Sun Studio on Linux.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, algunas instrucciones especiales para la construcción de Perl con Sun Studio en Linux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because C&lt;.*&gt; was greedy, so you get everything between the
I&lt;first&gt; &quot;foo&quot; and the I&lt;last&gt; &quot;bar&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T155033Z" changeid="explorer">
        <seg>Esto se debe a que C&lt;.*&gt; era avaricioso, por lo que obtiene todo lo que hay entre el I&lt;primer&gt; &quot;mesa&quot; y el I&lt;último&gt; &quot;come&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item F&lt;perlbug&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005510Z" changeid="explorer">
        <seg>=item F&lt;perlbug&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C, Perl does a certain amount of expression evaluation at
compile time whenever it determines that all arguments to an
operator are static and have no side effects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que C, Perl hace una cierta cantidad de evaluación de expresiones en tiempo de compilación cuando determina que todos los argumentos a un operador son estáticos y no tienen efectos secundarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kirrily &quot;Skud&quot; Robert &lt;skud@cpan.org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232659Z" changeid="explorer">
        <seg>Kirrily &quot;Skud&quot; Robert &lt;skud@cpan.org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See also L&lt;Integer Arithmetic&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver también L&lt;Aritmética entera&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># put commas in the right places in an integer</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># pone comas en los lugares adecuados en un entero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 PODs: Embedded Documentation
X&lt;POD&gt; X&lt;documentation&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043040Z" changeid="explorer">
        <seg>=head2 POD: Documentación embebida
X&lt;POD&gt; X&lt;documentación&gt; X&lt;documentación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.7.2 (Developmental) or Perl 5.8.x (forthcoming) for UTS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T213746Z" changeid="explorer">
        <seg>Perl 5.7.2 (en desarrollo) o Perl 5.8.x (en preparación) para UTS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To confirm this, from the main Perl source dir, do:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T215014Z" changeid="explorer">
        <seg>Para confirmar esto, desde el directorio principal fuente de Perl, hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such platforms include Mac OS
Classic, IBM z/OS (and other EBCDIC platforms), and NetWare.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T002239Z" changeid="explorer">
        <seg>En estas plataformas se incluyen a Mac OS Classic, IBM z/OS (y otras plataformas EBCDIC), y NetWare.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Escape sequences</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Secuencias de Escape</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is often a matter of opinion and taste, and there isn't any one
answer that fits everyone.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200549Z" changeid="explorer">
        <seg>Esto suele ser una cuestión de opinión y gusto, y no hay una respuesta definitiva para todos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shifts the first value of the array off and returns it, shortening the
array by 1 and moving everything down.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Extrae el primer valor del array y lo devuelve, acortando el array en uno y moviendo todos los demás hacia arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== != &lt;=&gt; eq ne cmp ~~  for equals foreach (ALWAYS)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224222Z" changeid="explorer">
        <seg>== != &lt;=&gt; eq ne cmp ~~  for igual a foreach (SIEMPRE)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;Quote-Like Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop/&quot;Operadores entrecomillados&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also see:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015146Z" changeid="explorer">
        <seg>Vea también:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Verbs that take an argument</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003030Z" changeid="explorer">
        <seg>=item Verbos que toman un argumento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsyn&gt; for alternative strategies.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsyn&gt; para estrategias alternativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $s is now &quot;The black cat jumped from the green tree&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># $s es ahora &quot;El gato negro saltó desde el árbol verde&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(*SKIP)&gt; C&lt;(*SKIP:NAME)&gt;
X&lt;(*SKIP)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T010357Z" changeid="explorer">
        <seg>=item C&lt;(*SKIP)&gt; C&lt;(*SKIP:NAME)&gt;
X&lt;(*SKIP)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can even set them to pipe commands.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso se puede configurar para entubar a comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To query options at another level the
protocol number of the appropriate protocol controlling the option
should be supplied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para consultar opciones en otro nivel se debe indicar el apropiado número de protocolo que controle a esa opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of the C3 MRO and switchable MROs within the perl core was
written by Brandon L Black.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T134345Z" changeid="explorer">
        <seg>La aplicación de la C3 MRO y la capacidad de intercambiar MRO en el núcleo de Perl fue escrito por Brandon L Black.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4 uid    4 month-1    4 hasargs      $|    autoflush</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224341Z" changeid="explorer">
        <seg>4 uid    4 mes-1      4 hasargs         $|    volcado automático</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this file
is found, it will be loaded in place of any file ending in a &quot;F&lt;.pm&gt;&quot;
extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si este archivo es encontrado, se cargará en lugar de cualquier archivo que termine en una extensión &quot;F&lt;.pm&gt;&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Works just like index() except that it returns the position of the I&lt;last&gt;
occurrence of SUBSTR in STR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Funciona igual que index() excepto que devuelve la posición de la I&lt;última&gt; ocurrencia de SUBCADENA en CADENA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the perlfunc(1) entry on C&lt;umask&gt; for more
on this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver la entrada perlfunc(1) para C&lt;umask&gt; para más información sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Module::Build should be more reliably pass its tests under cygwin.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230325Z" changeid="explorer">
        <seg>Module::Build debería ser más fiable a la hora de pasar sus test, en cygwin.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># ...		# other switches</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ...		# otras opciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Y2038 compliance</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003129Z" changeid="explorer">
        <seg>=head2 Cumplimiento Y2038</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also means that C&lt;$foo[1]&gt;
is a part of @foo, not a part of $foo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También significa que C&lt;$foo[1]&gt; es parte de @foo, no parte de $foo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array can be accessed one scalar at a
time by specifying a dollar sign (C&lt;$&gt;), then the
name of the array (without the leading C&lt;@&gt;), then the subscript inside
square brackets.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150013Z" changeid="explorer">
        <seg>Un array puede ser accedido, un escalar cada vez, especificando un signo dólar (C&lt;$&gt;), seguido por el nombre del array (sin el C&lt;@&gt;), seguido del subíndice entre corchetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># only on ASCII and ASCII-derived systems such as ISO Latin 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># solo en sistemas ASCII y derivados, como ISO Latin 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bar.pm
implements the related BAR protocol.&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015107Z" changeid="explorer">
        <seg>Bar.pm implementa el protocolo relacionado BAR.&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That way you're safe from the shell
expanding wildcards or splitting up words with whitespace in them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esta forma estará protegido de la expansión de los comodines del shell o de la división en palabras con un espacio en blanco dentro de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you can add new rows.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora puede agregar nuevas filas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means
that the C&lt;~&gt; and C&lt;~~&gt; tokens treat the entire PICTURE as a single line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que los tokens C&lt;~&gt; y C&lt;~~&gt; tratan al CUADRO entero como una única línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $mbox $msg,&quot;\n\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $mbox $msg,&quot;\n\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/comp/retainedlines.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005958Z" changeid="explorer">
        <seg>=item t/comp/retainedlines.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are upgrading from an earlier release such as 5.10.0, first read
L&lt;perl5120delta&gt;, which describes differences between 5.10.0 and
5.12.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052452Z" changeid="explorer">
        <seg>Si está actualizando desde una versión anterior como la 5.10.0, primero lea L&lt;perl5120delta&gt;, que describe las diferencias entre 5.10.0 y la 5.12.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {uc($a) cmp uc($b)} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {uc($a) cmp uc($b)} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/^=begin/ ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233429Z" changeid="explorer">
        <seg>when (/^=begin/ ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 The &quot;Artistic License&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 La &quot;Licencia Artística&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getprotobyname NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getprotobyname NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New     Maintenance  Development</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005710Z" changeid="explorer">
        <seg>Nuevo	Mantenimiento	Desarrollo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned depends on the
type of thing the reference is a reference to.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto depende del tipo de cosa que la referencia indique como referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a case additional elements $evaltext and
C&lt;$is_require&gt; are set: C&lt;$is_require&gt; is true if the frame is created by a
C&lt;require&gt; or C&lt;use&gt; statement, $evaltext contains the text of the
C&lt;eval EXPR&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012307Z" changeid="explorer">
        <seg>En tal caso, se añaden los nuevos elementos $evaltext y C&lt;$is_require&gt;: C&lt;$is_require&gt; es verdadero si el marco es creado por una instrucción C&lt;require&gt; o C&lt;use&gt;, $evaltext contiene el texto de la instrucción C&lt;eval EXPR&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$first = &lt;$handle&gt;
            or return ();     # Automatically closed here.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050439Z" changeid="explorer">
        <seg>$first = &lt;$handle&gt;
            or return ();     # Cerrado aquí automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the LIST is prepended whole, not one element at a time, so the
prepended elements stay in the same order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la LISTA se antepone en su conjunto, no un elemento a la vez, por lo que los elementos añadidos se mantienen en el mismo orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;$_&gt; is an alias to the list value, so it can be used to
modify the elements of the LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;$_&gt; es un alias al valor de la lista, por lo que puede ser usado para modificar los elementos de la LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} @array;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>} @array;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;re&gt; upgraded to version 0.05</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034535Z" changeid="explorer">
        <seg>C&lt;re&gt; actualizado a la versión 0.05</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means that C&lt;caller(N)&gt;
might not return information about the call frame you expect it to, for
C&lt;&lt; N &gt; 1 &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que C&lt;caller(N)&gt; quizás no devuelva información sobre el marco de llamada que espera, para C&lt;&lt; N &gt; 1 &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;use locale&gt; is in effect and
POSIX::setlocale() has been called, the character used for the decimal
separator in formatted floating-point numbers is affected by the LC_NUMERIC
locale setting.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T010702Z" changeid="explorer">
        <seg>Si C&lt;use locale&gt; está activo y POSIX::setlocale() ha sido llamada, el carácter utilizado para el separador decimal en números formateados en punto flotante se ve afectado por la configuración regional de LC_NUMERIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl B&lt;borrows syntax&gt; and concepts from many languages: awk, sed, C,
Bourne Shell, Smalltalk, Lisp and even English.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl B&lt;toma prestada la sintaxis&gt; y conceptos de muchos lenguajes: awk, sed, C, Bourne Shell, Smalltalk, Lisp e incluso el Inglés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no equivalent operator to force an expression to
be interpolated in list context because in practice, this is never
needed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay un operador equivalente que fuerce a una expresión a ser interpolada en contexto de lista, ya que en la práctica, esto nunca es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsec&gt; for a clean and safe example of a manual fork() and exec()
to emulate backticks safely.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220201Z" changeid="explorer">
        <seg>Vea L&lt;perlsec&gt; para un ejemplo seguro y limpio de un fork() y exec() manual para emular comillas invertidas de forma segura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or even just</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o incluso sólo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It uses the domain to provide
general support services to the Perl community, including the hosting
of mailing lists, web sites, and other services.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231322Z" changeid="explorer">
        <seg>Usa el dominio para proporcionar servicios generales de soporte a la comunidad Perl, como el alojamiento de listas de correo y sitios web, entre otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlko		Perl for Korean (in EUC-KR)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000831Z" changeid="explorer">
        <seg>perlko		Perl para coreano (en EUC-KR)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the output is empty and C&lt;$@&gt; contains an object reference that has a
C&lt;PROPAGATE&gt; method, that method will be called with additional file
and line number parameters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la salida está vacía y C&lt;$@&gt; contiene una referencia a un objeto que tiene un método C&lt;PROPAGATE&gt;, éste método será llamado con los parámetros adicionales del archivo y número de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235029Z" changeid="explorer">
        <seg>3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 CONTACT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 CONTACTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>31</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>31</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The EXPR can be arbitrarily complicated provided its
final operation is an element or slice of an aggregate:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La EXPR puede ser tan arbitrariamente complicada con tal de que el final de la operación sea un elemento o una porción de un agregado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function
implementing the C&lt;\U&gt; escape in double-quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la función interna del escapado C&lt;\U&gt; en las cadenas doblemente entrecomilladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sqrt</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sqrt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt;EOF;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt;EOF;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;aa&quot; =~ /${b}/;      # True</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191713Z" changeid="explorer">
        <seg>&quot;aa&quot; =~ /${b}/;      # Verdadero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225616Z" changeid="explorer">
        <seg>1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Verifies your POD's correctness</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T032021Z" changeid="explorer">
        <seg>Comprueba la exactitud de tu POD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/x</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getnetent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getnetent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hal Morris</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hal Morris</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Usage Hints for Perl on VM/ESA</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T111631Z" changeid="explorer">
        <seg>=head2 Sugerencias de uso para Perl en VM/ESA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9781565926998</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003530Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9781565926998</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;utf8&gt; upgraded to version 1.06</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041133Z" changeid="explorer">
        <seg>C&lt;utf8&gt; actualizado a la versión 1.06</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is faster and more productive than just posting a request.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230657Z" changeid="explorer">
        <seg>Esto suele ser más rápido y productivo que publicar una pregunta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235026Z" changeid="explorer">
        <seg>2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are more pack codes or if the repeat count of a field or a group
is larger than what the remainder of the input string allows, the result
is not well defined: the repeat count may be decreased, or
C&lt;unpack()&gt; may produce empty strings or zeros, or it may raise an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay más códigos de empaquetado o si el número de repeticiones de un campo o un grupo es más grande que lo que el resto de la cadena de entrada permite, el resultado no está bien definido: el número de repeticiones puede ser disminuido, o C&lt;unpack()&gt; puede producir cadenas vacías o ceros, o puede provocar una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read that documentation using the C&lt;perldoc&gt;
command or whatever method you're using to read this document.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224554Z" changeid="explorer">
        <seg>Puede consultar la documentación mediante el comando C&lt;perldoc&gt; o cualquier otro método que use para leer este documento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;exec&gt; function executes a system command I&lt;and never returns&gt;;
use C&lt;system&gt; instead of C&lt;exec&gt; if you want it to return.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función C&lt;exec&gt; ejecuta un comando del sistema I&lt;y nunca regresa&gt;; use C&lt;system&gt; en lugar de C&lt;exec&gt; si quiere que regrese.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Math::Trig&gt; upgraded to version 1.03</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033438Z" changeid="explorer">
        <seg>C&lt;Math::Trig&gt; actualizado a la versión 1.03</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(.)\g1/                        # find first doubled char
         and print &quot;'$1' is the first doubled character\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191323Z" changeid="explorer">
        <seg>/(.)\g1/                        # busca el primer carácter repetido
         and print &quot;'$1' es el primer carácter repetido\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlvmesa		Perl notes for VM/ESA</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlvmesa		Notas para VM/ESA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Six such conversions are possible:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232638Z" changeid="explorer">
        <seg>Hay seis conversiones posibles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 4) = 8   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 4) = 8   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your platform doesn't
support NaNs then NaN is just a string with numeric value 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su plataforma no es compatible con NaN entonces NaN es sólo una cadena con un valor numérico 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bad example:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014948Z" changeid="explorer">
        <seg>Mal ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235021Z" changeid="explorer">
        <seg>1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dbmopen(%NS_Hist, &quot;$ENV{HOME}/.netscape/history.db&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dbmopen(%NS_Hist, &quot;$ENV{HOME}/.netscape/history.db&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5005delta	Perl changes in version 5.005</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5005delta	Cambios en la versión 5.005</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl595delta	Perl changes in version 5.9.5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl595delta	Cambios en la versión 5.9.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$herstraddr     = inet_ntoa($iaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$herstraddr     = inet_ntoa($iaddr);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Writing subroutines</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T004059Z" changeid="zipf">
        <seg>=head2 Programación de subrutinas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;UTF-8&gt; is a Unicode encoding.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234428Z" changeid="explorer">
        <seg>B&lt;UTF-8&gt; es una codificación de Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without this, the
scalars have already been freed sufficiently at the point of detection that
it is impossible to produce any meaningful dump of their contents.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T052953Z" changeid="explorer">
        <seg>Sin esto, los escalares ya habrían sido liberados, de tal manera, que se haría imposible producir cualquier descarga significativa de sus contenidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare the following to the examples in C&lt;(*PRUNE)&gt;; note the string
is twice as long:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T011801Z" changeid="explorer">
        <seg>Compare lo siguiente con los ejemplos de C&lt;(*PRUNE)&gt;; nota que la cadena es el doble de larga:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That way when somebody
tries to run the new code under an old perl, rather than getting an error like</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031611Z" changeid="explorer">
        <seg>De esta forma cuando alguien intente ejecutar el nuevo código en un viejo perl, en lugar de obtener un error como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of
C&lt;O_TRUNC&gt; with C&lt;O_RDONLY&gt; is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento de C&lt;O_TRUNC&gt; con C&lt;O_RDONLY&gt; no está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, modifying an
element of a list returned by grep (for example, in a C&lt;foreach&gt;, C&lt;map&gt;
or another C&lt;grep&gt;) actually modifies the element in the original list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, modificar un elemento de la lista devuelto por grep (por ejemplo, en un C&lt;foreach&gt;, C&lt;map&gt; u otro C&lt;grep&gt;) modifica el elemento en la lista original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;N&quot;, $vector), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>unpack(&quot;N&quot;, $vector), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
C&lt;BENGALI DIGIT FOUR&gt; (U+09EA) looks very much like an
C&lt;ASCII DIGIT EIGHT&gt; (U+0038).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T172930Z" changeid="explorer">
        <seg>Por ejemplo, C&lt;BENGALI DIGIT FOUR&gt; (U+09EA) se parece mucho a una C&lt;ASCII DIGIT EIGHT&gt; (U+0038).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\x{100}&gt; and C&lt;\o{400}&gt; are both 256 in decimal, so the number is interpreted
as a Unicode code point no matter what the native encoding is.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T220735Z" changeid="explorer">
        <seg>C&lt;\x{100}&gt; y C&lt;\o{400}&gt; son, ambos dos, 256 en decimal, por lo que el número se interpreta como un punto de código Unicode no importa qué codificación nativa sea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '%3$d %d %1$d', 1, 2, 3;  # prints &quot;3 1 1&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '%3$d %d %1$d', 1, 2, 3;  # imprime &quot;3 1 1&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are multiple threads running, C&lt;close&gt; on a filehandle from a
piped open returns true without waiting for the child process to terminate,
if the filehandle is still open in another thread.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005746Z" changeid="explorer">
        <seg>Si hay múltiples hilos en ejecución, hacer un C&lt;close&gt; en un identificador de archivo desde un open entubado, devuelve verdadero sin esperar a que el proceso hijo termine, si el identificador de archivo sigue abierto en otro hilo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 (Reminder) 5.005-style threads are deprecated (really)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011011Z" changeid="explorer">
        <seg>=head3 (Recordatorio) los I&lt;threads&gt; estilo 5.005 son obsoletos (de verdad)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In versions of Perl prior to 5.004 the default seed was just the
current C&lt;time&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En las versiones de Perl anteriores a 5.004 la semilla por defecto era sólo el valor actual de C&lt;time&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated to version 1.33</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052706Z" changeid="explorer">
        <seg>Actualizado a la versión 1.33</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;pod2html|pod2html&gt; and L&lt;pod2latex|pod2latex&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233411Z" changeid="explorer">
        <seg>=item L&lt;pod2html|pod2html&gt; y L&lt;pod2latex|pod2latex&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item values EXPR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183757Z" changeid="explorer">
        <seg>=item values EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want
to call the underlying C&lt;getppid()&gt;, you may use the CPAN module
C&lt;Linux::Pid&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere llamar a la subyacente C&lt;getppid()&gt;, puede usar el módulo de CPAN C&lt;Linux::Pid&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Duping a filehandle does not take into account any existing contents
of IO buffers.) If you use the three-argument form, then you can pass either a
number, the name of a filehandle, or the normal &quot;reference to a glob&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004412Z" changeid="explorer">
        <seg>(Duplicar un identificador de archivo no tiene en cuenta ningún contenido actual de los búfer de E/S). Si utiliza la forma de tres argumentos, entonces puede pasar un número, el nombre de un identificador de archivo o la normal &quot;referencia a un glob&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 XS-assisted SWASHGET</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013811Z" changeid="explorer">
        <seg>=head2 SWASHGET XS-asistida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Building 'cc -n32' is the default.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002527Z" changeid="explorer">
        <seg>(Compilar 'cc -n32' está por defecto)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if the specified Perl version is greater than or equal to
5.11.0, strictures are enabled lexically as with C&lt;use strict&gt; (except
that the F&lt;strict.pm&gt; file is not actually loaded).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, si la versión especificada de Perl es mayor o igual a 5.11.0, el modo de trabajo estricto quedará activado léxicamente como con C&lt;use strict&gt; (excepto que el archivo F&lt;strict.pm&gt;, realmente, no se cargará).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can gain you a measure of efficiency if
you know the hash is going to get big.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacerle ganar más eficiencia si sabe que el hash va a tener un gran tamaño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's important to realize that there are no bytes in a text string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235219Z" changeid="explorer">
        <seg>Es importante comprender que en una cadena de texto no hay bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>45</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>45</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't
have a filehandle named &quot;log&quot;, for instance.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003421Z" changeid="explorer">
        <seg>No se puede tener un identificador de archivo llamado &quot;log&quot;, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntaxes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030906Z" changeid="explorer">
        <seg>La sintaxis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($image, $max_x * $x + $y, 8) = 3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($imagen, $max_x * $x + $y, 8) = 3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl594delta - what is new for perl v5.9.4</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T111910Z" changeid="explorer">
        <seg>perl594delta - qué hay de nuevo para perl v5.9.4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DBM Filters are useful for a class of problems where you I&lt;always&gt;
want to make the same transformation to all keys, all values or both.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T153547Z" changeid="zipf">
        <seg>Los filtros DBM son útiles para un tipo de problema en el que se desea aplicar I&lt;siempre&gt; la misma transformación a todas las claves, a todos los valores, o a todas las claves y todos los valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or you can see this document by entering &quot;perldoc perlartistic&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>O puede ver este documento mediante la introducción de &quot;perldoc perlartistic&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is C&lt;... || ...&gt;, C&lt;... // ...&gt; or C&lt;... or ...&gt;, the test
is applied recursively to the first operand (which may be a
higher-precedence AND operator, for example).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T214414Z" changeid="explorer">
        <seg>Si EXPR es C&lt;... || ...&gt;, C&lt;... // ...&gt; o C&lt;... or ...&gt;, el test se aplica recursivamente al primer operando (que puede ser un operador de mayor precedencia, como el AND, por ejemplo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 ) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>10 ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a number of Unicode characters that match multiple characters
under C&lt;/i&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162056Z" changeid="explorer">
        <seg>Hay una serie de caracteres Unicode que coinciden con múltiples caracteres con C&lt;/i&gt; activado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the curly brackets are I&lt;required&gt;--no
dangling statements allowed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013317Z" changeid="explorer">
        <seg>Esto significa que las llaves son I&lt;necesarias&gt;: no se permiten instrucciones sueltas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying the target
string also resets the search position.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Modificando la cadena objetivo también restablece la posición de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, when accepting literal string
input from the user, quotemeta() or C&lt;\Q&gt; must be used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T010908Z" changeid="explorer">
        <seg>Normalmente, quotemeta() o C&lt;\Q&gt; deben ser usados al aceptar cadenas de entrada provenientes del usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>embeddable and extensible</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001149Z" changeid="explorer">
        <seg>capacidad de integración y ampliación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub read_myfile_munged {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub leer_miarchivo {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5134delta	Perl changes in version 5.13.4</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141415Z" changeid="explorer">
        <seg>perl5134delta	Cambios en la versión 5.13.4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POSITION before the beginning of the string
or after its end is treated as if it were the beginning or the end,
respectively.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>POSICIÓN antes del comienzo del string o después de su final es tratado como si estuviera al principio o al final, respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The epoch was at 00:00 January 1, 1970 GMT.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(El epoch fue a las 00:00 GMT del 1 de enero de 1970)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%-6s&gt;', 12;   # prints &quot;&lt;12    &gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%-6s&gt;', 12;   # imprime &quot;&lt;12    &gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The terminating string may be either an identifier (a word), or some
quoted text.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La cadena de terminación puede ser un identificador (una palabra), o algún texto entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensive reworking of the pad code (the code responsible
for lexical variables) has been conducted by Dave Mitchell.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T001345Z" changeid="explorer">
        <seg>Una remodelación extensa del código de control (el código responsable de las variables léxicas) ha sido llevado a cabo por Dave Mitchell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Archive::Tar&gt; is a module to manipulate C&lt;tar&gt; archives.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013033Z" changeid="explorer">
        <seg>C&lt;Archive::Tar&gt; es un módulo para manipular archivos C&lt;tar&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,15, 2) = 2   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,15, 2) = 2   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$verbose &amp;&amp; print &quot;Starting analysis\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$locuaz &amp;&amp; print &quot;Empezando análisis\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Komodo</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>=item Komodo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one may need to use the template C&lt;c x![d] d c[2]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>puede tener que usar la plantilla C&lt;c x![d] d c[2]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1_000_000) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1_000_000) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Match a minimal number of characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Busca el mínimo número de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should instead use a simple test for size:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilize en su lugar una comprobación de tamaño:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context,
returns the elements removed from the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, devuelve los elementos retirados del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ip_address = inet_ntoa($packed_ip);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ip_address = inet_ntoa($packed_ip);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $passwd and $shell, user's encrypted password and
login shell, are also tainted, for the same reason.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T162215Z" changeid="explorer">
        <seg>La $contrasena y el $shell, la contraseña codificada del usuario y el shell del login, están también contaminados, por la misma razón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even C&lt;&lt; &lt;$x &gt; &gt;&gt; (note the extra space)
is treated as C&lt;glob(&quot;$x &quot;)&gt;, not C&lt;readline($x)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010919Z" changeid="explorer">
        <seg>Incluso C&lt;&lt; &lt;$x &gt; &gt;&gt; (note el espacio extra) es tratado como C&lt;glob(&quot;$x &quot;)&gt;, no como C&lt;readline($x)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TIEHASH classname, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TIEHASH clase, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space around most operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio alrededor de la mayoría de operadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &quot;DTrace support&quot; in F&lt;INSTALL&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003038Z" changeid="explorer">
        <seg>Vea &quot;Soporte DTrace&quot; en F&lt;INSTALL&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the L&lt;perlbook&gt; documentation or
( http://books.perl.org ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230707Z" changeid="explorer">
        <seg>Consulte el documento L&lt;perlbook&gt; o visite http://books.perl.org para obtener más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our $bar;      # emits warning but has no other effect</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>our $bar;      # emite una advertencia pero no tiene otro efecto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-r  File is readable by effective uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004457Z" changeid="explorer">
        <seg>-r  Archivo es legible por el uid/gid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\S        [3]  Match a non-whitespace character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223658Z" changeid="explorer">
        <seg>\S	 [3]  Coincide con un carácter que no es un espacio en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014732Z" changeid="explorer">
        <seg>Se lo agradeceremos...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;perlbug&gt; is the recommended way to report bugs in the perl interpreter
itself or any of the standard library modules back to the developers;
please read through the documentation for F&lt;perlbug&gt; thoroughly before
using it to submit a bug report.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234425Z" changeid="explorer">
        <seg>La manera recomendada de notificar errores del intérprete perl o de cualquier módulo de la biblioteca estándar a sus programadores es usar F&lt;perlbug&gt;; pero antes de usar F&lt;perlbug&gt; debe leer con atención su documentación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>srand;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225557Z" changeid="explorer">
        <seg>srand;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/pack&gt; for more examples and notes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/pack&gt; para más ejemplos y notas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a yet-more-powerful import facility, see L&lt;/use&gt; and L&lt;perlmod&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una más-que-poderosa facilidad de importación, ver L&lt;/use&gt; y L&lt;perlmod&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3  &quot;betty&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032547Z" changeid="explorer">
        <seg>3  &quot;betty&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use Module</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item use Módule</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many people think that Unicode and UTF-8 are
the same thing, but they're not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234432Z" changeid="explorer">
        <seg>Muchas personas creen que Unicode es lo mismo que UTF-8, pero se equivocan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of C&lt;ioctl&gt; (and C&lt;fcntl&gt;) is as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto de C&lt;ioctl&gt; (y C&lt;fcntl&gt;) es como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;Operator associativity&gt; defines what happens if a sequence of the
same operators is used one after another: whether the evaluator will
evaluate the left operations first or the right.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T010301Z" changeid="explorer">
        <seg>I&lt;Asociatividad de operadores&gt; define qué sucede si una secuencia de los mismos operadores es usada una detrás de otra: si el evaluador evaluará primero las operaciones a la izquierda o las de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232115Z" changeid="explorer">
        <seg>:)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, put this as the first line of your script:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224641Z" changeid="explorer">
        <seg>Como alternativa, puede colocar al principio del script la siguiente línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The S-magic avoids dropping
the caching optimization and making (??{...}) constructs obscenely
slow (and consequently useless).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001525Z" changeid="explorer">
        <seg>El S-magic evita decaer la optimización de almacenamiento en caché y que las construcciones (??{...}) sean obscenamente lentas (y por lo tanto, inútiles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function msgctl(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC msgctl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($b =~ /=(\d+)/)[0] &lt;=&gt; ($a =~ /=(\d+)/)[0]
            ||</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051339Z" changeid="explorer">
        <seg>($b =~ /=(\d+)/)[0] &lt;=&gt; ($a =~ /=(\d+)/)[0]
            ||</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A declaration can be put anywhere a statement can, but has no effect on
the execution of the primary sequence of statements--declarations all
take effect at compile time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012227Z" changeid="explorer">
        <seg>Una declaración puede ponerse en cualquier sitio, como si fuera una instrucción, pero no tiene efecto en la ejecución de la secuencia de instrucciones principal: todas las declaraciones toman efecto en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's no place
to declare a scalar variable to be of type &quot;string&quot;, type &quot;number&quot;,
type &quot;reference&quot;, or anything else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay ninguna forma de declarar que una variable escalar sea de tipo &quot;cadena&quot;, tipo &quot;número&quot;, tipo &quot;referencia&quot; o de cualquier otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, an opening parenthesis after the operator does not affect
how much of the following code constitutes the argument.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152529Z" changeid="explorer">
        <seg>Es decir, un paréntesis de apertura después del operador no influye en que el código que sigue se constituya como el argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># this is where that last takes me</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Aquí es donde lleva el 'last'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @AoA = (</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032340Z" changeid="explorer">
        <seg>my @AoA = (</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-blocking wait is available on machines supporting either the
waitpid(2) or wait4(2) syscalls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espera no bloqueanto está disponible en máquinas que soporten las llamadas del sistema, tanto waitpid(2) como wait4(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you get into the habit
of doing that, you get yourself into trouble if you then add an C&lt;/e&gt;
modifier.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T225610Z" changeid="explorer">
        <seg>Sin embargo, si usted entra en el hábito de hacer eso, se mete en problemas si, a continuación, añade un modificador C&lt;/e&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(this may not work on some bizarre filesystems).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(esto quizás no funcione en algunos sistemas de archivos extraños).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string =~ /$re/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T222849Z" changeid="explorer">
        <seg>$cadena =~ /$re/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 9, 2) = 2   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 9, 2) = 2   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Installation and Configuration Improvements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Mejoras en la instalación y configuración</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T195317Z" changeid="explorer">
        <seg>8;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a Usenet gateway to Perl mailing lists sponsored by
perl.org at nntp://nntp.perl.org , a web interface to the same lists
at http://nntp.perl.org/group/ and these lists are also available
under the C&lt;perl.*&gt; hierarchy at http://groups.google.com . Other
groups are listed at http://lists.perl.org/ ( also known as
http://lists.cpan.org/ ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230429Z" changeid="explorer">
        <seg>También existe una pasarela Usenet a las listas de correo de Perl patrocinada por perl.org en nntp://nntp.perl.org y una interfaz web a las mismas listas en http://nntp.perl.org/group/. Estas listas también están disponibles en la jerarquía C&lt;perl.*&gt; de http://groups.google.com . En la dirección http://lists.perl.org/ ( conocida también como http://lists.cpan.org/ ) se indican otros grupos. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item undef</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item undef</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of 5.005, C&lt;$&amp;&gt; is not so costly as the
other two.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de 5.005, C&lt;$&amp;&gt; no es tan costoso como los otros dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$days{'Feb'}	# the 'Feb' value from hash %days</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$dias{'Feb'}	# el valor 'Feb' del hash %dias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On simple groups, such as the pattern C&lt;&lt; (?&gt; [^()]+ ) &gt;&gt;, a comparable
effect may be achieved by negative look-ahead, as in C&lt;[^()]+ (?!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T215221Z" changeid="explorer">
        <seg>En grupos sencillos, como en el patrón C&lt;&lt; (?&gt; [^()]+ ) &gt;&gt;, un efecto comparable puede ser conseguido por medio de una aserción antecedente, como en C&lt;[^()]+ (?!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort { $a cmp $b } find_records @key;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort { $a cmp $b } busca_registros @claves;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>??</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>??</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Sadahiro Tomoyuki)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T111944Z" changeid="explorer">
        <seg>(Sadahiro Tomoyuki)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ease of experimentation flattens
the learning curve even more.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230443Z" changeid="explorer">
        <seg>Esta facilidad para realizar experimentos también allana la curva de aprendizaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Works just like L&lt;localtime&gt; but the returned values are
localized for the standard Greenwich time zone.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Funciona igual que L&lt;localtime&gt; pero los valores devueltos son localizados por la zona horaria estándar de Greenwich.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%o    an unsigned integer, in octal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%o    un entero sin signo, en octal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U16 length;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114046Z" changeid="explorer">
        <seg>U16 length;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($word = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($palabra = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For &quot;g&quot; and &quot;G&quot;, this specifies the maximum number of digits to show,
including thoe prior to the decimal point and those after it; for 
example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para &quot;g&quot; y &quot;G&quot;, especifica el número máximo de dígitos para mostrar, incluyendo los anteriores del punto decimal y los posteriores a él, por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that, due to
the implementation of C&lt;use filetest 'access'&gt;, the C&lt;_&gt; special
filehandle won't cache the results of the file tests when this pragma is
in effect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004543Z" changeid="explorer">
        <seg>Note también que, debido a la implementación de C&lt;use filetest 'access'&gt;, el identificador de archivo especial C&lt;_&gt; no almacenará los resultados de los test de archivo mientras este pragma esté activo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should C&lt;use Socket&gt; first
to get the proper definitions imported.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe usar C&lt;use Socket&gt; primero para obtener las apropiadas definiciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;cond_wait&gt; has a new two argument form.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;cond_wait&gt; tiene una nueva forma de dos argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000458Z" changeid="explorer">
        <seg>?:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	=~ !~</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	=~ !~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &quot;/&quot; is the delimiter then the initial C&lt;m&gt; is optional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si &quot;/&quot; es el delimitador entonces la inicial C&lt;m&gt; es opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>until EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>until EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,11, 1) = 1   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,11, 1) = 1   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a .= &quot;\n&quot;;     # same as $a = $a . &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055555Z" changeid="explorer">
        <seg>$a .= &quot;\n&quot;;     # igual que $a = $a . &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ( 1 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225458Z" changeid="explorer">
        <seg>for ( 1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function returns an undefined value,
it's an admission that it couldn't give you an honest answer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando una función devuelve un valor indefinido, se asume que no puede dar una respuesta honrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or with rationals:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033315Z" changeid="explorer">
        <seg>O con números racionales:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because these are not part of
the standard distribution, they may and in fact do differ from the
base perl port in a variety of ways.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225411Z" changeid="explorer">
        <seg>Como no forman parte de la distribución estándar, es posible que existan diferencias (de hecho, existen) con respecto a la versión básica de perl en diversos aspectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As well as these two, there are two other converters: F&lt;pod2html&gt; will
produce HTML pages from POD, and F&lt;pod2latex&gt;, which produces LaTeX
files.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233415Z" changeid="explorer">
        <seg>Hay otros dos conversores: F&lt;pod2html&gt; genera páginas HTML a partir de POD y F&lt;pod2latex&gt; genera archivos LaTeX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6 rdev   6 weekday    6 evaltext     $@    eval error</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224345Z" changeid="explorer">
        <seg>6 rdev   6 día semana 6 evaltext        $@    error eval</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you submit a patch, you
should add your name to this file as part of the patch.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014956Z" changeid="explorer">
        <seg>Si envía una revisión, debe agregar su nombre a este archivo como parte de la revisión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltodo		Perl things to do</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000625Z" changeid="explorer">
        <seg>perltodo		Tareas pendientes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The approach taken is analogous to the existing space optimisation for
subroutine stub declarations, which are stored as plain scalars in place
of the full typeglob.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T033513Z" changeid="explorer">
        <seg>El enfoque adoptado es análogo a la optimización del espacio existente para las declaraciones básicas de subrutinas, que son almacenadas como escalares normales en lugar del typeglob completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item formline PICTURE,LIST
X&lt;formline&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173435Z" changeid="explorer">
        <seg>=item formline CUADRO,LISTA
X&lt;formline&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the source number can be represented in the target form, that
representation is used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232700Z" changeid="explorer">
        <seg>Si el número de origen se puede representar en la forma de destino, se usa esa representación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might try to write that as</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T165951Z" changeid="explorer">
        <seg>Puede tratar de escribirlo como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item values ARRAY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item values ARRAY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Encode&gt; upgraded to version 2.12</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030800Z" changeid="explorer">
        <seg>C&lt;Encode&gt; actualizado a la versión 2.12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str = &quot;widget&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$str = &quot;widget&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're hacking
on the Perl core, this will help you find what you're looking for.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T013229Z" changeid="explorer">
        <seg>En él encontrará toda la información necesaria para «hackear» el núcleo de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, unpacks the C&lt;$_&gt; string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es omitido, desempaqueta la cadena C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's best to assume traditional behavior if you're writing
portable programs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es mejor asumir el comportamiento tradicional si está escribiendo programas portables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Testing tools</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T032045Z" changeid="explorer">
        <seg>=item Herramientas de prueba</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $animal = &quot;camel&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025616Z" changeid="explorer">
        <seg>my $animal    = &quot;camello&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can switch into a
package in more than one place, since this only determines which default 
symbol table the compiler uses for the rest of that block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede cambiar en un paquete en más de un lugar, ya que esto sólo determina qué tabla de símbolos por defecto será utilizada por el compilador para el resto de ese bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example: [a-z] matches &quot;a&quot; or &quot;b&quot; or &quot;c&quot; ... or &quot;z&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T044134Z" changeid="explorer">
        <seg>Ejemplo: [a-z] coincide con &quot;a&quot; o &quot;b&quot; o &quot;c&quot; ... o &quot;z&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an uncaught exception results in interpreter exit, the exit code is
determined from the values of C&lt;$!&gt; and C&lt;$?&gt; with this pseudocode:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171114Z" changeid="explorer">
        <seg>Si se produce una excepción no detectada en la salida del intérprete, el código de salida se determina a partir de los valores de C&lt;$!&gt; y C&lt;$?&gt; con este pseudocódigo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$vec = Bit::Vector-&gt;new_Hex(32, &quot;DEADBEEF&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225513Z" changeid="explorer">
        <seg>$vec = Bit::Vector-&gt;new_Hex(32, &quot;DEADBEEF&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't start caesar: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo iniciar caesar: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#.5o&gt;', 012;      # prints &quot;&lt;00012&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#.5o&gt;', 012;      # imprime &quot;&lt;00012&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Though forcing an argument into a particular form does not change the
stored number, Perl remembers the result of such conversions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234129Z" changeid="explorer">
        <seg>Aunque forzar la conversión de un argumento a un formato específico no cambia el número almacenado, Perl recuerda el resultado de las conversiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;r is a reference to a hash.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;r es una referencia a un hash.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item bind SOCKET,NAME
X&lt;bind&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165628Z" changeid="explorer">
        <seg>=item bind SOCKET,NOMBRE
X&lt;bind&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when( /^\d+\z/ )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225621Z" changeid="explorer">
        <seg>when( /^\d+\z/ )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you add or delete a hash's elements
while iterating over it, entries may be skipped or duplicated--so don't do
that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si añade o borra un elemento de un hash mientras está iterando sobre él, puede encontrarse con entradas desaparecidas o duplicadas, así que no lo haga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match 0 or 1 time, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide 0 o 1 veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;viacode()&gt; now accept hex strings and has been optimized.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025635Z" changeid="explorer">
        <seg>C&lt;viacode()&gt; ahora acepta cadenas hexadecimales y ha sido optimizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such literals are accepted by both C&lt;require&gt; and C&lt;use&gt; for
doing a version check.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos literales son aceptadas por ambas C&lt;require&gt; y C&lt;use&gt; para hacer una comprobación de versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators return the
last value in the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven el último valor de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original string is never changed when
C&lt;/r&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030847Z" changeid="explorer">
        <seg>La cadena original no se cambia nunca cuando C&lt;/r&gt; se utiliza.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type-casting operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operador de Forzado de tipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/c&gt; modifier is specified, the SEARCHLIST character set
is complemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se especifica el modificador C&lt;/c&gt;, el conjunto de caracteres LISTA_BÚSQUEDA es complementado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that the final match
did not update C&lt;pos&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También tenga en cuenta que la última coincidencia no actualizó C&lt;pos&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is the character specified by the hexadecimal number in the range
0x00 to 0xFF.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110515T001845Z" changeid="explorer">
        <seg>El resultado es el carácter especificado por el número hexadecimal en el rango 0x00 a 0xFF.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:encoding&gt; layer sometimes needs to be called in
mid-stream, and it doesn't flush the stream.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La capa C&lt;:encoding&gt; algunas veces necesita ser llamada en mitad del flujo de datos y no lo vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;threads::shared&gt; upgraded to version 0.94</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040625Z" changeid="explorer">
        <seg>C&lt;threads::shared&gt; actualizado a la versión 0.94</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A character range may be specified with a hyphen, so C&lt;tr/A-J/0-9/&gt;
does the same replacement as C&lt;tr/ACEGIBDFHJ/0246813579/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un intervalo de caracteres se puede especificar con un guión, por lo que C&lt;tr/A-J/0-9/&gt; es la sustitución de C&lt;tr/ACEGIBDFHJ/0246813579/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, for elementary pieces there is no such question, since at most
one match at a given position is possible.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T234557Z" changeid="explorer">
        <seg>Una vez más, de las piezas elementales no hay cuestión de este tipo, ya que la mayoría coincide en una posición determinada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= += -= *= etc.  ?     zero or one          /g global</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224247Z" changeid="explorer">
        <seg>= += -= *= etc.  ?     cero o una               /g global</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wanted to keep track of subscripts, you might do this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193838Z" changeid="explorer">
        <seg>Si quisiera hacer un seguimiento de los subíndices, podría hacer lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (%a_hash)   { print &quot;has hash members\n&quot;   }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (%a_hash)   { print &quot;el hash tiene miembros\n&quot;   }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;We have no bananas&quot; unless $bananas;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235734Z" changeid="zipf">
        <seg>print &quot;No quedan plátanos&quot; unless $platanos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treat string as single line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Trata a la cadena como una sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#etc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item no MODULE VERSION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item no MÓDULO VERSIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there's something you
need to do, then it's probably already been done, and a working example is
usually available for free.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230549Z" changeid="explorer">
        <seg>Cuando se enfrente a un problema, es probable que pueda obtener un ejemplo que funciona (generalmente gratis) de alguien que lo haya hecho ya.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Compound Statements
X&lt;statement, compound&gt; X&lt;block&gt; X&lt;bracket, curly&gt; X&lt;curly bracket&gt; X&lt;brace&gt;
X&lt;{&gt; X&lt;}&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt; X&lt;until&gt; X&lt;foreach&gt; X&lt;for&gt; X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013240Z" changeid="explorer">
        <seg>=head2 Instrucciones compuestas
X&lt;statement, compound&gt; X&lt;block&gt; X&lt;bracket, curly&gt; X&lt;curly bracket&gt; X&lt;brace&gt;
X&lt;{&gt; X&lt;}&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt; X&lt;until&gt; X&lt;foreach&gt; X&lt;for&gt; X&lt;continue&gt; X&lt;instrucción, compuesta&gt; X&lt;bloque&gt; X&lt;llave&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item PerlIO::scalar</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015240Z" changeid="explorer">
        <seg>=item PerlIO::scalar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-k  File has sticky bit set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-k  Archivo tiene puesto el bit sticky.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.activestate.com/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225435Z" changeid="explorer">
        <seg>http://www.activestate.com/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughout Perl's documentation, you'll find numerous examples intended
to help explain the discussed features.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004455Z" changeid="explorer">
        <seg>En la documentación de Perl se incluyen muchos ejemplos que ilustran las características descritas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hash code has been refactored to reduce source duplication.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El código hash ha sido reprogramado para reducir la duplicación de código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>means
of script invocation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T111759Z" changeid="explorer">
        <seg>para la invocación de I&lt;script&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl
works on platforms that have a native encoding currently of either ASCII/Latin1
or EBCDIC, each of which allow specification of 256 characters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T200706Z" changeid="explorer">
        <seg>Perl funciona en plataformas que tienen, actualmente, una codificación nativa ASCII/Latin1 o EBCDIC, cada una de las cuales permiten la especificación de 256 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;FOO&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;FOO&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILENO this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FILENO este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Where are the archives for comp.lang.perl.misc?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230942Z" changeid="explorer">
        <seg>=head2 ¿Dónde puedo encontrar los mensajes antiguos de comp.lang.perl.misc?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item CPAN</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015037Z" changeid="explorer">
        <seg>=item CPAN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ones = (5) x @ones;	# set all elements to 5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@unos = (5) x @unos;	# pone todos los elementos a 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The form C&lt;while/if BLOCK BLOCK&gt;, available in Perl 4, is no longer
available.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;while/if BLOQUE BLOQUE&gt;, existente en Perl 4, ya no está disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt; &gt; &lt;= &gt;= lt gt le ge</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000313Z" changeid="explorer">
        <seg>&lt; &gt; &lt;= &gt;= lt gt le ge</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a set of utilities which help you in developing Perl programs, 
and in particular, extending Perl with C.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234413Z" changeid="explorer">
        <seg>A continuación se describe un conjunto de utilidades que ayudan a desarrollar programas Perl y, en particular, a extender Perl con código C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chat scripts were just drivers for existing programs,
not stand-alone programs in their own right.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231735Z" changeid="explorer">
        <seg>Los scripts de chat sólo eran activadores de programas existentes, no programas autónomos por derecho propio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions obsoleted in perl5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones obsoletas en perl5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, its semantics have been adjusted for greater
consistency or usefulness in several cases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233653Z" changeid="explorer">
        <seg>Por otra parte, su semántica se ha ajustado para que tenga una mayor coherencia y utilidad en algunos casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly for the C&lt;:encoding&gt; pragma:
in that case pretty much any characters can be read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, para el pragma C&lt;:encoding&gt;: en este caso casi todos los caracteres se pueden leer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many regular expression constructs don't work on EBCDIC platforms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003808Z" changeid="explorer">
        <seg>Muchas construcciones de expresiones regulares no funcionan en plataformas EBCDIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&lt;&quot; returns true if the left argument is numerically less than
the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&lt;&quot; devuelve verdadero si el argumento de la izquierda es numéricamente menor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Truth and Falsehood
X&lt;truth&gt; X&lt;falsehood&gt; X&lt;true&gt; X&lt;false&gt; X&lt;!&gt; X&lt;not&gt; X&lt;negation&gt; X&lt;0&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040949Z" changeid="explorer">
        <seg>=head2 Verdad y Falsedad
X&lt;truth&gt; X&lt;falsehood&gt; X&lt;true&gt; X&lt;false&gt; X&lt;!&gt; X&lt;not&gt; X&lt;negation&gt; X&lt;0&gt; X&lt;verdad&gt; X&lt;falsedad&gt; X&lt;verdadero&gt; X&lt;falso&gt; X&lt;negación&gt; X&lt;no&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @greek_small =  map { chr }
		       ord &quot;\N{alpha}&quot; ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224642Z" changeid="explorer">
        <seg>my @griegas_minusculas =  map { chr }
                       ord(&quot;\N{alpha}&quot; ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extras({follow =&gt; 1})-&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225446Z" changeid="explorer">
        <seg>extras({follow =&gt; 1})-&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
need to exit the process with a specific exit code, see L&lt;/exit&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215355Z" changeid="explorer">
        <seg>Si necesita terminar el proceso con un valor de salida específico, vea L&lt;/exit&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use NDBM_File;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use NDBM_File;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlre - Perl regular expressions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlre - Expresiones regulares en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 2) = 2   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 2) = 2   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;axyz&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># &quot;axyz&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ...;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ...;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&lt; (?&lt;NAME&gt;pattern) &gt;&gt;
X&lt;&lt; (?&lt;NAME&gt;) &gt;&gt; X&lt;(?'NAME')&gt; X&lt;named capture&gt; X&lt;capture&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T213046Z" changeid="explorer">
        <seg>=item C&lt;&lt; (?&lt;NOMBRE&gt;patrón) &gt;&gt;
X&lt;&lt; (?&lt;NOMBRE&gt;) &gt;&gt; X&lt;(?'NOMBRE')&gt; X&lt;captura nominada&gt; X&lt;captura&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Hashes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232610Z" changeid="explorer">
        <seg>=item Hashes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An C&lt;eof&gt; without an argument uses the last file read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;eof&gt; sin argumento usa el último archivo leído.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;++&quot; and &quot;--&quot; work as in C.  That is, if placed before a variable,
they increment or decrement the variable by one before returning the
value, and if placed after, increment or decrement after returning the
value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;++&quot; y &quot;--&quot; funcionan como en C. Es decir, si son colocados antes de una variable, incrementan o decrementan la variable por uno antes de devolver el valor, y colocados después, incrementan o decrementan después de haber devuelto el valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Long lines broken after an operator (except C&lt;and&gt; and C&lt;or&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dividir líneas largas después de un operador (excepto C&lt;and&gt; y C&lt;or&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read the documentation for the C&lt;filetest&gt; pragma for more
information.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información, lea la documentación del pragma C&lt;filetest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING:&gt; This feature is highly experimental.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T144010Z" changeid="explorer">
        <seg>B&lt;ADVERTENCIA:&gt; Esta característica es muy experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you had the entire header of a normal Unix email message in $header,
you could split it up into fields and their values this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted tuviera el encabezado completo de un mensaje de correo electrónico Unix normal en $encabezado, puede dividirlo en sus campos y valores de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent examples:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplos equivalentes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 4) = 4   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 4) = 4   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlvar/%SIG&gt; for details on setting C&lt;%SIG&gt; entries, and
L&lt;&quot;eval BLOCK&quot;&gt; for some examples.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T154436Z" changeid="explorer">
        <seg>Ver L&lt;perlvar/%SIG&gt; para los detalles sobre cómo colocar entradas C&lt;%SIG&gt; y L&lt;&quot;eval BLOQUE&quot;&gt; para algunos ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GETC this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>GETC este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = kill 1, $child1, $child2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = kill 1, $child1, $child2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BUILD AND INSTALL</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 CONSTRUCCIÓN E INSTALACIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately
when Perl writes to DBM databases it doesn't use NULL termination, so
your Perl application will have to manage NULL termination itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T155908Z" changeid="zipf">
        <seg>Sin embargo, Perl no usa el carácter de terminación NULL al escribir en bases de datos DBM, por lo que la aplicación Perl deberá encargarse de agregar la terminación NULL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two elements of the list must be the NUMERIC access
and modification times, in that order.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024832Z" changeid="explorer">
        <seg>Los dos primeros elementos de la lista deben ser los tiempos NUMÉRICOS de acceso y de modificación, y en ese orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;assertions&gt; and L&lt;perlrun&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215219Z" changeid="explorer">
        <seg>Vea L&lt;aserciones&gt; y L&lt;perlrun&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto-&amp;NAME&gt; form is quite different from the other forms of
C&lt;goto&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto-&amp;NOMBRE&gt; es muy diferente de las otras formas de C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synced with its CPAN version 2.10</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T104714Z" changeid="explorer">
        <seg>Sincronizado con su versión 2.10 en CPAN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item B::Concise</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015058Z" changeid="explorer">
        <seg>=item B::Concise</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$old_filter = $db-&gt;filter_fetch_value( sub { ... } );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T224846Z" changeid="zipf">
        <seg>$filtro_antiguo = $db-&gt;filter_fetch_value( sub { ... } );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@whatever = ();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@loquesea  = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Something pulled the plug on a live tied variable, Perl plays
safe by bailing out.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002937Z" changeid="explorer">
        <seg>Algo tiró del enchufe en una variable enlazada que seguía viva, Perl apuesta seguro por el rescate.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hostname is $2\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T031204Z" changeid="explorer">
        <seg>print &quot;El nombre del servidor es $2\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signals should still be dispatched within the same statement as
they were previously - if this is not the case, or it is possible to
create uninterruptible loops, this is a bug, and reports are encouraged
of how to recreate such issues.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103128Z" changeid="explorer">
        <seg>Las señales aún deben ser despachadas dentro de la instrucción igual que antes - si este no es el caso, o es posible crear bucles sin interrupción, esto es un error, y los informes animan a recrear estas cuestiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Perl is configured to use ithreads, it will use re-entrant library calls
in preference to non-re-entrant versions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando Perl está configurado para usar ithreads, usará llamadas de biblioteca reentrantes preferentemente sobre versiones no-reentrantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix unpack U to be the reverse of pack U</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>arreglo de unpack(&quot;U&quot;) para que sea el inverso de pack(&quot;U&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack('(sl)&lt;', -42, 4711);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack('(sl)&lt;', -42, 4711);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># sequence, hence the presence of '\\' in the conversion rules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002013Z" changeid="explorer">
        <seg># secuencia \\Y|, y de ahí viene la presencia de '\\' en las reglas de conversión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lstat</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item lstat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space after each comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio después de cada coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new compilation flag C&lt;PERL_DONT_CREATE_GVSV&gt;, introduced as an option
in perl 5.8.8, is turned on by default in perl 5.9.3.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T033720Z" changeid="explorer">
        <seg>La nueva opción de compilación C&lt;PERL_DONT_CREATE_GVSV&gt;, presentado como una opción en perl 5.8.8, está activada de forma predeterminada en Perl 5.9.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You would 
want to use the list form of the pipe so you can pass literal arguments
to the command without risk of the shell interpreting any shell metacharacters
in them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T234023Z" changeid="explorer">
        <seg>Querrá usar la forma de lista de la tubería para que pueda pasar argumentos literales al comando sin el riesgo de que el shell interprete cualquier posible metacarácter que hubiera en ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Scalar values
X&lt;scalar&gt; X&lt;number&gt; X&lt;string&gt; X&lt;reference&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035219Z" changeid="explorer">
        <seg>=head2 Valores escalares
X&lt;scalar&gt; X&lt;number&gt; X&lt;string&gt; X&lt;reference&gt; X&lt;escalar&gt; X&lt;número&gt; X&lt;cadena&gt; X&lt;referencia&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 4) = 8   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 4) = 8   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$i = $i ++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$i = $i ++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Named Unary Operators
X&lt;operator, named unary&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234848Z" changeid="explorer">
        <seg>=head2 Operadores unarios con nombre
X&lt;operator, named unary&gt; X&lt;operador, unario con nombre&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5114delta	Perl changes in version 5.11.4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5114delta	Cambios en la versión 5.11.4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; lowercase&quot;),    redo LOOP if /\G\p{Ll}+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030014Z" changeid="explorer">
        <seg>print(&quot; minúscula&quot;),    redo LOOP if /\G\p{Ll}+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If OFFSET is negative then it starts that far from the end of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el DESPLAZAMIENTO es negativo, se cuenta la posición desde el final del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X DIRHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020025Z" changeid="explorer">
        <seg>=item -X IDENTIFICADOR_DIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $i ( 1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $i ( 1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(&quot;\n&quot;,@$[0..$#$]) if( $$[-1] );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225532Z" changeid="explorer">
        <seg>print join(&quot;\n&quot;,@$[0..$#$]) if( $$[-1] );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++($foo = &quot;zz&quot;);	# prints &quot;aaa&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223905Z" changeid="explorer">
        <seg>print ++($foo = &quot;zz&quot;);	# imprime &quot;aaa&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;!=&quot; returns true if the left argument is numerically not equal
to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;!=&quot; devuelve verdadero si el argumento de la izquierda es numéricamente distinto que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlink(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlink(&quot;alfa&quot;, &quot;beta&quot;, &quot;gamma&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cpan.org?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231244Z" changeid="explorer">
        <seg>¿Y cpan.org?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* / % x                 SYNTAX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>* / % x                 SINTAXIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more complete description of how Perl matches the switch variable
against the C&lt;when&gt; conditions is given in L&lt;perlsyn/&quot;Switch statements&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103237Z" changeid="explorer">
        <seg>Una descripción más completa de cómo Perl hace coincidir la variable del switch con las condiciones C&lt;when&gt; se da en L&lt;perlsyn/&quot;Instrucciones switch&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'aaab' =~ /a+b?(*PRUNE)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T012538Z" changeid="explorer">
        <seg>'aaab' =~ /a+b?(*PRUNE)(?{print &quot;$&amp;\n&quot;; $contador++})(*FAIL)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$re = customre::convert $re;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002857Z" changeid="explorer">
        <seg>$re = customre::convertir $re;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, typing in your own password to whoever asks you
for it is unwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Naturalmente es muy imprudente dar la propia contraseña a cualquiera que lo pregunte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $foo = 20;          # no warning about duplicate my $foo,
                           # but hey, you asked for it!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052618Z" changeid="explorer">
        <seg>my $foo = 20;          # no avisa de un my $foo duplicado,
                           # pero bueno, ¡tú lo has querido!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item utime LIST
X&lt;utime&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210739Z" changeid="explorer">
        <seg>=item utime LISTA
X&lt;utime&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>comp.lang.perl.moderated     Moderated discussion group</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230358Z" changeid="explorer">
        <seg>comp.lang.perl.moderated     Grupo de discusión moderado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.8.1 release and
the 5.8.2 release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe las diferencias entre la versión 5.8.1 y la versión 5.8.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This modifier may be specified to be the default by C&lt;use feature
'unicode_strings&gt;, but see
L&lt;/Which character set modifier is in effect?&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220430Z" changeid="explorer">
        <seg>Este modificador puede ser especificado para que sea el predeterminado por C&lt;use feature 'unicode_strings'&gt;, pero vea L&lt;/¿Qué modificador de conjunto de caracteres está en vigor?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, those variables will never be reinitialized, contrary to
lexical variables that are reinitialized each time their enclosing block
is entered.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, estas variables no se reinicializan, a diferencia de las variables léxicas que se reinicializan cada vez que entran en un bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The old version</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031606Z" changeid="explorer">
        <seg>La versión antigua</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previous versions of Perl tried to map POSIX style character class definitions onto
Unicode property names so that patterns would &quot;dwim&quot; when matches were made against latin-1 or
unicode strings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T001253Z" changeid="explorer">
        <seg>Las versiones anteriores de Perl intentaron mapear las definiciones de clase de caracteres del estilo POSIX a los nombres de las propiedades Unicode para que los patrones pudieran &quot;escribirse tal cual&quot; cuando las coincidencias se aplicaban a cadenas latin-1 o Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec '/bin/echo', 'Your arguments are: ', @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec '/bin/echo', 'Tus argumentos son: ', @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any number of
C&lt;(*MARK)&gt; patterns are allowed, and the NAME portion may be duplicated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T114947Z" changeid="explorer">
        <seg>Está permitido cualquier número de patrones C&lt;(*MARK)&gt;, y la parte del NOMBRE puede ser duplicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO) or die &quot;Can't open $FOO: $!&quot;;	# FOO or bust!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO) or die &quot;No puedo abrir $FOO: $!&quot;;	# ¡FOO o quieto!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make:      1 hour 15 minutes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make:      1 hora 15 minutos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;\t [ @$aref ],\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052825Z" changeid="explorer">
        <seg>print &quot;\t [ @$aref ],\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>le  less than or equal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>le  menor o igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @nums = @caps = ();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @numeros = @mayusculas = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>uopt: Warning: Perl_yylex: this procedure not optimized because it</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004821Z" changeid="explorer">
        <seg>uopt: Warning: Perl_yylex: this procedure not optimized because it</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Portability
X&lt;portability&gt; X&lt;Unix&gt; X&lt;portable&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165322Z" changeid="explorer">
        <seg>=head2 Portabilidad
X&lt;portability&gt; X&lt;Unix&gt; X&lt;portable&gt; X&lt;portabilidad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item NetBSD</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005659Z" changeid="explorer">
        <seg>=item NetBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item substr EXPR,OFFSET,LENGTH,REPLACEMENT
X&lt;substr&gt; X&lt;substring&gt; X&lt;mid&gt; X&lt;left&gt; X&lt;right&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201824Z" changeid="explorer">
        <seg>=item substr EXPR,DESPLAZAMIENTO,LONGITUD,REEMPLAZO
X&lt;substr&gt; X&lt;substring&gt; X&lt;mid&gt; X&lt;left&gt; X&lt;right&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Writing Perl Modules for CPAN&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003430Z" changeid="explorer">
        <seg>=item I&lt;Writing Perl Modules for CPAN&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;perlivp&gt; no longer checks for F&lt;*.ph&gt; files by default.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013639Z" changeid="explorer">
        <seg>C&lt;perlivp&gt;, por defecto, ya no comprueba los archivos F&lt;*.ph&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, &quot;&lt;:encoding(UTF-8)&quot;, &quot;filename&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $fh, &quot;&lt;:encoding(UTF-8)&quot;, &quot;archivo&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m?(barney)?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T212204Z" changeid="explorer">
        <seg>m?(barney)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $key, '=', $ENV{$key}, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $key, '=', $ENV{$key}, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with foreword by Randal L. Schwartz</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003613Z" changeid="explorer">
        <seg>con prólogo de Randal L. Schwartz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(mod_perl 1.x works fine.)
You will also need Apache::Test 1.04 or higher.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T012358Z" changeid="explorer">
        <seg>(mod_perl 1.x funciona bien.) También necesitará Apache::Test 1.04 o superior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like
C&lt;CLONE&gt;, C&lt;CLONE_SKIP&gt; is called once per package; however, it is called
just before cloning starts, and in the context of the parent thread.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T195236Z" changeid="explorer">
        <seg>Al igual que C&lt;CLONE&gt;, C&lt;CLONE_SKIP&gt; es llamado una vez por paquete; sin embargo, es llamado justo antes de que comience la clonación, y en el contexto del hilo de ejecución del padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adds C&lt;$Text::Wrap::separator2&gt;, which allows you to preserve existing newlines
but add line-breaks with some other string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040314Z" changeid="explorer">
        <seg>Agrega C&lt;$Text::Wrap::separator2&gt;, que le permite preservar los caracteres de nueva línea presentes, pero añade nuevas rupturas de línea usando otras cadenas de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The difference is that C
does not offer named loops combined with loop control.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(La diferencia con C es que no ofrece bucles nominales combinados con control de bucles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlutil		utilities packaged with the Perl distribution</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000449Z" changeid="explorer">
        <seg>perlutil		Utilidades empaquetadas en una distribución Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Win32 portability fix</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Arreglo en la portabilidad de Win32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No one is actively supporting Perl 4.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200827Z" changeid="explorer">
        <seg>Actualmente nadie ofrece soporte para Perl 4 de forma activa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|                 # or</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231729Z" changeid="explorer">
        <seg>|                 # o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a simpleminded Pascal comment stripper</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># elimina ingenuamente comentarios Pascal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;@INC&quot;			locations of perl libraries</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001543Z" changeid="explorer">
        <seg>&quot;@INC&quot;			ubicación de bibliotecas de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The author.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222749Z" changeid="explorer">
        <seg>El autor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What's happening is
that you've asked &quot;Is it true that at the start of $x, following 0 or more
non-digits, you have something that's not 123?&quot;  If the pattern matcher had
let C&lt;\D*&gt; expand to &quot;ABC&quot;, this would have caused the whole pattern to
fail.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170759Z" changeid="explorer">
        <seg>Lo que pasa es que usted ha preguntado &quot;¿Es verdad que al principio de $x, después de 0 o más no-dígitos, tiene algo que no es 123?&quot; Si el reconocedor de patrones hubiese dejado que se expandiera C&lt;\D*&gt; a &quot;ABC&quot;, habría causado que todo el patrón fallara.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, it'll need
to be executable first, so C&lt;chmod 755 script.pl&gt; (under Unix).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224647Z" changeid="explorer">
        <seg>Por supuesto, antes deberá marcarlo como ejecutable con el comando C&lt;chmod 755 script.pl&gt; (en Unix).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltru64		Perl notes for Tru64</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perltru64		Notas para Tru64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, C&lt;&quot;$foo XXX '@arr'&quot;&gt; becomes:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, C&lt;&quot;$foo XXX '@arr'&quot;&gt; se convierte en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>IO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rand EXPR
X&lt;rand&gt; X&lt;random&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194331Z" changeid="explorer">
        <seg>=item rand EXPR
X&lt;rand&gt; X&lt;random&gt; X&lt;aleatorio&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = &quot;ABC123&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050422Z" changeid="explorer">
        <seg>$_ = &quot;ABC123&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item my TYPE EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item my TYPE EXPR : ATRIBUTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Cannot open $filename: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T131919Z" changeid="zipf">
        <seg>or die &quot;No se puede abrir $archivo: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq6		Regexes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq6		Expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although in early versions of Perl,
an undefined scalar could become defined when first used in a
place expecting a defined value, this no longer happens except for
rare cases of autovivification as explained in L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque en las versiones anteriores de Perl, un escalar no definido podía llegar a ser definido la primera vez que se usaba en cualquier lugar que esperase un valor definido, esto no va a ocurrir más, excepto en los raros casos de &quot;autovivificación&quot; que se explican en L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*\D)(\d+)$</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233817Z" changeid="explorer">
        <seg>(.*\D)(\d+)$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Binary strings&gt;, or B&lt;byte strings&gt; are made of bytes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234553Z" changeid="explorer">
        <seg>Las B&lt;cadenas binarias&gt; (o B&lt;cadenas de bytes&gt;) están constituidas por bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Symbol table entries can be named with an initial '*',
but you don't really care about that yet (if ever :-).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las entradas de la tabla de símbolos pueden nombrarse empezando por '*', aunque no hace falta que se preocupe por esto ahora (y quizá nunca deba hacerlo :-).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it's possible to confuse Perl into thinking C&lt;//&gt; (the empty
regex) is really C&lt;//&gt; (the defined-or operator).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que es posible confundir a Perl haciéndolo creer que C&lt;//&gt; (la expresión regular vacía) es en realidad C&lt;//&gt; (el operador definido-o).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should use Perl's &quot;plain old documentation&quot; (POD) for your general 
technical documentation, though you may wish to write additional
documentation (white papers, tutorials, etc) in some other format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023859Z" changeid="explorer">
        <seg>Debe usar &quot;documentación simple y llana&quot; de Perl (POD) para su documentación técnica en general, aunque es posible que desee escribir documentación adicional (papeles, manuales, etc) en algún otro formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;rmdir&gt; instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilice C&lt;rmdir&gt; en su lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9 mtime               9 bitmask      @ARGV command line args</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224350Z" changeid="explorer">
        <seg>9 mtime               9 máscara bits    @ARGV args línea comandos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They're more readable than the C-style operators, but have
different precedence to C&lt;&amp;&amp;&gt; and friends.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225248Z" changeid="explorer">
        <seg>Ofrecen más legibilidad que los operadores tipo C correspondientes, como C&lt;&amp;&amp;&gt;, pero su precedencia es distinta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The core always sets I&lt;level&gt; to 0 when it calls your
function - the parameter is provided to allow your implementation to track
depth if it needs to recurse.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114449Z" changeid="explorer">
        <seg>El núcleo siempre pone &lt;nivel&gt; a 0 cuando se llama a la función - el parámetro es proporcionado para permitir su implementación para realizar un seguimiento profundo si es necesario que se llame a sí mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This construct is very flexible and powerful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta construcción es muy flexible y poderosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MSG must begin with the native long integer message
type, be followed by the length of the actual message, and then finally
the message itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000900Z" changeid="explorer">
        <seg>MSG debe comenzar con un tipo de mensaje, contenido en un entero nativo largo, seguido por la longitud del mensaje, y finalmente el mensaje mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $Config{intsize},      &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $Config{intsize},      &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>show_year();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021437Z" changeid="explorer">
        <seg>enseña_año();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Building with Borland's compilers on Win32 should work more smoothly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T042846Z" changeid="explorer">
        <seg>Compilando con compiladores Borland en Win32 debería funcionar con más facilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset	    if eof;		# reset ?pat?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T212237Z" changeid="explorer">
        <seg>reset	    if eof;		# reinicia ?patrón?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But now, the only reasons to use C&lt;/o&gt; are either:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T204215Z" changeid="explorer">
        <seg>Pero ahora, las únicas razones para utilizar C&lt;/o&gt; son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 ino    1 minute     1 filename     $0    program name</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224337Z" changeid="explorer">
        <seg>1 ino    1 minuto     1 nombre archivo  $0    nombre programa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Installing the built perl on DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Instalando el perl compilado en DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last component, if any (i.e. C&lt;X&gt;) is simply ignored.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110921T152138Z" changeid="explorer">
        <seg>El último componente, si existe (es decir, C&lt;X&gt;) es, simplemente, ignorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dec = sprintf(&quot;%d&quot;, $int);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225516Z" changeid="explorer">
        <seg>$dec = sprintf(&quot;%d&quot;, $int);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&lt; (?P=NAME) &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003220Z" changeid="explorer">
        <seg>=item C&lt;&lt; (?P=NOMBRE) &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Platform-specific pieces of the build system also live in platform-specific
directories like F&lt;win32/&gt;, F&lt;vms/&gt;, etc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014858Z" changeid="explorer">
        <seg>Las partes del sistema de compilación que son específicas de la plataforma se encuentran en directorios específicos de plataforma, como F&lt;win32/&gt;, F&lt;vms/&gt;, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's licensing terms are also more open
than GNU software's tend to be.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200510Z" changeid="explorer">
        <seg>Los términos de la licencia de Perl también son más flexibles en general que los de las licencias de software GNU.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules shipped as part of the Perl core live in four subdirectories.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014334Z" changeid="explorer">
        <seg>Los módulos distribuidos como parte del núcleo de Perl se encuentran en cuatro subdirectorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;`STRING`&quot;&gt; and L&lt;/exec&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop/&quot;`STRING`&quot;&gt; y L&lt;/exec&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perllinux		Perl notes for Linux</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perllinux		Notas para Linux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$on_a_tty = -t STDIN &amp;&amp; -t STDOUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$en_un_tty = -t STDIN &amp;&amp; -t STDOUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently the following new features are available: C&lt;switch&gt; (adds a
switch statement), C&lt;~~&gt; (adds a Perl 6-like smart match operator), C&lt;say&gt;
(adds a C&lt;say&gt; built-in function), and C&lt;err&gt; (adds an C&lt;err&gt; keyword).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103203Z" changeid="explorer">
        <seg>En la actualidad, están disponibles las siguientes nuevas características: C&lt;switch&gt; (añade una instrucción switch), C&lt;~~&gt; (añade un operador Perl 6 de emparejamiento inteligente), C&lt;say&gt; (añade una función incorporada C&lt;say&gt;), y C&lt;err&gt; (añade una palabra clave C&lt;err&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, case-insensitive matching works on the full set of Unicode
characters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T173134Z" changeid="explorer">
        <seg>Además, el sistema de coincidencia, insensible al tamaño de caja, funciona en el conjunto de caracteres Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raises an exception if truncate isn't implemented
on your system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lanza una excepción si truncate no está implementada en el sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qq/STRING/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item qq/STRING/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is quite safe and will not
produce an endless loop, since C&lt;__WARN__&gt; hooks are not called from
inside one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que esto es bastante seguro y no producirá un bucle sin fin, puesto que los enganches C&lt;__WARN__&gt; no son llamados desde el interior de uno mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The customary Unix
meaning of C&lt;\1&gt; is kludged in for C&lt;s///&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T225523Z" changeid="explorer">
        <seg>El significado Unix habitual de C&lt;\1&gt; es chapuceado dentro de C&lt;s///&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our $bar;      # declares $Foo::bar for rest of lexical scope</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>our $bar;      # declara $Foo::bar para el resto del ámbito léxico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imports some semantics into the current package from the named module,
generally by aliasing certain subroutine or variable names into your
package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Importa semántica en el paquete actual desde el módulo que se indica, generalmente por medio de alias de ciertas subrutinas o nombres de variables en su paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>binmode(SOCKET, &quot;:utf8&quot;) only worked on the input side, not on the
output side of the socket.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T011001Z" changeid="explorer">
        <seg>binmode(SOCKET, &quot;:utf8&quot;) solo funciona en el lado de la entrada, no en la salida del I&lt;socket&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($^O ne 'VMS')</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015211Z" changeid="explorer">
        <seg>if ($^O ne 'VMS')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POD documentation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031954Z" changeid="explorer">
        <seg>Documentación POD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, grep returns aliases into the original list, much as a for
loop's index variable aliases the list elements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Semejantemente, grep devuelve alias de la lista original, como los alias de los elementos de la lista de las variables de los bucles for.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not a C float&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es flotante en C&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unlike normal C&lt;open&gt;, the first
argument is I&lt;not&gt; a filehandle, even though it looks like one).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005808Z" changeid="explorer">
        <seg>(A diferencia de un C&lt;open&gt; normal, el primer argumento I&lt;no&gt; es un identificador de archivo, aunque lo parezca).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Sam Tregar</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003432Z" changeid="explorer">
        <seg>Sam Tregar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using ExtUtils::MakeMaker this will usually be:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024922Z" changeid="explorer">
        <seg>Cuando se utiliza ExtUtils::MakeMaker serán algo así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chop $str;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001236Z" changeid="explorer">
        <seg>chop $str;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@args = (&quot;command&quot;, &quot;arg1&quot;, &quot;arg2&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@args = (&quot;comando&quot;, &quot;arg1&quot;, &quot;arg2&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl_mro_set_private_data(aTHX_ meta, &amp;c3_alg, private_sv);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115248Z" changeid="explorer">
        <seg>Perl_mro_set_private_data(aTHX_ meta, &amp;c3_alg, private_sv);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shortening an array this way destroys intervening values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Acortar un array de esta forma destruye los valores involucrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of C&lt;\K&gt; inside of another look-around assertion
is allowed, but the behaviour is currently not well defined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212145Z" changeid="explorer">
        <seg>El uso de C&lt;\K&gt; dentro de otra aserción consiguiente está permitida, pero el comportamiento no está, actualmente, bien definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL while (EXPR) BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA while (EXPR) BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Known Problems with Perl on Hurd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Problemas conocidos de Perl sobre Hurd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Rick Delaney)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T111946Z" changeid="explorer">
        <seg>(Rick Delaney)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, you don't have
characters, just bytes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234556Z" changeid="explorer">
        <seg>Contienen bytes, no caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-201-65788-3 [2 edition, October 1999]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003728Z" changeid="explorer">
        <seg>ISBN 978-0-201-65788-3 [2ª edición - Octubre de 1999]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this is
I&lt;NOT&gt; true in C&lt;eval{}&gt;, C&lt;sub{}&gt;, or contrary to popular belief
C&lt;do{}&gt; blocks, which do I&lt;NOT&gt; count as loops.)  The C&lt;continue&gt;
block is optional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Note que esto I&lt;NO&gt; es verdad en C&lt;eval{}&gt;, C&lt;sub{}&gt;, y contrariamente a la creencia popular, bloques C&lt;do{}&gt;, que I&lt;NO&gt; cuentan como bucles). El bloque C&lt;continue&gt; es opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but doesn't spit out extra fields.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232153Z" changeid="explorer">
        <seg>pero no escupe campos extra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The Perl compiler suite as a whole continues
to be experimental.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180618Z" changeid="explorer">
        <seg>(El paquete del compilador de Perl, en su conjunto, sigue siendo experimental.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Give more meaningful error messages from C&lt;if&gt; when invoked with a
condition in list context.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032800Z" changeid="explorer">
        <seg>Da mensajes de error más significativos cuando se invoca C&lt;if&gt; con una condición en contexto de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also how
it should always have been done: letting the Perl_-less forms to leak
from the core was an accident.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001120Z" changeid="explorer">
        <seg>Esta también es la forma en que siempre se debería haber hecho: dejar que los formularios Perl agotasen el núcleo fue un accidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just set the environment variable
PERL_SIGNALS to C&lt;unsafe&gt;, and the old immediate (and unsafe)
signal handling behaviour returns.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T154808Z" changeid="explorer">
        <seg>Sólo tiene que configurar la variable de entorno PERL_SIGNALS a C&lt;unsafe&gt;, e inmediatamente el antiguo (y peligroso) comportamiento de la gestión de señales volverá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But if you
ask this question of someone who isn't a computer scientist, they might
tell you that a I&lt;program&gt; has been compiled to physical machine code
once and can then be run multiple times, whereas a I&lt;script&gt; must be
translated by a program each time it's used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231820Z" changeid="explorer">
        <seg>Pero si hace esta pregunta a alguien que no es un científico de computación, pueden decirle que un I&lt;programa&gt; se compila para generar código máquina físico que se puede ejecutar repetidamente, mientras que un I&lt;script&gt; debe ser traducido por un programa cada vez que se ejecuta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently there are no known holes in C&lt;suidperl&gt;, but previous
experience shows that we cannot be confident that these were the last.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T103646Z" changeid="explorer">
        <seg>Actualmente no hay ningún agujero conocido en C&lt;suidperl&gt;, pero la experiencia anterior muestra que no podemos estar seguros de que estos fueron los últimos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hersockaddr    = getpeername(SOCK);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$hersockaddr    = getpeername(SOCK);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt; and C&lt;V&gt; accept the C&lt;!&gt; modifier to
represent signed 16-/32-bit integers in big-/little-endian order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt; y C&lt;V&gt; aceptan el modificador C&lt;!&gt; para representar enteros de 16-/32-bit con signo en distinta ordenación de bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if L&lt;C&lt;S&lt;use encoding&gt;&gt;|encoding&gt; is in effect, the
number is considered to be in that encoding, and is translated from that into
the platform's native encoding if there is a corresponding native character;
otherwise to Unicode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T221603Z" changeid="explorer">
        <seg>Y si L&lt;C&lt;S&lt;use encoding&gt;&gt;|encoding&gt; está activo, el número es considerado que está en esa codificación, y es traducido en la codificación nativa de la plataforma si existe un carácter local correspondiente; de lo contrario, es traducido a Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;Parse::CPAN::Meta&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010649Z" changeid="explorer">
        <seg>=item C&lt;Parse::CPAN::Meta&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+15241578780673678515622620750190521</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033308Z" changeid="explorer">
        <seg>+15241578780673678515622620750190521</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;a &quot; . $b . &quot; -&gt; {c}&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054412Z" changeid="explorer">
        <seg>&quot;a &quot; . $b . &quot; -&gt; {c}&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore a C&lt;/&gt; terminates a C&lt;qq//&gt; construct, while a C&lt;]&gt; terminates
C&lt;qq[]&gt; and C&lt;qq]]&gt; constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto, una C&lt;/&gt; termina una construcción C&lt;qq//&gt;, mientras que un C&lt;]&gt; termina las construcciones C&lt;qq[]&gt; y C&lt;qq]]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although not for the faint of heart, Perl does support a C&lt;goto&gt;
statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013534Z" changeid="explorer">
        <seg>Aunque no sea muy querido, Perl soporta la instrucción C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is just a selected list of some of the more notable changes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es sólo una selección de algunos de los cambios más notables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The experimental versions may include features that
don't make it into the stable versions, and have an odd number as the
minor release (i.e. perl5.9.x, where 9 is the minor release).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T225624Z" changeid="explorer">
        <seg>Las versiones experimentales pueden incluir características que no se incluyen en las versiones estables; en este caso el número de versión secundaria es un número impar (p. ej., perl5.9.x, donde 9 es la versión secundaria).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We see this as the
lesser of two evils.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vemos esto como el menor de dos males.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt;ABC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt;ABC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The precedence is a little lower
than || and &amp;&amp;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La precedencia es un poco menor que || y &amp;&amp;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth
iteration of the outermost C&lt;(?:)*&gt; matches a zero-length string, it stops
the C&lt;*&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T232111Z" changeid="explorer">
        <seg>Tenga en cuenta que &quot;hola&quot; sólo se imprime una vez, ya que cuando Perl ve la sexta iteración del C&lt;(?:)*&gt; más exterior coincide con una cadena de longitud cero, detiene a C&lt;*&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Scoping of the C&lt;sort&gt; pragma</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192525Z" changeid="explorer">
        <seg>=head2 Ámbito del pragma C&lt;sort&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The L&lt;File::stat&gt; module provides a convenient, by-name access mechanism:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo &lt;File::stat&gt; proporciona un conveniente mecanismo de acceso por nombre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\b  Match a word boundary</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225642Z" changeid="explorer">
        <seg>\b  Coincide con un límite de palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some
systems, a value of 0 indicates that there are processes still running.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas, un valor de 0 indica que hay procesos en funcionamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because the C&lt;(?!foo)&gt; is just saying that
the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will
match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T210950Z" changeid="explorer">
        <seg>Esto es así porque C&lt;(?!foo)&gt; está diciendo que la siguiente cosa no puede ser &quot;foo&quot;, y no lo es, es &quot;bar&quot;, por lo que &quot;foobar&quot; sí que coincidirá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In C&lt;&lt; native floating point --&gt; native integer &gt;&gt; conversions the magnitude
of the result is less than or equal to the magnitude of the source.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232824Z" changeid="explorer">
        <seg>En las conversiones C&lt;&lt; punto flotante nativo --&gt; entero nativo &gt;&gt;, la magnitud del resultado es menor o igual que la magnitud del número de origen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 4) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 4) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given($foo) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>given($foo) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last two would be the
$0 and the $s variables in the (presumably) non-existent package
C&lt;who&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La última sería una variable $0 en un (presumiblemente) inexistente paquete C&lt;quien&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-52812-6 [3rd edition August 2006]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003552Z" changeid="explorer">
        <seg>ISBN 978-0-596-52812-6 [3ª edición - Agosto de 2006]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item redo</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item redo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can browse and search
the Perl 5 bugs at F&lt;http://bugs.perl.org/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T002425Z" changeid="explorer">
        <seg>Puede navegar y buscar por los errores de Perl 5 en F&lt;http://bugs.perl.org/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't disambiguate that by saying C&lt;\{1}000&gt;, whereas you can fix it with
C&lt;${1}000&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T225829Z" changeid="explorer">
        <seg>No puede eliminar la ambigüedad diciendo C&lt;\{1}000&gt;, mientras que lo puede arreglar con C&lt;${1}000&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For string conversions, specifying a precision truncates the string
to fit the specified width:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las conversiones de cadena, especificando una precisión trunca la cadena a la anchura especificada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So you write this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050517Z" changeid="explorer">
        <seg>Así que escribe esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$@%&amp;* dereference     $$foo{bar}     aka $foo-&gt;{bar}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224140Z" changeid="explorer">
        <seg>$@%&amp;* resolver referencia   $$foo{bar}     equivale a $foo-&gt;{bar}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A problem where the state of the regexp engine would sometimes get clobbered when running
under the debugger has been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030053Z" changeid="explorer">
        <seg>Un problema donde el estado del motor de expresiones regulares, algunas veces, se sobrecargaba cuando se ejecutaba en el depurador, se ha solucionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -C0 -ne 'printf &quot;%v02X\n&quot;, $_ for unpack(&quot;C0A*&quot;, $_)'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003612Z" changeid="explorer">
        <seg>perl -C0 -ne 'printf &quot;%v02X\n&quot;, $_ for unpack(&quot;C0A*&quot;, $_)'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Semaphore trouble: $!\n&quot; unless semop($semid, $semop);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;Problema son semáforo: $!\n&quot; unless semop($semid, $semop);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should also try to ask people who 
are already familiar with the module's application domain and the CPAN
naming system.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015521Z" changeid="explorer">
        <seg>También debería tratar de pedir a las personas que ya están familiarizadas con el dominio de aplicación del módulo y el sistema de nombres de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;IO&gt; upgraded to version 1.22</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032820Z" changeid="explorer">
        <seg>C&lt;IO&gt; actualizado a la versión 1.22</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Double Quotes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Dobles comillas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other
systems like OS/2, DOS, and the various flavors of MS-Windows, your program
sees a C&lt;\n&gt; as a simple C&lt;\cJ&gt;, but what's stored in text files are the
two characters C&lt;\cM\cJ&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022835Z" changeid="explorer">
        <seg>En otros sistemas como OS/2, DOS y los distintos sabores de MS-Windows, tu programa ve un C&lt;\n&gt; como un simple C&lt;\cJ&gt;, pero es almacenado en los archivos de texto como los dos caracteres C&lt;\cM\cJ&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It bypasses
buffered IO, so mixing this with other kinds of reads, C&lt;print&gt;,
C&lt;write&gt;, C&lt;seek&gt;, C&lt;tell&gt;, or C&lt;eof&gt; can cause confusion because the
perlio or stdio layers usually buffers data.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110307T000816Z" changeid="explorer">
        <seg>Omite E/S con búfer, por lo que mezclar esto con otros tipos de lecturas, C&lt;print&gt;, C&lt;write&gt;, C&lt;seek&gt;, C&lt;tell&gt;, o C&lt;eof&gt; puede causar confusión porque las capas Perlio o stdio por lo general usan búfer de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.  Null-fill or truncate to absolute position specified by the value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050454Z" changeid="explorer">
        <seg>.  Relleno con nulos o truncado a una posición absoluta especificada por el valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It formats (see L&lt;perlform&gt;) a list of values according to the
contents of PICTURE, placing the output into the format output
accumulator, C&lt;$^A&gt; (or C&lt;$ACCUMULATOR&gt; in English).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Formatea (ver L&lt;perlform&gt;) una lista de valores de acuerdo a los contenidos de CUADRO, colocando la salida en el acumulador de salida de format, C&lt;$^A&gt; (o C&lt;$ACCUMULATOR&gt; en English).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item return EXPR
X&lt;return&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194632Z" changeid="explorer">
        <seg>=item return EXPR
X&lt;return&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following things B&lt;might&gt; happen in future.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T012635Z" changeid="explorer">
        <seg>Las siguientes cosas B&lt;pueden&gt; suceder en el futuro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this to break up
your regular expression into (slightly) more readable parts.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar esto para romper la expresión regular en partes (un poco) más legibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;find2perl|find2perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234223Z" changeid="explorer">
        <seg>=item L&lt;find2perl|find2perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;IPC::Open3&gt; upgraded to version 1.02</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032846Z" changeid="explorer">
        <seg>C&lt;IPC::Open3&gt; actualizado a la versión 1.02</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Preamble</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Preámbulo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While not quite all Perl 4 scripts run flawlessly
under Perl 5, an update to perl should nearly never invalidate a program
written for an earlier version of perl (barring accidental bug fixes
and the rare new keyword).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230249Z" changeid="explorer">
        <seg>Aunque no todos los scripts de Perl 4 se ejecutan sin errores en Perl 5, una actualización de perl no invalidará casi nunca un programa escrito para una versión anterior de perl (salvo correcciones de errores accidentales o una palabra clave nueva).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The collected standard output of the command is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo lo que salga por la salida estándar del comando se devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Jarkko Hietaniemi &lt;jhi@iki.fi&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005413Z" changeid="explorer">
        <seg>Jarkko Hietaniemi &lt;jhi@iki.fi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A unary operator generally provides scalar context to its
argument, while a list operator may provide either scalar or list
contexts for its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110704T234010Z" changeid="explorer">
        <seg>Un operador unario generalmente proveé de un contexto escalar a su argumento, mientras que un operador de listas puede proveer tanto de un contexto escalar o de un contexto de lista, a sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232035Z" changeid="explorer">
        <seg>Así que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both failures are not really specific to the Hurd, as indicated by the
test suite output.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020028Z" changeid="explorer">
        <seg>En realidad, estos errores no son específicos de Hurd (como parece indicar el resultado del conjunto de pruebas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$perl_info  = qx(ps $$);            # that's Perl's $$</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$perl_info  = qx(ps $$);            # es el $$ de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a side effect, calling values() resets the HASH or ARRAY's internal
iterator;
see L&lt;/each&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024925Z" changeid="explorer">
        <seg>Como efecto colateral, llamando a values() reinicia el iterador interno del HASH o ARRAY; vea L&lt;/each&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>refers to the collection of files distributed by the
Copyright Holder, and derivatives of that collection of files created
through textual modification.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>se refiere a la colección de archivos distribuidos por el Titular del Copyright, y derivados de esa colección de archivos creados mediante la modificación del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perlstyle&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031843Z" changeid="explorer">
        <seg>=item L&lt;perlstyle&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, a reasonably
portable way to find out the home directory might be:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto, un forma razonablemente portátil para averiguar el directorio principal podría ser:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(INPUT, 'foo')          # get sort's results</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(INPUT, 'foo')          # obtener los resultado de sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Quantifiers can be used to specify how many of the previous thing you
want to match on, where &quot;thing&quot; means either a literal character, one
of the metacharacters listed above, or a group of characters or
metacharacters in parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225437Z" changeid="explorer">
        <seg>Los cuantificadores se utilizan para especificar cuántas coincidencias de lo anterior (un carácter literal, uno de los metacaracteres antes especificados o un grupo de caracteres o metacaracteres entre paréntesis) se desea detectar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hopefully the contents of each of the filters should be
self-explanatory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111003T121458Z" changeid="zipf">
        <seg>El contenido de cada filtro debe ser autodescriptivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbook - Books about and related to Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T002814Z" changeid="explorer">
        <seg>perlbook - Libros sobre Perl y otros libros relacionados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(ARGV, $ARGV);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(ARGV, $ARGV);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each result bit is based on the least-significant bit of the corresponding
input character, i.e., on C&lt;ord($char)%2&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada bit resultante se basa en el bit menos significativo del correspondiente carácter de la entrada, es decir, en C&lt;ord($carácter)%2&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'aaaaaaaaaaaa' =~ /((a{0,5}){0,5})*[c]/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003546Z" changeid="explorer">
        <seg>'aaaaaaaaaaaa' =~ /((a{0,5}){0,5})*[c]/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># process argument list of files along with any includes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># procesa la lista de archivos pasados como argumentos junto con cualquier archivo a incluir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^([^ ]*) *([^ ]*)/$2 $1/;     # intercambia las dos primeras palabras</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if C&lt;die&gt; won't do what you want (say, in a CGI script,
where you want to format a suitable error message (but there are
modules that can help with that problem)) always check
the return value from opening a file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso si C&lt;die&gt; no hace lo que usted quiere (por ejemplo, en un script CGI, en la que desea dar formato a un mensaje de error apropiado (aunque existen módulos que pueden ayudar con ese problema)) controle siempre el valor de retorno de la apertura de un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (&lt;NAME&gt;) ('NAME')</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T194643Z" changeid="explorer">
        <seg>=item (&lt;NOMBRE&gt;) ('NOMBRE')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The similarity to the title of the major
Perl book (which came later) is not completely accidental:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003721Z" changeid="explorer">
        <seg>La similitud con el título de libro principal de 
Perl (que se publicó posteriormente) no es totalmente accidental:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IRWXU S_IRUSR S_IWUSR S_IXUSR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_IRWXU S_IRUSR S_IWUSR S_IXUSR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the value of the last evaluated expression of the C&lt;given&gt; block if no
condition is true.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223150Z" changeid="explorer">
        <seg>el valor de la última expresión evaluada del bloque C&lt;given&gt;, si ninguna condición es verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.contexteditor.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://www.contexteditor.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>results in C&lt;&lt; &lt;&gt;&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T232526Z" changeid="explorer">
        <seg>resulta en C&lt;&lt; &lt;&gt;&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;a4&quot;,&quot;abcd&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;a4&quot;,&quot;abcd&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This program is free software; you can redistribute it and/or modify
it under the terms of either:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222825Z" changeid="explorer">
        <seg>Este programa es software libre; puede redistribuirlo y/o modificarlo bajo los términos de:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last Updated: Fri, 29 Oct 1999 22:50:30 +0200</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Last Updated: Fri, 29 Oct 1999 22:50:30 +0200</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to stack multiple here-docs in a row:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es posible apilar múltiples documentos incrustados en una fila:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%+ d&gt;', 12;   # prints &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%+ d&gt;', 12;   # imprime &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;overload&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;sobrecarga&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596000271/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003015Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596000271/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even a one-word documentation patch should
result in a change in version at the sub-minor level.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030023Z" changeid="explorer">
        <seg>Incluso una revisión de documentación de una sola palabra debe dar lugar a un cambio en la versión de nivel más bajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$minutes = $2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$minutos = $2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pop(@a)             splice(@a,-1)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pop(@a)             splice(@a,-1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item bytes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015042Z" changeid="explorer">
        <seg>=item bytes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\z</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000801Z" changeid="explorer">
        <seg>\z</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(*THEN)&gt; C&lt;(*THEN:NAME)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T140850Z" changeid="explorer">
        <seg>=item C&lt;(*THEN)&gt; C&lt;(*THEN:NOMBRE)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Makes C&lt;shift;&gt; 5%
faster over C&lt;shift @_;&gt; on not threaded perl and 25% faster on threaded.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T054256Z" changeid="explorer">
        <seg>Hace a un C&lt;shift;&gt; un 5% más rápido que C&lt;shift @_;&gt; en un perl sin hebras y un 25% más rápido en uno con hebras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># or just leave it undef to autoviv</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T000205Z" changeid="explorer">
        <seg># o simplemente dejarlo indefinido, para autovivificarlo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>default {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $key (sort(keys %ENV)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $key (sort(keys %ENV)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>% perl -le 'print for @INC'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225436Z" changeid="explorer">
        <seg>% perl -le 'print for @INC'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item join EXPR,LIST
X&lt;join&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174111Z" changeid="explorer">
        <seg>=item join EXPR,LISTA
X&lt;join&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document needs a rewrite that separates the tutorial content
from the reference content.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T004126Z" changeid="explorer">
        <seg>Este documento necesita una reescritura que separe el contenido de manual del contenido de referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Overview</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000139Z" changeid="explorer">
        <seg>=head2 Introducción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general the cure
is to sort the keys (or the values); in particular for Data::Dumper to
use the C&lt;Sortkeys&gt; option.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135547Z" changeid="explorer">
        <seg>En general, la cura es ordenar las claves (o valores); en particular para Data::Dumper use la opción C&lt;Sortkeys&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note
that the delimiter may be longer than one character.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tenga en cuenta que el delimitador puede ser más largo que un carácter).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@animals[1..$#animals];         # gives all except the first element</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T214003Z" changeid="explorer">
        <seg>@animales[1..$#animales];  # devuelve todos excepto el primero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So will C&lt;next&gt;, but since it will execute a C&lt;continue&gt;
block, it may be more entertaining.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También C&lt;next&gt;, pero como ejecutará un bloque C&lt;continue&gt;, quizás se convierta en algo divertido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>are exempt from warnings (because they care about truth rather than
definedness).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>están exentos de esos avisos (porque tienen en cuenta el valor de verdad en vez de ver si está definido).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub/&quot;Persistent variables via state()&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T000715Z" changeid="explorer">
        <seg>Vea L&lt;perlsub/&quot;Variables persistentes vía state()&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;threads::shared&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;threads::shared&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Testing Perl on DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Comprobando Perl en DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, en</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ISA = qw(Foo);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015306Z" changeid="explorer">
        <seg>@ISA = qw(Foo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unlink LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item unlink LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically
used as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Típicamente se usa como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;s2p|s2p&gt; and L&lt;psed&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234201Z" changeid="explorer">
        <seg>=item L&lt;s2p|s2p&gt; y L&lt;psed&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the arguments are omitted,
it defaults to C&lt;0,0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los argumentos son omitidos, el valor predeterminado es C&lt;0,0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($curpos = tell(FILE); $_ = &lt;FILE&gt;;
             $curpos = tell(FILE)) {
            # search for some stuff and put it into files</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051322Z" changeid="explorer">
        <seg>for ($curpos = tell(FILE); $_ = &lt;FILE&gt;;
             $curpos = tell(FILE)) {
            # buscar por algo y ponerlo en los archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means for example that the
Unicode character properties are as in Unicode 4.0.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170751Z" changeid="explorer">
        <seg>Esto significa que, por ejemplo, las propiedades de caracteres Unicode son como en Unicode 4.0.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless (EXPR) BLOCK else BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless (EXPR) BLOQUE else BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item hex EXPR
X&lt;hex&gt; X&lt;hexadecimal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173911Z" changeid="explorer">
        <seg>=item hex EXPR
X&lt;hex&gt; X&lt;hexadecimal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perlivp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234323Z" changeid="explorer">
        <seg>=item L&lt;perlivp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay una línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the current priority for a process, a process group, or a user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la prioridad actual de un proceso, un grupo de procesos o un usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior is undefined if LENGTH is greater than the length of the
file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento no está definido si LONGITUD es mayor que la longitud del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's too
long and an explicit count is provided, C&lt;Z&gt; packs only C&lt;$count-1&gt; bytes,
followed by a null byte.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si es demasiado largo y se indica un contador explícito, C&lt;Z&gt; empaqueta solo C&lt;$contador-1&gt; bytes, seguido por un byte nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filehandles STDIN, STDOUT, and STDERR are predefined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013950Z" changeid="explorer">
        <seg>Los identificadores de archivo STDIN, STDOUT y STDERR están predefinidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.5g&gt;', 100.01; # prints &quot;&lt;100.01&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.5g&gt;', 100.01; # imprime &quot;&lt;100.01&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When
you write to the database you will have to use something like this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110812T145123Z" changeid="zipf">
        <seg>Para escribir en la base de datos debe usar una instrucción similar a la siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously, F&lt;.pmc&gt; files were loaded only if more recent than the
matching F&lt;.pm&gt; file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T235605Z" changeid="explorer">
        <seg>Anteriormente, los archivos F&lt;.pmc&gt; sólo se cargaban si eran más recientes que el archivo F&lt;.pm&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot currently get the precision from a specified number,
but it is intended that this will be possible in the future, for
example using C&lt;.*2$&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Actualmente, no se puede conseguir la precisión de un número determinado, pero es intención de que esto será posible en el futuro, por ejemplo, con C&lt;.*2$&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; MiXeD&quot;),        redo LOOP if /\G\pL+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030119Z" changeid="explorer">
        <seg>print(&quot; MeZcLaDoS&quot;),	redo LOOP if /\G\pL+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is the output (split into several lines):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí está la salida (dividido en varias líneas):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say $x * $x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033306Z" changeid="explorer">
        <seg>say $x * $x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>give non-standard executables non-standard names, and clearly
document the differences in manual pages (or equivalent), together with
instructions on where to get the Standard Version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dar nombres no estándares a los ejecutables no estándares, y claramente documentar las diferencias en páginas del manual (o equivalente), junto con instrucciones sobre dónde obtener la Versión Estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backslash interpolation also happens at
compile time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La interpolación de contrabarras también sucede en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some frequently seen examples:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos ejemplos que suelen encontrarse frecuentemente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As more readable alternatives to C&lt;&amp;&amp;&gt; and C&lt;||&gt; when used for
control flow, Perl provides the C&lt;and&gt; and C&lt;or&gt; operators (see below).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220049Z" changeid="explorer">
        <seg>Como alternativas más legibles a C&lt;&amp;&amp;&gt; y C&lt;||&gt; cuando se usan para control de flujo, Perl proporciona los operadores C&lt;and&gt; y C&lt;or&gt; (vea más adelante).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 readdir()/closedir()/etc. attempted on invalid dirhandle</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040622Z" changeid="explorer">
        <seg>=head2 readdir()/closedir()/etc. attempted on invalid dirhandle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perltie&gt; and L&lt;AnyDBM_File&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001201Z" changeid="explorer">
        <seg>Se describe en L&lt;perltie&gt; y L&lt;AnyDBM_File&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>followed by</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005854Z" changeid="explorer">
        <seg>seguido por</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;color = $color, animal = $animal\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T220525Z" changeid="explorer">
        <seg>print &quot;color = $color, animal = $animal\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0377                # octal (only numbers, begins with 0)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0377                # octal (solo números, comenzando con 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be aware that the optimizer might have optimized call frames away before
C&lt;caller&gt; had a chance to get the information.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuidado con el optimizador, que puede optimizar marcos de llamada antes de que C&lt;caller&gt; tenga la oportunidad de obtener la información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array of an array is just a regular old array @AoA that you can
get at with two subscripts, like C&lt;$AoA[3][2]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un array de un array es justo un array @AoA normal sobre la que se puede aplicar dos subíndices, como C&lt;$AoA[3][2]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($quote = &lt;&lt;'FINIS') =~ s/^\s+//gm;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($quote = &lt;&lt;'FINIS') =~ s/^\s+//gm;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some modules available both within the perl core and independently from CPAN
(&quot;dual-life modules&quot;) have not yet had these changes applied; the changes
will be integrated into future stable perl releases as the modules are
updated on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T104608Z" changeid="explorer">
        <seg>Algunos módulos disponibles, tanto en el núcleo de perl e independientes de CPAN (&quot;módulos con doble vida&quot;) aún no han tenido los cambios aplicados; los cambios se integrarán en futuras versiones estables de perl, ya que los módulos se actualizan en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid using C&lt;grep()&gt; (or C&lt;map()&gt;) or `backticks` in a void context, that is,
when you just throw away their return values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evite usar C&lt;grep()&gt; (o C&lt;map()&gt;) o `acentos graves` en contexto nulos, es decir, cuando usted no va usar los valores de retorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Support C&lt;inf&gt; for C&lt;make&gt;/C&lt;emake&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033357Z" changeid="explorer">
        <seg>Soporte de C&lt;inf&gt; para C&lt;make&gt;/C&lt;emake&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item push EXPR,LIST</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T180430Z" changeid="explorer">
        <seg>=item push EXPR,LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference is that you're now
using characters instead of bytes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235205Z" changeid="explorer">
        <seg>La única diferencia es que ahora trabajamos con caracteres en lugar de bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unnecessary assignment optimised away in</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T105206Z" changeid="explorer">
        <seg>Optimizadas las asignaciones innecesarias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C&lt;if&gt;, C&lt;unless&gt; can be followed
by C&lt;else&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como C&lt;if&gt;, C&lt;unless&gt; puede ser seguido por C&lt;else&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another description starts with notions of &quot;better&quot;/&quot;worse&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T234113Z" changeid="explorer">
        <seg>Otra descripción comienza con las nociones de &quot;mejor&quot;/&quot;peor&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item CGI</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item CGI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl
5.8.1 the ordering is different even between different runs of Perl
for security reasons (see L&lt;perlsec/&quot;Algorithmic Complexity Attacks&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde Perl 5.8.1 la ordenación es diferente incluso entre diferentes ejecuciones de Perl por razones de seguridad (ver L&lt;perlsec/&quot;Ataques por Complejidad Algorítmica&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mainly due to security reasons, the &quot;random ordering&quot; of hashes
has been made even more random.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030610Z" changeid="explorer">
        <seg>Debido principalmente a razones de seguridad, el &quot;orden aleatorio&quot; de los hashes se ha hecho aún más aleatorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment to a list (or slice, which is just a list
anyway) also evaluates the right-hand side in list context.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T145426Z" changeid="explorer">
        <seg>La asignación a una lista (o a una porción, que también es una lista después de todo) también evalúa el lado derecho en contexto de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's probably because you forgot libraries, or library paths differ.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225843Z" changeid="explorer">
        <seg>Probablemente se deba a que olvidó copiar las bibliotecas, o a que las rutas de acceso de las bibliotecas difieren.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 1-59059-454-1 [1st edition July 2005]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003652Z" changeid="explorer">
        <seg>ISBN 1-59059-454-1 [1ª edición - Julio de 2005]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T182751Z" changeid="explorer">
        <seg>\)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will automatically accept all the defaults and
in particular /usr/local/ as installation directory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto, automáticamente, aceptará todos los valores predeterminados y, en particular, /usr/local/ como directorio de instalación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Math::BigFloat</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014826Z" changeid="explorer">
        <seg>=item Math::BigFloat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;ExtUtils::Constant&gt; upgraded to version 0.17</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031102Z" changeid="explorer">
        <seg>C&lt;ExtUtils::Constant&gt; actualizado a la versión 0.17</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item each ARRAY
X&lt;array, iterator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171532Z" changeid="explorer">
        <seg>=item each ARRAY
X&lt;array, iterator&gt; X&lt;array, iterador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;long doubles by default\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;long doubles por defecto\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some examples:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113413Z" changeid="explorer">
        <seg>Aquí algunos ejemplos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.zsh.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225453Z" changeid="explorer">
        <seg>http://www.zsh.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can read this document in the following formats:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede leer este documento en los siguientes formatos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Testing for exact floating-point equality or inequality is not a
good idea.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011231Z" changeid="explorer">
        <seg>No es una buena idea comprobar la igualdad o la desigualdad exacta de números en punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IRIX</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015341Z" changeid="explorer">
        <seg>IRIX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is pretty much useful only to find out whether
Perl's internal hashing algorithm is performing poorly on your data
set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil solamente para conocer si el algoritmo interno de los hashes está teniendo un bajo rendimiento sobre un conjunto de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;-X&gt;, C&lt;binmode&gt;, C&lt;chmod&gt;, C&lt;chown&gt;, C&lt;chroot&gt;, C&lt;crypt&gt;,
C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;dump&gt;, C&lt;endgrent&gt;, C&lt;endhostent&gt;,
C&lt;endnetent&gt;, C&lt;endprotoent&gt;, C&lt;endpwent&gt;, C&lt;endservent&gt;, C&lt;exec&gt;,
C&lt;fcntl&gt;, C&lt;flock&gt;, C&lt;fork&gt;, C&lt;getgrent&gt;, C&lt;getgrgid&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getlogin&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getppid&gt;, C&lt;getpgrp&gt;, C&lt;getpriority&gt;, C&lt;getprotobynumber&gt;,
C&lt;getprotoent&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;, C&lt;getpwuid&gt;,
C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;getsockopt&gt;, C&lt;glob&gt;, C&lt;ioctl&gt;,
C&lt;kill&gt;, C&lt;link&gt;, C&lt;lstat&gt;, C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;,
C&lt;msgsnd&gt;, C&lt;open&gt;, C&lt;pipe&gt;, C&lt;readlink&gt;, C&lt;rename&gt;, C&lt;select&gt;, C&lt;semctl&gt;,
C&lt;semget&gt;, C&lt;semop&gt;, C&lt;setgrent&gt;, C&lt;sethostent&gt;, C&lt;setnetent&gt;,
C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;setprotoent&gt;, C&lt;setpwent&gt;,
C&lt;setservent&gt;, C&lt;setsockopt&gt;, C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;,
C&lt;shmwrite&gt;, C&lt;socket&gt;, C&lt;socketpair&gt;,
C&lt;stat&gt;, C&lt;symlink&gt;, C&lt;syscall&gt;, C&lt;sysopen&gt;, C&lt;system&gt;,
C&lt;times&gt;, C&lt;truncate&gt;, C&lt;umask&gt;, C&lt;unlink&gt;,
C&lt;utime&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165331Z" changeid="explorer">
        <seg>C&lt;-X&gt;, C&lt;binmode&gt;, C&lt;chmod&gt;, C&lt;chown&gt;, C&lt;chroot&gt;, C&lt;crypt&gt;,
C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;dump&gt;, C&lt;endgrent&gt;, C&lt;endhostent&gt;,
C&lt;endnetent&gt;, C&lt;endprotoent&gt;, C&lt;endpwent&gt;, C&lt;endservent&gt;, C&lt;exec&gt;,
C&lt;fcntl&gt;, C&lt;flock&gt;, C&lt;fork&gt;, C&lt;getgrent&gt;, C&lt;getgrgid&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getlogin&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getppid&gt;, C&lt;getpgrp&gt;, C&lt;getpriority&gt;, C&lt;getprotobynumber&gt;,
C&lt;getprotoent&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;, C&lt;getpwuid&gt;,
C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;getsockopt&gt;, C&lt;glob&gt;, C&lt;ioctl&gt;,
C&lt;kill&gt;, C&lt;link&gt;, C&lt;lstat&gt;, C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;,
C&lt;msgsnd&gt;, C&lt;open&gt;, C&lt;pipe&gt;, C&lt;readlink&gt;, C&lt;rename&gt;, C&lt;select&gt;, C&lt;semctl&gt;,
C&lt;semget&gt;, C&lt;semop&gt;, C&lt;setgrent&gt;, C&lt;sethostent&gt;, C&lt;setnetent&gt;,
C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;setprotoent&gt;, C&lt;setpwent&gt;,
C&lt;setservent&gt;, C&lt;setsockopt&gt;, C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;,
C&lt;shmwrite&gt;, C&lt;socket&gt;, C&lt;socketpair&gt;,
C&lt;stat&gt;, C&lt;symlink&gt;, C&lt;syscall&gt;, C&lt;sysopen&gt;, C&lt;system&gt;,
C&lt;times&gt;, C&lt;truncate&gt;, C&lt;umask&gt;, C&lt;unlink&gt;,
C&lt;utime&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, F&lt;s2p&gt; converts F&lt;sed&gt; scripts to Perl programs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234204Z" changeid="explorer">
        <seg>De manera similar, F&lt;s2p&gt; convierte scripts F&lt;sed&gt; en programas Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This emulates the C&lt;syswrite&gt; function (or vice versa):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto emula la función C&lt;syswrite&gt; (o viceversa):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not a decimal number&quot; unless /^-?\d+\.?\d*$/;     # rejects .2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es número real&quot;    unless /^-?\d+\.?\d*$/;     # rechaza .2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$b = '(.)\g{1}';     # Avoids the problems.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191652Z" changeid="explorer">
        <seg>$b = '(.)\g{1}';     # Evita los problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it cannot be
used by itself to fetch single characters without waiting for the user
to hit enter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, esto no puede ser usado para extraer caracteres sueltos sin esperar a que el usuario pulse la tecla de I&lt;Enter&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that
you must fully qualify the sub's name, as unqualified C&lt;INC&gt; is always forced
into package C&lt;main&gt;.)  Here is a typical code layout:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tenga en cuenta que debe cualificar completamente el nombre de la subrutina, así como un no cualificado C&lt;INC&gt; está siempre forzado en el paquete C&lt;main&gt;). Este es un diseño de código típico:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boolean contexts,
such as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contextos booleanos, como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chomp( LIST )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chomp( LISTA )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl 5.8.0 sets C&lt;$^X&gt; where possible to a full path by asking the operating
system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl 5.8.0 pone C&lt;$^X&gt; hasta donde sea posible a todo el camino completo preguntando al sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adds support for Berkeley DB 4.4.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030115Z" changeid="explorer">
        <seg>Añadido soporte para Berkeley DB 4.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They were v-strings from Perl 5.6.0 to
Perl 5.8.0, but that caused more confusion and breakage than good.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fueron v-strings desde Perl 5.6.0 a Perl 5.8.0, pero causó más confusión y problemas, que bienes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$vec = Bit::Vector-&gt;new(32);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225514Z" changeid="explorer">
        <seg>$vec = Bit::Vector-&gt;new(32);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of tell() for the standard streams like the STDIN
depends on the operating system: it may return -1 or something else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de retorno de tell() para los flujos estándares como STDIN depende del sistema operativo: puede devolver -1 o algo más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#      $foo = pack(&quot;WWWW&quot;,193,194,195,196);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#      $foo = pack(&quot;WWWW&quot;,193,194,195,196);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't want it to test the right operand until the
next evaluation, as in B&lt;sed&gt;, just use three dots (&quot;...&quot;) instead of
two.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no quiere poner a prueba el operando derecho hasta la próxima evaluación, al igual que en B&lt;sed&gt;, sólo tiene que utilizar tres puntos (&quot;...&quot;) en lugar de dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to Gerard Goossen from TTY.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110405T001241Z" changeid="explorer">
        <seg>Gerard Goossen de TTY.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item syswrite FILEHANDLE,SCALAR,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013037Z" changeid="explorer">
        <seg>=item syswrite IDENTIFICADOR_ARCHIVO,ESCALAR,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;IMPORTANT&gt;: Without patch 2401, a kernel bug in Irix 6.2 will cause
your machine to panic and crash when running threaded perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004443Z" changeid="explorer">
        <seg>B&lt;IMPORTANTE&gt;: Sin el parche 2401, un error del kernel en Irix 6.2 causará que su máquina entre en pánico y casque cuando ejecute perl enhebrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.7.2 release and the
5.7.3 release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe las diferencias entre la versión 5.7.2 y la versión 5.7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;New C&lt;INIT&gt; keyword&gt;,
L&lt;New C&lt;lock&gt; keyword&gt;, and L&lt;New C&lt;qrE&lt;sol&gt;E&lt;sol&gt;&gt; operator&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T011750Z" changeid="explorer">
        <seg>See L&lt;New C&lt;INIT&gt; keyword&gt;,
L&lt;New C&lt;lock&gt; keyword&gt;, and L&lt;New C&lt;qrE&lt;sol&gt;E&lt;sol&gt;&gt; operator&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\s        [3]  Match a whitespace character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223630Z" changeid="explorer">
        <seg>\s	 [3]  Coincide con un carácter espacio en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$3 = bar(baz)+baz(bop)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185705Z" changeid="explorer">
        <seg>$3 = bar(baz)+baz(bop)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;sysseek&gt; instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use en su lugar C&lt;sysseek&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a += 2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a += 2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%E    like %e, but using an upper-case &quot;E&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%E    como %e, pero usando una letra &quot;E&quot; mayúscula</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the C&lt;eval{}&gt; form as an exception trap in libraries does have some
issues.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar la forma C&lt;eval{}&gt; como una trampa de excepciones en bibliotecas puede tener algunos problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exceptions, C&lt;abs&gt;, C&lt;++&gt; and C&lt;--&gt;, do not change their
behavior with C&lt;use integer;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234030Z" changeid="explorer">
        <seg>Las excepciones son C&lt;abs&gt;, C&lt;++&gt; y C&lt;--&gt;, que no cambian su comportamiento con C&lt;use integer;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Mastering Regular Expressions&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003549Z" changeid="explorer">
        <seg>=item I&lt;Mastering Regular Expressions&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;signal.h&gt; is now always included.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;signal.h&gt; ahora es siempre incluido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All communication with the outside world (anything
outside of your current Perl process) is done in binary.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234600Z" changeid="explorer">
        <seg>La comunicación con el mundo exterior (todo lo que esté fuera del proceso Perl actual) se realiza en binario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It used to do so in Perl 4, but we
had to break this to make sure destructors were called when expected.)
X&lt;$#&gt; X&lt;array, length&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Así solía hacerse en Perl 4, aunque aunque tuvimos que cambiarlo para asegurar que los destructores eran llamados cuando se esperaba hacerlo).
X&lt;$#&gt; X&lt;array, length&gt; X&lt;array, longitud&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're storing handles in an array or hash, or in general whenever
you're using any expression more complex than a bareword handle or a plain,
unsubscripted scalar variable to retrieve it, you will have to use a block
returning the filehandle value instead, in which case the LIST may not be
omitted:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T010401Z" changeid="explorer">
        <seg>Si está almacenando identificadores en un array o hash, o en general, en cualquier expresión más compleja que un simple identificador o una sencilla variable escalar sin subíndice, para acceder a él, tendrá que utilizar un bloque que retorne el valor del identificador de archivo, en cuyo caso la LISTA no puede ser omitida:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will
often point out exactly where the trouble is.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000934Z" changeid="explorer">
        <seg>Normalmente le indicará dónde está el problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rin = '';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051101Z" changeid="explorer">
        <seg>$rin = '';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the final value specified is not in the sequence that the magical
increment would produce, the sequence goes until the next value would
be longer than the final value specified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el valor final especificado no está en la secuencia que el incremento mágico produciría, la secuencia continúa hasta el siguiente valor que sería más largo que el valor final fijado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item order of arguments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item orden de los argumentos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># sort numerically descending</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ordenación numérica descendente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bin = sprintf(&quot;%b&quot;, 3735928559);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225516Z" changeid="explorer">
        <seg>$bin = sprintf(&quot;%b&quot;, 3735928559);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will set C&lt;$res = 4&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T221148Z" changeid="explorer">
        <seg>será C&lt;$res = 4&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But generally, a block is delimited by curly brackets, also known as braces.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero generalmente, un bloque está delimitado por llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport/&quot;Supported Platforms&quot;&gt;
for a listing.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001509Z" changeid="explorer">
        <seg>Encontrará una lista en la sección &quot;Plataformas compatibles&quot; de L&lt;perlport&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@files = glob($files[$i]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@archivos = glob($archivos[$i]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This makes learning Perl easier
for C folks.)  With very few exceptions, these all operate on scalar
values only, not array values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto hace el aprendizaje de Perl más fácil para la gente de C). Con pocas excepciones, todas éstas operan solamente en valores escalares, no en valores de array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't readlink $sym: $!&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo enlazar simbólicamente con $sym: $!&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item return</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item return</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\N{U+I&lt;hex number&gt;}&gt; is
always interpreted as a Unicode code point, so that C&lt;\N{U+0050}&gt; is &quot;P&quot; even
on EBCDIC platforms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T221358Z" changeid="explorer">
        <seg>C&lt;\N{U+I&lt;número hex.&gt;}&gt; siempre es interpretado como un punto de código Unicode, por lo que C&lt;\N{U+0050}&gt; es &quot;P&quot;, incluso en plataformas EBCDIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$me = myname $0 		or die &quot;can't get myname&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$me = minombre $0 		or die &quot;no puedo obtener minombre&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that if a developer only needs a module for the BAR standard,
they should not be forced to install libraries for FOO as well.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015144Z" changeid="explorer">
        <seg>Esto significa que si un desarrollador sólo necesita un módulo para el estándar BAR, no debe verse obligado a instalar las bibliotecas para FOO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the length of the input string is not even, it behaves as if padded by
a null character at the end.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la longitud de la cadena de entrada no es par, se comporta como si estuviera rellenada con un carácter nulo al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you've found a bug with the perl interpreter or one of the modules
in the standard library (those that come with Perl), you can use the
L&lt;perlbug&gt; utility that comes with Perl (&gt;= 5.004).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231154Z" changeid="explorer">
        <seg>Si ha encontrado un error en el intérprete de perl o en uno de los módulos de la biblioteca estándar (los que se incluyen con Perl), puede usar la utilidad L&lt;perlbug&gt; incluida en Perl (&gt;= 5.004) para enviar un informe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note also that
each C&lt;use&gt; statement creates a C&lt;require&gt; frame inside an C&lt;eval EXPR&gt;
frame.)  $subroutine may also be C&lt;(unknown)&gt; if this particular
subroutine happens to have been deleted from the symbol table.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012339Z" changeid="explorer">
        <seg>(Note también que cada instrucción C&lt;use&gt; crea un marco C&lt;require&gt; dentro de un marco C&lt;eval EXPR&gt;).  $subrutina puede ser también C&lt;(unknown)&gt; (desconocida) si esta subrutina en particular parece haber sido borrada de la tabla de símbolos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no such thing as an unvarying, physical
newline character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe tal cosa como un invariable o físico, carácter de nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a regular expression to match, the I&lt;entire&gt; regular expression must
match, not just part of it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T145610Z" changeid="explorer">
        <seg>Para que una expresión regular coincida, debe coincidir la expresión I&lt;entera&gt;, no sólo parte de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not try to use Perl's malloc, this will lead into very mysterious
errors (especially with -Duse64bitall).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004025Z" changeid="explorer">
        <seg>No intente usar el malloc de Perl, esto le conducirá a errores muy misteriosos (especialmente con -Duse64bitall)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$c //= $d;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015130Z" changeid="explorer">
        <seg>$c //= $d;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is described in more detail below
and in L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ésto se describe con mayor detalle más abajo y en L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Linenumbers in Perl scripts may now be greater than 65536, or 2**16.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232745Z" changeid="explorer">
        <seg>Los números de línea en Perl ahora pueden ser mayores de 65536, o 2**16.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl internal debugging macros DEBUG() and DEB() have been renamed
to PERL_DEBUG() and PERL_DEB() to avoid namespace conflicts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001644Z" changeid="explorer">
        <seg>Las macros internas de depueración Perl DEBUG() y DEB() han sido renombradas a PERL_DEBUG() y PERL_DEB() para evitar conflictos en el espacio de nombres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $packed = getsockopt($socket, $tcp, TCP_NODELAY)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $packed = getsockopt($socket, $tcp, TCP_NODELAY)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because the implicit
derefererence will never autovivify an undefined variable the way C&lt;@{ }&gt;
always will:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031142Z" changeid="explorer">
        <seg>Eso es así porque la desrefererencia implícita nunca autovivificará una variable indefinida de la misma manera que C&lt;@{}&gt; lo hace siempre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt; `EOC`; # execute command and get results</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt; `EOC`; # ejecuta comando y obtén resultados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$Some_Caps_Here  package-wide global/static</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$Algunas_Mayusculas Ámbito de paquete/estática</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, it is better to create directories with a permissive MASK
and let the user modify that with their C&lt;umask&gt; than it is to supply
a restrictive MASK and give the user no way to be more permissive.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000608Z" changeid="explorer">
        <seg>En general, es mejor crear directorios con una MÁSCARA permisiva y dejar que el usuario lo modifique con su C&lt;umask&gt; que suministrar una MÁSCARA restrictiva y no darle al usuario una forma de ser más permisivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar or list context propagates downward into the 2nd
or 3rd argument, whichever is selected.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Contexto escalar o lista es propagado hacia adelante, en el segundo o tercer argumento, cualquiera que sea el seleccionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Handling of pmc files</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T235102Z" changeid="explorer">
        <seg>=head2 Gestión de archivos pmc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading in the whole file at one time is called slurping.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235621Z" changeid="zipf">
        <seg>La lectura de un archivo completo se suele llamar &quot;slurping&quot; (succión).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Combining RE Pieces</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T233349Z" changeid="explorer">
        <seg>=head2 Combinando piezas RE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Regexp Quote-Like Operators
X&lt;operator, regexp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003334Z" changeid="explorer">
        <seg>=head2 Operadores Regexp entrecomillados
X&lt;operator, regexp&gt; X&lt;operador, regexp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;.IX foo\n&quot;    if /\bfoo\b/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;.IX foo\n&quot;    if /\bfoo\b/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C&lt;ioctl&gt;, it maps a C&lt;0&gt; return from the system call into
C&lt;&quot;0 but true&quot;&gt; in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como C&lt;ioctl&gt;, mapea un C&lt;0&gt; devuelto de la llamada del sistema en un C&lt;&quot;0 but true&quot;&gt; (&quot;0 pero cierto&quot;) en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The auto-decrement operator is not magical.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador de auto decremento no es mágico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any subroutine named
C&lt;ToLower&gt; will be ignored.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165635Z" changeid="explorer">
        <seg>Cualquier subrutina denominada C&lt;ToLower&gt; será ignorada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restricted hashes and
their place holders are now allocated and deleted at slightly different times,
but this should not be visible to user code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T111202Z" changeid="explorer">
        <seg>Hashes restringidos y sus marcadores de posición son ahora reservados y eliminados en momentos ligeramente diferentes, pero esto no debería ser apreciado por el código de usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a list reference that does I&lt;NOT&gt; interpolate, see L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215254Z" changeid="explorer">
        <seg>Para hacer referencia a una lista que &lt;NO&gt; interpole, vea L&lt;perlref&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%U    a synonym for %lu</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%U    un sinónimo para %lu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlglossary	Perl Glossary</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000456Z" changeid="explorer">
        <seg>perlglossary	Glosario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first pass is finding the end of the quoted construct, where
the information about the delimiters is used in parsing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer paso es encontrar el final de la construcción entrecomillada, donde la información sobre los delimitadores se utiliza en el análisis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>into the next variable in the parameter list</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>en la siguiente variable en la lista de parámetros</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fact that you can store such &quot;large&quot; numbers
does not mean that the I&lt;operations&gt; over these numbers will use all
of the significant digits.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232553Z" changeid="explorer">
        <seg>El hecho de poder almacenar números tan &quot;grandes&quot; no significa que en las I&lt;operaciones&gt; con estos números se usen todos los dígitos significativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ =  &quot;The food is under the bar in the barn.&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T155146Z" changeid="explorer">
        <seg>$_ = &quot;En la mesa, al mediodía, se come, y en el comedor se cena.&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5138delta	Perl changes in version 5.13.8</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141332Z" changeid="explorer">
        <seg>perl5138delta	Cambios en la versión 5.13.8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;canonpath&gt; on Win32 now collapses C&lt;foo/..&gt; (or C&lt;foo\..&gt;) sections
correctly, rather than doing the &quot;misguided&quot; work it was previously doing.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032025Z" changeid="explorer">
        <seg>Ahora, C&lt;canonpath&gt;, en Win32, colapsa secciones C&lt;foo/..&gt; (o C&lt;foo\..&gt;) correctamente, en lugar de la &quot;equivocada&quot; tarea que hacía antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require 5.6.1;      # ditto</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require 5.6.1;      # ídem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it useful for control flow:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230340Z" changeid="explorer">
        <seg>Esto lo hace útil para el control de flujo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For BeOS specifics problems feel free to mail to:
Ingo Weinhold &lt;bonefish@cs.tu-berlin.de&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para información específica de problemas BeOS no dude en enviar un correo a: Ingo Weinhold &lt;bonefish@cs.tu-berlin.de&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dealing with bugs and bug reports
is unglamorous work; not something ideally suited to volunteer labour,
but that is all that we have.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tratar con errores e informes de errores es un trabajo poco atractivo; no es algo ideal para un trabajo voluntario, pero eso es todo lo que tenemos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, splits the C&lt;$_&gt; string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es omitido, divide la cadena C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed F&lt;libgdbm&gt; for AIX 5L and 6.1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153042Z" changeid="explorer">
        <seg>Eliminado F&lt;libgdbm&gt; de AIX 5L y 6.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Craig Berry was tireless in getting maint to run under VMS, no matter how
many times we broke it for him.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235238Z" changeid="explorer">
        <seg>Craig Berry fue incansable en conseguir que se ejecutara maint en VMS, sin importar cuántas veces lo rompíamos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!/usr/bin/perl -wl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#!/usr/bin/perl -wl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that 0 is a valid match offset.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175851Z" changeid="explorer">
        <seg>Tenga en cuenta que 0 es un desplazamiento válido de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may be other
reasons you can't actually read, write, or execute the file: for
example network filesystem access controls, ACLs (access control lists),
read-only filesystems, and unrecognized executable formats.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede haber otras razones por las que no pueda leer, escribir o ejecutar un archivo: por ejemplo, controles de acceso a sistemas de archivos en red, ACL (listas de control de acceso), sistemas de archivos de solo lectura, y formatos irreconocibles de ejecutables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some more examples
are</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113447Z" changeid="explorer">
        <seg>Algunos ejemplos más</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmodstyle - Perl module style guide</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T012724Z" changeid="explorer">
        <seg>perlmodstyle - Guía de estilo de los módulos Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n}+   Match exactly n times and give nothing back (redundant)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n}+   Coincide exactamente n veces y no devuelve nada (redundante)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match at least n times, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide al menos n veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aa</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050702Z" changeid="explorer">
        <seg>aa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ab</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050717Z" changeid="explorer">
        <seg>ab</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the commas on the right of the sort are evaluated before the sort,
but the commas on the left are evaluated after.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>las comas a la derecha de sort son evaluadas antes que el sort, pero las comas a la izquierda se evalúan después.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Unicode keys with tied hashes should now work correctly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando claves Unicode con hashes enlazados ahora debería funcionar correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upgraded from version 6.42 to 6.55_02.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152451Z" changeid="explorer">
        <seg>Actualizado desde la versión 6.42 a la 6.55_02.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can get thread status, or the list of running or joinable threads.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005550Z" changeid="explorer">
        <seg>Se puede obtener el estado de un hilo, o la lista de hilos en ejecución o acoplables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What modules and extensions are available for Perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225945Z" changeid="explorer">
        <seg>=head2 ¿Qué módulos y extensiones están disponibles para Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>man perldgux</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>man perldgux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item opendir DIRHANDLE,EXPR
X&lt;opendir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020645Z" changeid="explorer">
        <seg>=item opendir IDENTIFICADOR_DIR,EXPR
X&lt;opendir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir ($foo) * 20;	# (chdir $foo) * 20</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir ($foo) * 20;	# (chdir $foo) * 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no changes intentionally incompatible with 5.12.2.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225902Z" changeid="explorer">
        <seg>No hay cambios intencionadamente incompatibles con 5.12.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215835Z" changeid="explorer">
        <seg>Vea L&lt;perlipc&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the input string is longer than needed, remaining characters are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena de entrada es más larga de lo necesario, los caracteres sobrantes se ignoran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The require function will look for the &quot;F&lt;Foo::Bar&gt;&quot; file in the @INC array and
will complain about not finding &quot;F&lt;Foo::Bar&gt;&quot; there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función require buscará por el archivo &quot;F&lt;Foo::Bar&gt;&quot; en los directorios especificados por el array C&lt;@INC&gt; y se quejará de que no lo encuentra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $variables = {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232613Z" changeid="explorer">
        <seg>my $variables = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ok</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214822Z" changeid="explorer">
        <seg>ok</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item state EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item state EXPR : ATRIBS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;You&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Usted&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having fewer than 3 digits may lead to a misleading warning message that says
that what follows is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T210709Z" changeid="explorer">
        <seg>Tener menos de 3 dígitos puede dar lugar a un mensaje de advertencia engañoso, que dice que lo que sigue es ignorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># guarantee stability, regardless of algorithm</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># garantiza estabilidad, sin importar el algoritmo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When operations on data vary according to data type (making
polymorphic invocation of methods feasible)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015927Z" changeid="explorer">
        <seg>Cuando las operaciones en los datos varían de acuerdo al tipo de datos (haciendo factible la invocación de métodos polimórficos)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your module should also handle 
taint-checking where appropriate, though this can cause difficulties in
many cases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023021Z" changeid="explorer">
        <seg>El módulo también debe manejar comprobaciones de pringue, aunque esto puede causar dificultades en muchos casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last update: 2004-12-16</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Última actualización: 2004-12-16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for features of how perl actually runs, including exit codes and
handling of PERL* environment variables.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014657Z" changeid="explorer">
        <seg>Pruebas de las características de funcionamiento de perl, incluidos los códigos de salida y el control de las variables de entorno PERL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = 'a' x 8;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T220954Z" changeid="explorer">
        <seg>$_ = 'a' x 8;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This timeline
hopefully helps a bit: it lists the new major releases, their maintenance
releases, and the development releases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005642Z" changeid="explorer">
        <seg>Esta línea de tiempo, con suerte, le ayudará un poco: lista los lanzamientos importantes, sus programas de mantenimiento y las versiones de desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use comp.lang.perl.misc for topics
which do not have a more-appropriate specific group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230418Z" changeid="explorer">
        <seg>Use comp.lang.perl.misc para temas para los que no exista un grupo específico más apropiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(':', split(/\W/, 'hi there!', -1)), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(':', split(/\W/, 'hola aqui!', -1)), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;TPJ&gt; has columns
on web development, databases, Win32 Perl, graphical programming,
regular expressions, and networking, and sponsors the Obfuscated Perl
Contest and the Perl Poetry Contests.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230851Z" changeid="explorer">
        <seg>I&lt;TPJ&gt; incluye columnas sobre desarrollo web, bases de datos, Perl para Win32, programación gráfica, expresiones regulares o conexión a redes. También patrocinó el concurso de ofuscación de código Perl y los concursos de poesía Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string which is (possibly) interpolated and then executed as a
system command with C&lt;/bin/sh&gt; or its equivalent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una cadena que es (posiblemente) interpolada y luego ejecutada como un comando del sistema con C&lt;/bin/sh&gt; o su equivalente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may alter the usual smart match semantics.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esta manera se altera la semántica normal de la coincidencia inteligente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your SYNOPSIS section should contain a
minimal example of use (perhaps as little as one line of code; skip the
unusual use cases or anything not needed by most users); the
DESCRIPTION should describe your module in broad terms, generally in
just a few paragraphs; more detail of the module's routines or methods,
lengthy code examples, or other in-depth material should be given in 
subsequent sections.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024332Z" changeid="explorer">
        <seg>Su sección SINOPSIS debe contener un ejemplo mínimo de uso (quizás tan sólo una línea de código; evitar los casos de uso inusuales o cualquier cosa que no sea necesaria para la mayoría de los usuarios); la DESCRIPCIÓN debe describir el módulo en términos generales, por lo general en sólo unos pocos párrafos; más detalles de las rutinas del módulo o métodos, ejemplos con código más largo, u otro material en profundidad se debe dar en las secciones siguientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treats the string in EXPR as a bit vector made up of elements of
width BITS and returns the value of the element specified by OFFSET
as an unsigned integer.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T025022Z" changeid="explorer">
        <seg>Trata a la cadena en EXPR como un vector de bits compuesta de elementos de tantos BITS de ancho y devuelve el valor del elemento especificado por el DESPLAZAMIENTO como un entero sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has been
fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235659Z" changeid="explorer">
        <seg>Esto ha sido corregido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltie		Perl objects hidden behind simple variables</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000339Z" changeid="explorer">
        <seg>perltie		Objetos Perl ocultos en variables simples</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = (($foo,$bar) = f());           # set $x to f()'s return count</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035826Z" changeid="explorer">
        <seg>$x = (($foo,$bar) = f());           # pone $x al número de valores devueltos por f()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item perl Build test</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025002Z" changeid="explorer">
        <seg>=item perl Build test</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/ ( A (*PRUNE) B | C (*PRUNE) D ) /</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050621Z" changeid="explorer">
        <seg>/ ( A (*PRUNE) B | C (*PRUNE) D ) /</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $animals[1];              # prints &quot;llama&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121217Z" changeid="zipf">
        <seg>print $animales[1];  # imprime &quot;llama&quot; en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item printf FORMAT, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item printf FORMATO, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is
omitted, returns the length of C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171157Z" changeid="explorer">
        <seg>Si EXPR se omite, devuelve la longitud de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A
potential problem caught by C&lt;use strict;&gt; will cause your code to stop
immediately when it is encountered, while C&lt;use warnings;&gt; will merely
give a warning (like the command-line switch B&lt;-w&gt;) and let your code run.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224714Z" changeid="explorer">
        <seg>Un posible problema detectado por C&lt;use strict;&gt; hará que el código se detenga inmediatamente, mientras que C&lt;use warnings;&gt; (al igual que el modificador de línea de comandos B&lt;-w&gt;) sólo mostrará una advertencia y dejará que el código se ejecute.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;&quot;Numeric operators and numeric conversions&quot;&gt; for details.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232557Z" changeid="explorer">
        <seg>Encontrará información detallada en L&lt;&quot;Operadores numéricos y conversiones numéricas&quot;&gt;.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no parentheses, it returns a list of all
the matched strings, as if there were parentheses around the whole
pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay paréntesis, devuelve una lista de todas las cadenas coincidentes, como si hubiera paréntesis alrededor de todo el patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pack and unpack can operate in two modes: character mode (C&lt;C0&gt; mode) where
the packed string is processed per character, and UTF-8 mode (C&lt;U0&gt; mode)
where the packed string is processed in its UTF-8-encoded Unicode form on
a byte-by-byte basis.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pack y unpack pueden funcionar de dos modos: modo de caracteres (modo C&lt;C0&gt;) donde la cadena empaquetada es procesada por cada carácter, y el modo UTF-8 (modo C&lt;U0&gt;) donde la cadena empaquetada es procesada en su formato codificado en UTF-8, byte a byte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PUSH this, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>PUSH este, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $hash{'a'}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225612Z" changeid="explorer">
        <seg>delete $hash{'a'}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Development</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234408Z" changeid="explorer">
        <seg>=head2 Desarrollo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Visual Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>=item Visual Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means the following
behavior holds:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que el siguiente comportamiento cumple que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since changing a slice changes the original array or hash that it's
slicing, a C&lt;foreach&gt; construct will alter some--or even all--of the
values of the array or hash.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234939Z" changeid="explorer">
        <seg>Debido a que alterar una porción altera al array o hash original, una construcción C&lt;foreach&gt; alterará algunos -o incluso todos- los valores del array o hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @ints, $i if vec($vec, ++$i, 1);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>push @ints, $i if vec($vec, ++$i, 1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the output is empty and C&lt;$@&gt; already contains a value (typically from a
previous eval) that value is reused after appending C&lt;&quot;\t...propagated&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la LISTA está vacía y C&lt;$@&gt; ya contiene un valor (típicamente de un eval() anterior) este valor es reutilizado después de añadirle C&lt;&quot;\t...propagated&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Respects current LC_CTYPE locale.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174902Z" changeid="explorer">
        <seg>Respeta la actual configuración regional LC_CTYPE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At startup Perl blocks the SIGFPE signal away since there isn't much
Perl can do about it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232618Z" changeid="explorer">
        <seg>En el arranque, Perl bloquea la señal SIGFPE, ya que no hay mucho que Perl pueda hacer al respecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;last&gt; command is like the C&lt;break&gt; statement in C (as used in
loops); it immediately exits the loop in question.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012519Z" changeid="explorer">
        <seg>El comando C&lt;last&gt; es como la instrucción C&lt;break&gt; del C (usada en bucles); inmediatamente sale del bucle en cuestión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if this operator is used and NOT inside of an alternation then
it acts exactly like the C&lt;(*PRUNE)&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T141423Z" changeid="explorer">
        <seg>Tenga en cuenta que si este operador es usado, y NO dentro de una alternancia, entonces actúa exactamente igual que el operador C&lt;(*PRUNE)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are upgrading from an earlier release such as 5.6.1, first read
the L&lt;perl58delta&gt;, which describes differences between 5.6.0 and
5.8.0, and the L&lt;perl581delta&gt;, which describes differences between
5.8.0 and 5.8.1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está actualizando desde una versión anterior como la 5.6.1, primero lea L&lt;perl58delta&gt;, que describe las diferencias entre 5.6.0 y 5.8.0, y L&lt;perl581delta&gt;, que describe las diferencias entre 5.8.0 y 5.8.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;&gt; 8;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&gt;&gt; 8;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just what is in the packed string depends on LEVEL and OPTNAME;
consult getsockopt(2) for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo que exactamente esté en la cadena empaquetada depende de NIVEL y OPCIÓN; consulte getsockopt(2) para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlop/&quot;Regexp Quote-Like Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop/&quot;Operadores Regexp entrecomillados&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prints the value of LIST to STDERR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Imprime el valor de LISTA a STDERR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005342Z" changeid="explorer">
        <seg>Identificadores de archivo se deben pasar como comodines o referencias a comodines para que sean reconocidos; las palabras sueltas se consideran como nombres de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no shell metacharacters in the argument,
it is split into words and passed directly to C&lt;execvp&gt;, which is
more efficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay metacaracteres shell en el argumento, es dividido en palabras y pasadas directamente a C&lt;execvp&gt;, que es más eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;open&gt; pragma can be used to
establish default I/O layers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El pragma C&lt;open&gt; puede ser usado para establecer las capas I/O por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Topaz provided valuable insights to the next version
of Perl and its implementation, but was ultimately abandoned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230056Z" changeid="explorer">
        <seg>La experiencia proporcionada por Topaz resultó muy útil para la siguiente versión de Perl y su implementación, pero el proyecto acabó por abandonarse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item m/PATTERN/msixpodualgc
X&lt;m&gt; X&lt;operator, match&gt;
X&lt;regexp, options&gt; X&lt;regexp&gt; X&lt;regex, options&gt; X&lt;regex&gt;
X&lt;/m&gt; X&lt;/s&gt; X&lt;/i&gt; X&lt;/x&gt; X&lt;/p&gt; X&lt;/o&gt; X&lt;/g&gt; X&lt;/c&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T232652Z" changeid="explorer">
        <seg>=item m/PATRÓN/msixpodualgc
X&lt;m&gt; X&lt;operator, match&gt;
X&lt;regexp, options&gt; X&lt;regexp&gt; X&lt;regex, options&gt; X&lt;regex&gt;
X&lt;/m&gt; X&lt;/s&gt; X&lt;/i&gt; X&lt;/x&gt; X&lt;/p&gt; X&lt;/o&gt; X&lt;/g&gt; X&lt;/c&gt;
X&lt;operador, coincidencia&gt; X&lt;opciones, regex&gt; X&lt;opciones, regexp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, a side effect
of the current implementation is that the effects of C&lt;shift @_&gt; can
I&lt;normally&gt; be undone (but not C&lt;pop @_&gt; or other splicing, I&lt;and&gt; not if a
reference to C&lt;@_&gt; has been taken, I&lt;and&gt; subject to the caveat about reallocated
elements), so C&lt;@DB::args&gt; is actually a hybrid of the current state and
initial state of C&lt;@_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023219Z" changeid="explorer">
        <seg>Por último, un efecto secundario de la implementación actual es que los efectos de C&lt;shift @_&gt; pueden I&lt;normalmente&gt; ser deshechos (pero no C&lt;pop @_&gt; u otras operaciones de troceado, I&lt;y&gt; tampoco si se ha tomado una referencia a C&lt;@_&gt;, I&lt;y&gt; con la salvedad sobre los elementos reasignados), por lo que C&lt;@DB::args&gt; es realmente un híbrido del estado actual e inicial de C&lt;@_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes various features of Irix that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002306Z" changeid="explorer">
        <seg>Este documentos describe varias características de Irix que afectarán a cómo Perl versión 5 (de ahora en adelante sólo Perl) es compilado y/o ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m&lt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T220958Z" changeid="explorer">
        <seg>m&lt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Tie::Hash</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Tie::Hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Irix cc versions, e.g. 7.3.1.1m (try cc -version) have been known
to have issues (coredumps) when compiling perl.c.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003056Z" changeid="explorer">
        <seg>Algunas versiones de cc de Irix, por ejemplo, la 7.3.1.1m (pruebe cc -version) se sabe que tienen problemas (coredumps) al compilar perl.c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\cB      chr(2)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034624Z" changeid="explorer">
        <seg>\cB      chr(2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use warnings FATAL =&gt; &quot;printf&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182342Z" changeid="explorer">
        <seg>use warnings FATAL =&gt; &quot;printf&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See F&lt;INSTALL&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015407Z" changeid="explorer">
        <seg>Vea F&lt;INSTALL&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting from the beginning of the template to pack(), each pair
of characters is converted to 1 character of output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir del comienzo de la plantilla a pack(), cada par de caracteres se convierte en un carácter en la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is due to bugs in Haiku's network stack implementation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se debe a errores en la implementación de la pila del sistema de red de Haiku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -Dcc='cc -n32'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002335Z" changeid="explorer">
        <seg>sh Configure -Dcc='cc -n32'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the terminating string is quoted, the type of quotes used determine
the treatment of the text.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena de terminación está entrecomillada, el tipo de comillas usadas determinan el tratamiento del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*)(\d+)    &lt;I have 2 numbers: 5314&gt; &lt;7&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T234103Z" changeid="explorer">
        <seg>(.*)(\d+)    &lt;Tegno 2 números: 5314&gt; &lt;7&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dave Mitchell provided a fix.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045949Z" changeid="explorer">
        <seg>Dave Mitchell proporcionó un arreglo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The precedence of &quot;and&quot;
and &quot;or&quot; is much lower, however, so that you can safely use them after a
list operator without the need for parentheses:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, la precedencia de &quot;and&quot; y &quot;or&quot; es mucho menor, de modo que usted puede usarlos con seguridad después de un operador de lista sin necesidad de paréntesis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>m/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An exception to this is the C&lt;:encoding&gt; layer that
changes the default character encoding of the handle; see L&lt;/open&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020132Z" changeid="explorer">
        <seg>Una excepción a esto es la capa C&lt;:encoding&gt; que cambia la codificación por defecto del identificador de archivo; ver L&lt;/open&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@array[ 4 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach (@array[ 4 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setpriority WHICH,WHO,PRIORITY
X&lt;setpriority&gt; X&lt;priority&gt; X&lt;nice&gt; X&lt;renice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200518Z" changeid="explorer">
        <seg>=item setpriority CUÁL,QUIÉN,PRIORIDAD
X&lt;setpriority&gt; X&lt;priority&gt; X&lt;nice&gt; X&lt;renice&gt; X&lt;prioridad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.zeusedit.com/lookmain.html</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>http://www.zeusedit.com/lookmain.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/when&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T232530Z" changeid="explorer">
        <seg>Vea L&lt;/when&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has a new -dt command-line flag, which enables threads support in the
debugger.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T210605Z" changeid="explorer">
        <seg>Perl tiene una nueva bandera de línea de comandos llamada -dt, que activa el soporte de hebras en el depurador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;feature&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;feature&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use look-behind instead (see below).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T200737Z" changeid="explorer">
        <seg>Use en su lugar el antecedente (I&lt;look-behind&gt;) (vea más abajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>He
previously used the phrase with many subjects (&quot;Just another x hacker,&quot;),
so to distinguish his JAPH, he started to write them as Perl programs:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231946Z" changeid="explorer">
        <seg>Previamente había utilizado esta frase con muchos sujetos distintos (&quot;Just another x hacker,&quot;), así que para distinguir su JAPH decidió empezar a escribir la firma como un programa Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But in all other cases, you should decode it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235051Z" changeid="explorer">
        <seg>Pero en todos los demás casos debe hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $hash{A}{B}[$ix])        { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $hash{A}{B}[$i])           { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,12, 2) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,12, 2) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 &quot;%s&quot; variable %s masks earlier declaration</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040332Z" changeid="explorer">
        <seg>=head2 &quot;%s&quot; variable %s masks earlier declaration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>jJfFdDpP   (The &quot;little end&quot; touches the construct.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>jJfFdDpP   (El &quot;little end&quot; toca la construcción).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The collected standard
output of the command is returned; standard error is unaffected.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo lo que salga por la salida estándar del comando se devuelve; la salida estándar de error no se verá afectada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may therefore need to use multiple formlines to implement a single
record format, just like the C&lt;format&gt; compiler.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede por eso necesitar usar múltiples formlines para implementar un único registro format, como lo hace el propio compilador de C&lt;format&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that doesn't work (some I/O implementations are particularly
cantankerous), you might need something like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si eso no funciona (algunas implementaciones de E/S son particularmente irritables), puede que tenga que hacer algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other rules are likely to contradict the user's
expectations much less frequently than this first one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las demás normas es probable que contradigan las expectativas del usuario con mucha menos frecuencia que ésta primera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perldoc|perldoc&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233258Z" changeid="explorer">
        <seg>=item L&lt;perldoc|perldoc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE&gt;: Failed matches in Perl do not reset the match variables,
which makes it easier to write code that tests for a series of more
specific cases and remembers the best match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;NOTA&gt;: Coincidencias fallidas en perl no reinicializan las variables de coincidencia, lo que facilita escribir código que haga comprobaciones para una serie específica de casos y recuerde la mejor coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows for computed C&lt;goto&gt;s per FORTRAN, but isn't
necessarily recommended if you're optimizing for maintainability:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto permite crear C&lt;goto&gt; calculados como en FORTRAN, pero no está necesariamente recomendado si usted está optimizando, durante el mantenimiento:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int(rand(10))</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>int(rand(10))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== -1) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== -1) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perlnewmod&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031935Z" changeid="explorer">
        <seg>=item L&lt;perlnewmod&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;x$where a$howmuch&quot;, $what);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;x$donde a$cuanto&quot;, $que);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The conditions can be any Perl expression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181953Z" changeid="zipf">
        <seg>Una condición puede ser cualquier expresión Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to the control flow of your Perl program
X&lt;control flow&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T011817Z" changeid="explorer">
        <seg>=item Palabras clave relativas al control de flujo de su programa Perl
X&lt;control flow&gt; X&lt;control de flujo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir '/usr/spool/news' or die &quot;Can't cd to spool: $!\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir '/usr/spool/news' or die &quot;No puedo entrar en spool/: $!\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unlink</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item unlink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the pattern is encoded in UTF-8; or</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000628Z" changeid="explorer">
        <seg>el patrón está codificado en UTF-8; o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $members value returned by I&lt;getgr*()&gt; is a space-separated list of
the login names of the members of the group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T162449Z" changeid="explorer">
        <seg>El valor de $miembros devuelto por I&lt;getgr*()&gt; es una lista separada por espacios de los nombres de login de los miembros del grupo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the only form of quoting in perl where there is no need
to worry about escaping content, something that code generators
can and do make good use of.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la única forma de entrecomillar en Perl donde no es necesario preocuparse por el escapado del contenido, algo que los generadores de código pueden y hacen buen uso de él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -MDateTime -le'print DateTime-&gt;today-&gt;jd'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>$ perl -MDateTime -le'print DateTime-&gt;today-&gt;jd'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also import the symbolic C&lt;S_I*&gt; constants from the C&lt;Fcntl&gt;
module:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede importar las constantes simbólicas C&lt;S_I*&gt; desde el módulo Fcntl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$passwd,$gid,$members) = getgr*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($name,$passwd,$gid,$members) = getgr*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\1&gt; in the replacement of C&lt;s'''&gt; does not work as C&lt;$1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;\1&gt; en el reemplazo de C&lt;s'''&gt; no funciona como C&lt;$1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
will help people find and remember your module, and make programming
with your module more intuitive.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015245Z" changeid="explorer">
        <seg>Esto ayudará a la gente a encontrar y recordar su módulo, y hacer la programación con el módulo de forma más intuitiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(At one point C&lt;$0&gt; did
also, but now it returns the name of the program.)  C&lt;$`&gt; returns
everything before the matched string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Hace un tiempo, C&lt;$0&gt; también lo hacía, pero ahora devuelve el nombre del programa).  C&lt;$`&gt; devuelve todo lo anterior a la cadena coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The defaults assume a little endian LP32 platform - ie long and pointers are
32 bits, so sizeof(long) and sizeof(void *) are 4
If your platform is little endian LP64 - ie long and pointers are 64 bits,
sizeof(long) and sizeof(void *) are 8, then you first need to run</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223504Z" changeid="explorer">
        <seg>Los valores por defecto asumen una plataforma little-endian LP32 - es decir, los largos y punteros son de 32 bits, por lo que sizeof(long) y sizeof(void *) son 4
Si su plataforma es little-endian LP64 - es decir, los largos y punteros son de 64 bits, sizeof(long) y sizeof(void *) son 8, entonces primero tiene que ejecutar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is deprecated in favour of F&lt;h2xs&gt; these days.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234531Z" changeid="explorer">
        <seg>Han quedado obsoletos desde que surgió F&lt;h2xs&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlreguts		Perl regular expression engine internals</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000522Z" changeid="explorer">
        <seg>perlreguts		Componentes del motor de expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually
used depend on various things, and as a result you can get unexpected
results.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000932Z" changeid="explorer">
        <seg>Otra regla mnemotécnica para este modificador es &quot;Depende&quot;, porque las reglas utilizadas realmente dependen de varias cosas, y como resultado se puede obtener resultados inesperados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
largely eliminates the need for typeglobs when opening filehandles
that must be passed around, as in the following example:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003849Z" changeid="explorer">
        <seg>Esto elimina en gran medida la necesidad de typeglobs al abrir identificadores de archivo que deberían ser traspasados, como en el ejemplo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new operator C&lt;//&gt; (defined-or) will be available.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014338Z" changeid="explorer">
        <seg>Un nuevo operador C&lt;//&gt; (definido-o) estará disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl.com ( http://www.perl.com/ ) used to be part of the O'Reilly
Network, a subsidiary of O'Reilly Media.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231309Z" changeid="explorer">
        <seg>Anteriormente, Perl.com ( http://www.perl.com/ ) formaba parte de O'Reilly Network, una subsidiaria de O'Reilly Media.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $x = &quot;foo&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232627Z" changeid="explorer">
        <seg>my $x = &quot;foo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next step is interpolation in the text obtained, which is now
delimiter-independent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El siguiente paso es la interpolación del texto obtenido, que ahora es independiente del delimitador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of bytes
actually written, or C&lt;undef&gt; if there was an error (in this case the
errno variable C&lt;$!&gt; is also set).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de bytes realmente escritos, o C&lt;undef&gt; si hubo un error (en este caso, también se establece la variable C&lt;$!&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LOOP: {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BUCLE: {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is designed to give you several
ways to do anything, so consider picking the most readable one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl está diseñado para darle varias opciones para hacer cualquier cosa, así que elija la más legible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;suidperl&gt;
is installed as a hard link to C&lt;perl&gt;; both C&lt;suidperl&gt; and C&lt;perl&gt; will
invoke C&lt;sperl5.8.4&gt; automatically the set uid binary, so this change should
be completely transparent.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T104000Z" changeid="explorer">
        <seg>C&lt;suidperl&gt; es instalado como un enlace duro a C&lt;perl&gt;; tanto C&lt;suidperl&gt; como C&lt;perl&gt; invocarán al binario C&lt;sperl5.8.4&gt; automáticamente, por lo que este cambio debería ser completamente transparente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($i++ &lt; 2) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($i++ &lt; 2) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-00374-6 [4th edition July 2002]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003233Z" changeid="explorer">
        <seg>ISBN 978-0-596-00374-6 [4ª edición - Julio de 2002]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But there are a few situations in recent Perls where programs are likely to
want to call C&lt;srand&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182949Z" changeid="explorer">
        <seg>Pero hay unas pocas situaciones en programas recientes de Perl donde es probable que desee llamar a C&lt;srand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;defined&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;formline&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;,
C&lt;reset&gt;, C&lt;scalar&gt;, C&lt;state&gt;, C&lt;undef&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;defined&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;formline&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;, C&lt;reset&gt;, C&lt;scalar&gt;, C&lt;undef&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, it comes back as a single (potentially
multi-line) string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, se devuelve como una sola cadena (potencialmente multi-línea).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This points to a closed subscription
unarchived mailing list, which includes all the core committers, who be able
to help assess the impact of issues, figure out a resolution, and help
co-ordinate the release of patches to mitigate or fix the problem across all
platforms on which Perl is supported.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T232548Z" changeid="explorer">
        <seg>Esto apunta a una lista de correo de suscripción cerrada y no archivada, que incluye a todos los participantes principales, que podrán ayudar a evaluar el impacto de los problemas, encontrar una resolución, y ayudar a coordinar la liberación de parches para mitigar o solucionar el problema en todas las plataformas en las que Perl está soportado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;keys&gt;, C&lt;values&gt; work on arrays</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225952Z" changeid="explorer">
        <seg>=head2 C&lt;keys&gt;, C&lt;values&gt; funcionan con arrays</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, using C&lt;unlink&gt; on directories is
not supported on many operating systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por último, con C&lt;unlink&gt; en directorios no está soportado en muchos sistemas operativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/this/&lt;&lt;E . 'that'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054239Z" changeid="explorer">
        <seg>s/este/&lt;&lt;E . 'ese'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically used as
follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Típicamente se usa como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This view may conflict with other information that you
may have found on the web, but that's mostly because many sources are wrong.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234251Z" changeid="explorer">
        <seg>Nuestro enfoque puede chocar con otros que haya encontrado en Internet, pero esto se debe a que la información proporcionada por muchas fuentes no es correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you set up a loop of piped processes, deadlock can occur
unless you are very careful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si se establece un circuito de procesos entubados, puede producirse un bloqueo mortal a menos que sea muy cuidadoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># insert dashes just before last line of last file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># inserta guiones justo antes de la última línea del último archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EOF this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EOF este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*)(\d+)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233755Z" changeid="explorer">
        <seg>(.*)(\d+)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is in
practice difficult to do, as it's unclear how to escape which characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es en la práctica es difícil de hacer, como que no está claro cómo escapar qué caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But realize that what we are discussing the rules for just the
I&lt;storage&gt; of these numbers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232548Z" changeid="explorer">
        <seg>(Pero no olvide que lo que estamos describiendo son solo las normas del I&lt;almacenamiento&gt; de estos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also
L&lt;perlipc/&quot;SysV IPC&quot;&gt; and the documentation for C&lt;IPC::SysV&gt; and
C&lt;IPC::Msg&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215424Z" changeid="explorer">
        <seg>Vea también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt; y C&lt;IPC::SysV&gt; y C&lt;IPC::Msg&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If OFFSET is negative (or more precisely, less than C&lt;$[&gt;), starts
that far back from the end of the string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015510Z" changeid="explorer">
        <seg>Si DESPLAZAMIENTO es negativo (o más precisamente, menor que C&lt;$[&gt;), cuenta la posición desde el final de la cadena, hacia adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;C0&gt; to get Unicode characters while using C&lt;U0&gt; to get I&lt;non&gt;-Unicode 
bytes is not necessarily obvious.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003418Z" changeid="explorer">
        <seg>Usar C&lt;C0&gt; para obtener los caracteres Unicode mientras se utiliza C&lt;U0&gt; para obtener bytes I&lt;no&gt; Unicode, no es necesariamente obvio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require 'syscall.ph';        # may need to run h2ph</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require 'syscall.ph';        # puede necesitar ejecutar h2ph</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify a precision (for numeric conversions) or a maximum
width (for string conversions) by specifying a C&lt;.&gt; followed by a number.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede especificar una precisión (para las conversiones numéricas) o una anchura máxima (para las conversiones de cadena) mediante la especificación de un C&lt;.&gt; seguido de un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But it leads to some ambiguities if
there are more than 9 capture groups, as C&lt;\10&gt; could mean either the tenth
capture group, or the character whose ordinal in octal is 010 (a backspace in
ASCII).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T185445Z" changeid="explorer">
        <seg>Pero conduce a algunas ambigüedades si hay más de 9 grupos de captura, como C&lt;\10&gt; podría referirse al décimo grupo de captura, o al carácter cuyo ordinal en octal es 010 (un retroceso, en ASCII).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, it's worth noting that patterns defined this way probably will
not be as efficient, as the optimiser is not very clever about
handling them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T203418Z" changeid="explorer">
        <seg>Además, vale la pena señalar que los patrones definidos de esta manera probablemente no serán tan eficientes, debido a que el optimizador no es muy inteligente sobre el manejo de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Steffen Mueller and David Golden in particular helped getting CPAN modules
polished and synchronised with their in-core equivalents.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235118Z" changeid="explorer">
        <seg>Steffen Mueller y David Golden, en particular, ayudaron a obtener módulos CPAN pulidos y sincronizados con sus correspondientes versiones incluidas en la distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/   division</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235212Z" changeid="zipf">
        <seg>/   división</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($item) = /\d+\s*(\S+)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>($item) = /\d+\s*(\S+)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>None.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T152732Z" changeid="explorer">
        <seg>Ninguno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*)(\d*)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233752Z" changeid="explorer">
        <seg>(.*)(\d*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use FreezeThaw qw(cmpStr cmpStrHard);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225554Z" changeid="explorer">
        <seg>use FreezeThaw qw(cmpStr cmpStrHard);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Setgid\n&quot; if -g _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Setgid\n&quot; if -g _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub pvec {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225604Z" changeid="explorer">
        <seg>sub pvec {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The End</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fin

=head1 Nota del traductor

Esta traducción C&lt;no&gt; es un documento legal. La expresión de la legalidad de la Licencia Artística reside únicamente en el texto original en inglés de perlartistic.pod.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Yup, no 123 in $_\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170035Z" changeid="explorer">
        <seg>print &quot;Yep, no hay 123 en $_\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If too many strange characters (&gt;30%)
are found, it's a C&lt;-B&gt; file; otherwise it's a C&lt;-T&gt; file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T014654Z" changeid="explorer">
        <seg>Si se encuentran demasiados caracteres extraños (E&lt;gt&gt;30%), es un archivo C&lt;-B&gt;; de lo contrario es un archivo C&lt;-T&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pseudohashes Will Be Removed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014744Z" changeid="explorer">
        <seg>Pseudo-hashes serán eliminados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-l  File is a symbolic link.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004651Z" changeid="explorer">
        <seg>-l  Archivo es un enlace simbólico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is another real-life example.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110812T145232Z" changeid="zipf">
        <seg>Otro ejemplo del mundo real:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ @{ $lrr-&gt;[$_] } [ $y_lo ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053110Z" changeid="explorer">
        <seg>[ @{ $lrr-&gt;[$_] } [ $y_lo ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;LATIN SMALL LIGATURE FI&gt;
should match the sequence C&lt;fi&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162115Z" changeid="explorer">
        <seg>Por ejemplo, C&lt;LATIN SMALL LIGATURE FI&gt; debe coincidir con la secuencia C&lt;fi&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T134617Z" changeid="explorer">
        <seg>a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;&quot;Modules and Pragmata&quot;&gt; for more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T185307Z" changeid="explorer">
        <seg>Vea L&lt;&quot;Módulos y prágmata&quot;&gt; para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;Text::Balanced&gt; module (standard as of v5.8,
and from CPAN before then) is able to do this properly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T231115Z" changeid="explorer">
        <seg>El módulo C&lt;Text::Balanced&gt; (estándar a partir de v5.8, y desde CPAN antes de esa fecha) es capaz de hacer esto de forma correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are known as
&quot;barewords&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T003834Z" changeid="explorer">
        <seg>Estos son conocidos como &quot;I&lt;barewords&gt;&quot; (palabras sueltas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;h2xs&gt; enhancements</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041631Z" changeid="explorer">
        <seg>=head2 Mejoras en C&lt;h2xs&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some dual-life modules, it has not yet been determined if the CPAN version
or the blead source is canonical.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014515Z" changeid="explorer">
        <seg>Para algunos módulos de evolución dual aún no se ha determinado si la versión canónica es la de CPAN o la del código fuente de la rama I&lt;blead&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative to using substr() as an lvalue is to specify the
replacement string as the 4th argument.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203421Z" changeid="explorer">
        <seg>Una alternativa al uso substr() como un I&lt;ivalor&gt; es especificar la cadena de reemplazo como el cuarto argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Recursive sort subs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200219Z" changeid="explorer">
        <seg>=head2 Subrutinas recursivas sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The documentation has been revised in places to produce more standard manpages.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La documentación ha sido revisada en diversos lugares para producir páginas de manual más estándares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item oct EXPR
X&lt;oct&gt; X&lt;octal&gt; X&lt;hex&gt; X&lt;hexadecimal&gt; X&lt;binary&gt; X&lt;bin&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191552Z" changeid="explorer">
        <seg>=item oct EXPR
X&lt;oct&gt; X&lt;octal&gt; X&lt;hex&gt; X&lt;hexadecimal&gt; X&lt;binary&gt; X&lt;bin&gt; X&lt;binario&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On success, it returns the number of files
it successfully deleted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de éxito, devuelve el número de archivos que se han eliminado correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*s&gt;',  3, &quot;string&quot;;   # prints &quot;&lt;str&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*s&gt;',  3, &quot;cadena&quot;;   # imprime &quot;&lt;cad&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;end_form()&gt; doesn't emit empty (and non-validating) C&lt;&lt; &lt;div&gt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025428Z" changeid="explorer">
        <seg>C&lt;end_form()&gt; ya no emite un C&lt;&lt; &lt;div&gt; &gt;&gt; vacío (e inválido)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And Larry
will sleep easier, too--Wall Street programs not withstanding.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231323Z" changeid="explorer">
        <seg>Larry también dormirá mejor (si logra no pensar en los programas que se crean para Wall Street).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than
requiring you to put parentheses around every function call and
declare every variable, you can often leave such explicit elements off
and Perl will figure out what you meant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En vez de obligarle a poner paréntesis en todas las llamadas de función y declarar cada variable, puede, a menudo, dejar algunos elementos de forma explícita, y Perl intentará adivinar lo que quiere decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;perl&gt;	S&lt;[ B&lt;-sTtuUWX&gt; ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;perl&gt;	S&lt;[ B&lt;-sTtuUWX&gt; ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Non-string passed as bitmask</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040357Z" changeid="explorer">
        <seg>=head2 Non-string passed as bitmask</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$oldfh = select(STDERR); $| = 1; select($oldfh);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$oldfh = select(STDERR); $| = 1; select($oldfh);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requires require a 64-bit MIPS CPU (R8000, R10000, ...)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002610Z" changeid="explorer">
        <seg>Esto requiere una CPU MIPS de 64-bit (R8000, R10000, ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$n_encontrados = select($rout=$rin, $wout=$win, $eout=$ein, undef);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item q/STRING/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item q/STRING/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>quotemeta (and C&lt;\Q&gt; ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192847Z" changeid="explorer">
        <seg>quotemeta (y C&lt;\Q&gt; ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a new warning, produced when number has been passed as a argument to
select(), instead of a bitmask.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051009Z" changeid="explorer">
        <seg>Esta es una nueva advertencia, producida cuando un número ha sido pasado como un argumento a select(), en vez de una máscara de bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
can be done using the C&lt;O_TRUNC&gt; flag.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se puede hacer con el uso de la bandera C&lt;O_TRUNC&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blank lines between chunks that do different things.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Líneas en blanco entre bloques que hacen cosas diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And so do these:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así como estos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;MIME::Base64&gt; upgraded to version 3.07</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033903Z" changeid="explorer">
        <seg>C&lt;MIME::Base64&gt; actualizado a la versión 3.07</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%b    an unsigned integer, in binary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%b    un entero sin signo, en binario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values to be compared are always passed by reference and should not
be modified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores a ser comparados siempre se pasan por referencia y no deben ser modificados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the C&lt;local $SIG{__DIE__}&gt; construct for this purpose,
as this example shows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar la construcción C&lt;local $SIG{__DIE__}&gt; para este propósito, como muestra este ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Why is it free?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T195945Z" changeid="explorer">
        <seg>¿Por qué es gratis?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ucfirst EXPR
X&lt;ucfirst&gt; X&lt;uppercase&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210103Z" changeid="explorer">
        <seg>=item ucfirst EXPR
X&lt;ucfirst&gt; X&lt;uppercase&gt; X&lt;mayúscula&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 4) = 4   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 4) = 4   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack('sx2l', 12, 34);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack('sx2l', 12, 34);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some things that are planned for perl 5.10.0 :</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003826Z" changeid="explorer">
        <seg>Aquí hay algunas cosas que están previstas para Perl 5.10.0:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two potentially non-obvious but traditional C&lt;flock&gt; semantics are
that it waits indefinitely until the lock is granted, and that its locks
are B&lt;merely advisory&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T161744Z" changeid="explorer">
        <seg>Dos, potencialmente no obvias, pero tradicionales semánticas de C&lt;flock&gt; son: que espera indefinidamente hasta que el bloqueo se concede, y que sus cerrojos son B&lt;meramente consultivos&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That same loop could be replaced with a slice operation:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194731Z" changeid="explorer">
        <seg>Ese mismo bucle podría ser sustituido por una operación de corte:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlguts		Perl internal functions for those doing extensions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000514Z" changeid="explorer">
        <seg>perlguts		Funciones internas para crear extensiones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print sort backwards @harry;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print sort al_reves @harry;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item F&lt;h2xs&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003511Z" changeid="explorer">
        <seg>=item F&lt;h2xs&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-A  Same for access time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-A  Lo mismo, para el tiempo de acceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns 1 if the next read on FILEHANDLE will return end of file I&lt;or&gt; if
FILEHANDLE is not open.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T233048Z" changeid="explorer">
        <seg>Devuelve 1 si la siguiente lectura sobre IDENTIFICADOR_ARCHIVO devolverá un fin-de-archivo, I&lt;o&gt; si IDENTIFICADOR_ARCHIVO no está abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Carp&gt; and the internal diagnostic routines used by C&lt;Devel::Peek&gt; have been
made clearer, as described in L&lt;/Incompatible Changes&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110931Z" changeid="explorer">
        <seg>C&lt;Carp&gt; y las rutinas de diagnóstico internas utilizadas por C&lt;Devel::Peek&gt; se han hecho más claras, como se describe en L&lt;/Cambios incompatibles&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specify position as byte offset in the internal
                   representation of the packed string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050653Z" changeid="explorer">
        <seg>Especifica una posición como desplazamiento de byte en la
                   representación interna de la cadena empaquetada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Robin Houston)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T214856Z" changeid="explorer">
        <seg>(Robin Houston)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not recommended
for production code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003303Z" changeid="explorer">
        <seg>No se recomienda para código en producción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if successful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tuvo éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto-LABEL&gt; form finds the statement labeled with LABEL and
resumes execution there.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012509Z" changeid="explorer">
        <seg>La forma C&lt;goto-ETIQUETA&gt; busca la instrucción etiquetada con ETIQUETA y continua la ejecución desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or to force an anon hash constructor use C&lt;+{&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o para forzar a un constructor de un hash anónimo use C&lt;+{&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*)(\d+)$   &lt;I have 2 numbers: 5314&gt; &lt;7&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T234226Z" changeid="explorer">
        <seg>(.*)(\d+)$   &lt;Tengo 2 números: 5314&gt; &lt;7&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\x{263A}     [1,8]  hex char          (example: SMILEY)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T231308Z" changeid="explorer">
        <seg>\x{263A}	[1,8]	car. hex.			(ejemplo: SMILEY)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 16  ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 16  ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item VMS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230619Z" changeid="explorer">
        <seg>=item VMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say $ref_to_AoA-&gt;[2][1];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T025914Z" changeid="explorer">
        <seg>say $ref_to_AoA-&gt;[2][1];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, starting with
Perl 5.14, it returns the seed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182642Z" changeid="explorer">
        <seg>En cualquier caso, a partir de Perl 5.14, devuelve la semilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the warnings related to pack() and unpack() were made more
informative and consistent.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001356Z" changeid="explorer">
        <seg>Todos las advertencias relacionadas con pack() y unpack() se hicieron más informativas y consistentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the bug you are reporting has security implications, which make it
inappropriate to send to a publicly archived mailing list, then please
send it to perl5-security-report@perl.org.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052858Z" changeid="explorer">
        <seg>Si el fallo que está reportando tiene implicaciones de seguridad, que lo hace inadecuado para ser enviado a una lista de correo pública, por favor, envíelo a perl5-security-report@perl.org.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $Fld2;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234158Z" changeid="explorer">
        <seg>print $Fld2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*   multiplication</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235210Z" changeid="zipf">
        <seg>*   multiplicación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($key,$val) = each %HIST) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (($key,$val) = each %HIST) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 2) = 1   ==         64 00000010000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 2) = 1   ==         64 00000010000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/d&gt; modifier is used, the REPLACEMENTLIST is always interpreted
exactly as specified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se usa el modificador C&lt;/d&gt;, la LISTA_REEMPLAZO siempre es interpretada exactamente como esté especificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If @foo doesn't otherwise exist, then it's obviously a
character class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si @foo no existe, entonces es obvio que es una clase carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improved C&lt;nanosleep&gt; detection</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040934Z" changeid="explorer">
        <seg>Mejorada la detección de C&lt;nanosleep&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(@foo,@bar,&amp;SomeSub,%glarch)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(@foo,@bar,&amp;AlgunaSub,%glarch)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Begun in 1993 (see L&lt;perlhist&gt;), Perl version 5 is nearly a complete
rewrite that provides the following additional benefits:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T214625Z" changeid="explorer">
        <seg>En 1993 (vea L&lt;perlhist&gt;) se lanzó Perl 5, prácticamente una reescritura completa del lenguaje, que proporciona las siguientes ventajas adicionales:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@days{'a','c'}	# same as ($days{'a'},$days{'c'})</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@dias{'a','c'}	# igual que ($dias{'a'},$dias{'c'})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omitting the C&lt;continue&gt; section is equivalent to using an
empty one, logically enough, so C&lt;next&gt; goes directly back
to check the condition at the top of the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La omisión de la sección C&lt;continue&gt; es equivalente a usar un bloque vacío, como es lógico, por lo que C&lt;next&gt; va directamente a comprobar la condición en la parte superior del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @backwards = reverse @numbers;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T001800Z" changeid="zipf">
        <seg>my @orden_inverso = reverse @numeros;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is usually a mistake to intermix C&lt;alarm&gt; and C&lt;sleep&gt; calls, because
C&lt;sleep&gt; may be internally implemented on your system with C&lt;alarm&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001709Z" changeid="explorer">
        <seg>Normalmente es un error entremezclar llamadas a C&lt;alarm&gt; y C&lt;sleep&gt;, porque C&lt;sleep&gt; puede ser, internamente, implementado en su sistema con C&lt;alarm&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The call is implemented in terms of either Perl's or your system's native
fread(3) library function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La llamada es implementada en términos de Perl o de la función nativa fread(3) de su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 (Reminder) The $* variable is deprecated (really)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011438Z" changeid="explorer">
        <seg>=head3 (Recordatorio) La variable $* es obsoleta (de verdad)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;eq&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;eq&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;..&gt; and C&lt;...&gt; flip-flop operators are now evaluated in boolean
context, following their usual semantics; see L&lt;perlop/&quot;Range Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233213Z" changeid="explorer">
        <seg>Los operadores flip-flop C&lt;..&gt; y C&lt;...&gt; ahora son evaluados en contexto booleano, siguiendo su semántica normal; vea L&lt;perlop/&quot;Operadores de rango&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub func {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225542Z" changeid="explorer">
        <seg>sub func {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>}}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For portably packed integers, either use the formats C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt;, 
and C&lt;V&gt; or else use the C&lt;&lt; &gt; &gt;&gt; and C&lt;&lt; &lt; &gt;&gt; modifiers described
immediately below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para enteros empaquetados de forma portátil, o bien usar los formatos C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt;, y C&lt;V&gt; o bien los modificadores C&lt;&lt; &gt; &gt;&gt; y C&lt;&lt; &lt; &gt;&gt; descritos inmediatamente abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the handler's responsibility to deal with the message
as it sees fit (like, for instance, converting it into a C&lt;die&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es responsabilidad del controlador tratar el mensaje como lo considere oportuno (como, por ejemplo, convertirlo en un C&lt;die&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$pattern =~ s/(\W)/\\\1/g;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T224809Z" changeid="explorer">
        <seg>$patrón  =~ s/(\W)/\\\1/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item our TYPE EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item our TIPO EXPR : ATRIBUTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item VOS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230841Z" changeid="explorer">
        <seg>=item VOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open my $fh, &quot;@_&quot;
             or die &quot;Can't open '@_': $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043112Z" changeid="explorer">
        <seg>open my $fh, &quot;@_&quot;
             or die &quot;No puedo abrir '@_': $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to scoping</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Palabras clave relacionadas con el ámbito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># example: '# line 42 &quot;new_filename.plx&quot;'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ejemplo: '# line 42 &quot;nuevo_archivo.plx&quot;'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A positive OFFSET greater than the length of SCALAR
results in the string being padded to the required size with C&lt;&quot;\0&quot;&gt;
bytes before the result of the read is appended.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DESPLAZAMIENTO positivo mayor que la longitud de ESCALAR resulta en un cadena rellenada al tamaño requerido con bytes C&lt;&quot;\0&quot;&gt; antes de que el resultado de la lectura sea añadido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldebtut		Perl debugging tutorial</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000226Z" changeid="explorer">
        <seg>perldebtut		Tutorial de depuración</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>||</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>||</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, the global (package) scalar variable of the same
name as the FILEHANDLE contains the filename.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T001609Z" changeid="explorer">
        <seg>Si EXPR se omite, la variable escalar global (a nivel de paquete) del mismo nombre que el IDENTIFICADOR_ARCHIVO contiene el nombre del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its name comes from the observation that this operation combined with the
alternation operator (C&lt;|&gt;) can be used to create what is essentially a
pattern-based if/then/else block:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T141323Z" changeid="explorer">
        <seg>Su nombre proviene de la observación de que esta operación combinada con el operador de alternancia (C&lt;|&gt;) se puede utilizar para crear lo que es, esencialmente, un bloque basado en un patrón if/then/else:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=over</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(There is a maintenance penalty for
doing this, as mentioning C&lt;/o&gt; constitutes a promise that you won't
change the variables in the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T204558Z" changeid="explorer">
        <seg>(Hay un castigo en el mantenimiento, al hacer esto, porque al usar C&lt;/o&gt; constituye una promesa de que no va a cambiar las variables que hay dentro del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Yow!&quot; if $zippy;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235719Z" changeid="zipf">
        <seg>print &quot;¡Caramba!&quot; if $zippy;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version numbers should indicate at least major and minor releases, and
possibly sub-minor releases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025142Z" changeid="explorer">
        <seg>Los números de versión deben indicar al menos las versiones principales y secundarias, y posiblemente, versiones menores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE,
using the format associated with that file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013518Z" changeid="explorer">
        <seg>Escribe un registro formateado (posiblemente de varias líneas) al IDENTIFICADOR_ARCHIVO especificado, utilizando el formato asociado con ese archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Current categories under C&lt;CPAN/modules/by-category/&gt;
include Perl core modules; development support; operating system
interfaces; networking, devices, and interprocess communication; data
type utilities; database interfaces; user interfaces; interfaces to
other languages; filenames, file systems, and file locking;
internationalization and locale; world wide web support; server and
daemon utilities; archiving and compression; image manipulation; mail
and news; control flow utilities; filehandle and I/O; Microsoft
Windows modules; and miscellaneous modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230200Z" changeid="explorer">
        <seg>Las categorías especificadas actualmente en C&lt;CPAN/modules/by-category/&gt;
son: Perl core modules (módulos básicos de Perl); development support (utilidades para desarrollo); operating system interfaces (interfaces de sistemas operativos); networking, devices, and interprocess communication (redes, dispositivos y comunicación entre procesos); data type utilities (utilidades para tipos de datos); database interfaces (interfaces de bases de datos); user interfaces (interfaces de usuario); interfaces to other languages (interfaces de otros lenguajes); filenames, file systems, and file locking (nombres de archivos, sistemas de archivos y bloqueo de archivos); internationalization and locale (internacionalización y configuración regional); world wide web support (soporte para world wide web); server and
daemon utilities (utilidades para servidores y demonios); archiving and compression (almacenamiento y compresión); image manipulation (manipulación de imágenes); mail and news (correo y noticias); control flow utilities (utilidades para flujo de control); filehandle and I/O (identificadores de archivos y E/S); Microsoft
Windows modules (módulos para Microsoft Windows) y miscellaneous (varios).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some comparison documents can be found at http://www.perl.com/doc/FMTEYEWTK/versus/
if you really can't stop yourself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230757Z" changeid="explorer">
        <seg>Si no puede contener su curiosidad, en http://www.perl.com/doc/FMTEYEWTK/versus/ encontrará algunos documentos con comparaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}x</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195918Z" changeid="explorer">
        <seg>}x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C  An unsigned char (octet) value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C  Un valor de un carácter sin signo (octeto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\V        [3]  Not vertical whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224936Z" changeid="explorer">
        <seg>\V        [3]  No espacio en blanco vertical</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Text::Wrap;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225533Z" changeid="explorer">
        <seg>use Text::Wrap;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If POSITION is omitted, starts searching from the
beginning of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite POSICIÓN, comienza a buscar desde el comienzo del string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will not, in
itself, form the B&lt;entire&gt; toolkit.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031516Z" changeid="explorer">
        <seg>No formará, en sí mismo, el kit de herramientas B&lt;entero&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Error handling and messages</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023125Z" changeid="explorer">
        <seg>=head2 Control de errores y mensajes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;m//&gt;, C&lt;pos&gt;, C&lt;quotemeta&gt;, C&lt;s///&gt;, C&lt;split&gt;, C&lt;study&gt;, C&lt;qr//&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;m//&gt;, C&lt;pos&gt;, C&lt;quotemeta&gt;, C&lt;s///&gt;, C&lt;split&gt;, C&lt;study&gt;, C&lt;qr//&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates the BLOCK or EXPR for each element of LIST (locally setting
C&lt;$_&gt; to each element) and returns the list value consisting of those
elements for which the expression evaluated to true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa el BLOQUE o EXPRE para cada elemento de LISTA (poniendo localmente C&lt;$_&gt; a cada elemento) y devuelve un valor de lista consistente en los elementos por los que la expresión evaluada es verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;do BLOCK&gt; does I&lt;not&gt; count as a loop, so the loop control statements
C&lt;next&gt;, C&lt;last&gt;, or C&lt;redo&gt; cannot be used to leave or restart the block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012028Z" changeid="explorer">
        <seg>C&lt;do BLOQUE&gt; I&lt;no&gt; cuenta como un bucle, así que las instrucciones de control de bucle C&lt;next&gt;, C&lt;last&gt;, o C&lt;redo&gt; no pueden ser usadas para dejar o reiniciar el bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\L&gt;, C&lt;\U&gt;, and C&lt;\Q&gt; can stack, in which case you need one
C&lt;\E&gt; for each.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232723Z" changeid="explorer">
        <seg>C&lt;\L&gt;, C&lt;\U&gt;, y C&lt;\Q&gt; pueden apilarse, en cuyo caso necesita un C&lt;\E&gt; por cada uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$scalar = delete @hash{qw(foo bar)};     # $scalar is 22</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$scalar = delete @hash{qw(foo bar)};     # $scalar es 22</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eq  equality</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120435Z" changeid="zipf">
        <seg>eq  igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;/p&gt; X&lt;p modifier&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;/p&gt; X&lt;p modificador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value may be given to C&lt;seekdir&gt; to access a particular location in a
directory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor puede ser indicado a C&lt;seekdir&gt; para acceder a un lugar determinado en un directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scope of the package declaration is either the
supplied code BLOCK or, in the absence of a BLOCK, from the declaration
itself through the end of current scope (the enclosing block, file, or
C&lt;eval&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T004033Z" changeid="explorer">
        <seg>El alcance de la declaración del paquete es, tanto el BLOQUE indicado o, en ausencia de un BLOQUE, desde la misma declaración hasta el final del ámbito actual (el bloque, archivo o C&lt;eval&gt; que lo engloba).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
takes the cosine of C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T153945Z" changeid="explorer">
        <seg>Si EXPR se omite, devuelve el coseno de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gt  greater than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>gt  mayor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>},</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232143Z" changeid="explorer">
        <seg>},</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only things you need to declare in Perl are report formats and
subroutines (and sometimes not even subroutines).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los únicos elementos que necesita declarar en Perl son los informes y las subrutinas (y algunas veces ni siquiera las subrutinas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>})</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T221042Z" changeid="explorer">
        <seg>})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\U          uppercase till \E (think vi)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043857Z" changeid="explorer">
        <seg>\U		pasar a mayúscula hasta \E (como en vi)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else { # in body
            # do something else</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034211Z" changeid="explorer">
        <seg>} else { # en cuerpo
            # hacer otra cosa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Time::HiRes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Time::HiRes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function returns a packed string representing the requested socket
option, or C&lt;undef&gt; on error, with the reason for the error placed in
C&lt;$!&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T164649Z" changeid="explorer">
        <seg>La llamada devuelve una cadena empaquetada representando la opción socket solicitada, o C&lt;undef&gt; si hay un error, con la razón del error puesta en C&lt;$!&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length of ARRAY increases by the length of LIST.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T010809Z" changeid="explorer">
        <seg>La longitud de ARRAY se incrementa por la misma cantidad que la longitud de LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrebackslash/Misc&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220457Z" changeid="explorer">
        <seg>Vea L&lt;perlrebackslash/Miscelánea&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;j p \n&quot; ^ &quot; a h&quot;;        	# prints &quot;JAPH\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;j p \n&quot; ^ &quot; a h&quot;;        	# imprime &quot;JAPH\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Support for C&lt;configure_requires&gt; in CPAN module metadata</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003118Z" changeid="explorer">
        <seg>=head2 Suporte para C&lt;configure_requires&gt; en el módulo de CPAN metadata</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, gives C&lt;exp($_)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, devuelve C&lt;exp($_)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting C&lt;O_CREAT|O_EXCL&gt; prevents the file from
being opened if it is a symbolic link.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estableciendo C&lt;O_CREAT|O_EXCL&gt; impide que el archivo sea abierto si es un enlace simbólico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously while the order of hash
elements from keys(), values(), and each() was essentially random,
it was still repeatable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135026Z" changeid="explorer">
        <seg>Anteriormente, mientras que el orden de los elementos de un hash obtenidos mediante keys(), values() y each() era, esencialmente, aleatorio, seguía siendo replicable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item printf FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011503Z" changeid="explorer">
        <seg>=item printf IDENTIFICADOR_ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++($foo = &quot;99&quot;);	# prints &quot;100&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223811Z" changeid="explorer">
        <seg>print ++($foo = &quot;99&quot;);	# imprime &quot;100&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># or for GMT formatted appropriately for your locale:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># o para GMT formateado a su región:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 UTF-8 no longer default under UTF-8 locales</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143524Z" changeid="explorer">
        <seg>=head2 UTF-8 ya no está por defecto bajo la configuración regional de UTF-8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;fred&quot;, &quot;barney&quot;, &quot;pebbles&quot;, &quot;bambam&quot;, &quot;dino&quot;, ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;pedro&quot;, &quot;pablo&quot;, &quot;pebbles&quot;, &quot;bambam&quot;, &quot;dino&quot;, ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;&gt; 8;    # child exit status</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171152Z" changeid="explorer">
        <seg>&gt;&gt; 8;    # estado de salida del hijo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($str == 0 &amp;&amp; $str ne &quot;0&quot;)  {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($str == 0 &amp;&amp; $str ne &quot;0&quot;)  {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(STDERR, &quot;&gt;&amp;STDOUT&quot;)     or die &quot;Can't dup STDOUT: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004521Z" changeid="explorer">
        <seg>open(STDERR, &quot;&gt;&amp;STDOUT&quot;)     or die &quot;No puedo duplicar STDOUT: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you specify C&lt;&lt; '&lt;&amp;=X' &gt;&gt;, where C&lt;X&gt; is a file descriptor number
or a filehandle, then Perl will do an equivalent of C's C&lt;fdopen&gt; of
that file descriptor (and not call C&lt;dup(2)&gt;); this is more
parsimonious of file descriptors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011216Z" changeid="explorer">
        <seg>Si especifica C&lt;&lt; '&lt;&amp;=X' &gt;&gt;, donde C&lt;X&gt; es un número de descriptor de archivo o un identificador de archivo, entonces Perl hará un equivalente de C de C&lt;fdopen&gt; de ese descriptor de archivo (y no llamar a C&lt;dup(2)&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\R        [4]  Linebreak</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225002Z" changeid="explorer">
        <seg>\R        [4]  Ruptura de línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SCALAR this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SCALAR este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-00639-6 [2nd edition May 2009]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003456Z" changeid="explorer">
        <seg>ISBN 978-0-596-00639-6 [2ª edición - Mayo de 2009]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Same as C&lt;S{0,1}?&gt;, C&lt;S{0,BIG_NUMBER}?&gt;, C&lt;S{1,BIG_NUMBER}?&gt; respectively.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235842Z" changeid="explorer">
        <seg>Lo mismo que C&lt;S{0,1}?&gt;, C&lt;S{0,BIG_NUMBER}?&gt;, C&lt;S{1,BIG_NUMBER}?&gt; respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; line-noise&quot;),   redo LOOP if /\G\W+/gc;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030148Z" changeid="explorer">
        <seg>print(&quot; línea-ruido&quot;),	redo LOOP if /\G\W+/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, all
filehandles operate on bytes, but for example if the filehandle has
been opened with the C&lt;:utf8&gt; I/O layer (see L&lt;/open&gt;, and the C&lt;open&gt;
pragma, L&lt;open&gt;), the I/O will operate on UTF8-encoded Unicode
characters, not bytes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011120Z" changeid="explorer">
        <seg>Por defecto, todos los identificadores de archivo operan en bytes, pero por ejemplo, si el identificador ha sido abierto con la capa de E/S C&lt;:utf8&gt; (vea L&lt;/open&gt;, y el pragma C&lt;open&gt;, L&lt;open&gt;), la E/S operará en caracteres codificados en UTF-8, no bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No interpolation is performed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se realiza ninguna interpolación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VERSION must be a
&quot;strict&quot; style version number as defined by the L&lt;version&gt; module: a positive
decimal number (integer or decimal-fraction) without exponentiation or else a
dotted-decimal v-string with a leading 'v' character and at least three
components.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VERSIÓN debe ser un número de versión al estilo &quot;estricto&quot;, según lo define el módulo L&lt;version&gt;: un número decimal positivo (entero o decimal) sin exponentes o una v-cadena con una 'v' precedente con al menos tres componentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$line .= &lt;ARGV&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$linea .= &lt;ARGV&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># or ./Configure -de -Dusedevel</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># o ./Configure -de -Dusedevel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot read() (or sysread()) from a closed or unopened filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002745Z" changeid="explorer">
        <seg>No se puede read() (o sysread()) de un identificador de archivo cerrado o no abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume ANSI C89 plus the following:
- &lt;stddef.h&gt;, &lt;stdlib.h&gt;
- rename()
- opendir(), readdir(), closedir() (via dirent.h)
- memchr(), memcmp(), memcpy(), memset() (via string.h)
- (a safe) putenv() (via stdlib.h)
- strtoul() (via stdlib.h)
(grep for 'define' in uconfig.sh.)
Also, Perl times() is defined to always return zeroes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223330Z" changeid="explorer">
        <seg>Asumimos ANSI C89 más lo siguiente:
- &lt;stddef.h&gt;, &lt;stdlib.h&gt;
- rename()
- opendir(), readdir(), closedir() (vía dirent.h)
- memchr(), memcmp(), memcpy(), memset() (vía string.h)
- (un seguro) putenv() (vía stdlib.h)
- strtoul() (vía stdlib.h)
(grep para 'define' en uconfig.sh.)
También, Perl times() está definido para devolver siempre ceros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when it's a list-context assignment and you're trying to use
C&lt;||&gt; for control flow, you probably need &quot;or&quot; so that the assignment
takes higher precedence.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230804Z" changeid="explorer">
        <seg>Sin embargo, cuando se trata de una asignación en contexto de lista y usted está tratando de usar &quot;||&quot; para el control de flujo, es probable que necesite usar &quot;or&quot; para que la asignación tenga la mayor precedencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo =  150  |  105;	# yields 255  (0x96 | 0x69 is 0xFF)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo =  150  |  105;	# produce 255  (0x96 | 0x69 es 0xFF)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, reads until end-of-file
is reached and returns a list of lines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, lee hasta el final de archivo y devuelve una lista de líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation provides a cache, in
which you can store a single C&lt;SV *&gt;, or anything that can be cast to
C&lt;SV *&gt;, such as C&lt;AV *&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115051Z" changeid="explorer">
        <seg>La implementación proporciona una memoria caché, en el que puede almacenar un único C&lt;SV *&gt;, o cualquier cosa que se puede convertir a C&lt;SV *&gt;, como un C&lt;AV *&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Win32, S&lt;Plan 9&gt;, S&lt;RISC OS&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014923Z" changeid="explorer">
        <seg>(Win32, S&lt;Plan 9&gt;, S&lt;RISC OS&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
function calls the underlying operating system's I&lt;open&gt;(2) function with the
parameters FILENAME, MODE, and PERMS.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T020534Z" changeid="explorer">
        <seg>Esta función llama a la función subyacente del sistema operativo I&lt;open&gt;(2) con los parámetros ARCHIVO, MODO y PERMISOS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning is &lt;I have 2 numbers: 53147&gt;, number is &lt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233602Z" changeid="explorer">
        <seg>El comienzo es &lt;Tengo 2 números: 53147&gt;, número es &lt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final section, &quot;Common Pitfalls&quot;, describes some of the 
most popular mistakes made by CPAN authors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013248Z" changeid="explorer">
        <seg>La sección final, &quot;Errores comunes&quot;, describe algunos de los errores más populares hechas por los autores de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is now fixed [RT #50256].</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T004007Z" changeid="explorer">
        <seg>Esto ha sido arreglado [RT #50256].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item http://pause.perl.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T032048Z" changeid="explorer">
        <seg>=item http://pause.perl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parsing of the bracketed character class construct, C&lt;[...]&gt;, is
rather different than the rule used for the rest of the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El análisis de la construcción clase de caracteres, entre corchetes, C&lt;[...]&gt;, es bastante diferente a la regla utilizada para el resto del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>spicy tomato</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tomate especiado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That will efficiently match a nonempty group with matching parentheses
two levels deep or less.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T013443Z" changeid="explorer">
        <seg>Coincidirá, de manera eficiente, con un grupo no vacío de parejas de paréntesis anidados a dos niveles o menos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Net::Ping</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015235Z" changeid="explorer">
        <seg>=item Net::Ping</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ordering is the same as for the regular expression which is
the result of EXPR, or the pattern contained by capture group PARNO.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T000445Z" changeid="explorer">
        <seg>El orden es el mismo que para la expresión regular que sea el resultado de EXPR, o el patrón capturado en el grupo de captura PARNO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transliteration operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador de transliteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item wait
X&lt;wait&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210844Z" changeid="explorer">
        <seg>=item wait
X&lt;wait&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlnumber - semantics of numbers and numeric operations in Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232255Z" changeid="explorer">
        <seg>perlnumber - Semántica de números y operaciones numéricas en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pattern C&lt;/PATTERN/&gt; may be replaced with an expression to specify
patterns that vary at runtime.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El patrón C&lt;/PATRÓN/&gt; puede ser sustituido por una expresión para especificar patrones que varían en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Unicode::Normalize</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Unicode::Normalize</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shmread ID,VAR,POS,SIZE
X&lt;shmread&gt;
X&lt;shmwrite&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200631Z" changeid="explorer">
        <seg>=item shmread ID,VAR,POSICIÓN,TAMAÑO
X&lt;shmread&gt; X&lt;shmwrite&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc/&quot;UDP: Message Passing&quot;&gt; for examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc/&quot;UDP: Paso de mensajes&quot;&gt; para ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If PATTERN is also omitted,
splits on whitespace (after skipping any leading whitespace).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si PATRÓN es también omitido, se divide por el espacio en blanco(después de saltarse cualquier espacio en blanco precedente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;overloading&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005439Z" changeid="explorer">
        <seg>=item C&lt;overloading&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the C&lt;base&gt; pragma, an intermediate class with no fields used to messes
up private fields in the base class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con el pragma C&lt;base&gt;, una clase intermedia sin campos es utilizada para mezclarse con los campos privados de la clase base.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>179231</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>179231</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1  0..2  &quot;george&quot; &quot;jane&quot; &quot;elroy&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032417Z" changeid="explorer">
        <seg>1  0..2  &quot;george&quot; &quot;jane&quot; &quot;elroy&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If it's text
data.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235419Z" changeid="explorer">
        <seg>(si son datos de tipo texto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/index_thr.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010020Z" changeid="explorer">
        <seg>=item t/op/index_thr.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Math::Complex;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Math::Complex;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-number v-strings like C&lt;v65.66&gt; and C&lt;65.66.67&gt; continue to
be v-strings always.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>V-strings multi números como C&lt;v65.66&gt; y C&lt;65.66.67&gt; siguen siendo v-strings.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(STDERR, &quot;&gt;&amp;OLDERR&quot;)    or die &quot;Can't dup OLDERR: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004547Z" changeid="explorer">
        <seg>open(STDERR, &quot;&gt;&amp;OLDERR&quot;)    or die &quot;No puedo duplicar OLDERR: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%+10.6d&gt;', 1;   # prints &quot;&lt;   +000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%+10.6d&gt;', 1;   # imprime &quot;&lt;   +000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl also has its own built-in variables whose names don't follow
these rules.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl también tiene su propias variables incorporadas cuyos nombres no siguen estas reglas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die 'foo';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die 'foo';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl build system starts with the F&lt;Configure&gt; script in the root
directory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014853Z" changeid="explorer">
        <seg>El sistema de compilación de Perl empieza por el script F&lt;Configure&gt; del directorio raíz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596528126</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003555Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596528126</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you haven't used regular expressions before, a quick-start
introduction is available in L&lt;perlrequick&gt;, and a longer tutorial
introduction is available in L&lt;perlretut&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no ha utilizado expresiones regulares antes, una introducción rápida está disponible en L&lt;perlrequick&gt;, y un cursillo de introducción mayor está disponible en L&lt;perlretut&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Jerry
D. Hedden)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112146Z" changeid="explorer">
        <seg>(Jerry D. Hedden)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now we can use the subroutine just as any other built-in function:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T004124Z" changeid="zipf">
        <seg>Ahora podemos usar la subrutina como cualquier función integrada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(uc($bar),$baz);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(uc($bar),$baz);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See setpriority(2).)  Raises an exception when used on a machine
that doesn't implement setpriority(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver setpriority(2)). Lanza una excepción cuando se utiliza en una máquina que no implementa setpriority(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;cat -n '$file'|&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, &quot;cat -n '$archivo'|&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Special Backtracking Control Verbs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T002514Z" changeid="explorer">
        <seg>=head2 Verbos especiales para el control de la vuelta atrás</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also gain some minuscule measure of efficiency by pre-extending
an array that is going to get big.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También se puede ganar una minúscula cantidad de eficiencia pre-extendiendo un array que va a hacerse grande.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
the actual argument was negative, Perl would call FETCHSIZE implicitly
and add the result to the index before passing the result to the tied
array method.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170403Z" changeid="explorer">
        <seg>Si el argumento era negativo, Perl llamaría a FETCHSIZE de forma implícita y sumaría el resultado al índice antes de pasar el resultado al método de array enlazado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6 rdev     the device identifier (special files only)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>6 rdev     identificador del dispositivo (solo archivos especiales)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?adluimsx-imsx:pattern)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T194136Z" changeid="explorer">
        <seg>=item C&lt;(?adluimsx-imsx:patrón)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;Bitwise String Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185827Z" changeid="explorer">
        <seg>Ver L&lt;perlop/&quot;Operadores de bit en cadenas&quot;&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printing to a closed pipe or socket will generate a SIGPIPE signal.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Imprimir a una tubería o socket cerrados generará una señal SIGPIPE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also Perl's exception-trapping mechanism, where
the die operator is used to raise exceptions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T160639Z" changeid="explorer">
        <seg>También es el mecanismo de captura de excepciones, donde el operador die se usa para levantar excepciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are some cases where Perl can't immediately tell the difference
between an expression and a statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012714Z" changeid="explorer">
        <seg>Hay algunos casos donde Perl no puede decir, de forma inmediata, la diferencia entre una expresión y una instrucción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore C&lt;&lt;&lt;EOF&gt; is
terminated by C&lt;EOF&gt; immediately followed by C&lt;&quot;\n&quot;&gt; and starting
from the first column of the terminating line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto C&lt;&lt;&lt;EOF&gt; es terminado por un C&lt;EOF&gt; inmediatamente seguido por un C&lt;&quot;\n&quot;&gt; y empezando en la primera columna de la línea de terminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ref_to_AoA-&gt;[2]-&gt;[2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ref_to_AoA-&gt;[2]-&gt;[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when ([ 'pear', 'apple' ]) { 1 }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223444Z" changeid="explorer">
        <seg>when ([ 'pera', 'manzana' ]) { 1 }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document exists to list all of these utilities, explain
what they are for and provide pointers to each module's documentation,
if appropriate.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233240Z" changeid="explorer">
        <seg>Este documento contiene una descripción de las utilidades y referencias a la documentación de cada módulo (si existe).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aaab</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050700Z" changeid="explorer">
        <seg>aaab</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aaaa</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T221044Z" changeid="explorer">
        <seg>aaaa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will test only the regex, which causes both operands to be treated as boolean.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215305Z" changeid="explorer">
        <seg>pondrá a prueba sólo la expresión regular, lo que hace que ambos operandos sean tratados como booleanos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine you'd like to match
everything between &quot;foo&quot; and &quot;bar&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T154727Z" changeid="explorer">
        <seg>Imagínese que quisiera buscar todo lo que hay entre &quot;mesa&quot; y &quot;come&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now weaken references to read only values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora puede debilitar referencias para leer solo valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 2) = 2   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 2) = 2   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (my $ev_err = $@) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (my $ev_err = $@) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDERR &quot;stderr 1\n&quot;;  # subprocesses too</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print STDERR &quot;stderr 1\n&quot;;  # también para subprocesos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the Fcntl module or your fcntl(2)
manpage to learn what functions are available on your system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el módulo Fcntl o la página de manual fcntl(2) para aprender qué funciones están disponibles en su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a side-effect, no longer refuses to startup when
run by root.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T174452Z" changeid="explorer">
        <seg>Como efecto colateral, ya no se niega a iniciarse cuando se ejecuta como el usuario root.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replace C&lt;5.14.2&gt; with your respective version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111002T143739Z" changeid="explorer">
        <seg>Reemplace C&lt;5.14.2&gt; con su respectiva versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The comp.lang.perl.*
newsgroups and several of the mailing lists provide free answers to your
questions in near real-time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231028Z" changeid="explorer">
        <seg>Los grupos de noticias comp.lang.perl.* y varias listas de correo ofrecen respuestas a sus preguntas de forma gratuita y casi en tiempo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're planning to filetest the return values out of a C&lt;readdir&gt;, you'd
better prepend the directory in question.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está planeando hacer test de archivos de los valores retornados por un C&lt;readdir&gt;, más le vale anteponer el directorio en cuestión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2254 Pthread library fixes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004316Z" changeid="explorer">
        <seg>2254 Pthread arreglos en biblioteca</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is omitted, assumes the file
last read.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013201Z" changeid="explorer">
        <seg>Si IDENTIFICADOR_ARCHIVO se omite, se asume que es el último archivo leído.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Perl emulates the
system call by remembering the status values of processes that have
exited but have not been harvested by the Perl script yet.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Perl emula la llamada al sistema, recordando los valores de estado de los procesos que han salido, pero que todavía no han sido recolectadas por el script Perl).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Tcsh</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225453Z" changeid="explorer">
        <seg>=item Tcsh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Tie::IxHash;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225615Z" changeid="explorer">
        <seg>use Tie::IxHash;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, if
the number is 255 (0xFF, 0377) or below, Perl interprets this in the platform's
native encoding.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T200834Z" changeid="explorer">
        <seg>En general, si el número es 255 (0xFF, 0377) o menor, Perl lo interpreta en la codificación nativa de la plataforma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2/10850 subtests failed, 99.98% okay.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2/10850 subtests failed, 99.98% okay.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Num     numish[4] numeric equality         $a == $b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Número      numeral[4] igualdad numérica                $a == $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-O  File is owned by real uid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004605Z" changeid="explorer">
        <seg>-O  Archivo es propiedad del uid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec &quot;sort $outfile | uniq&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec &quot;sort $salida | uniq&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as after matching the A but failing on the B the C&lt;(*THEN)&gt; verb will
backtrack and try C; but the C&lt;(*PRUNE)&gt; verb will simply fail.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T141733Z" changeid="explorer">
        <seg>porque después de buscar por la A, pero fallando con la B, el verbo C&lt;(*THEN)&gt; dará una vuelta atrás y lo intentará con C; pero el verbo C&lt;(*PRUNE)&gt; simplemente fallará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$hints&gt; and C&lt;$bitmask&gt; contain pragmatic hints that the caller was
compiled with.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$hints&gt; y C&lt;$bitmask&gt; contienen detalles para los cuales caller fue compilado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the Cross/README file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010031Z" changeid="explorer">
        <seg>Vea el archivo Cross/README.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want all items in C&lt;@ARGV&gt; to be interpreted as file names, you
can use the module C&lt;ARGV::readonly&gt; from CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea que todos los elementos de C&lt;@ARGV&gt; deban ser interpretados como nombres de archivo, puede utilizar el módulo C&lt;ARGV::readonly&gt; de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item GNU Emacs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item GNU Emacs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a discussion of the important changes in this release, see
pod/perldelta.pod.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T221802Z" changeid="explorer">
        <seg>Para una discusión de los cambios importantes en esta versión, consulte pod/perldelta.pod.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, putting
a C&lt;use&gt; inside the false branch of a conditional doesn't prevent it
from being processed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, poniendo un C&lt;use&gt; dentro de la rama falsa de un condicional no impide que sea procesado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;/(?&lt;=\t)\w+/&gt;
matches a word that follows a tab, without including the tab in C&lt;$&amp;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T211652Z" changeid="explorer">
        <seg>Por ejemplo, C&lt;/(?&lt;=\t)\w+/&gt; coincide con una palabra seguida por un tabulador, sin incluir el tabulador en C&lt;$&amp;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a pattern, you may designate subpatterns for later reference
by enclosing them in parentheses, and you may refer back to the
I&lt;n&gt;th subpattern later in the pattern using the metacharacter
\I&lt;n&gt; or \gI&lt;n&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T224159Z" changeid="explorer">
        <seg>Dentro de un patrón, puede designar subpatrones para su posterior consulta encerrándolos entre paréntesis, y puede referirse al subpatrón I&lt;n&gt;-ésimo más adelante, en el patrón utilizando el metacarácter \I&lt;n&gt; o \gI&lt;n&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will now (correctly) fail under use strict.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110351Z" changeid="explorer">
        <seg>ahora fallará (correctamente) bajo el uso estricto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;A&gt; is a better match for C&lt;S&gt; than C&lt;A'&gt;, C&lt;AB&gt; is a better
match than C&lt;A'B'&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235152Z" changeid="explorer">
        <seg>Si C&lt;A&gt; es una mejor coincidencia para C&lt;S&gt; que C&lt;A'&gt;, C&lt;AB&gt; es una mejor coincidencia que C&lt;A'B'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($package, $filename, $line) = caller;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($paquete, $nombre_archivo, $linea) = caller;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$newAoA[$x - $startx][$y - $starty] = $AoA[$x][$y];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053011Z" changeid="explorer">
        <seg>$newAoA[$x - $startx][$y - $starty] = $AoA[$x][$y];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notably, the
ctime field is non-portable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, el campo ctime no es portátil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsolaris 	Perl notes for Solaris</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsolaris 	Notas para Solaris</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless ( condition ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002940Z" changeid="zipf">
        <seg>unless ( condición ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
external interface is unchanged, and aside from the bug fixes described
above, there should be no change in behaviour.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El interfaz externo no se ha modificado, y aparte de la corrección de errores descritos anteriormente, no debería haber ningún cambio en el comportamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$wday&gt; is the day of the week, with 0 indicating Sunday and 3 indicating
Wednesday.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$sdia&gt; es el día de la semana, con 0 indicando domingo y 3 indicando miércoles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More precisely: the subtests
using datagram sockets fail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Precisando más: las subpruebas usando sockets de datagramas fallan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used on numbers, the bitwise operators (&quot;&amp;&quot;, &quot;|&quot;, &quot;^&quot;, &quot;~&quot;, &quot;&lt;&lt;&quot;,
and &quot;&gt;&gt;&quot;) always produce integral results.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usado en números, los operadores binarios (&quot;&amp;&quot;, &quot;|&quot;, &quot;^&quot;, &quot;~&quot;, &quot;&lt;&lt;&quot;, y &quot;&gt;&gt;&quot;) siempre producen resultados enteros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=encoding utf8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=encoding utf8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;This \Qquoting \ubusiness \Uhere isn't quite\E done yet,\E is it?&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T233227Z" changeid="explorer">
        <seg>say &quot;Este \Qtrabajo de \uescapado \Uaún no se ha\E terminado,\E ¿no?&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scalar value is B&lt;not&gt; locale-dependent but is a Perl builtin.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171226Z" changeid="explorer">
        <seg>Este valor escalar B&lt;no&gt; es dependiente de la región, sino que viene de una función interna de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;31&quot;);  print $z2[$mday];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224432Z" changeid="explorer">
        <seg>&quot;31&quot;);  print $z2[$dmes];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Virtually
all known and current Unix derivatives are supported (perl's native
platform), as are other systems like VMS, DOS, OS/2, Windows,
QNX, BeOS, OS X, MPE/iX and the Amiga.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225402Z" changeid="explorer">
        <seg>Es compatible con prácticamente todos los sistemas operativos derivados de Unix (la plataforma nativa de perl) conocidos y actuales, así como con otros sistemas como VMS, DOS, OS/2, Windows, QNX, BeOS, OS X, MPE/iX y Amiga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%days		# (key1, val1, key2, val2 ...)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%dias		# (clave1, valor1, clave2, valor2 ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/(\w+)/\u\L$1/g;   # &quot;titlecase&quot; words</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/(\w+)/\u\L$1/g;   # capitaliza las palabras</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This last example splits $foo into the first two words and the
remainder of the line, and assigns those three fields to $F1, $F2, and
$Etc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este último ejemplo divide $foo en las dos primeras palabras y el resto de la línea, y asigna los tres campos a $F1, $F2, y $Etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ten years ago it was a dead
camel carcass (according to this document).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004258Z" changeid="explorer">
        <seg>Hace diez años era un camello muerto (según este documento).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$time = stat($file)[8];  # OOPS, FORGOT PARENTHESES</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004227Z" changeid="explorer">
        <seg>$acceso = stat($archivo)[8];  # ¡OOPS!, OLVIDÓ LOS PARÉNTESIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those constructs are discouraged
anyway.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035000Z" changeid="explorer">
        <seg>Se desaconseja, de todas maneras, usar estas construcciones.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open() or die $!;  `$userinput`     use.perl.org</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224326Z" changeid="explorer">
        <seg>open() or die $!;  `$entrada_usuario`     use.perl.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a simple example to illustrate the difference between
the two range operators:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He aquí un ejemplo sencillo para ilustrar la diferencia entre los dos operadores rango:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all other regards, &quot;...&quot; behaves just like &quot;..&quot; does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En todos los demás aspectos, &quot;...&quot; se comporta como &quot;..&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RE engine scans the string from left to right and
converts it to a finite automaton.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El motor de RE explora la cadena de izquierda a derecha y lo convierte en un autómata finito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say '$foo is the string &quot;foo&quot;';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>say '$foo es la cadena &quot;foo&quot;';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#X&gt;',  12;   # prints &quot;&lt;0XC&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#X&gt;',  12;   # imprime &quot;&lt;0XC&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/d&gt; modifier is specified, any characters
specified by SEARCHLIST not found in REPLACEMENTLIST are deleted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se especifica el modificador C&lt;/d&gt;, cualquier carácter especificado por LISTA_BÚSQUEDA que no sea encontrado en la LISTA_REEMPLAZO es eliminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARRAY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ARRAY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See C&lt;getpriority(2)&gt;.)  Will raise a fatal exception if used on a
machine that doesn't implement getpriority(2).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015228Z" changeid="explorer">
        <seg>(Ver L&lt;getpriority&gt;). Lanzará una excepción fatal si se usa en una máquina que no implemente getpriority(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>H  A hex string (high nybble first).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>H  Una cadena hexadecimal (primero el nibble alto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getpwuid($num);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$name  = getpwuid($num);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;(?0)&gt; is an alternate syntax for
C&lt;(?R)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T184230Z" changeid="explorer">
        <seg>C&lt;(?0)&gt; es una sintaxis alternativa para C&lt;(?R)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should reopen those to F&lt;/dev/null&gt; if it's any issue.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Deberá reabrirlos a F&lt;/dev/null&gt; si eso es un problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3];            # array slice</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3];            # porción array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002620Z" changeid="explorer">
        <seg>También puede usar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (ref($r) eq &quot;HASH&quot;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (ref($r) eq &quot;HASH&quot;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Tony Stubblebine</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003317Z" changeid="explorer">
        <seg>Tony Stubblebine</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a comprehensive date and time representation look at the
L&lt;DateTime&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una completa y actualizada representación del tiempo mire el módulo L&lt;DateTime&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(3,1,3);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>set_vec(3,1,3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you've downloaded the binary distribution, it needs to be
installed below /usr/local.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101217Z" changeid="explorer">
        <seg>Si ha descargado la distribución binaria, necesita ser instalada en /usr/local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently NAME is restricted to simple identifiers only.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T214029Z" changeid="explorer">
        <seg>Actualmente NOMBRE está limitado solamente a identificadores sencillos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are improved hints for next-3.0, vmesa, IX, Darwin, Solaris, Linux,
DEC/OSF, HP-UX and MPE/iX</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T043337Z" changeid="explorer">
        <seg>Hay mejoras para next-3.0, vmesa, IX, Darwin, Solaris, Linux,
DEC/OSF, HP-UX y MPE/iX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmacosx		Perl notes for Mac OS X</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmacosx		Notas para Mac OS X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$atime,$mtime,$ctime,$blksize,$blocks)
           = stat($filename);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051833Z" changeid="explorer">
        <seg>$atime,$mtime,$ctime,$blksize,$blocks)
           = stat($archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We are grateful to the Debian project for their input in this area.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estamos muy agradecidos con el proyecto Debian por sus aportaciones en este ámbito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's equivalent to C&lt;||&gt; except for the very low precedence.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230327Z" changeid="explorer">
        <seg>Es equivalente a &quot;||&quot; excepto por tener una precedencia muy baja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mode remains in effect until the next 
mode change, or until the end of the C&lt;()&gt; group it (directly) applies to.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este modo permanece activo hasta el cambio del modo siguiente, o hasta el final del grupo C&lt;()&gt; en que se aplicó directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In related fixes, it was possible for badly written code that did not follow
the documentation of C&lt;Sys::Syslog&gt; to have formatting vulnerabilities.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044717Z" changeid="explorer">
        <seg>En arreglos relacionados, era posible, para código mal escrito que no siguiera la documentación de C&lt;Sys::Syslog&gt;, tener vulnerabilidades en el formateo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no elements in the
array, returns the undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay elementos en el array, devuelve el valor undef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're
dealing with just matrices, it's often easiest to use simple assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está tratando con matrices justo, a menudo es más fácil usar una asignación simple:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $a = $hash{&quot;ABC&quot;};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190144Z" changeid="zipf">
        <seg>my $a = $hash{&quot;ABC&quot;};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my($bits);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my($bits);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
is intended as a &quot;bootstrap&quot; guide for those who are new to the
language, and provides just enough information for you to be able to
read other peoples' Perl and understand roughly what it's doing, or
write your own simple scripts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224536Z" changeid="explorer">
        <seg>Es una guía de iniciación para los nuevos usuarios del lenguaje que proporciona la información necesaria para poder leer el código Perl de otras personas y comprender a grandes rasgos su funcionamiento, o para escribir scripts sencillos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Devel::PPPort&gt; upgraded to version 3.06_01</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030155Z" changeid="explorer">
        <seg>C&lt;Devel::PPPort&gt; actualizado a la versión 3.06_01</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the right side is a method name or a simple scalar
variable containing either the method name or a subroutine reference,
and the left side must be either an object (a blessed reference)
or a class name (that is, a package name).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, el lado derecho es un nombre de método o una variable escalar simple conteniendo ya sea el nombre del método o una referencia a una subrutina, y el lado izquierdo debe ser un objeto (una referencia bendecida) o un nombre de clase (es decir, un nombre de paquete).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before any operation that may do a fork, but this may not be
supported on some platforms (see L&lt;perlport&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215506Z" changeid="explorer">
        <seg>Empezando con v5.6.0, Perl intentará vaciar todos los archivos abiertos para la salida antes de cualquier operación que pueda hacer un fork, pero esto quizás no esté soportado en algunas plataformas (vea L&lt;perlport&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die unless $@ eq &quot;alarm\n&quot;;   # propagate unexpected errors</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die unless $@ eq &quot;alarma\n&quot;;   # propagar errores inesperados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, you don't need the temporary array to have a name at all:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por supuesto, no necesita el array temporal para nada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*?)(\d+)$</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233809Z" changeid="explorer">
        <seg>(.*?)(\d+)$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless you've
changed this (such as building Perl with C&lt;Configure -Uuseperlio&gt;), you can
open filehandles directly to Perl scalars via:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003757Z" changeid="explorer">
        <seg>A menos que haya cambiado esto (como compilar Perl con C&lt;Configure -Uuseperlio&gt;), puede abrir identificadores de archivo directamente a escalares Perl de esta forma:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some new keywords have been introduced.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T011643Z" changeid="explorer">
        <seg>Some new keywords have been introduced.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;x&gt; and C&lt;X&gt; accept the C&lt;!&gt; modifier to act as alignment commands: they
jump forward or back to the closest position aligned at a multiple of C&lt;count&gt;
characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;x&gt; y C&lt;X&gt; aceptan el modificar C&lt;!&gt; para actuar como comando de alineamiento: saltan hacia adelante o atrás a la posición más cercana alineada a un múltiplo de C&lt;contador&gt; caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules should be packaged using one of the standard packaging tools.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030736Z" changeid="explorer">
        <seg>Los módulos deben estar empaquetados con una de las herramientas de empaquetado estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Unicode</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234256Z" changeid="explorer">
        <seg>=head3 Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item visiPerl+</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>=item visiPerl+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my($min, $max) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225521Z" changeid="explorer">
        <seg>my($min, $max) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The caret tells Perl that this cluster doesn't inherit the flags of any
surrounding pattern, but uses the system defaults (C&lt;d-imsx&gt;),
modified by any flags specified.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T194538Z" changeid="explorer">
        <seg>El circunflejo le dice a Perl que esta agrupación no hereda las banderas de ningún patrón vecino, pero usa los valores por defecto del sistema (C&lt;d-imsx&gt;), modificado por cualquier otra bandera especificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item umask</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item umask</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>l   Use the locale</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T223036Z" changeid="explorer">
        <seg>l	Usa la definición regional local (I&lt;locale&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because you're assigning to
an @array, so you need parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es así porque está asignando a un @array, por lo que necesita usar paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do various useful things to lists:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T002003Z" changeid="zipf">
        <seg>Puede hacer varias cosas útiles con las listas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-i&gt;[I&lt;extension&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-i&gt;[I&lt;extensión&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/continue&gt; for an illustration of how C&lt;last&gt;, C&lt;next&gt;, and
C&lt;redo&gt; work.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/continue&gt; para una ilustración de cómo funcionan C&lt;last&gt;, C&lt;next&gt; y C&lt;redo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is important only if
C&lt;S&gt; has capturing parentheses, and backreferences are used somewhere
else in the whole regular expression.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T000147Z" changeid="explorer">
        <seg>(Esto es importante sólo si C&lt;S&gt; tiene paréntesis de captura, y las contrareferencias son utilizadas en otra parte de la expresión regular.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot; ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot; ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($variable) {		# trim whitespace in $variable, cheap</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ($variable) {		# recorta el espacio en blanco en $variable, de forma más simple</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( /foo(.*?)bar/ ) { print &quot;got &lt;$1&gt;\n&quot; }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T155329Z" changeid="explorer">
        <seg>if ( /mesa(.*?)come/ ) { print &quot;obtiene &lt;$1&gt;\n&quot; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Requirements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Requisitos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a % 2) ? ($a += 10) : ($a += 2)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054124Z" changeid="explorer">
        <seg>($a % 2) ? ($a += 10) : ($a += 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But alternative
hashing schemes (like MD5), higher level security schemes (like C2),
and implementations on non-Unix platforms may produce different
strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero esquemas alternativos de cálculo de hash (como MD5), esquemas de seguridad de alto nivel (como C2) e implementaciones en plataformas no UNIX pueden producir cadenas diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some documentation improvements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas mejoras en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;http://archive.develooper.com/perl-mvs@perl.org/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T064835Z" changeid="explorer">
        <seg>http://archive.develooper.com/perl-mvs@perl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,}+  Match at least n times and give nothing back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n,}+  Coincide al menos n veces y no devuelve nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl Mongers uses the pm.org domain for services related to Perl user
groups, including the hosting of mailing lists and web sites.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231338Z" changeid="explorer">
        <seg>Perl Mongers usa el dominio pm.org para ofrecer servicios relacionados para grupos de usuarios de Perl, como el alojamiento de listas de correo y sitios web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$oct_perm_str = sprintf &quot;%o&quot;, $perms;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$oct_perm_str = sprintf &quot;%o&quot;, $permisos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rounded = sprintf(&quot;%.3f&quot;, $number);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$redondeo = sprintf(&quot;%.3f&quot;, $numero);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the exception is outside of all enclosing C&lt;eval&gt;s, then the uncaught
exception prints LIST to C&lt;STDERR&gt; and exits with a non-zero value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170937Z" changeid="explorer">
        <seg>Si la excepción está fuera de un C&lt;eval&gt;, entonces la excepción no capturada imprime LISTA al C&lt;STDERR&gt; y sale con un valor no nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's cleaner, safer, and faster.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más limpio, seguro y rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5004delta	Perl changes in version 5.004</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5004delta	Cambios en la versión 5.004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the B&lt;-i&gt; switch in L&lt;perlrun&gt; for a
better approach.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver la opción B&lt;-i&gt; en L&lt;perlrun&gt; para una mejor aproximación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use the C&lt;use warnings&gt; pragma or Perl's B&lt;-w&gt; command-line 
option, you may see warnings
about useless uses of constants or functions in &quot;void context&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T000519Z" changeid="explorer">
        <seg>Cuando se utiliza el pragma C&lt;use warnings&gt; o la opción de Perl en la línea de órdenes B&lt;-w&gt;, pueden mostrarse avisos sobre el uso inútil de constantes o funciones en contexto vacío (&quot;I&lt;void&gt;&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This strategy
is so successful that Perl programmers often do not suspect the
ambivalence of what they write.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta estrategia es tan exitosa que los programadores de Perl a menudo no sospechan de la ambivalencia de lo que escriben.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tutorial documents included in current or upcoming Perl releases
include L&lt;perltoot&gt; for objects or L&lt;perlboot&gt; for a beginner's
approach to objects, L&lt;perlopentut&gt; for file opening semantics,
L&lt;perlreftut&gt; for managing references, L&lt;perlretut&gt; for regular
expressions, L&lt;perlthrtut&gt; for threads, L&lt;perldebtut&gt; for debugging,
and L&lt;perlxstut&gt; for linking C and Perl together.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230324Z" changeid="explorer">
        <seg>Entre los tutoriales incluidos en la versión actual de Perl (o en futuras versiones) se cuentan L&lt;perltoot&gt; (objetos), L&lt;perlboot&gt; (introducción a la programación orientada a objetos para principiantes), L&lt;perlopentut&gt; (semántica de apertura de archivos), L&lt;perlreftut&gt; (administración de referencias), L&lt;perlretut&gt; (expresiones regulares), L&lt;perlthrtut&gt; (hilos de ejecución), L&lt;perldebtut&gt; (depuración) y L&lt;perlxstut&gt; (comunicación de código C con código Perl).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If ARRAY is omitted, pops the C&lt;@ARGV&gt; array in the
main program, but the C&lt;@_&gt; array in subroutines, just like C&lt;shift&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192655Z" changeid="explorer">
        <seg>Si ARRAY se omite, se extrae desde el array C&lt;@ARGV&gt; en el programa principal, y del array C&lt;@_&gt; en subrutinas, igual que C&lt;shift&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item kill</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014845Z" changeid="explorer">
        <seg>=item kill</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, when a LIST is
evaluated, each element of the list is evaluated in list context, and
the resulting list value is interpolated into LIST just as if each
individual element were a member of LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, cuando una LISTA se evalúa, cada elemento de la lista se evalúa en contexto lista, y el valor de la lista resultante se interpola en la LISTA como si cada elemento individual fuera un miembro de LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type prefix of a typeglob is a C&lt;*&gt;, because
it represents all types.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El prefijo de un tipo de typeglob es una C&lt;*&gt;, porque representa todos los tipos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} $x_lo ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053113Z" changeid="explorer">
        <seg>} $x_lo ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Storing numbers</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232425Z" changeid="explorer">
        <seg>=head1 Cómo se almacenan los números</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to connect to a remote socket, just like connect(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intenta conectarse a un socket remoto, al igual que connect(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a &lt;FILEHANDLE&gt; is used in a context that is looking for
a list, a list comprising all input lines is returned, one line per
list element.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014049Z" changeid="explorer">
        <seg>Si un &lt;IDENTIFICADOR_ARCHIVO&gt; es utilizado en un contexto en el que está esperando una lista, es devuelta una lista que contiene todas las líneas de entrada, una línea por cada elemento de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get multiple values from an array:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T223516Z" changeid="zipf">
        <seg>Para obtener varios elementos de un array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use SDBM_File;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190121Z" changeid="zipf">
        <seg>use SDBM_File;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, return 1 for each valid line, and 0 after all lines have been
returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De nuevo, devuelve 1 para cada línea válida y 0 después de que todas las líneas han sido devueltas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can actually chop anything that's an lvalue, including an assignment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede recortar cualquier cosa que sea un lvalue (valor a la izquierda), incluyendo una asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @greek_small =  (&quot;\N{alpha}&quot; ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @griegas_minusculas =  (&quot;\N{alpha}&quot; ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $foo = '';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $foo = '';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New parser</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Nuevo analizador</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you don't have a C compiler, you're doomed and your vendor
should be sacrificed to the Sun gods.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225812Z" changeid="explorer">
        <seg>Como no tiene un compilador de C, no puede hacerlo; podría descargar su ira contra su proveedor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getservent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getservent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To forbid ASCII/non-ASCII matches (like &quot;k&quot; with C&lt;\N{KELVIN SIGN}&gt;),
specify the &quot;a&quot; twice, for example C&lt;/aai&gt; or C&lt;/aia&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000127Z" changeid="explorer">
        <seg>Para prohibir coincidencias ASCII/no-ASCII (como &quot;k&quot; con C&lt;\N{KELVIN SIGN}&gt;), especifique la &quot;a&quot; dos veces, por ejemplo C&lt;/aai&gt; o C&lt;/aia&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;([^\&quot;\\]*(?:\\.[^\&quot;\\]*)*)&quot;,?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225536Z" changeid="explorer">
        <seg>&quot;([^\&quot;\\]*(?:\\.[^\&quot;\\]*)*)&quot;,?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allow installing extra modules or bundles when building Perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>permitir la instalación de módulos extra o empaquetados cuando se compila Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(To convert strings that might start with either C&lt;0&gt;, C&lt;0x&gt;, or C&lt;0b&gt;, see
L&lt;/oct&gt;.)  If EXPR is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para convertir strings que pueden comenzar con C&lt;0&gt;, C&lt;0x&gt; o C&lt;0b&gt;, ver L&lt;/oct&gt;.)  Si se omite EXPR, usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It used to provide a mechanism to
emulate setuid permission bits on systems that don't support it properly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235428Z" changeid="explorer">
        <seg>Se utiliza para proporcionar un mecanismo para emular a los bits de permiso setuid en sistemas que no lo soportan correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
are the semantics that lockf(3) implements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas son las semánticas que lockf(3) implementa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0x34 0x12 0x78 0x56</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0x34 0x12 0x78 0x56</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some
operators return the first value in the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven el primer valor de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless defined($value = readlink $sym);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless defined($valor = readlink $sym);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/y/) { say '$foo contains a y' }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/y/) { say '$foo contiene una y' }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.macos - Perl under Mac OS (Classic)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.macos - Perl bajo Mac OS (Classic)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlunicode/The &quot;Unicode Bug&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001004Z" changeid="explorer">
        <seg>Vea L&lt;perlunicode/El &quot;Bug Unicode&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 References</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003154Z" changeid="explorer">
        <seg>=head2 Referencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect of C&lt;unshift&gt; is considered highly
experimental.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183754Z" changeid="explorer">
        <seg>Este aspecto de C&lt;unshift&gt; es considerado altamente experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value
gives the real filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T022044Z" changeid="explorer">
        <seg>IDENTIFICADOR_ARCHIVO puede ser una expresión cuyo valor da el identificador de archivo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Backticks</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Comillas invertidas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Source filters in @INC</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T001245Z" changeid="explorer">
        <seg>=head2 Filtros de código fuente en @INC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When assigning to a list, if LIMIT is omitted, or zero, Perl supplies
a LIMIT one larger than the number of variables in the list, to avoid
unnecessary work.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al asignar a una lista, si LÍMITE es omitido, o cero, Perl proporciona un LÍMITE uno mayor que el número de variables en la lista, para evitar trabajo innecesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| //</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000443Z" changeid="explorer">
        <seg>|| //</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restore backwards compatibility with earlier versions of perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032809Z" changeid="explorer">
        <seg>Restaura la compatibilidad con versiones anteriores de perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getgrnam NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getgrnam NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus ((),(),()) is equivalent to ().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que ((),(),()) es equivalente a ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shmwrite ID,STRING,POS,SIZE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item shmwrite ID,CADENA,POSICIÓN,TAMAÑO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the outcome may be determined by voting based
on heuristic estimators, the result is not strictly predictable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que el resultado puede ser determinado por votación basada en estimadores heurísticos, el resultado no es estrictamente predecible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Updated Modules And Pragmata</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Módulos y Pragmata actualizados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Solaris</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230447Z" changeid="explorer">
        <seg>=item Solaris</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0         1         2         3
                       unpack(&quot;V&quot;,$_) 01234567890123456789012345678901</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052533Z" changeid="explorer">
        <seg>0         1         2         3
                       unpack(&quot;V&quot;,$_) 01234567890123456789012345678901</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One should
conscientiously choose between the I&lt;magic&gt; and I&lt;three-argument&gt; form
of open():</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235503Z" changeid="explorer">
        <seg>Uno debe elegir escrupulosamente entre la I&lt;magia&gt; y la forma de I&lt;tres argumentos&gt; de open():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For reasons of security, this construct is forbidden if the regular
expression involves run-time interpolation of variables, unless the
perilous C&lt;use re 'eval'&gt; pragma has been used (see L&lt;re&gt;), or the
variables contain results of the C&lt;qr//&gt; operator (see
L&lt;perlop/&quot;qrE&lt;sol&gt;STRINGE&lt;sol&gt;msixpodual&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T202144Z" changeid="explorer">
        <seg>Por razones de seguridad, esta construcción está prohibida si la expresión regular incluye interpolación de variables en tiempo de ejecución, a menos que el peligroso pragma C&lt;use re 'eval'&gt; esté en uso (vea L&lt;re&gt;), o las variables contengan resultados del operador C&lt;qr//&gt; (vea L&lt;perlop/&quot;qr/CADENAE&lt;sol&gt;msixpodual&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also use C&lt;defined(&amp;func)&gt; to check whether subroutine C&lt;&amp;func&gt;
has ever been defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar también C&lt;defined(&amp;func)&gt; para comprobar si la subrutina C&lt;&amp;func&gt; ha sido definida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
can test a random subset each time, and should there be a failure, log the seed
used for that run so that it can later be used to reproduce the same results.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014836Z" changeid="explorer">
        <seg>Se puede probar un subconjunto aleatorio cada vez, y si ocurre un fallo, registre las semillas utilizadas para las que se ha ejecutado a fin de que más adelante se puedan utilizar para reproducir los mismos resultados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$utmp_template = &quot;Z8 Z8 Z16 L&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$utmp_template = &quot;Z8 Z8 Z16 L&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>uc($a)  cmp  uc($b)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>uc($a)  cmp  uc($b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Capture groups are numbered from left to right, but inside this
construct the numbering is restarted for each branch.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T200112Z" changeid="explorer">
        <seg>Los grupos de captura son numerados de izquierda a derecha, pero dentro de esta construcción la numeración es reiniciada en cada rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's
because while we have a nice synonym for single elements via the
pointer arrow for dereferencing, no such convenience exists for slices.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194606Z" changeid="explorer">
        <seg>Eso es porque mientras que nosotros tenemos un sinónimo sencillo para los elementos individuales a través de la flecha puntero de desreferencia, no existe tal conveniencia para las porciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variable has been deprecated for a
long time, and a deprecation warning C&lt;Use of $* is deprecated&gt; is given,
now the variable will just finally be removed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011711Z" changeid="explorer">
        <seg>La variable ha dejado de utilizarse desde hace bastante tiempo, y ahora se muestra la advertencia de desaprobación C&lt;Use of $* is deprecated&gt;; ahora la variable será finalmente eliminada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;state&gt; variables are enabled only when the C&lt;use feature &quot;state&quot;&gt; pragma 
is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;state&gt; variables sólo se activan cuando el pragma C&lt;use feature &quot;state&quot;&gt; está en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dec_perms = (stat(&quot;filename&quot;))[2] &amp; 07777;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$dec_perms = (stat(&quot;archivo&quot;))[2] &amp; 07777;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(print $foo), exit;	# This is what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(print $foo), exit;	# Esto es lo que quiere hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$abc    = 1 when /^abc/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$abc    = 1 when /^abc/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;ByteLoader&gt; upgraded to version 0.06</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T024218Z" changeid="explorer">
        <seg>C&lt;ByteLoader&gt; actualizado a la versión 0.06</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;feature&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022249Z" changeid="explorer">
        <seg>Vea L&lt;feature&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only those places
that contain this &quot;rarest&quot; character are examined.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo estos lugares que contienen este &quot;carácter&quot; más raro son examinados).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can use sophisticated pattern matching techniques to
scan large amounts of data quickly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001055Z" changeid="explorer">
        <seg>Perl puede utilizar sofisticadas técnicas de detección de patrones para analizar rápidamente grandes cantidades de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;/ucfirst&gt; for that.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210050Z" changeid="explorer">
        <seg>Ver L&lt;/ucfirst&gt; para eso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$text = ucfirst $text;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234534Z" changeid="explorer">
        <seg>$texto = ucfirst $texto;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directory contains pure-Perl modules which are only released as part of
the core.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014400Z" changeid="explorer">
        <seg>Este directorio contiene módulos programados en puro Perl que solo se publican como parte del núcleo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@EXPORT = qw( foo bar baz );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@EXPORT = qw( foo bar baz );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo,  9,  8) = 0x65;   # 'PerlPerlPe'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($foo,  9,  8) = 0x65;   # 'PerlPerlPe'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Mac OS X: no usemymalloc</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T004212Z" changeid="explorer">
        <seg>=head2 Mac OS X: no usemymalloc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's &quot;C123&quot;, which suffices.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171230Z" changeid="explorer">
        <seg>Se trata de &quot;C123&quot;, suficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the new life of this switch, see L&lt;&quot;UTF-8 no longer default under
UTF-8 locales&quot;&gt;, and L&lt;perlrun/-C&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142139Z" changeid="explorer">
        <seg>Para la nueva vida de esta opción, vea L&lt;&quot;UTF-8 ya no está por defecto bajo la configuración regional de UTF-8&quot;&gt; y L&lt;perlrun/-C&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an empty list as soon as an explicit C&lt;break&gt; is encountered.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T110000Z" changeid="explorer">
        <seg>una lista vacía tan pronto como se encuentre un C&lt;break&gt; explícito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If in doubt,
spell out the character sets in full.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T222618Z" changeid="explorer">
        <seg>En caso de duda, explicite los conjuntos de caracteres completamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item split /PATTERN/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item split /PATRÓN/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;defined(...)&gt;, C&lt;exists(...)&gt;, or C&lt;eof(...)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;defined(...)&gt;, C&lt;exists(...)&gt;, o C&lt;eof(...)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the process id of the parent process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el identificador de proceso del proceso padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\b St  )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025607Z" changeid="explorer">
        <seg>\b St  )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596520106</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003342Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596520106</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those features are described below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T193338Z" changeid="explorer">
        <seg>Estas características se describen a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-00503-0 [1st edition January 2004]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003256Z" changeid="explorer">
        <seg>ISBN 978-0-596-00503-0 [1ª edición - Enero de 2004]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item String comparison</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Comparación de cadenas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>untie(%HIST);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>untie(%HIST);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sort BLOCK LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sort BLOQUE LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match at least n but not more than m times, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide al menos n pero no más de m veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cant usually use
either read-write mode for updating textfiles, since they have
variable-length records.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T002527Z" changeid="explorer">
        <seg>Por lo general, no puede utilizar el modo de lectura-escritura para la actualización de archivos de texto, ya que tienen registros de longitud variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordinarily you must assign the returned value to a variable, but
there is one situation where an automatic assignment happens.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente debe asignar el valor devuelto a una variable, pero hay una situación en la que sucede una asignación automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\G  Match only at pos() (e.g. at the end-of-match position</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225944Z" changeid="explorer">
        <seg>\G  Coincide solo en pos() (p. ej. en la posición de la última coincidencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;abc&quot; . quotemeta(&quot;foo\tbar$s&quot;) . &quot;xyz&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222227Z" changeid="explorer">
        <seg>&quot;abc&quot; . quotemeta(&quot;foo\tbar$s&quot;) . &quot;xyz&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Which magazines have Perl content?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230710Z" changeid="explorer">
        <seg>=head2 ¿En qué revistas puedo encontrar artículos sobre Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596520113</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003119Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596520113</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only C&lt;m??&gt;
patterns local to the current package are reset.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205915Z" changeid="explorer">
        <seg>Sólo son reinicializados los patrones locales C&lt;m??&gt; del paquete actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Quote-Like Operators
X&lt;operator, quote-like&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010108Z" changeid="explorer">
        <seg>=head2 Operadores de entrecomillado
X&lt;operator, quote-like&gt; X&lt;operador, entrecomillado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 32  ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 32  ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;syslog()&gt; now uses local timestamp.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035209Z" changeid="explorer">
        <seg>C&lt;syslog()&gt; ahora usa fecha y hora locales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item `STRING`</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item `CADENA`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extracts a substring out of EXPR and returns it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Extrae una subcadena de EXPR y la devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Unicode Character Database 5.1.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T191858Z" changeid="explorer">
        <seg>=head2 Unicode Character Database 5.1.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pthreads patches information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004548Z" changeid="explorer">
        <seg>de parches en pthreads.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual limit can
be seen in the error message generated by code such as this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El límite real se puede ver en el mensaje de error generado por un código como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$proto) = getproto*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($name,$aliases,$proto) = getproto*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next unless -f $_;  # ignore specials</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next unless -f $_;	# ignora especiales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll
notice that perl is not itself written in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231215Z" changeid="explorer">
        <seg>Notará que perl no está programado en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq1		General Questions About Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000232Z" changeid="explorer">
        <seg>perlfaq1		Preguntas generales sobre Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($logmessage, $priority) = @_;       # common</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110204T165732Z" changeid="zipf">
        <seg>my ($mensaje_registro, $prioridad) = @_; # común</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Performance Enhancements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Mejoras en el rendimiento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;panic: sv_chop %s&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T004127Z" changeid="explorer">
        <seg>=item C&lt;panic: sv_chop %s&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;autodie/&quot;BUGS&quot;&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010629Z" changeid="explorer">
        <seg>Vea L&lt;autodie/&quot;ERRORES&quot;&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/ftmp-security....File::Temp::_gettemp:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lib/ftmp-security....File::Temp::_gettemp:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will match, and C&lt;$1&gt; will be C&lt;AB&gt; and C&lt;$2&gt; will be C&lt;B&gt;, C&lt;$3&gt; will not
be set.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T144646Z" changeid="explorer">
        <seg>coincidirá, y C&lt;$1&gt; será C&lt;AB&gt; y C&lt;$2&gt; será C&lt;B&gt;; C&lt;$3&gt; no será ajustado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># inefficiently sort by descending numeric compare using</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#  ordenación ineficiente por comparación numérica descendente usando</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Confused?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005556Z" changeid="explorer">
        <seg>¿Confundido?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may (and usually should) use the three-argument form of open to specify
I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the handle
that affect how the input and output are processed (see L&lt;open&gt; and
L&lt;PerlIO&gt; for more details).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003330Z" changeid="explorer">
        <seg>Puede (y normalmente debería) usar la forma de tres argumentos de open para especificar capas E/S (algunas veces referidas como &quot;disciplinas&quot;) para aplicarlas al identificador, afectando al modo en que la entrada y salida son procesadas (vea L&lt;open&gt; y L&lt;PerlIO&gt; para más detalles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5140delta	Perl changes in version 5.14.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T015205Z" changeid="explorer">
        <seg>perl5140delta	Cambios en la versión 5.14.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 A note on freshness</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003741Z" changeid="explorer">
        <seg>=head2 ¿Está la lista al día?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can cause
characters that normally function as metacharacters to be interpreted
literally by prefixing them with a &quot;\&quot; (e.g., &quot;\.&quot; matches a &quot;.&quot;, not any
character; &quot;\\&quot; matches a &quot;\&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212335Z" changeid="explorer">
        <seg>Puede hacer que los caracteres que normalmente funcionan como metacaracteres sean interpretados literalmente mediante un prefijado con un &quot;\&quot; (p.e., &quot;\.&quot; coincide con un &quot;.&quot;, no con cualquier carácter; &quot;\\&quot; coincide con un &quot;\&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\c]      chr(29)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034635Z" changeid="explorer">
        <seg>\c]      chr(29)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fixed size array could cause C stack exhaustion on
systems configured to use large numbers of groups.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045423Z" changeid="explorer">
        <seg>El array de tamaño fijo podría provocar el agotamiento de la pila C en sistemas configurados para utilizar un gran número de grupos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to create anonymous filehandles is with the Symbol
module or with the IO::Handle module and its ilk.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003941Z" changeid="explorer">
        <seg>Otra forma de crear identificadores de archivo anónimos es con el módulo Symbol o con el módulo IO::Handle y sus acólitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Zsh</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225453Z" changeid="explorer">
        <seg>=item Zsh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(3,4,7);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>set_vec(3,4,7);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Defined\n&quot; if defined &amp;subroutine;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Definido\n&quot; if defined &amp;subrutina;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/say&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T214854Z" changeid="explorer">
        <seg>Vea L&lt;perlfunc/say&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binds a network address to a socket, just as bind(2)
does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Enlaza una dirección de red a un socket, como lo hace bind(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LABEL identifies the loop for the loop control
statements C&lt;next&gt;, C&lt;last&gt;, and C&lt;redo&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013400Z" changeid="explorer">
        <seg>La ETIQUETA identifica el bucle para las instrucciones de control de bucle C&lt;next&gt;, C&lt;last&gt; y C&lt;redo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, your locale might not think that C&lt;LATIN SMALL
LETTER ETH&gt; is a letter (unless you happen to speak Icelandic), but
Unicode does.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T172325Z" changeid="explorer">
        <seg>Por ejemplo, tu configuración regional no pensaría que C&lt;LATIN SMALL LETTER ETH&gt; es una letra (a menos que usted hable de Islandés), pero Unicode sí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language is intended to be practical (easy to use, efficient,
complete) rather than beautiful (tiny, elegant, minimal).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224610Z" changeid="explorer">
        <seg>El lenguaje se diseñó para ser práctico (fácil de usar, eficaz, completo), más que estético (reducido, elegante, minimalista).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A computer scientist will correctly explain that all programs are
interpreted and that the only question is at what level.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231803Z" changeid="explorer">
        <seg>Un científico de computación puede explicarle correctamente que, en realidad, todos los programas son interpretados y solo se diferencian en el grado en que lo son.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>D  A float of long-double precision in native format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>D  Un flotante en doble-largo precisión en formato nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Can now store code references (via B::Deparse, so not foolproof).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T174556Z" changeid="explorer">
        <seg>Ahora puede almacenar referencias a código (a través de B::Deparse, no es tan infalible).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Symmetrically, C&lt;no VERSION&gt; allows you to specify that you want a version
of Perl older than the specified one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Simétricamente, C&lt;no VERSIÓN&gt; le permite especificar que desea una versión de Perl más vieja que la especificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl 5.8.0 had been released
for BeOS BONE, I suspect, there is a good chance, that it still compiles on
a BONE system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde que Perl 5.8.0 ha sido lanzado para BeOS BONE, sospecho, que es una buena oportunidad, para que todavía se pueda compilar en un sistema BONE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ary1[$i] += $ary2[$j];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ary1[$i] += $ary2[$j];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\g{-1}    [5]  The number may be negative indicating a relative
                   previous group and may optionally be wrapped in
                   curly brackets for safer parsing.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045024Z" changeid="explorer">
        <seg>\g{-1}    [5]  El número puede ser negativo, indicando la posición relativa de
                    un grupo anterior y puede, opcionalmente, estar rodeado por
                    llaves, para un mejor análisis de la exp. reg.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>got &lt;d is under the &gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T155356Z" changeid="explorer">
        <seg>obtiene &lt;, al mediodía, se &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to C&lt;&lt; (?&amp;NAME) &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003802Z" changeid="explorer">
        <seg>Equivalente a C&lt;&lt; (?&amp;NOMBRE) &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;pack&gt;, you write I&lt;length-item&gt;C&lt;/&gt;I&lt;sequence-item&gt;, and the
I&lt;length-item&gt; describes how the length value is packed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para C&lt;pack&gt;, escriba I&lt;longitud-item&gt;C&lt;/&gt;I&lt;secuencia-item&gt;, y la I&lt;longitud-item&gt; indica el valor de la longitud de lo que está empaquetado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Pod::Functions&gt; upgraded to version 1.03</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034132Z" changeid="explorer">
        <seg>C&lt;Pod::Functions&gt; actualizado a la versión 1.03</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::GMP              another one using an external C library</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035514Z" changeid="explorer">
        <seg>Math::GMP			otro usando una biblioteca C externa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr/AAA/XYZ/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr/AAA/XYZ/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$addrtype,$net) = getnet*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($name,$aliases,$addrtype,$net) = getnet*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod/&quot;Packages&quot;&gt; for more information about packages, modules,
and classes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod/&quot;Paquetes&quot;&gt; para más información sobre paquetes, módulos y clases.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlxs		Perl XS application programming interface</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlxs		Interfaz de programación de aplicaciones XS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o	Compile pattern only once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o	Compila el patrón solo una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A simple Boolean test will not distinguish among
C&lt;undef&gt;, zero, the empty string, and C&lt;&quot;0&quot;&gt;, which are all equally
false.)  Note that since C&lt;undef&gt; is a valid scalar, its presence
doesn't I&lt;necessarily&gt; indicate an exceptional condition: C&lt;pop&gt;
returns C&lt;undef&gt; when its argument is an empty array, I&lt;or&gt; when the
element to return happens to be C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Un simple test Booleano no distinguirá entre C&lt;undef&gt;, cero, el string vacío y C&lt;&quot;0&quot;&gt;, que son todos igualmente falso). Note que como C&lt;undef&gt; es un escalar válido, su presencia no indica I&lt;necesariamente&gt; una condición excepcional: C&lt;pop&gt; devuelve C&lt;undef&gt; cuando su argumento es un array vacío, I&lt;o&gt; cuando el elemento a devolver sea un C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;unshift&gt;, C&lt;push&gt;, and C&lt;pop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215751Z" changeid="explorer">
        <seg>Vea también C&lt;unshift&gt;, C&lt;push&gt;, y C&lt;pop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for perl-5.8.8 and perl-5.9.3 by Ken Hirsch.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Actualización para perl-5.8.8 y perl-5.9.3 por Ken Hirsch.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp; 128) ? 'with' : 'without';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052247Z" changeid="explorer">
        <seg>&amp; 128) ? 'con' : 'sin';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keys of a hash are returned in an apparently random order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las claves de un hash son devueltas en un aparente orden aleatorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Safety net</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235813Z" changeid="zipf">
        <seg>=head2 Red de seguridad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$baz = '\n';		# a two-character string</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$baz = '\n';		# una cadena de dos caracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Repeated Patterns Matching a Zero-length Substring</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230108Z" changeid="explorer">
        <seg>=head2 Patrones repetidos coincidiendo con subcadenas de longitud cero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this issue should only make a difference for disk
files, as sockets and pipes have always been in &quot;binary&quot; mode in the
Windows port.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T005133Z" changeid="explorer">
        <seg>Tenga en cuenta que este problema sólo afecta a los archivos de disco, ya que los I&lt;sockets&gt; y tuberías siempre han estado en modo &quot;binario&quot; en la versión para Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^abc/) { $abc = 1; last SWITCH; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^abc/) { $abc = 1; last SWITCH; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Just read in this line: $_&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T003122Z" changeid="zipf">
        <seg>print &quot;Acabo de leer esta línea: $_&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 TODO</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015608Z" changeid="explorer">
        <seg>=head1 TODO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Commas should separate literal elements of the LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las comas deberían separar elementos literales de la LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parallel makes should work properly now, although there may still be problems
if C&lt;make test&gt; is instructed to run in parallel.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T042815Z" changeid="explorer">
        <seg>Hacer make en paralelo debería funcionar ahora correctamente, aunque todavía puede haber problemas si se indica a C&lt;make test&gt; que se ejecute en paralelo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(To
avoid this cost while retaining the grouping behaviour, use the
extended regular expression C&lt;(?: ... )&gt; instead.)  But if you never
use C&lt;$&amp;&gt;, C&lt;$`&gt; or C&lt;$'&gt;, then patterns I&lt;without&gt; capturing
parentheses will not be penalized.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para evitar este coste mientras quiera usar el comportamiento de agrupación, use en su lugar la expresión regular extendida C&lt;(?: ... )&gt;). Pero si nunca usa C&lt;$&amp;&gt;, C&lt;$`&gt; o C&lt;$'&gt;, entonces los patrones I&lt;sin&gt; paréntesis de captura no serán penalizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$mday&gt; is the day of the month and C&lt;$mon&gt; the month in
the range C&lt;0..11&gt;, with 0 indicating January and 11 indicating December.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000147Z" changeid="explorer">
        <seg>C&lt;$mdia&gt; es el día del mes, y C&lt;$mes&gt; es el mes en el rango C&lt;0..11&gt;, con 0 indicando enero, y 11, diciembre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the selected element is outside the string, the value 0 is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el elemento seleccionado se fuera de la cadena, se devuelve el valor 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;telldir&gt; has the same caveats about possible directory
compaction as the corresponding system library routine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;telldir&gt; también tiene las mismas advertencias sobre la posible compactación del directorio como la correspondiente rutina del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next if /barney/; # same effect as &quot;last&quot;, but doesn't document as well</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next if /pablo/; # mismo efecto que &quot;last&quot;, pero no se ve muy claro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
expression is interpreted as a list of single characters (hyphens
allowed for ranges).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La expresión se interpreta como una lista de caracteres simples (guiones permitidos para indicar rangos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Character set modifiers</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163536Z" changeid="explorer">
        <seg>=head3 Modificadores del conjunto de caracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is planned to change this behavior in 5.16, but the exact rules
haven't been determined yet.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T180853Z" changeid="explorer">
        <seg>Está previsto cambiar este comportamiento en 5.16, pero las reglas exactas no se han determinado todavía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, attempting to
use them raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, al tratar de usarlos lanzará una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page describes the syntax of regular expressions in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta página describe la sintaxis de las expresiones regulares en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Identical to the chmod 0755 of the example above.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Idéntico a chmod 0755 del ejemplo anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use 5.11.0;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T001328Z" changeid="explorer">
        <seg>use 5.11.0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dir = (getpwnam(&quot;daemon&quot;))[7];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150042Z" changeid="explorer">
        <seg>$dir = (getpwnam(&quot;daemon&quot;))[7];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LDLOADLIBS=-lc make</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LDLOADLIBS=-lc make</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rand(10) * 20;	# (rand 10) * 20</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>rand(10) * 20;	# (rand 10) * 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmacosx has been added to tell about the installation and use
of Perl in Mac OS X.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180945Z" changeid="explorer">
        <seg>perlmacosx ha sido añadido para hablar acerca de la instalación y el uso de Perl en Mac OS X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef &amp;mysub;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef &amp;mysub;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for basic control structures, C&lt;if/else&gt;, C&lt;while&gt;,
subroutines, etc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014616Z" changeid="explorer">
        <seg>Pruebas de estructuras de control básicas, C&lt;if/else&gt;, C&lt;while&gt;, subrutinas, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command is normally used by programs that want to lie to themselves
about what was just input.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comando se usa, normalmente, por los programas que quieren engañarse a sí mismos sobre lo que fue introducido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means C&lt;srand(42)&gt; will usually
produce the same results as C&lt;srand(42.1)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que C&lt;srand(42)&gt; produce los mismos resultados, generalmente, que C&lt;srand(42.1)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A literal of the form C&lt;v1.20.300.4000&gt; is parsed as a string composed
of characters with the specified ordinals.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T003610Z" changeid="explorer">
        <seg>Un literal de la forma C&lt;v1.20.300.4000&gt; es interpretada como una cadena compuesta de caracteres con los ordinales especificados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PerlIO::get_layers(FH) returns the names of the PerlIO layers
active on a filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171221Z" changeid="explorer">
        <seg>PerlIO::get_layers(FH) devuelve los nombres de las capas PerlIO activas en un identificador de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The old &quot;gnu-0.2&quot;
binary distribution will most certainly have additional problems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La anterior distribución binaria &quot;gnu-0.2&quot; con toda seguridad, tiene problemas adicionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now Perl restores the original
SIGFPE handling routine, whatever it was, before running external
programs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232655Z" changeid="explorer">
        <seg>Ahora Perl restaura la rutina de manejo de SIGFPE original, fuera cual fuera, antes de ejecutar programas externos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If TEMPLATE requires more arguments than pack() is given, pack()
assumes additional C&lt;&quot;&quot;&gt; arguments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175226Z" changeid="explorer">
        <seg>Si PLANTILLA requiere más argumentos de los que se pasan a pack(), éste asume argumentos adicionales iguales a C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T214938Z" changeid="explorer">
        <seg>También:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PARNO is a sequence of digits (not starting with 0) whose value reflects
the paren-number of the capture group to recurse to.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T212559Z" changeid="explorer">
        <seg>PARNO es una secuencia de dígitos (no empezando en 0) cuyo valor refleja el número del par de paréntesis del grupo de captura que hay que re-ejecutar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a fairly obvious gotcha included with the line directive:
Debuggers and profilers will only show the last source line to appear
at a particular line number in a given file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existe obviamente un problema con esta directiva: los I&lt;debuggers&gt; y perfiladores sólo mostrarán la última línea del código fuente que aparece en un número de línea en particular de un determinado archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This lets you indirectly pass arguments to
the subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto le permite pasar argumentos indirectamente a la subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may work on
other versions, but that's the one we've tested it on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T064931Z" changeid="explorer">
        <seg>Es posible que funcione en otras versiones, pero esta es la única en la que lo hemos probado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>place your modifications in the Public Domain or otherwise make them
Freely Available, such as by posting said modifications to Usenet or an
equivalent medium, or placing the modifications on a major archive site
such as uunet.uu.net, or by allowing the Copyright Holder to include
your modifications in the Standard Version of the Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>coloque sus modificaciones en el Dominio Público o de otra manera hacerlos de Libre Disposición, o mediante la publicación de dichas modificaciones en Usenet o un medio equivalente, o la colocación de las modificaciones en sitios importantes como uunet.uu.net, o permitiendo que el Titular del Copyright incluya las modificaciones en la Versión Estándar del Paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolating it in a list
has no effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Interpolarla en una lista no tiene ningún efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrun/-C&gt; and L&lt;perlrun/PERL_UNICODE&gt; for more
information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T152350Z" changeid="explorer">
        <seg>Vea L&lt;perlrun/-C&gt; y L&lt;perlrun/PERL_UNICODE&gt; para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The warnings show up both during the build of Perl and during certain
lib/ExtUtils tests that invoke the C compiler.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003938Z" changeid="explorer">
        <seg>Estas advertencias aparecen durante la compilación de Perl y durante ciertas pruebas de lib/ExtUtils que invocan al compilador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/Login: $foo/Login: $bar/; # run-time pattern</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034932Z" changeid="explorer">
        <seg>s/Login: $foo/Login: $bar/;			# patrón en tiempo de ejecución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Especially alternative
libraries like Math::BigInt::GMP benefit from this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T173939Z" changeid="explorer">
        <seg>Especialmente las bibliotecas alternativas como Math::BigInt::GMP se beneficiaron de todo esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behaviour of
a smart match now depends primarily on the type of its right hand
argument.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233626Z" changeid="explorer">
        <seg>El comportamiento de una coincidencia inteligente ahora depende, principalmente, del tipo de su argumento derecho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -MExtUtils::MakeMaker -le 'print MM-&gt;parse_version(shift)' 'Foo.pm'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025504Z" changeid="explorer">
        <seg>perl -MExtUtils::MakeMaker -le 'print MM-&gt;parse_version(shift)' 'Foo.pm'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type =&gt; &quot;text&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021603Z" changeid="explorer">
        <seg>tipo =&gt; &quot;texto&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**                      &lt; &gt; &lt;= &gt;=  lt gt le ge   pm.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>**                      &lt; &gt; &lt;= &gt;=  lt gt le ge   pm.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The upshot of all this is that Perl cannot store a number like
12345678901234567 as a floating point number on such architectures without
loss of information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232535Z" changeid="explorer">
        <seg>Como consecuencia, Perl no puede almacenar un número como 12345678901234567 en forma de número de punto flotante para estas arquitecturas sin pérdida de información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return \@a;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225458Z" changeid="explorer">
        <seg>return \@a;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.borland.com/codewright/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://www.borland.com/codewright/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># pack little-endian 16- and 32-bit signed integers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># empaqueta 16 y 32-bit enteros con signo, en little-endian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=~ !~                                            perldoc.com</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=~ !~                                            perldoc.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlipc&gt; for more on signal handling.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc&gt; para más información sobre el manejo de señales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're trying to do variable interpolation, it's definitely better
to use the glob() function, because the older notation can cause people
to become confused with the indirect filehandle notation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014801Z" changeid="explorer">
        <seg>Si está tratando de hacer interpolación de variables, sin duda es mejor utilizar la función glob(), porque la notación más antigua puede hacer que las personas se confundan con la notación de identificador de archivo indirecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you may tell the compiler to use integer operations
(see L&lt;integer&gt; for a detailed explanation) from here to the end of
the enclosing BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220300Z" changeid="explorer">
        <seg>puede indicar al compilador que utilice operaciones con enteros (vea L&lt;integer&gt; para una explicación más detallada) desde aquí hasta el final del BLOQUE actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now has bytes::substr.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031054Z" changeid="explorer">
        <seg>Ahora tiene bytes::substr.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($starty = $y = 7; $y &lt;= 12; $y++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053009Z" changeid="explorer">
        <seg>for ($starty = $y = 7; $y &lt;= 12; $y++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the builtin is not I&lt;overridable&gt; (such as
C&lt;qw//&gt;) or if its arguments cannot be adequately expressed by a prototype
(such as C&lt;system&gt;), prototype() returns C&lt;undef&gt;, because the builtin
does not really behave like a Perl function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la orden interna no es yo &lt;sobreescribible&gt; (como lo es C&lt;qw//&gt;) o si sus argumentos no pueden ser adecuadamente expresados por un prototipo (como C&lt;system&gt;), prototype() devuelve C&lt;undef&gt;, porque la orden interna en realidad no se comporta como una función de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may turn it off explicitly for particular
portions of code via the C&lt;no warnings&gt; pragma or the C&lt;$^W&gt; variable
if you must.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede desactivarla explícitamente en partes del código con el pragma C&lt;no warnings&gt; o con la variable C&lt;$^W&gt; si así lo desea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># line 200 &quot;bzzzt&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># line 200 &quot;bzzzt&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pseudo-hashes were deprecated in Perl 5.8.0 and will be removed in
Perl 5.10.0, see L&lt;perl58delta&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T010517Z" changeid="explorer">
        <seg>Pseudo-hashes están obsoletas desde Perl 5.8.0 y serán eliminadas en Perl 5.10.0, vea L&lt;perl58delta&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not              (?:)  no capture       REGEX CHARCLASSES</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224259Z" changeid="explorer">
        <seg>not              (?:)  sin captura              CLASES CARACTERES EXP. REG.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2453401.5</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>2453401.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not necessarily all are available on your system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No necesariamente todos están disponibles en su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $s = &quot;The black cat climbed the green tree&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $s = &quot;El gato negro subió el árbol verde&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%6s&gt;',  12;   # prints &quot;&lt;    12&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%6s&gt;',  12;   # imprime &quot;&lt;    12&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also no attention is paid to C&lt;\c\&gt; (multichar control char syntax) during
this search.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco se presta atención a C&lt;\c\&gt; (sintaxis multicarácter de control) durante esta búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3 - If a circular reference is found, we fall back to referential equality.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3 - Si se encuentra una referencia circular, regresamos a la igualdad referencial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($dev, $ino, undef, undef, $uid, $gid) = stat($file);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004232Z" changeid="explorer">
        <seg>($dev, $ino, undef, undef, $uid, $gid) = stat($archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($map{'red'}, $map{'blue'}, $map{'green'}) = (0x00f, 0x0f0, 0xf00);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($map{'rojo'}, $map{'azul'}, $map{'verde'}) = (0x00f, 0x0f0, 0xf00);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being strings, and thus of arbitrary length, there
is no practical limit for the exponent or number of decimal digits for these
numbers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232544Z" changeid="explorer">
        <seg>Al ser cadenas y, por tanto, al tener una longitud arbitraria, no existe un límite práctico para el exponente o el número de dígitos decimales para estos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three principal virtues of a programmer are Laziness,
Impatience, and Hubris.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T015340Z" changeid="explorer">
        <seg>Las tres virtudes principales de un buen programador son la pereza, la impaciencia y la confianza en sí mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to take advantage of this new implicit dereferencing behavior,
go right ahead: it makes code easier on the eye and wrist.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031324Z" changeid="explorer">
        <seg>Si desea aprovecharse de este nuevo comportamiento de desreferencia implícita, adelante: hace el código más fácil para el ojo y la muñeca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231221Z" changeid="explorer">
        <seg>($espaciolimpio = $string) =~ s/()/ /g;      # paréntesis evitan la magia de s// /</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chown $uid, $gid, @filenames;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chown $uid, $gid, @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/io/pvbm.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010011Z" changeid="explorer">
        <seg>=item t/io/pvbm.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is a large and complex system that's used for everything from
knitting to rocket science.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222302Z" changeid="explorer">
        <seg>Perl es un sistema grande y complejo que se utiliza para todo, desde hacer calceta a la ciencia de los cohetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@harry  = qw(dog cat x Cain Abel);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@harry  = qw(dog cat x Cain Abel);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; should
be the only Pod code for file names, but as most Pod formatters render it
as italic, Unix and Windows paths with their slashes and backslashes may
be less readable, and better rendered with C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; debe ser el único código Pod para nombres de archivo, pero como la mayoría de los formateadores de Pod lo muestran en cursiva, los caminos Unix y Windows con sus barras y contrabarras pueden hacerlo menos legible, por lo que es mejor mostrarlo con C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Unicode interpretation of \w, \d, \s, and the POSIX character classes redefined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T232840Z" changeid="explorer">
        <seg>=head2 Redefinidas las interpretaciones Unicode de \w, \d, \s, y las clase carácter POSIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another use for typeglobs is to pass filehandles into a function or
to create new filehandles.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003615Z" changeid="explorer">
        <seg>Otro uso para los typeglobs es pasar identificadores de archivo en una función o para crear nuevos identificadores de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String modifying combinations for
case and quoting such as C&lt;\Q&gt;, C&lt;\U&gt;, and C&lt;\E&gt; are not recognized.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Combinaciones de modificación de caracteres para cambios de tamaño de caja y entrecomillado, como C&lt;\Q&gt;, C&lt;\U&gt;, y C&lt;\E&gt;, no son reconocidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
behaviour is the same as a C&lt;while&gt; loop conditional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comportamiento es el mismo que en la condición de un bucle C&lt;while&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
construct is useful for optimizations of what would otherwise be
&quot;eternal&quot; matches, because it will not backtrack (see L&lt;&quot;Backtracking&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220546Z" changeid="explorer">
        <seg>Esta construcción es útil para la optimización de lo que, en caso contrario, serían coincidencias &quot;eternas&quot;, porque no va a dar marcha atrás (vea L&lt;&quot;Retroceso&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus Perl returns true on success and false on failure, yet you can
still easily determine the actual value returned by the operating
system:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001751Z" changeid="explorer">
        <seg>Así, Perl devuelve verdadero en éxito y falso en caso de error, por lo que aún podemos determinar el valor actual devuelto por el sistema operativo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See also L&lt;Integer Arithmetic&gt; and
L&lt;Bitwise String Operators&gt;.)  Note that the width of the result is
platform-dependent: ~0 is 32 bits wide on a 32-bit platform, but 64
bits wide on a 64-bit platform, so if you are expecting a certain bit
width, remember to use the &quot;&amp;&quot; operator to mask off the excess bits.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224006Z" changeid="explorer">
        <seg>(Vea también L&lt;Aritmética entera&gt; y L&lt;Operadores de bit en cadenas&gt;). Tenga en cuenta que el ancho del resultado depende de la plataforma: ~0 es de 32 bits de ancho en una plataforma de 32 bits, pero 64 bits de ancho en una plataforma de 64 bits, así que si está esperando por un determinado ancho de bits, recuerde utilizar el operador &amp; para enmascarar los bits excedentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlos390		Perl notes for OS/390</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlos390		Notas para OS/390</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 2) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 2) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, Perl attempts to flush all files opened for
output before the exec, but this may not be supported on some platforms
(see L&lt;perlport&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de la versión v5.6.0, Perl intenta vaciar todos los archivos abiertos para salida antes de ejecutar exec, pero esto puede no estar soportado en algunas plataformas (ver L&lt;perlport&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inclusion of library modules is better done with the
C&lt;use&gt; and C&lt;require&gt; operators, which also do automatic error checking
and raise an exception if there's a problem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La inclusión de bibliotecas de módulos es mejor hacerla con los operadores C&lt;use&gt; y C&lt;require&gt;, que también hacen una comprobación automática de errores y generan una excepción si existe algún problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also several utilities
which are used by the Perl distribution itself as part of the install
process.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233230Z" changeid="explorer">
        <seg>algunas de ellas se usan durante el proceso de instalación de la distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># open for input, reusing the fileno of $fd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># abrir para lectura, reutilizando el número de descriptor de $fd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR, 0666, $DB_HASH</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T131935Z" changeid="zipf">
        <seg>my $db = tie %hash, 'DB_File', $archivo, O_CREAT|O_RDWR, 0666, $DB_HASH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sprintf FORMAT, LIST
X&lt;sprintf&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201152Z" changeid="explorer">
        <seg>=item sprintf FORMATO, LISTA
X&lt;sprintf&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl584delta	Perl changes in version 5.8.4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl584delta	Cambios en la versión 5.8.4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (101 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (101 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose we parse text with comments being delimited
by C&lt;#&gt; followed by some optional (horizontal) whitespace.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T220226Z" changeid="explorer">
        <seg>Supongamos que analiza un texto con comentarios que están delimitados por C&lt;#&gt; seguido por algunos espacios en blanco (horizontales) opcionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful for matching path names
that contain &quot;/&quot;, to avoid LTS (leaning toothpick syndrome).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es particularmente útil para hacer coincidir los nombres de ruta que contienen &quot;/&quot;, para evitar el &quot;síndrome del palillo de dientes&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling binmode() normally flushes any
pending buffered output data (and perhaps pending input data) on the
handle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020108Z" changeid="explorer">
        <seg>Llamando a binmode(), normalmente vaciará cualquier dato pendiente que esté almacenado en la salida (y quizás datos pendientes a la entrada) del identificador de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef *xyz;       # destroys $xyz, @xyz, %xyz, &amp;xyz, etc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef *xyz;       # destruye $xyz, @xyz, %xyz, &amp;xyz, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The padding spaces would appear after the newline, which is
probably not what you had in mind.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002303Z" changeid="explorer">
        <seg>Pueden aparecer espacios de relleno después del avance de línea, que probablemente no es lo que tenía en mente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $j ( 0 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052912Z" changeid="explorer">
        <seg>for $j ( 0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll have to put a C&lt;local $_;&gt; before the loop if you want that
to happen.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tendrá que poner un C&lt;local $_;&gt; antes del bucle si quiere que sea así.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, you may need to set
C&lt;$|&gt; ($AUTOFLUSH in English) or call the C&lt;autoflush()&gt; method of
C&lt;IO::Handle&gt; on any open handles to avoid duplicate output.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020556Z" changeid="explorer">
        <seg>Para estar seguros, puede necesitar poner C&lt;$|&gt; ($AUTOFLUSH en English) o llamar el método C&lt;autoflush()&gt; de C&lt;IO::Handle&gt; en cualquiera de los identificadores de archivo abiertos para evitar duplicación de salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With version objects, we need them to use MODULE VERSION syntax.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152905Z" changeid="explorer">
        <seg>Con los objetos de versión, les necesitamos para usar la sintaxis MÓDULO VERSIÓN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EXISTS this, key</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EXISTS este, clave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 8, 1) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 8, 1) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(&quot;ab&quot; x 32768) =~ /^(ab)*$/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003915Z" changeid="explorer">
        <seg>(&quot;ab&quot; x 32768) =~ /^(ab)*$/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[the list of failures being compiled]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T111620Z" changeid="explorer">
        <seg>[La lista de fracasos que han sido recopilados]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8 tests and 24 subtests skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>8 tests and 24 subtests skipped.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item truncate</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015430Z" changeid="explorer">
        <seg>=item truncate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>space   prefix non-negative number with a space</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>espacio prefija un número no negativo con un espacio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does not protect against
symbolic links in the file's path.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No protege contra enlaces simbólicos en la ruta del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.6x&gt;', 1;      # prints &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.6x&gt;', 1;      # imprime &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Allen Smith &lt;easmith@beatrice.rutgers.edu&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003828Z" changeid="explorer">
        <seg>(Allen Smith &lt;easmith@beatrice.rutgers.edu&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next OUTER if $wid &gt; $jet;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next EXTERNO if $wid &gt; $jet;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shell wildcards,
pipes, and redirections will be honored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los comodines del intérprete, tuberías y redirecciones serán respetados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print scalar reverse;                       # Hello, world</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print scalar reverse;                       # Hola, mundo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the undefined value if the context is
looking for no value (void context).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor indefinido si el contexto está buscando por ningún valor (contexto void).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure
that CLASSNAME is a true value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Asegúrese de que NOMBRECLASE es un valor verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($condition &amp;&amp; ...) { say &quot;Hello&quot; }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225713Z" changeid="explorer">
        <seg>if ($condicion &amp;&amp; ...) { say &quot;Hola&quot; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return 0 unless @a == @b;  # same len?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return 0 unless @a == @b;  # ¿misma longitud?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp; s//WILMA $1 WILMA/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;&amp; s//WILMA $1 WILMA/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say $+ {a};   # Prints '12'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T125430Z" changeid="explorer">
        <seg>say $+ {a};   # Imprime '12'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read the F&lt;INSTALL&gt; file, which is part of the source distribution.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225934Z" changeid="explorer">
        <seg>Lea el archivo F&lt;INSTALL&gt; incluido en la distribución de código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is merely equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030835Z" changeid="explorer">
        <seg>es equivalente a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;die&gt; instead,
which can be trapped by an C&lt;eval&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use en su lugar C&lt;die&gt;, que puede ser atrapado por un C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mentioning a subroutine name for exists or defined
does not count as declaring it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mencionar el nombre de una subrutina para saber si existe o está definida no cuenta como si fuera su declaración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Language
historians will also note some vestiges of B&lt;csh&gt;, Pascal, and even
BASIC-PLUS.)  Expression syntax corresponds closely to C
expression syntax.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001030Z" changeid="explorer">
        <seg>(los historiadores de los lenguajes también destacarán algunos vestigio de B&lt;csh&gt;, Pascal e incluso BASIC-PLUS). La sintaxis de expresiones es muy parecida a la de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is undefined, returns
C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171205Z" changeid="explorer">
        <seg>Si EXPR es indefinido, devuelve C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all, in your
journey as a programmer, you are likely to encounter different styles.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004542Z" changeid="explorer">
        <seg>Al fin y al cabo, en su vida profesional como programador se va a encontrar distintos estilos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of hash keys starting with a hyphen (C&lt;-name&gt;) or entirely in 
upper case (C&lt;NAME&gt;) is a relic of older versions of Perl in which
ordinary lower case strings were not handled correctly by the C&lt;=E&lt;gt&gt;&gt;
operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022705Z" changeid="explorer">
        <seg>El uso de claves hash comenzando con un guión (C&lt;-name&gt;) o totalmente en mayúsculas (C&lt;NOMBRE&gt;) es una reliquia de las versiones anteriores de Perl en el que las cadenas en minúscula no se manejaban correctamente por el operador C&lt;=E&lt;gt&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
I&lt;really&gt; want to follow an C&lt;exec&gt; with some other statement, you
can use one of these styles to avoid the warning:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012459Z" changeid="explorer">
        <seg>Si I&lt;verdaderamente&gt; quiere continuar un C&lt;exec&gt; con otra instrucción, puede usar algunas de estas formas para evitar el aviso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's important to set a few things straight first.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234239Z" changeid="explorer">
        <seg>Para empezar es importante aclarar algunas ideas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $tail   = substr $s, -4;        # tree</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $tail   = substr $s, -5;        # verde</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item the replacement of C&lt;s///&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item el reemplazo de C&lt;s///&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no changes incompatible with 5.8.2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay cambios incompatibles con 5.8.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># short 12, two zero bytes padding, long 34</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un 12 short, dos bytes cero de relleno, un 34 long</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item my TYPE EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item my TIPO EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;long doubles\n&quot; if $Config{d_longdbl} eq &quot;define&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;long doubles\n&quot; if $Config{d_longdbl} eq &quot;define&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words: regardless of platform, use binmode() on binary data,
like images, for example.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T153010Z" changeid="explorer">
        <seg>En otras palabras: indiferentemente de la plataforma, use binmode() en datos binarios, como por ejemplo imágenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C-style Logical Defined-Or
X&lt;//&gt; X&lt;operator, logical, defined-or&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235624Z" changeid="explorer">
        <seg>=head2 Defined-Or lógico al estilo del C
X&lt;//&gt; X&lt;operator, logical, defined-or&gt; X&lt;operador, lógico, defined-or&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using this operator can lead to programs that are difficult to port,
because the shell commands called vary between systems, and may in
fact not be present at all.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando este operador puede dar lugar a programas que son difíciles de portar, porque el shell de comandos varían entre sistemas, y de hecho no pueden estar presentes en todos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rare access violation at Perl start-up could occur if the Perl image was
installed with privileges or if there was an identifier with the
subsystem attribute set in the process's rightslist.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000041Z" changeid="explorer">
        <seg>Una violación de acceso poco frecuente en la puesta en marcha de Perl podría producirse si la imagen de Perl se instaló con privilegios o si hubo un identificador con el conjunto de atributos del subsistema en la lista de derechos del proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[aeiou]             matches a single character in the given set</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121720Z" changeid="zipf">
        <seg>[aeiou]             un solo carácter del conjunto especificado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or you can continue to use the L&lt;fields&gt; pragma, but please don't
expect the data structures to be pseudohashes any more.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T010925Z" changeid="explorer">
        <seg>O bien, puede seguir utilizando el pragma L&lt;fields&gt; pero, por favor, no permita que las estructuras de datos sigan siendo pseudo-hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Subscripts of slices</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035131Z" changeid="explorer">
        <seg>=head2 Subíndices de porciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;GDBM_File&gt; upgraded to version 1.08</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032251Z" changeid="explorer">
        <seg>C&lt;GDBM_File&gt; actualizado a la versión 1.08</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlxstut		Perl XS tutorial</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000506Z" changeid="explorer">
        <seg>perlxstut		Tutorial de XS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no changes incompatible with 5.8.5.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay cambios incompatibles con 5.8.5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed,
and on systems without line terminator,
printing C&lt;&quot;\n&quot;&gt; might emit no actual data.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T233947Z" changeid="explorer">
        <seg>Por ejemplo, en los antiguos Mac (pre MacOS X) de antaño, estos solían estar invertidos, y en los sistemas sin terminador de línea, la impresión de un C&lt;&quot;\n&quot;&gt; puede no emitir ningún dato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getnetbyname NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getnetbyname NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>update to Unicode 3.1.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>actualización a Unicode 3.1.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 QUICK CHECKLIST</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013345Z" changeid="explorer">
        <seg>=head1 RESUMEN LISTA DE CONTROL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># bytes because the U at the start of the format caused a switch to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># porque la U al principio del formato causó un cambio a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl588delta	Perl changes in version 5.8.8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl588delta	Cambios en la versión 5.8.8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[^aeiou]            matches a single character outside the given set</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T221909Z" changeid="zipf">
        <seg>[^aeiou]            un solo carácter no perteneciente al conjunto especificado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A categorized list of modules is
also available from CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225603Z" changeid="explorer">
        <seg>En CPAN también está disponible una lista de módulos clasificados por categorías.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>++     Match 1 or more times and give nothing back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>++     Coincide 1 o más veces y no devuelve nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;Compress::Raw::Bzip2&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010634Z" changeid="explorer">
        <seg>=item C&lt;Compress::Raw::Bzip2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;h2xs&gt; converts C header files into XS modules, and will try and write
as much glue between C libraries and Perl modules as it can.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234542Z" changeid="explorer">
        <seg>F&lt;h2xs&gt; convierte archivos de encabezado de C en módulos XS y agrega gran parte del código necesario para la comunicación entre bibliotecas C y módulos Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $end    = substr $s, 14;        # climbed the green tree</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $end    = substr $s, 14;        # subió el árbol verde</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/@INC&gt; and L&lt;perlvar/%INC&gt; for
these variables.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T154641Z" changeid="explorer">
        <seg>Ver L&lt;perlvar/@INC&gt; y L&lt;perlvar/%INC&gt; por estas variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0  0..3  &quot;fred&quot; &quot;barney&quot; &quot;wilma&quot; &quot;betty&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032411Z" changeid="explorer">
        <seg>0  0..3  &quot;pedro&quot; &quot;pablo&quot; &quot;wilma&quot; &quot;betty&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;enc2xs&gt; builds a Perl extension for use by Encode from either
Unicode Character Mapping files (.ucm) or Tcl Encoding Files (.enc).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234553Z" changeid="explorer">
        <seg>F&lt;enc2xs&gt; genera una extensión Perl para Encode a partir de archivos de asignación de caracteres Unicode (.ucm) o de archivos de codificación Tcl (.enc).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return your results in the most generic form possible and allow the user 
to choose how to use them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020724Z" changeid="explorer">
        <seg>Muestre los resultados en su forma más genérica posible y permita al usuario elegir la forma de utilizarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|  (?&lt;a&gt; z ) (?&lt;b&gt; w )) /x</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T125327Z" changeid="explorer">
        <seg>|  (?&lt;a&gt; z ) (?&lt;b&gt; w )) /x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rand (10) * 20;	# (rand 10) * 20</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>rand (10) * 20;	# (rand 10) * 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $fh;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return $fh;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In a script passed to Perl via B&lt;-e&gt; switches, each
B&lt;-e&gt; is counted as one line.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001647Z" changeid="explorer">
        <seg>(En un script pasado a Perl a través de modificadores B&lt;-e&gt;, cada B&lt;-e&gt; cuenta como una línea.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regex   Array     array grep               grep /$a/, @$b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Regex       Array      grep array                       grep /$a/, @$b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.xemacs.org/Download/index.html</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://www.xemacs.org/Download/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash    CodeRef   sub truth for each key[1] !grep { !$b-&gt;($_) } keys %$a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hash        RefCódigo  sub verdad por cada clave[1]     !grep { !$b-&gt;($_) } keys %$a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for LIST</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.5s&gt;', &quot;truncated&quot;;   # prints &quot;&lt;trunc&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.5s&gt;', &quot;truncado&quot;;   # imprime &quot;&lt;trunc&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;cannot open &gt; output.txt: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T001013Z" changeid="explorer">
        <seg>or die &quot;cannot open &gt; output.txt: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read all about them in L&lt;perlrequick&gt;,
L&lt;perlretut&gt;, and L&lt;perlre&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225512Z" changeid="explorer">
        <seg>Encontrará más información en L&lt;perlrequick&gt;, L&lt;perlretut&gt; y L&lt;perlre&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forcing big- or little-endian byte-order on floating-point values for
data exchange can work only if all platforms use the same
binary representation such as IEEE floating-point.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Forzar una ordenación de bytes en valores de punto flotante para el intercambio de datos sólo puede funcionar si todas las plataformas utilizan la misma representación binaria de punto flotante IEEE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failed 3/811 test scripts, 99.63% okay.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005044Z" changeid="explorer">
        <seg>Fallaron 3/811 de las pruebas, 99,63% bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all of these examples, Perl
will assume you meant defined-or.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En todos estos ejemplos, Perl asumirá que significaba definido-o.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return list's length always matches that of
the argument list: deleting non-existent elements returns the undefined value
in their corresponding positions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La longitud de la lista devuelta siempre coincide con el de la lista de argumentos: eliminar elementos no existentes devuelve el valor indefinido en sus posiciones correspondientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| die &quot;can't open &lt; $ARGV[0]: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235549Z" changeid="explorer">
        <seg>|| die &quot;no puedo abrir &lt; $ARGV[0]: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another useful shortcut is that, if you use a literal array
or hash as the argument to C&lt;given&gt;, it is turned into a
reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otro método abreviado útil es que, si usa un array o hash literal, como el argumento a C&lt;given&gt;, se convierte en una referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $string = 'ABC';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045503Z" changeid="explorer">
        <seg>my $string = 'ABC';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;foreach&gt; loop iterates over a normal list value and sets the
variable VAR to be each element of the list in turn.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bucle C&lt;foreach&gt; itera sobre los valores de una lista normal y pone la variable VAR a cada uno de los elementos de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;AnyDBM_File&gt; for a more general description of the pros and
cons of the various dbm approaches, as well as L&lt;DB_File&gt; for a particularly
rich implementation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;AnyDBM_File&gt; para una descripción más general de los pros y contras de las distintas formas dbm, así como L&lt;DB_File&gt; para ver una implementación particularmente rica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl56delta 	Perl changes in version 5.6</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl56delta 	Cambios en la versión 5.6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>v  An unsigned short (16-bit) in &quot;VAX&quot; (little-endian) order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>v  Un corto sin signo (16 bit) en orden &quot;VAX&quot; (little-endian).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
EXPR is omitted, C&lt;$_&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la EXPR se omite, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should contact modules@perl.org to ask them about your module name
before publishing your module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015458Z" changeid="explorer">
        <seg>Debería ponerse en contacto con modules@perl.org para preguntarles acerca del nombre de su módulo antes de publicarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sysseek FILEHANDLE,POSITION,WHENCE
X&lt;sysseek&gt; X&lt;lseek&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T020729Z" changeid="explorer">
        <seg>=item sysseek IDENTIFICADOR_ARCHIVO,POSICIÓN,DÓNDE
X&lt;sysseek&gt; X&lt;lseek&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an empty list, C&lt;undef&gt;, or nothing that matches the first 3 values above
is returned, then C&lt;require&gt; looks at the remaining elements of @INC.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se devuelve una lista vacía, C&lt;undef&gt;, o nada que coincida con los tres primeros valores anteriores, entonces C&lt;require&gt; mira en los elementos restantes de @INC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl585delta	Perl changes in version 5.8.5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl585delta	Cambios en la versión 5.8.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the starting delimiter is an unpaired character like C&lt;/&gt; or a closing
punctuation, the ending delimiter is same as the starting delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el delimitador de partida es un carácter no emparejado, como C&lt;/&gt; o un carácter de puntuación de cierre, el delimitador de cierre es el mismo que el delimitador de inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a simple but
sufficient example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un simple pero útil ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Perl 4, Perl 5 treats backticks
as normal delimiters; the replacement text is not evaluated as a command.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de Perl 4, Perl 5 trata las comillas simples invertidas como delimitadores normales; el texto de reemplazo no es evaluado como un comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, C&lt;times&gt; returns C&lt;$user&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, C&lt;times&gt; devuelve C&lt;$usuario&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documented -X overloading.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003643Z" changeid="explorer">
        <seg>Documentada la sobrecarga de -X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 1) = 1   ==        128 00000001000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 1) = 1   ==        128 00000001000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As this can lead to
unexpected results, it is best to specify which other rule set should be
used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T235940Z" changeid="explorer">
        <seg>Ya que esto puede conducir a resultados inesperados, lo mejor es especificar qué conjunto de reglas se deben usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Trying to do too much</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031407Z" changeid="explorer">
        <seg>=head2 Tratar de hacer demasiado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is unspecified, output goes to the current default output
channel, which starts out as STDOUT but may be changed by the
C&lt;select&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013602Z" changeid="explorer">
        <seg>Si IDENTIFICADOR_ARCHIVO no está especificado, la salida va al canal predeterminado de salida actual, que suele ser STDOUT, pero puede ser modificado por el operador C&lt;select&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unquoted identifier works like double quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un identificador sin comillas funciona igual que las comillas dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5 now has a switch statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103216Z" changeid="explorer">
        <seg>Perl 5 ahora tiene una instrucción switch.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tell FILEHANDLE
X&lt;tell&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013119Z" changeid="explorer">
        <seg>=item tell IDENTIFICADOR_ARCHIVO
X&lt;tell&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to C&lt;(R1)&gt;, this predicate checks to see if we're executing
directly inside of the leftmost group with a given name (this is the same
logic used by C&lt;(?&amp;NAME)&gt; to disambiguate).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195640Z" changeid="explorer">
        <seg>Al igual que C&lt;(R1)&gt;, este predicado comprueba si estamos ejecutando directamente dentro del grupo nominado más a la izquierda (esta es la misma lógica usada por C&lt;(?&amp;NOMBRE)&gt; para eliminar la ambigüedad).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This distinction is determined on syntactic
grounds alone.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta distinción está determinada sólo por razones sintácticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rand</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item rand</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl core has an extensive test suite.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014526Z" changeid="explorer">
        <seg>Existe un completo conjunto de pruebas del núcleo de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close STDOUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close STDOUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>native floating_point --&gt; native integer		(*)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113005Z" changeid="explorer">
        <seg>punto flotante nativo --&gt; entero nativo (*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;% +d&gt;', 12;   # prints &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;% +d&gt;', 12;   # imprime &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%F    a synonym for %f</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%F    un sinónimo para %f</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To disable the hash randomisation in runtime, set the environment
variable PERL_HASH_SEED to 0 (zero) before running Perl (for more
information see L&lt;perlrun/PERL_HASH_SEED&gt;), or to disable the feature
completely in compile time, compile with C&lt;-DNO_HASH_SEED&gt; (see F&lt;INSTALL&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T140511Z" changeid="explorer">
        <seg>Para desactivar la asignación al azar de un hash en tiempo de ejecución, ponga la variable de entorno PERL_HASH_SEED a 0 (cero) antes de ejecutar Perl (para más información véase L&lt;perlrun/PERL_HASH_SEED&gt;), o para desactivar la función completamente en tiempo de compilación, compilar con C&lt;-DNO_HASH_SEED&gt; (vea F&lt;INSTALL&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;c2ph&gt; and F&lt;pstruct&gt;, which are actually the same program but behave
differently depending on how they are called, provide another way of
getting at C with Perl - they'll convert C structures and union declarations
to Perl code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234526Z" changeid="explorer">
        <seg>F&lt;c2ph&gt; y F&lt;pstruct&gt; son en realidad el mismo programa, pero se comportan de manera distinta en función de cómo se invoquen. Proporcionan otra manera de incorporar código C en Perl: convierten declaraciones de estructuras y uniones de C en código Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form is typically
used to trap exceptions more efficiently than the first (see below), while
also providing the benefit of checking the code within BLOCK at compile
time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma es típicamente usada para atrapar excepciones más eficientemente que la primera forma (ver arriba), mientras que también provee del beneficio de comprobar el código dentro del BLOQUE en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
transpired that although the implementation introduced in 5.8.1 was source
compatible with 5.8.0, it was not binary compatible in certain cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se constató que, aunque la implementación fue introducida en 5.8.1, compatible a nivel de código fuente con 5.8.0, no era compatible a nivel binario, en ciertos casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of overflowing the range of the integers is undefined
because it is undefined also in C.  In other words, using 32-bit
integers, C&lt;&lt; 1 &lt;&lt; 32 &gt;&gt; is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resultado del desbordamiento del rango de los números enteros no está definido, ya que tampoco está definido en C. En otras palabras, usando enteros de 32 bits, C&lt;&lt; 1 &lt;&lt; 32 &gt;&gt; no está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's also a negated version, for the same reason we have C&lt;unless&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225145Z" changeid="explorer">
        <seg>Existe también una versión negada, por la misma razón que existe C&lt;unless&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/run/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014648Z" changeid="explorer">
        <seg>=item * F&lt;t/run/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SCALAR will be grown or
shrunk so that the last byte actually read is the last byte of the
scalar after the read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESCALAR crecerá o se reducirá de manera que el último byte leído sea el último byte del escalar después de la lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, only double quotes &quot;interpolate&quot; variables and special
characters such as newlines (C&lt;\n&gt;):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224749Z" changeid="explorer">
        <seg>Sin embargo las variables y los caracteres especiales, como los caracteres de nueva línea (C&lt;\n&gt;), solo se &quot;interpolan&quot; con comillas dobles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The short-circuit behavior is identical.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento abreviado es idéntico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print hex 'aF';   # same</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print hex 'aF';   # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The error, if any, is still returned in C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El error, si está, es devuelto en C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference between them is the
place that the filter is installed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T153217Z" changeid="zipf">
        <seg>La única diferencia entre ellos es el lugar en el que se instala el filtro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Capture group contents are dynamically scoped and available to you outside the
pattern until the end of the enclosing block or until the next successful
match, whichever comes first.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T152831Z" changeid="explorer">
        <seg>Los contenidos del grupo de captura están, dinámicamente, ajustados a un ámbito y disposición fuera del patrón hasta el final del bloque que lo contiene o hasta que la siguiente coincidencia con éxito, lo que ocurra primero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq4		Data Manipulation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq4		Manipulación de datos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$nread = sysread SOCKET, $buffer, $size;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110307T000250Z" changeid="explorer">
        <seg>$nread = sysread SOCKET, $búfer, $largo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here be dragons.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de aquí, dragones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly during unpacking, &quot;extra&quot; bits are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo durante el desempaquetado, los bits &quot;extra&quot; se ignoran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl
5.8.2 the ordering can be different even between different runs of Perl
for security reasons (see L&lt;perlsec/&quot;Algorithmic Complexity Attacks&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde Perl 5.8.2 la ordenación puede ser diferente incluso entre diferentes ejecuciones de Perl por razones de seguridad (ver L&lt;perlsec/&quot;Ataques por Complejidad Algorítmica&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0  &quot;fred&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032539Z" changeid="explorer">
        <seg>0  &quot;pedro&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;getsockopt TCP_NODELAY: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;getsockopt TCP_NODELAY: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if the protocol you're using supports a way of letting the recipient know
which character encoding you used, please help the receiving end by using that
feature!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235331Z" changeid="explorer">
        <seg>Y si el protocolo utilizado ofrece alguna manera de indicar al destinatario la codificación de caracteres utilizada, es muy recomendable hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in C&lt;8
- 4 - 2&gt;, subtraction is left associative so Perl evaluates the
expression left to right.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, en C&lt;8 - 4 - 2&gt;, la resta es asociativa a la izquierda así que Perl evalúa la expresión de izquierda a derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($i = 1; $i &lt; 10; $i++) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ($i = 1; $i &lt; 10; $i++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the PATTERN is delimited by bracketing quotes, the REPLACEMENT has
its own pair of quotes, which may or may not be bracketing quotes, e.g.,
C&lt;s(foo)(bar)&gt; or C&lt;&lt; s&lt;foo&gt;/bar/ &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el PATRÓN está delimitado por paréntesis, corchetes, llaves, el REEMPLAZO tiene su propio par de delimitadores, que puede o no estar encerrado entre los mismos delimitadores, por ejemplo, C&lt;s(foo)(bar)&gt; o C&lt;&lt; s&lt;foo&gt;/bar/ &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;%&gt; X&lt;remainder&gt; X&lt;modulo&gt; X&lt;mod&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;%&gt; X&lt;remainder&gt; X&lt;modulo&gt; X&lt;mod&gt; X&lt;módulo&gt; X&lt;resto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two control characters ^D and ^Z, and the tokens __END__ and __DATA__
may be used to indicate the logical end of the script before the actual
end of file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004158Z" changeid="explorer">
        <seg>Los dos caracteres de control ^D y ^Z, y los símbolos __END__ y __DATA__ pueden ser usados para indicar el fin lógico del programa antes del final real del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If multiple transliterations are given for a character, only the
first one is used:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se dan múltiples transliteraciones para un carácter, sólo se utiliza el primero:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use Module VERSION LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item use Módulo VERSIÓN LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print if defined $switch{D};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T232548Z" changeid="explorer">
        <seg>print if defined $switch{D};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any additional ld flags (NOT including libraries)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Any additional ld flags (NOT including libraries)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Q and A (or FAQ)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235422Z" changeid="explorer">
        <seg>=head1 Preguntas y respuestas (o P+F)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.cpan.org/       the Comprehensive Perl Archive</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001557Z" changeid="explorer">
        <seg>http://www.cpan.org/       Comprehensive Perl Archive Network</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%c    a character with the given number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%c    un carácter del numero indicado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precompilation of the pattern into an internal representation at
the moment of qr() avoids a need to recompile the pattern every
time a match C&lt;/$pat/&gt; is attempted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La precompilación del patrón en una representación interna en el momento de qr() evita la necesidad de recompilar el patrón cada vez que una coincidencia de C&lt;/$pat/&gt; sea intentada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @executables;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @ejecutables;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This construct is useful when you want to capture one of a
number of alternative matches.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T200238Z" changeid="explorer">
        <seg>Esta construcción será útil cuando desea capturar una sola de una serie de alternativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/Math/BigInt/t/mbimbf...........Use of uninitialized value ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214808Z" changeid="explorer">
        <seg>lib/Math/BigInt/t/mbimbf...........Use of uninitialized value ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $thingie = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $cosita = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>? &quot;Error closing sort pipe: $!&quot;
                   : &quot;Exit status $?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043755Z" changeid="explorer">
        <seg>? &quot;Error cerrando la tubería con sort: $!&quot;
                   : &quot;Estado de salida $?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldbmfilter	Perl DBM filters</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldbmfilter	Filtros DBM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not use tell() (or other buffered I/O operations) on a filehandle
that has been manipulated by sysread(), syswrite(), or sysseek().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T023649Z" changeid="explorer">
        <seg>No utilice tell() (u otras operaciones de E/S con búfer) en un identificador de archivo que ha sido manipulado con sysread(), syswrite() o sysseek().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With flock() support:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con soporte de flock():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlartistic has been added: it is the Artistic License in pod format,
making it easier for modules to refer to it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180742Z" changeid="explorer">
        <seg>perlartistic ha sido añadido: se trata de la Licencia Artística en formato pod, haciendo más fácil para los módulos referirse a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also can't be used to go into a
construct that is optimized away.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco puede ser usada para ir a una construcción que ha sido optimizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, text strings are never in any other format!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110405T000933Z" changeid="explorer">
        <seg>(de hecho, es el único formato de las cadenas de texto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 How can I convince others to use Perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232136Z" changeid="explorer">
        <seg>=head2 ¿Cómo puedo animar a otros programadores a probar Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The v-ful version
(v1.2.3) will become obsolete.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T005748Z" changeid="explorer">
        <seg>La versión v-ful (v1.2.3) se convertirá en obsoleta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly,
interpolating an array with no elements is the same as if no
array had been interpolated at that point.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, la interpolación de un array sin elementos es lo mismo que si no se hubiera interpolado ningún array en ese punto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, C&lt;glob(&quot;*.c *.h&quot;)&gt; 
matches all files with a F&lt;.c&gt; or F&lt;.h&gt; extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En este sentido, C&lt;glob(&quot;*.c *.h&quot;)&gt; coincide con todos los archivos con una extensión F&lt;.c&gt; o F&lt;.h&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One possible scenario is when output of an application has included
hash data.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135347Z" changeid="explorer">
        <seg>Un posible escenario es cuando la salida de una aplicación ha incluido datos hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232557Z" changeid="explorer">
        <seg>print</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item quotemeta EXPR
X&lt;quotemeta&gt; X&lt;metacharacter&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192827Z" changeid="explorer">
        <seg>=item quotemeta EXPR
X&lt;quotemeta&gt; X&lt;metacharacter&gt; X&lt;metacarácter&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent
confusion, you may wish to avoid such package names as well.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para evitar confusiones, evite nombres de paquete también de esta manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are documented in L&lt;perlvar&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T205451Z" changeid="zipf">
        <seg>Se describen en L&lt;perlvar&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr/a-zA-Z/ /cs;		# change non-alphas to single space</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr/a-zA-Z/ /cs;		# cambia los caracteres no alfabéticos por un solo espacio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also the source of a useful idiom for executing a function or
performing an operation in list context and then counting the number of
return values, by assigning to an empty list and then using that
assignment in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es también el origen de un modismo muy útil para ejecutar una función o realizar una operación en contexto lista, y luego contar el número de valores devueltos, mediante la asignación a una lista vacía y luego usar esa asignación en el contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar represents a single value:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230800Z" changeid="zipf">
        <seg>Un escalar representa un solo valor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Math::BigInt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Math::BigInt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a lot to know about character sets, and text encodings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T233226Z" changeid="explorer">
        <seg>Hay mucho que aprender sobre juegos de caracteres y codificaciones de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $file (@ARGV) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $archivo (@ARGV) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m?(fred)?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T212202Z" changeid="explorer">
        <seg>m?(fred)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item write EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item write EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, either the string is a result
of C&lt;pack&gt;, or the characters of the string represent a C structure of some
kind.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo general, ya sea la cadena es un resultado de C&lt;pack&gt;, o los caracteres de la cadena representan una estructura de C de algún tipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;read&gt; into a UTF8-encoded buffer with an offset off the end of the buffer
no longer mis-calculates buffer lengths.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212034Z" changeid="explorer">
        <seg>C&lt;read&gt; en un búfer codificado en UTF8 con un desplazamiento más allá del final del búfer ya no calcula mal la longitud del búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then rerun the tests.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A continuación, vuelva a ejecutar las pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sort LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sort LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sleep</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sleep</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($tmp = $global) =~ tr [0-9] [a-j];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224920Z" changeid="explorer">
        <seg>($tmp = $global) =~ tr [0-9] [a-j];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dbmopen HASH,DBNAME,MASK
X&lt;dbmopen&gt; X&lt;dbm&gt; X&lt;ndbm&gt; X&lt;sdbm&gt; X&lt;gdbm&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170423Z" changeid="explorer">
        <seg>=item dbmopen HASH,DBNAME,MÁSCARA
X&lt;dbmopen&gt; X&lt;dbm&gt; X&lt;ndbm&gt; X&lt;sdbm&gt; X&lt;gdbm&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When
unpacking, C&lt;A&gt; strips trailing whitespace and nulls, C&lt;Z&gt; strips everything
after the first null, and C&lt;a&gt; returns data with no stripping at all.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T002430Z" changeid="explorer">
        <seg>Al desempaquetar, C&lt;A&gt; elimina el espacio en blanco y nulos sobrantes del final, C&lt;Z&gt; elimina todo después del primer nulo, y C&lt;a&gt; devuelve los datos sin ningún tipo de recorte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Works only for fixed-width look-behind.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T211707Z" changeid="explorer">
        <seg>Sólo funciona para antecedentes de ancho fijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first publicly
available releases having these characteristics will be the developer
releases Perl 5.9.x, culminating in the Perl 5.10.0 release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T012751Z" changeid="explorer">
        <seg>Los primeros lanzamientos a disposición del público de estas características serán publicadas en la versión desarrollador Perl 5.9.x, culminando con la publicación de Perl 5.10.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gratuitous object orientation results in complex APIs which are
difficult for the average module user to understand or use.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020502Z" changeid="explorer">
        <seg>Una orientación a objetos injustificada resulta en unas API complejas que serán difíciles de comprender o utilizar para el usuario medio del módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support futimes(2), passing filehandles raises
an exception.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013443Z" changeid="explorer">
        <seg>En sistemas que no admiten futimes(2), pasarle un identificador de archivo lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is omitted, reads from
STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010736Z" changeid="explorer">
        <seg>Si IDENTIFICADOR_ARCHIVO se omite, se lee desde STDIN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Which version of Perl should I use?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200537Z" changeid="explorer">
        <seg>=head2 ¿Qué versión de Perl debo utilizar?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>u   Use Unicode rules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T223047Z" changeid="explorer">
        <seg>u	Usa las reglas Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Rafael Garcia-Suarez)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112015Z" changeid="explorer">
        <seg>(Rafael Garcia-Suarez)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;(?#...)&gt; comments are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;(?#...)&gt; los comentarios son ignorados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\D        [3]  Match a non-digit character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223721Z" changeid="explorer">
        <seg>\D	 [3]  Coincide con un carácter que no es dígito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before the first edition of I&lt;Programming perl&gt;, people commonly
referred to the language as &quot;perl&quot;, and its name appeared that way in
the title because it referred to the interpreter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231449Z" changeid="explorer">
        <seg>Antes de la primera edición de I&lt;Programming perl&gt;, el lenguaje se solía llamar &quot;perl&quot;, y su nombre aparecía así en el título porque hacía referencia al intérprete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;==&quot; returns true if the left argument is numerically equal to
the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;==&quot; devuelve verdadero si el argumento de la izquierda es numéricamente igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you'd like to make C&lt;system&gt; (and many other bits of Perl) die on error,
have a look at the L&lt;autodie&gt; pragma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea hacer que C&lt;system&gt; (y muchos otros fragmentos de Perl) mueran en caso de error, eche un vistazo al pragma L&lt;autodie&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any of these modifiers can be set to apply globally to all regular
expressions compiled within the scope of a C&lt;use re&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T192818Z" changeid="explorer">
        <seg>Cualquiera de estos modificadores pueden ser inicializados de forma global, para todas las expresiones regulares compiladas dentro del ámbito de un C&lt;use re&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>continue; # Fall through</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>continue; # Sigue en la siguiente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As VM/ESA doesn't fully support the fork() API programs relying on
this call will not work.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102129Z" changeid="explorer">
        <seg>Como VM/ESA no es totalmente compatible con la API fork(), los programas que confían en esta llamada no funcionarán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the
substrings which may be matched by the given regular expression can be
sorted from the &quot;best&quot; match to the &quot;worst&quot; match, and it is the &quot;best&quot;
match which is chosen.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T234337Z" changeid="explorer">
        <seg>Todas las subcadenas que pueden ser coincidentes con la expresión regular dada se pueden clasificar desde la &quot;mejor&quot; coincidencia hasta la &quot;peor&quot; coincidencia, y es la &quot;mejor&quot; coincidencia la que es elegida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Switch statements
X&lt;switch&gt; X&lt;case&gt; X&lt;given&gt; X&lt;when&gt; X&lt;default&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013516Z" changeid="explorer">
        <seg>=head2 Instrucciones Switch
X&lt;switch&gt; X&lt;case&gt; X&lt;given&gt; X&lt;when&gt; X&lt;default&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use charnames &quot;greek&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224526Z" changeid="explorer">
        <seg>use charnames &quot;greek&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp;               ^     string begin         /i case insens.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224228Z" changeid="explorer">
        <seg>&amp;&amp;               ^     principio cadena         /i no distingue may./min.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { local $SIG{'__DIE__'}; $answer = $a / $b; };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { local $SIG{'__DIE__'}; $respuesta = $a / $b; };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the inverse sine operation, you may use the C&lt;Math::Trig::asin&gt;
function, or use this relation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la inversa de la operación seno, puede usar la función C&lt;Math::Trig::asin()&gt;, o usar esta relación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The good news is that
B::Bytecode and ByteLoader are better than they used to be.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003148Z" changeid="explorer">
        <seg>(Las buenas noticias es que B::Bytecode y ByteLoader son mejores de lo que solía ser.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string =~ /$re/;		# or this way</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034914Z" changeid="explorer">
        <seg>$cadena =~ /$re/;		# o de esta manera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @{ $AoA[0] }, &quot;wilma&quot;, &quot;betty&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @{ $AoA[0] }, &quot;wilma&quot;, &quot;betty&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;format s is %d, s!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;formato s es %d, s!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$@&gt; is empty then the string C&lt;&quot;Warning: Something's wrong&quot;&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$@&gt; está vacío entonces se usa la cadena C&lt;&quot;Warning: Something's wrong&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $in,  &quot;&lt;&quot;,  &quot;input.txt&quot;)  or die &quot;Can't open input.txt: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T031023Z" changeid="explorer">
        <seg>open(my $entrada,  &quot;&lt;&quot;,  &quot;entrada.txt&quot;) or die &quot;No se puede abrir entrada.txt: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\Q          quote (disable) pattern metacharacters till \E</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043935Z" changeid="explorer">
        <seg>\Q		escapa (desactiva) los metacaracteres hasta \E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225503Z" changeid="explorer">
        <seg>perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use sysread() and check
for a return value for 0 to decide whether you're done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use sysread() y compruebe si el valor devuelto es 0 para decidir si ha llegado al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $word (@words) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $palabra (@palabras) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/&quot;$/&quot;&gt; and L&lt;perlvar/&quot;$.&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/&quot;$/&quot;&gt; y L&lt;perlvar/&quot;$.&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;japh\nJunk&quot; &amp; '_____';   	# prints &quot;JAPH\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;japh\nJunk&quot; &amp; '_____';   	# imprime &quot;JAPH\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalars aren't necessarily one thing or another.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los escalares no tienen que ser necesariamente una cosa o la otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a C&lt;__WARN__&gt; handler provides a powerful way to silence all
warnings (even the so-called mandatory ones).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de un controlador C&lt;__WARN__&gt; proporciona una poderosa manera de silenciar a todas las advertencias (incluso las no menos llamadas obligatorias).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might be tempted to use C&lt;$#array + 1&gt; to tell you how many items there
are in an array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224855Z" changeid="explorer">
        <seg>Podría sentirse tentado de usar C&lt;$#array + 1&gt; para determinar el número de elementos de un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A file test, where X is one of the letters listed below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004340Z" changeid="explorer">
        <seg>Un test de archivo, donde X es una de las letras listadas abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last two examples in each block show the pipe as &quot;list form&quot;, which is
not yet supported on all platforms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T233741Z" changeid="explorer">
        <seg>Los dos últimos ejemplos de cada bloque muestra la tubería como &quot;en forma de lista&quot;, que todavía no está soportado en todas las plataformas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The repeat 
count should not be more than 65.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de repeticiones no debe ser mayor de 65.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/&quot;Updated Modules&quot;&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110803T113842Z" changeid="explorer">
        <seg>Vea L&lt;/&quot;Módulos actualizados&quot;&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>closedir $dh;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>closedir $dh;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values for WHENCE are C&lt;0&gt; to set the new position
I&lt;in bytes&gt; to POSITION; C&lt;1&gt; to set it to the current position plus
POSITION; and C&lt;2&gt; to set it to EOF plus POSITION, typically
negative.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013113Z" changeid="explorer">
        <seg>Los valores de DÓNDE son C&lt;0&gt; para poner la nueva posición I&lt;en bytes&gt; a POSICIÓN; C&lt;1&gt; para poner la posición actual más POSICIÓN; y C&lt;2&gt; para ponerlo a EOF más POSICIÓN, normalmente negativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>He will be missed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Le echaremos de menos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>decimal string        --&gt; native integer</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113021Z" changeid="explorer">
        <seg>cadena decimal        --&gt; entero nativo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Unix
touch(1) command will in fact normally use this form instead of the
one shown in the first example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando de Unix touch(1), de hecho, utilizará esta forma en lugar de la que se muestra en el primer ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlmod&gt; describes Perl modules in general.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T183926Z" changeid="zipf">
        <seg>En L&lt;perlmod&gt; se describen los módulos de Perl en general.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as a number,
C&lt;undef&gt; is treated as C&lt;0&gt;; when used as a string, it is treated as
the empty string, C&lt;&quot;&quot;&gt;; and when used as a reference that isn't being
assigned to, it is treated as an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa como un número, C&lt;undef&gt; es tratado como si fuera C&lt;0&gt;; cuando se usa como una cadena de caracteres (I&lt;string&gt;), se trata como el string vacío, C&lt;&quot;&quot;&gt;; y cuando se usa como una referencia que no ha sido asignada, es tratado como un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not everything is mentioned, but 195 features may
already be overwhelming.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T214953Z" changeid="explorer">
        <seg>No abarca todo, pero incluye 195 características del lenguaje; no es mal comienzo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\L$a&quot; cmp &quot;\L$b&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225610Z" changeid="explorer">
        <seg>&quot;\L$a&quot; cmp &quot;\L$b&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\u          uppercase next char (think vi)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043836Z" changeid="explorer">
        <seg>\u		pasar a mayúscula el siguiente carácter (como en vi)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>STORE this, key, value</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>STORE este, clave, valor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bit</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192124Z" changeid="explorer">
        <seg>Bit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Notepad++</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>=item Notepad++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens
immediately, so C&lt;$^R&gt; can be used from other C&lt;(?{ code })&gt; assertions
inside the same regular expression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T222123Z" changeid="explorer">
        <seg>Esto ocurre de forma inmediata, por lo que C&lt;$^R&gt; puede ser usada desde otras aserciones C&lt;(?{ código })&gt; dentro de la misma expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should look
something like:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe ser algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item msgget KEY,FLAGS
X&lt;msgget&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191445Z" changeid="explorer">
        <seg>=item msgget KEY,FLAGS
X&lt;msgget&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$uid == $uid{'root'}) &amp;&amp;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234250Z" changeid="explorer">
        <seg>$uid == $uid{'root'}) &amp;&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, any
object code linked with perl does not automatically fall under the
terms of the GPL, provided such object code only adds definitions
of subroutines and variables, and does not otherwise impair the
resulting interpreter from executing any standard Perl script.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T223739Z" changeid="explorer">
        <seg>Además, cualquier código objeto enlazado con perl no será afectado por los términos de la GPL, siempre y cuando el código objeto sólo agregue definiciones de subrutinas y variables, y de ningún otro modo ponga en peligro el resultante intérprete de la ejecución de cualquier script estándar de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also don't have to use push().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco tiene por qué usar push().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;c2ph|c2ph&gt; and L&lt;pstruct|pstruct&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234514Z" changeid="explorer">
        <seg>=item L&lt;c2ph|c2ph&gt; y L&lt;pstruct|pstruct&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows you to install
modules or distributions from CPAN, or just get information about them, and
a lot more.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235031Z" changeid="explorer">
        <seg>Permite hacer muchas cosas, como instalar módulos o distribuciones de CPAN, o simplemente obtener información sobre ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enhanced documentation and typo fixes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Documentación mejorada y errores ortográficos arreglados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T182618Z" changeid="explorer">
        <seg>(?:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use constant;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use constant;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose you are running script &quot;canasta&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Suponga que está corriendo el script &quot;canasta&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your module will be part of a developer's toolkit.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031420Z" changeid="explorer">
        <seg>Su módulo será parte del conjunto de herramientas del desarrollador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is mainly an
internal issue that only affects people actively working on the perl core;
but it may have minor external visibility, for example in some of details
of the output of C&lt;perl -V&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190321Z" changeid="explorer">
        <seg>Esto es principalmente un asunto interno que sólo afecta a las personas que trabajan activamente en el núcleo de perl; pero puede tener visibilidad externa de menor importancia, por ejemplo, en algunos de los detalles de la salida de C&lt;perl -V&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt;'EOT';
                                      0         1         2         3
                       unpack(&quot;V&quot;,$_) 01234567890123456789012345678901</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052441Z" changeid="explorer">
        <seg>print &lt;&lt;'EOT';
                                      0         1         2         3
                       unpack(&quot;V&quot;,$_) 01234567890123456789012345678901</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules which are &quot;stable&quot; should not break backwards compatibility
without at least a long transition phase and a major change in version
number.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023055Z" changeid="explorer">
        <seg>Los módulos que sean &quot;estables&quot; no deben romper la compatibilidad hacia atrás sin al menos una larga fase de transición y un cambio importante en el número de versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;&gt; 8 if $?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171139Z" changeid="explorer">
        <seg>&gt;&gt; 8 if $?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;Config&gt; module will also let you interrogate values
determined by the B&lt;Configure&gt; program when Perl was installed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo C&lt;Config&gt; le permitirá también interrogar por los valores determinados por el programa B&lt;Configure&gt; cuando Perl fue instalado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Basic syntax overview</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Descripción general de la sintaxis básica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fileno FILEHANDLE
X&lt;fileno&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010141Z" changeid="explorer">
        <seg>=item fileno IDENTIFICADOR_ARCHIVO
X&lt;fileno&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is worth noting that C&lt;\G&gt; improperly used can result in an infinite
loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cabe señalar que C&lt;\G&gt; mal utilizado puede resultar en un bucle infinito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although a
scalar may not directly hold multiple values, it may contain a
reference to an array or hash which in turn contains multiple values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque un escalar no puede contener directamente múltiples valores, podría contener una referencia a un array o un hash, los cuales a su vez sí que pueden contener múltiples valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @a = complex_calculation();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @a = calculo_complejo();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that according to the POSIX 1003.1-1996 the FILENAME may have any
number of trailing slashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que de acuerdo con POSIX 1.003.1-1996, el nombre de archivo puede tener cualquier número de barras inclinadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorry.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo sentimos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>untouched.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T214402Z" changeid="explorer">
        <seg>intacta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On platforms with 64 bit pointers numeric comparison operators used to
erroneously compare the addresses of references that are overloaded, rather
than using the overloaded values.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T211855Z" changeid="explorer">
        <seg>En las plataformas con punteros de 64 bits los operadores de comparación numéricos eran erróneamente usados para comparar las direcciones de las referencias que estaban sobrecargadas, en lugar de utilizar los valores sobrecargados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Length of the name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114054Z" changeid="explorer">
        <seg>Longitud del nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltoc		Perl documentation table of contents</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000151Z" changeid="explorer">
        <seg>perltoc		Tabla de contenido de la documentación de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item OptiPerl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>=item OptiPerl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with regular pattern matching, any capturing parentheses that are not
matched in a C&lt;split()&gt; will be set to C&lt;undef&gt; when returned:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que con la coincidencia de patrones regulares, cualquier paréntesis de captura que no coincida en un C&lt;split()&gt; se establecerá a C&lt;undef&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty C&lt;DESTROY&gt; methods are no longer called.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T011116Z" changeid="explorer">
        <seg>Ya no son llamados los métodos C&lt;DESTROY&gt; vacíos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;AvFLAGS&gt; macro has been removed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T041301Z" changeid="explorer">
        <seg>La macro C&lt;AvFLAGS&gt; se ha eliminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| //            $     str.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>|| //            $     fin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item my EXPR
X&lt;my&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191531Z" changeid="explorer">
        <seg>=item my EXPR
X&lt;my&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltooc		Perl OO tutorial, part 2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000214Z" changeid="explorer">
        <seg>perltooc		Programación orientada a objetos, parte 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print { $OK ? STDOUT : STDERR } &quot;stuff\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050728Z" changeid="explorer">
        <seg>print { $OK ? STDOUT : STDERR } &quot;cosas\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is like</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232048Z" changeid="explorer">
        <seg>es como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DESCRIPCIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is Perl short-hand for the more explicitly written version:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>que es la versión corta de la versión más explícita:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Data: Numbers</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225509Z" changeid="explorer">
        <seg>=head1 Data: Numbers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, C&lt;$$&gt; is the current process
id.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;$$&gt; es el ID del proceso actual).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; &gt;= &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; &gt;= &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For constructs that do interpolate, variables beginning with &quot;C&lt;$&gt;&quot;
or &quot;C&lt;@&gt;&quot; are interpolated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las construcciones que hacen interpolación, las variables que empiezan por &quot;C&lt;$&gt;&quot; o &quot;C&lt;@&gt;&quot; son interpoladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/mro/package_aliases.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010015Z" changeid="explorer">
        <seg>=item t/mro/package_aliases.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common mistake is to try to separate the words with comma or to
put comments into a multi-line C&lt;qw&gt;-string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un error común es tratar de separar las palabras con una coma o poner comentarios en una cadena C&lt;qw&gt; multilínea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$element_count = scalar(@whatever);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$contador_elementos = scalar(@loquesea);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Unicode::Collate</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Unicode::Collate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto-EXPR&gt; form expects a label name, whose scope will be resolved
dynamically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-EXPR espera un nombre de etiqueta, cuyo ámbito será resuelto dinámicamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233552Z" changeid="zipf">
        <seg>print &quot;Hola</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlop/&quot;Gory details of parsing quoted constructs&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>L&lt;perlop/&quot;Gory details of parsing quoted constructs&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, quite a lot faster, actually.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T173714Z" changeid="explorer">
        <seg>En algunos casos, mucho más rápido, en realidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This zero-width pattern can be used to mark the point reached in a string
when a certain part of the pattern has been successfully matched.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T114706Z" changeid="explorer">
        <seg>Este patrón de ancho cero puede ser utilizado para marcar el punto alcanzado en una cadena cuando una parte del patrón ha sido encontrado con éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$line = &lt;STDIN&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$linea = &lt;STDIN&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read from an open filehandle using the C&lt;&lt; &lt;&gt; &gt;&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225309Z" changeid="explorer">
        <seg>Puede utilizar el operador C&lt;&lt; &lt;&gt; &gt;&gt; para leer de un identificador de archivo abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Things that make Perl easier to learn: Unix experience, almost any kind
of programming experience, an understanding of regular expressions, and
the ability to understand other people's code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230510Z" changeid="explorer">
        <seg>Si tiene experiencia en el uso de Unix, cualquier tipo de experiencia en programación, conocimientos de expresiones regulares y la capacidad de leer y entender el código de otros programadores, le costará menos aprender Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules look complicated, but usually they will do what
you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas reglas parecen complicadas, pero usualmente harán lo que usted desea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I  A unsigned integer value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>I  Un valor entero sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compile with
C&lt;-DPERL_USE_LARGE_HV_ALLOC&gt; to use the old, sloppier, default.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T052321Z" changeid="explorer">
        <seg>Compile con C&lt;-DPERL_USE_LARGE_HV_ALLOC&gt; para usar el viejo, descuidado, valor por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as in the shell, a backslashed bareword following the C&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;
means the same thing as a single-quoted string does:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T032755Z" changeid="explorer">
        <seg>Al igual que en el I&lt;shell&gt;, una palabra suelta con contrabarras siguiendo a C&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt; significa lo mismo que una cadena entrecomillada simple:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Same for a L&lt;quantifier|/Quantifiers&gt; such as C&lt;{3}&gt; or
C&lt;{5,}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222900Z" changeid="explorer">
        <seg>Lo mismo para los L&lt;cuantificadores|Cuantificadores&gt; como C&lt;{3}&gt; o C&lt;{5,}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?                   zero or one of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055631Z" changeid="explorer">
        <seg>?                   cero o una coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While there may be a bug somewhere in Perl's configuration or
C&lt;ExtUtil::MakeMaker&gt; causing the problem, the most likely cause is an
incomplete understanding of Sun Studio by this author.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si bien puede haber un error en algún lugar de configuración de Perl o C&lt;ExtUtil::MakeMaker&gt; que sea la razón del problema, la causa más probable es una comprensión incompleta de Sun Studio por parte de este autor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &quot;Matching Code&quot; column is not always an exact rendition.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la columna &quot;Código similar&quot; no siempre es una interpretación exacta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, it is best to
use this construct only for ordinals C&lt;\077&gt; and below, remembering to pad to
the left with zeros to make three digits.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T210419Z" changeid="explorer">
        <seg>De lo contrario, es mejor utilizar esta construcción sólo para los ordinales C&lt;\077&gt; e inferiores, recordando que hay que rellenar a la izquierda con ceros, para tener los tres dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.microemacs.de/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://www.microemacs.de/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it more useful to implement lexical
pragmas.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200432Z" changeid="explorer">
        <seg>Esto hace que sea más útil para implementar pragmas léxicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checks if a group with the given name has matched something.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213310Z" changeid="explorer">
        <seg>Comprueba si el grupo con el nombre indicado ha coincidido con algo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A typical use of the returned seed is for a test program which has too many
combinations to test comprehensively in the time available to it each run.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183536Z" changeid="explorer">
        <seg>Un uso típico de la semilla devuelta es para un programa de prueba que tiene demasiadas combinaciones que probar, exhaustivamente, en el tiempo disponible para cada ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A  A text (ASCII) string, will be space padded.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A  Una cadena de texto (ASCII), será rellenada con espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my(@fhlist) = split(' ',$_[0]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my(@fhlist) = split(' ',$_[0]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default all sockets
operate on bytes, but for example if the socket has been changed using
binmode() to operate with the C&lt;:encoding(utf8)&gt; I/O layer (see the
C&lt;open&gt; pragma, L&lt;open&gt;), the I/O will operate on UTF8-encoded Unicode
characters, not bytes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011249Z" changeid="explorer">
        <seg>Por defecto todos los I&lt;sockets&gt; operan en bytes, pero por ejemplo si el I&lt;socket&gt; ha sido cambiado usando binmode() para operar con la capa de E/S C&lt;:encoding(utf8)&gt; (ver el pragma C&lt;open&gt;, L&lt;open&gt;), la E/S operará en caracteres codificados en UTF-8, no bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the context of the current subroutine call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el contexto de la llamada a la subrutina actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @a = ();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014903Z" changeid="explorer">
        <seg>my @a = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But method calls such as C&lt;&lt; $obj-&gt;meth &gt;&gt; are not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero llamadas a métodos como C&lt;&lt; $objeto-&gt;metodo &gt;&gt;, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, unlike C&lt;if&gt; and C&lt;unless&gt;, failed C&lt;when&gt; statements always
evaluate to an empty list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T105938Z" changeid="explorer">
        <seg>Tenga en cuenta que, a diferencia de C&lt;if&gt; y C&lt;unless&gt;, las instrucciones fallidas de C&lt;when&gt; siempre se evalúan a una lista vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While literal lists and named arrays are often interchangeable, that's
not the case for hashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si bien las listas literales y los array nominales a menudo, son intercambiables, este no es el caso de los hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/r&gt; (non-destructive) option is present, a new copy of the string
is made and its characters transliterated, and this copy is returned no
matter whether it was modified or not: the original string is always
left unchanged.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031550Z" changeid="explorer">
        <seg>Si la opción C&lt;/r&gt; (no-destructiva) está presente, se crea una nueva copia de la cadena y sus caracteres transliterados, y esta copia es devuelta sin importar si fue modificada o no: la cadena original siempre permanece sin cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?&lt;= \S )                   # that ends in non-whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025529Z" changeid="explorer">
        <seg>(?&lt;= \S )                   # que termina en un no-blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is usually something to be avoided when writing clear code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es algo usualmente a ser evitado cuando se está escribiendo código claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is slower
than unprototyped subroutines, where the elements to be compared are passed
into the subroutine as the package global variables $a and $b (see example
below).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014258Z" changeid="explorer">
        <seg>Esto es más lento que las subrutinas no prototipadas, donde los elementos a comparar son pasados a la subrutina en las variables globales del paquete actual $a y $b (ver ejemplo más abajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item splice ARRAY or EXPR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181326Z" changeid="explorer">
        <seg>=item splice ARRAY o EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;break&gt;, C&lt;continue&gt;, C&lt;default, &gt;C&lt;given&gt;, C&lt;when&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022056Z" changeid="explorer">
        <seg>C&lt;break&gt;, C&lt;continue&gt;, C&lt;default&gt;, C&lt;given&gt;, C&lt;when&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Pod::Plainer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T020329Z" changeid="explorer">
        <seg>C&lt;Pod::Plainer&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;CGI::Carp&gt; works better in certain mod_perl configurations</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025516Z" changeid="explorer">
        <seg>C&lt;CGI::Carp&gt; funciona mejor en ciertas configuraciones de mod_perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the result of C&lt;&quot;\Q STRING \E&quot;&gt; has all metacharacters
quoted, there is no way to insert a literal C&lt;$&gt; or C&lt;@&gt; inside a
C&lt;\Q\E&gt; pair.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que el resultado de C&lt;&quot;\Q STRING \E&quot;&gt; tiene todos los metacaracteres entrecomillados, no hay forma de insertar un literal C&lt;$&gt; o C&lt;@&gt; dentro de una pareja C&lt;\Q\E&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;**&quot; is the exponentiation operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;**&quot; es el operador de exponenciación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of EXPR with the first character lowercased.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor de EXPR con el primer carácter en minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cmpStr(\@a, \@b) == 0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225553Z" changeid="explorer">
        <seg>cmpStr(\@a, \@b) == 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($i &lt; 10) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($i &lt; 10) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$year += 1900;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$anno += 1900;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The status is returned in C&lt;$?&gt; and C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El estado se devuelve en C&lt;$?&gt; y C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>January 12, 2006</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>12 de enero 2006</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, note that Perl's pipes use
IO buffering, so you may need to set C&lt;$|&gt; to flush your WRITEHANDLE
after each command, depending on the application.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, tenga en cuenta que las tuberías de Perl utilizan el búfer de E/S, así que puede que necesite establecer C&lt;$|&gt; para limpiar su CONTROLADOR_ESCRITURA después de cada comando, dependiendo de la aplicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no string is
specified via the C&lt;=~&gt; or C&lt;!~&gt; operator, the $_ string is transliterated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031430Z" changeid="explorer">
        <seg>Si no se especifica una cadena a través de los operadores C&lt;=~&gt; o C&lt;!~&gt;, la cadena $_ es transliterada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5100delta	Perl changes in version 5.10.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5100delta	Cambios en la versión 5.10.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sendmsg(2) syscall is currently
unimplemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La llamada del sistema sendmsg(2) no está, actualmente, implementada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %h = ();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014909Z" changeid="explorer">
        <seg>my %h = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can effect a sleep of 250 milliseconds this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede efectuar una espera de 250 milisegundos de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with Perl 5.14, C&lt;push&gt; can take a scalar EXPR, which must hold a
reference to an unblessed array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T180441Z" changeid="explorer">
        <seg>A partir de Perl 5.14, C&lt;push&gt; puede tomar una EXPR escalar, que debe contener la referencia a un hash o un array no bendecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/^xyz/) { $xyz = 1; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/^xyz/) { $xyz = 1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll say that the first part in $1 must be followed both by a digit
and by something that's not &quot;123&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171311Z" changeid="explorer">
        <seg>Vamos a decir que la primera parte en $1 debe ser seguida tanto por un dígito como por algo que no es &quot;123&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\D                  a non-digit</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230245Z" changeid="zipf">
        <seg>\D                  un carácter que no sea un dígito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl581delta	Perl changes in version 5.8.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl581delta	Cambios en la versión 5.8.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extend your pattern's legibility by permitting whitespace and comments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Amplía la legibilidad del patrón, al permitir espacios en blanco y comentarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That'll be $10 please, ma'am.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T032831Z" changeid="explorer">
        <seg>Van a ser $10, por favor, señora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty -cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty -cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;-|&quot;) || exec &quot;cat&quot;, &quot;-n&quot;, $file;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T233704Z" changeid="explorer">
        <seg>open(FOO, &quot;-|&quot;) || exec &quot;cat&quot;, &quot;-n&quot;, $archivo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an expression that specifies the name of a subroutine,
returns true if the specified subroutine has ever been declared, even
if it is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dada una expresión que especifica el nombre de una subrutina, devuelve verdadero si la subrutina especificada ha sido declarada, incluso si esta está indefinida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This file everyone who's contributed to Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014951Z" changeid="explorer">
        <seg>En este archivo figuran todas las personas que han contribuido a Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The content of the here doc is treated just as it would be if the
string were embedded in backticks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El contenido del documento indicado es tratado como si la cadena estuviera incrustada entre comillas invertidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl590delta	Perl changes in version 5.9.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl590delta	Cambios en la versión 5.9.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is an error to refer to a name that is not declared somewhere in the
pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T191852Z" changeid="explorer">
        <seg>Es un error referirse a un nombre que no se haya declarado en alguna parte del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constant folding routine is now wrapped in an exception handler, and
if folding throws an exception (such as attempting to evaluate 0/0), perl
now retains the current optree, rather than aborting the whole program.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T001230Z" changeid="explorer">
        <seg>La rutina de plegado de constantes está ahora envuelta por un manejador de excepciones, y si el plegado produce una excepción (por ejemplo, al intentar evaluar 0/0), perl ahora conserva el árbol de operaciones actual, en lugar de abortar todo el programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uncuddled elses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else en nueva línea. No en la misma línea que la llave de cierre del if.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For compatibility with
older scripts written before __DATA__ was introduced, __END__ behaves
like __DATA__ in the top level script (but not in files loaded with
C&lt;require&gt; or C&lt;do&gt;) and leaves the remaining contents of the
file accessible via C&lt;main::DATA&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T003707Z" changeid="explorer">
        <seg>Por compatibilidad con I&lt;scripts&gt; viejos escritos antes de la introducción de __DATA__, __END__ se comporta como __DATA__ en el script de nivel superior (pero no en los archivos cargados con C&lt;require&gt; o C&lt;do&gt;) y deja el resto del contenido del archivo accesible a través de C&lt;main::DATA&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Operators which expect an integer</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234052Z" changeid="explorer">
        <seg>=item Operadores que consumen un entero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a descending numeric sort of a hash by its values:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es una ordenación numérica descendente de un hash por sus valores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sound principle is to use only ranges
that begin from and end at either alphabetics of equal case ([a-e],
[A-E]), or digits ([0-9]).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T222609Z" changeid="explorer">
        <seg>Un buen principio es el de usar rangos que sólo comiencen y terminen, de forma alfabética, con un mismo tamaño de caja ([a-e], [A-E]), o dígitos ([0-9]).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $Config{shortsize},    &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $Config{shortsize},    &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functionality has
been supplanted by the C&lt;/s&gt; and C&lt;/m&gt; modifiers on pattern matching.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011743Z" changeid="explorer">
        <seg>La funcionalidad ha sido reemplazada por los modificadores C&lt;/s&gt; y C&lt;/m&gt; en la coincidencia de patrones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\o{23072}    [6,8]  octal char        (example: SMILEY)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T185838Z" changeid="explorer">
        <seg>\o{23072}	[6,8]	car. octal			(ejemplo: SMILEY)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say '$foo is numerically less than 100';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>say '$foo es numéricamente menor que 100';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $lrr = shift; 	# ref to array of array refs!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053105Z" changeid="explorer">
        <seg>my $lrr = shift; 	# ¡ref. a un array de array de ref.!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return an undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023154Z" changeid="explorer">
        <seg>Devolver un valor indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, you cannot expect it to be a
&quot;creation time&quot;; see L&lt;perlport/&quot;Files and Filesystems&quot;&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015125Z" changeid="explorer">
        <seg>En particular, no puede esperar que sea el &quot;tiempo de creación&quot;; vea L&lt;perlport/&quot;Archivos y sistemas de archivos&quot;&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot;
mode on systems where the run-time libraries distinguish between
binary and text files.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004746Z" changeid="explorer">
        <seg>Ordena que el modo de lectura o escritura para el IDENTIFICADOR_ARCHIVO sea en &quot;binario&quot; o &quot;texto&quot; en sistemas donde las bibliotecas en tiempo de ejecución distingan entre archivos binarios y de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a compile-time error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un error en tiempo de compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually this name is a single I&lt;identifier&gt;,
that is, a string beginning with a letter or underscore, and
containing letters, underscores, and digits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente, este nombre es un I&lt;identificador&gt;, es decir, una palabra que comienza por una letra o carácter de subrayado y que contiene letras, caracteres de subrayado o dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a filehandle, then the subroutine will be
called to act as a simple source filter, with the line as read in C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011914Z" changeid="explorer">
        <seg>Si hay un identificador de archivo, a continuación, la subrutina será llamada a actuar como un simple filtro de código fuente, con la línea leída en C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># assign to our array, an array of array references</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># asignar a nuestro array, un array de referencias a array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR starts off with C&lt;0b&gt;, it is interpreted as a
binary string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR empieza con C&lt;0b&gt;, se interpreta como una cadena binaria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;O_EXCL&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;O_EXCL&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a side effect, calling keys() resets the internal interator of the HASH or ARRAY
(see L&lt;/each&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T235931Z" changeid="explorer">
        <seg>Como efecto colateral, llamando a keys() reinicia el iterador interno del HASH o del ARRAY (vea L&lt;/each&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are quite a few systems out there that do worse!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020115Z" changeid="explorer">
        <seg>En muchos sistemas los resultados obtenidos son peores...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = '(.)\1';        # Creates problems when concatenated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191556Z" changeid="explorer">
        <seg>$a = '(.)\1';        # Crea problemas cuando es concatenado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;/&gt; template character allows packing and unpacking of a sequence of
items where the packed structure contains a packed item count followed by
the packed items themselves.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La plantilla C&lt;/&gt; permite empaquetar y desempaquetar una secuencia de elementos en donde la estructura empaquetada contiene un contador de elementos empaquetados seguido por los propios elementos empaquetados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means that case-mapping
a single character can sometimes produce several characters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T233520Z" changeid="explorer">
        <seg>Esto significa que el mapeo de un único carácter a veces puede producir varios caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use Module VERSION LIST
X&lt;use&gt; X&lt;module&gt; X&lt;import&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210418Z" changeid="explorer">
        <seg>=item use Módulo VERSIÓN LISTA
X&lt;use&gt; X&lt;module&gt; X&lt;import&gt; X&lt;módulo&gt; X&lt;importar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deletes the directory specified by FILENAME if that directory is
empty.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elimina el directorio especificado por NOMBRE_DIRECTORIO si ese directorio está vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that smart match's matching rules take precedence over
overloading, so if C&lt;$obj&gt; has smart match overloading, then</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note también que las reglas de coincidencias de la coincidencia inteligente toman precedencia sobre la sobrecarga, así que si C&lt;$obj&gt; tiene sobrecargado la coincidencia inteligente, entonces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X  Back up a byte.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X  Retrocede un byte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;ExtUtils::MakeMaker&gt; upgraded to version 6.30 (was 6.17)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031144Z" changeid="explorer">
        <seg>C&lt;ExtUtils::MakeMaker&gt; actualizado a la versión 6.30 (era 6.17)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this also bars you from opening pipes to commands
that intentionally contain shell metacharacters, such as:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T234221Z" changeid="explorer">
        <seg>Sin embargo, esto también le impedirá la apertura de tuberías a comandos que, intencionalmente, contenga metacaracteres shell, tales como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although
quicksort's run time is O(NlogN) when averaged over all arrays of
length N, the time can be O(N**2), I&lt;quadratic&gt; behavior, for some
inputs.)  In 5.7, the quicksort implementation was replaced with
a stable mergesort algorithm whose worst-case behavior is O(NlogN).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque el tiempo de ejecución de quicksort es O(NlogN) de promedio de todos los arrays de longitud N, el tiempo puede ser O(N**2), comportamiento I&lt;cuadrático&gt;, para algunas entradas). En v5.7 la implementación de quicksort fue reemplazada con un algoritmo estable mergesort cuyo peor comportamiento es O(NlogN).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All values must be read before it will start
over.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todos los valores deben ser leídos antes de empezar de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may
be an expression whose value gives the name of the filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T020657Z" changeid="explorer">
        <seg>IDENTIFICADOR_ARCHIVO puede ser una expresión cuyo valor da el nombre del identificador de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perllocale&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220327Z" changeid="explorer">
        <seg>Vea L&lt;perllocale&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must
put the list in parentheses to avoid ambiguity.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe poner la lista entre paréntesis para evitar ambigüedades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The integer types C&lt;s&gt;, C&lt;S&gt;, C&lt;l&gt;, and C&lt;L&gt; may be
followed by a C&lt;!&gt; modifier to specify native shorts or
longs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tipos enteros C&lt;s&gt;, C&lt;S&gt;, C&lt;l&gt;, y C&lt;L&gt; pueden ser seguidos por un modificar C&lt;!&gt; para especificar un corto (short) o largo (long) nativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;O_CREAT&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;O_CREAT&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For systems from the Microsoft family this means that, if your binary
data contain C&lt;\cZ&gt;, the I/O subsystem will regard it as the end of
the file, unless you use binmode().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T153347Z" changeid="explorer">
        <seg>Para los sistemas de la familia Microsoft esto significa que si sus datos binarios contienen C&lt;\cZ&gt;, el subsistema de E/S lo considerará como el fin del archivo, a menos que use binmode().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE&gt;: Unlike C and other languages, Perl has no C&lt;\v&gt; escape sequence for
the vertical tab (VT - ASCII 11), but you may use C&lt;\ck&gt; or C&lt;\x0b&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;NOTA&gt;: A diferencia de C y otros lenguajes, Perl no tiene una secuencia de escape C&lt;\v&gt; para el tabulado vertical (VT - ASCII 11), pero puede usar C&lt;\ck&gt; o C&lt;\x0b&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One or more embedded pattern-match modifiers, to be turned on (or
turned off, if preceded by C&lt;-&gt;) for the remainder of the pattern or
the remainder of the enclosing pattern group (if any).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230756Z" changeid="explorer">
        <seg>Uno o más modificadores de coincidencia de patrón incrustados, que han de ser activados (o desactivados, si son precedidos por C&lt;-&gt;) para el resto del patrón o el resto del grupo de patrón más interior (si existe).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace
between the function and left parenthesis doesn't count, so sometimes
you need to be careful:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco entre la función y el paréntesis izquierdo no cuenta, por lo que deberá tener cuidado en algunas ocasiones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESTROY this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DESTROY este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 16  ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 16  ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLEAR this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CLEAR este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a
BLOCK it's just a forward declaration.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015248Z" changeid="explorer">
        <seg>Sin un BLOQUE es sólo una declaración previa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are not under C&lt;use threads::shared&gt; this does nothing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no está bajo C&lt;use threads::shared&gt;, no hará nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlopentut&gt; and
L&lt;perlfunc/open&gt; for details on this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220243Z" changeid="explorer">
        <seg>Vea L&lt;perlopentut&gt; y L&lt;perlfunc/open&gt; para más detalles sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the substring
is not found, C&lt;index&gt; returns one less than the base, ordinarily C&lt;-1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el substring no se encuentra, C&lt;index&gt; devuelve uno menos que la base, normalmente C&lt;-1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
particular Steve Hay has worked to side step many warnings emitted by their
compilers and at least one C compiler internal error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T042959Z" changeid="explorer">
        <seg>En particular, Hay Steve trabajó para quitar muchas advertencias emitidas por estos compiladores y al menos un error interno del compilador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>grep {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>grep {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to inspect both the string given to RE engine and the
resulting finite automaton.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es posible inspeccionar tanto la cadena dada al motor RE y el autómata finito que resulta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;config_data|config_data&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234307Z" changeid="explorer">
        <seg>=item L&lt;config_data|config_data&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used with a
C&lt;foreach&gt; loop or the experimental C&lt;given&gt; block, C&lt;when&gt; can be used in
Perl to implement C&lt;switch&gt;/C&lt;case&gt; like statements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103602Z" changeid="explorer">
        <seg>Usando con un bucle C&lt;foreach&gt; o el experimental bloque C&lt;given&gt;, C&lt;when&gt; puede ser usado en Perl para implementar instrucciones parecidas a C&lt;switch&gt;/C&lt;case&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlunifaq&gt;, L&lt;perlunicode&gt;, L&lt;perluniintro&gt;, L&lt;Encode&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235558Z" changeid="explorer">
        <seg>L&lt;perlunifaq&gt;, L&lt;perlunicode&gt;, L&lt;perluniintro&gt;, L&lt;Encode&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use mod_perl 2.x with Perl 5.8.1, you will need
mod_perl-1.99_10 or higher.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T012119Z" changeid="explorer">
        <seg>Si desea utilizar mod_perl 2.x. con Perl 5.8.1, necesitará mod_perl-1.99_10 o superior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iain 'Spoon' Truskett, Perl hacker, author of L&lt;perlreref&gt; and
contributor to CPAN, died suddenly on 29th December 2003, aged 24.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Iain 'Spoon' Truskett, Perl hacker, autor de L&lt;perlreref&gt; y contribuidor a CPAN, murió repentinamente el 29 de diciembre de 2003, a la edad de 24 años.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>now gives a C&lt;&quot;our&quot; variable %s redeclared&gt; warning.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040619Z" changeid="explorer">
        <seg>ahora da una advertencia C&lt;&quot;our&quot; variable %s redeclared&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no corresponding capture group defined, then it is a
fatal error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T212829Z" changeid="explorer">
        <seg>Si no se define un correspondiente grupo de captura, entonces es un error fatal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($key,$value) = each %ENV) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (($clave,$valor) = each %ENV) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open FILEHANDLE,MODE,EXPR,LIST</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011049Z" changeid="explorer">
        <seg>=item open IDENTIFICADOR_ARCHIVO,MODO,EXPR,LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NAME should be a
packed address of the appropriate type for the socket.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NOMBRE debe ser una dirección empaquetada del tipo apropiado para el socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support fchdir(2), you may pass a filehandle or
directory handle as the argument.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005245Z" changeid="explorer">
        <seg>En sistemas que soportan fchdir(2), puede pasarle un identificador de archivo o un identificador de directorio como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item scalar EXPR
X&lt;scalar&gt; X&lt;context&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200156Z" changeid="explorer">
        <seg>=item scalar EXPR
X&lt;scalar&gt; X&lt;context&gt; X&lt;escalar&gt; X&lt;contexto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In non-Unix environments, the functionality of some
Unix system calls may not be available or details of the available
functionality may differ slightly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022327Z" changeid="explorer">
        <seg>En entornos no Unix, la funcionalidad de algunas llamadas del sistema Unix pueden no estar disponibles, o los detalles de la funcionalidad disponible pueden diferir ligeramente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also find out from within Perl what your
$quota and $comment fields mean and whether you have the $expire field
by using the C&lt;Config&gt; module and the values C&lt;d_pwquota&gt;, C&lt;d_pwage&gt;,
C&lt;d_pwchange&gt;, C&lt;d_pwcomment&gt;, and C&lt;d_pwexpire&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede también encontrar dentro de Perl que es lo que significan sus campos $cuota, $comentario y $expira usando el módulo C&lt;Config&gt; y los valores C&lt;d_pwquota&gt;, C&lt;d_pwage&gt;, C&lt;d_pwchange&gt;, C&lt;d_pwcomment&gt; y C&lt;d_pwexpire&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for the core support of Unicode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014701Z" changeid="explorer">
        <seg>Pruebas de compatibilidad básica con Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also
L&lt;perlipc/&quot;SysV IPC&quot;&gt; and the documentation for C&lt;IPC::SysV&gt; and
C&lt;IPC::Semaphore&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215419Z" changeid="explorer">
        <seg>Vea también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt; y C&lt;IPC::SysV&gt; y C&lt;IPC::Semaphore&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 4   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 4   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LENGTH is omitted, returns
everything through the end of the string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015524Z" changeid="explorer">
        <seg>Si se omite LONGITUD, devuelve todo hasta el final de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What's the difference between &quot;perl&quot; and &quot;Perl&quot;?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231326Z" changeid="explorer">
        <seg>=head2 ¿Cuál es la diferencia entre &quot;perl&quot; y &quot;Perl&quot;?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/&quot;Regexp Quote-Like Operators&quot;&gt; for details and L&lt;perlretut&gt; for
examples using these operators.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T184645Z" changeid="explorer">
        <seg>Ver L&lt;/&quot;Operadores Regexp entrecomillados&quot;&gt; para más detalles y L&lt;perlretut&gt; para ejemplos usando estos operadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets FILEHANDLE's position, just like the C&lt;fseek&gt; call of C&lt;stdio&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012035Z" changeid="explorer">
        <seg>Establece la posición de IDENTIFICADOR_ARCHIVO, igual que la llamada C&lt;fseek&gt; de C&lt;stdio&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>d_fchdir='undef'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T134612Z" changeid="explorer">
        <seg>d_fchdir='undef'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># using an in-line function</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># usando una función incluida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a subroutine that does not
exist may still be callable: its package may have an C&lt;AUTOLOAD&gt;
method that makes it spring into existence the first time that it is
called; see L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que una subrutina que no existe puede ser llamada: su paquete puede tener un método C&lt;AUTOLOAD&gt; que la hace aparecer la primera vez que es llamada; ver L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$DOWARN = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$DOWARN = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>------------------------------------------------------------------</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>------------------------------------------------------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should be noted that C&lt;~~&gt; will refuse to work on objects that
don't overload it (in order to avoid relying on the object's
underlying structure).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se debe hacer notar que C&lt;~~&gt; rechazará funcionar en objetos que no lo sobrecargan (para no depender de la estructura subyacente del objeto)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you or your team can be faster,
better, and stronger through Perl, you'll deliver more value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004345Z" changeid="explorer">
        <seg>Si con Perl usted y su equipo pueden desarrollar de manera más rápida y mejor, su productividad aumentará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn't matter whether those elements are already
there or not: it'll gladly create them for you, setting
intervening elements to C&lt;undef&gt; as need be.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No importa qué elementos estén allí o no: serán, con mucho gusto, creados para usted, estableciendo elementos intermedios a C&lt;undef&gt; cuando sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl573delta - what's new for perl v5.7.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl573delta - qué hay de nuevo para perl v5.7.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these cases, whitespace
and comments are allowed between both parts, though the comment must follow
at least one whitespace character; otherwise a character expected as the 
start of the comment may be regarded as the starting delimiter of the right part.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T214705Z" changeid="explorer">
        <seg>En estos casos, los espacios en blanco y los comentarios están permitidos entre ambas partes, aunque el comentario debe estar precedido, por lo menos, de un espacio en blanco; de lo contrario, un carácter esperado como inicio del comentario puede ser considerado como el delimitador de inicio de la parte derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open my $logfile, &quot;&gt;&gt;&quot;, &quot;my.log&quot; or die &quot;Could not open my.log: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T222040Z" changeid="zipf">
        <seg>open my $registro, &quot;&gt;&gt;&quot;, &quot;mi.registro&quot; or die &quot;No se pudo abrir mi.registro: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To transform a bit vector into a string or list of 0's and 1's, use these:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para transformar un vector de bits en una cadena o una lista de 0 y 1, utilice los siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/^baz/ || [qw(foo bar)]) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215213Z" changeid="explorer">
        <seg>when (/^baz/ || [qw(foo bar)]) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>force the argument into the integer format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234055Z" changeid="explorer">
        <seg>Fuerzan la conversión del argumento al formato de entero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print +(1+2)+4;   # Prints 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print +(1+2)+4;	# Imprime 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>h           interpret integer as C type &quot;short&quot; or &quot;unsigned short&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>h           interpreta un entero como un &quot;short&quot; o &quot;unsigned short&quot; del C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If BITS is 8, &quot;elements&quot; coincide with bytes of the input string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si BITS es 8, los &quot;elementos&quot; coinciden con bytes de la cadena de entrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ref EXPR
X&lt;ref&gt; X&lt;reference&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194520Z" changeid="explorer">
        <seg>=item ref EXPR
X&lt;ref&gt; X&lt;reference&gt; X&lt;referencia&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sin EXPR
X&lt;sin&gt; X&lt;sine&gt; X&lt;asin&gt; X&lt;arcsine&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200720Z" changeid="explorer">
        <seg>=item sin EXPR
X&lt;sin&gt; X&lt;sine&gt; X&lt;asin&gt; X&lt;arcsine&gt; X&lt;arco seno&gt; X&lt;seno&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with filehandles and labels, a bareword that consists
entirely of lowercase letters risks conflict with future reserved
words, and if you use the C&lt;use warnings&gt; pragma or the B&lt;-w&gt; switch, 
Perl will warn you about any such words.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003544Z" changeid="explorer">
        <seg>Al igual que con identificadores de archivo y las etiquetas, una palabra suelta que consiste enteramente en minúsculas tiene el riesgo de llegar a un conflicto con los futuras palabras reservadas, y si utiliza el pragma C&lt;use warnings&gt; o la opción B&lt;-w&gt;, Perl le advertirá sobre cualquiera de estas palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stable modules should maintain backwards compatibility</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013802Z" changeid="explorer">
        <seg>Módulos estables deben mantener la compatibilidad hacia atrás</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Beginning is &lt;$1&gt;, number is &lt;$2&gt;.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233120Z" changeid="explorer">
        <seg>print &quot;El comienzo es &lt;$1&gt;, número es &lt;$2&gt;.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = 4;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194702Z" changeid="explorer">
        <seg>$x = 4;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;x&gt; repetition operator is now able to operate on C&lt;qw//&gt; lists.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035509Z" changeid="explorer">
        <seg>El operador de repetición C&lt;x&gt; es ahora capaz de operar en listas C&lt;qw//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example that looks up nonnumeric uids in the passwd file:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo que obtiene el uid numérico a partir del archivo de contraseñas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to receive LENGTH characters
of data into variable SCALAR from the specified SOCKET filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011821Z" changeid="explorer">
        <seg>Intenta leer LONGITUD I&lt;caracteres&gt; de datos en la variable ESCALAR del identificador de archivo SOCKET especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl debugger (F&lt;lib/perl5db.pl&gt;) can now save all debugger commands for
sourcing later, and can display the parent inheritance tree of a given class.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T105306Z" changeid="explorer">
        <seg>El depurador de Perl (F&lt;lib/perl5db.pl&gt;) ahora puede guardar todos los comandos del depurador para ser analizados más tarde, y puede mostrar el árbol de herencia de una clase padre dada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For historical reasons, the leading C&lt;m&gt; in C&lt;m?PATTERN?&gt; is optional,
but the resulting C&lt;?PATTERN?&gt; syntax is deprecated, will warn on
usage and might be removed from a future stable release of Perl (without
further notice!).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030602Z" changeid="explorer">
        <seg>Por razones históricas, la C&lt;m&gt; precedente en C&lt;m?PATRÓN?&gt; es opcional, pero la sintaxis resultante C&lt;?PATRÓN?&gt; es obsoleta, generando una advertencia sobre su uso y que puede ser eliminada de una próxima versión estable de Perl (¡sin previo aviso!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will match C&lt;blah&gt; in any case, some spaces, and an exact (I&lt;including the case&gt;!)
repetition of the previous word, assuming the C&lt;/x&gt; modifier, and no C&lt;/i&gt;
modifier outside this group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T231240Z" changeid="explorer">
        <seg>coincidirá con C&lt;bla&gt; en cualquier tamaño de caja, algunos espacios, y una exacta (I&lt;¡incluyendo el tamaño de caja!&gt;) repetición de la palabra anterior, asumiendo el modificador C&lt;/x&gt;, y no el modificador C&lt;/i&gt; alrededor de este grupo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another good indicator that you should use defaults is if most of your 
users call your routines with the same arguments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021259Z" changeid="explorer">
        <seg>Otro buen indicador de que debe usar valores por defecto es si la mayor parte de los usuarios llama a sus rutinas con los mismos argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C application
assumes that I&lt;all&gt; keys and values are NULL terminated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111003T120421Z" changeid="zipf">
        <seg>La aplicación en C supone que I&lt;todas&gt; las claves y sus valores correspondientes terminan con un carácter NULL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Text::Autoformat;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225535Z" changeid="explorer">
        <seg>use Text::Autoformat;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MASK defaults to 0777 if omitted, and FILENAME defaults
to C&lt;$_&gt; if omitted.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000534Z" changeid="explorer">
        <seg>MÁSCARA está puesto por defecto a 0777, si no se indica, y ARCHIVO es por defecto C&lt;$_&gt;, si no se indica, también.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is somewhat equivalent to the C-style switch statement's fallthrough
functionality (not to be confused with I&lt;Perl's&gt; fallthrough functionality - see
below), wherein the same block is used for several C&lt;case&gt; statements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T105802Z" changeid="explorer">
        <seg>Esto es algo equivalente a la funcionalidad de la instrucción C&lt;switch&gt; del C (no debe confundirse con la funcionalidad de I&lt;Perl&gt;; vea más adelante), en donde el mismo bloque se utiliza para varias instrucciones C&lt;case&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $vector = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225604Z" changeid="explorer">
        <seg>my $vector = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$quota,$comment,$gcos,$dir,$shell,$expire) = getpw*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cuota,$comentario,$gcos,$dir,$shell,$expiracion) = getpw*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now system utilities that read the legacy process
name such as ps, top and killall will recognize the name you set when
assigning to C&lt;$0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T053711Z" changeid="explorer">
        <seg>Ahora las utilidades del sistema que lean el nombre del proceso, tales como ps, top y killall reconocerán el nombre asignado a C&lt;$0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># open for append, using the fileno of OLDFH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Abrir para añadir, usando el número de descriptor de OLDFH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The importation can be made conditional; see L&lt;if&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024518Z" changeid="explorer">
        <seg>La importación puede estar condicionado; vea L&lt;if&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$2 follows $1.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T150928Z" changeid="explorer">
        <seg>print &quot;$2 sigue a $1.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that both &quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot; in Perl are implemented directly using
&quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot; in C.  If C&lt;use integer&gt; (see L&lt;Integer Arithmetic&gt;) is
in force then signed C integers are used, else unsigned C integers are
used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220023Z" changeid="explorer">
        <seg>Tenga en cuenta que tanto &quot;&lt;&lt;&quot; como &quot;&gt;&gt;&quot; en Perl están implementados directamente a través de &quot;&lt;&lt;&quot; y &quot;&gt;&gt;&quot; en C. Si C&lt;use integer&gt; (vea L&lt;Aritmética entera&gt;) está en vigor entonces se utilizan los enteros C con signo; sino, se utilizan enteros C sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;Regexp Quote-Like Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>See L&lt;perlop/&quot;Operadores Regexp&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value is the exit status of the program as returned by the
C&lt;wait&gt; call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto es el estado de salida del programa devuelto por la llamada C&lt;wait&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose, scope and target applications of your module</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024001Z" changeid="explorer">
        <seg>El propósito, ámbito y las aplicaciones objetivo de su módulo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/foo\Kbar//g;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212614Z" changeid="explorer">
        <seg>s/foo\Kbar//g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given ($foo) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T194011Z" changeid="explorer">
        <seg>given ($foo) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the LABEL is omitted, the loop control statement
refers to the innermost enclosing loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013409Z" changeid="explorer">
        <seg>Si la ETIQUETA se omite, las instrucciones de control de bucle se refieren al bucle más interior en que se encuentren.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File::Spec upgraded to version 3.01 (as part of the new PathTools distribution)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>File::Spec actualizado a la versión 3.01 (como parte de la nueva distribución PathTools)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -V:{short,int,long{,long}}size</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ perl -V:{short,int,long{,long}}size</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some examples:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113340Z" changeid="explorer">
        <seg>Algunos ejemplos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( /$pat/ ) {
            print &quot;&lt;$1&gt; &lt;$2&gt;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233914Z" changeid="explorer">
        <seg>if ( /$patron/ ) {
            print &quot;&lt;$1&gt; &lt;$2&gt;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will use smart matching (only the first operand is considered), whereas</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215211Z" changeid="explorer">
        <seg>usará coincidencia inteligente (sólo el primer operando es considerado), mientras que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But you cannot do so for the very first one if it's a scalar containing
a reference, which means that $ref_to_AoA always needs it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero no puede hacerlo para el primer caso si es un escalar que contenga una referencia, lo que significa que $ref_to_AoA siempre lo necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this grouping operator there is no need to describe the ordering, since
only whether or not C&lt;S&gt; can match is important.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T000307Z" changeid="explorer">
        <seg>Para este operador de agrupación no hay necesidad de describir el orden, ya que sólo es importante si C&lt;S&gt; puede coincidir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl resolves this ambiguity by interpreting C&lt;\10&gt; as a backreference
only if at least 10 left parentheses have opened before it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T185603Z" changeid="explorer">
        <seg>Perl resuelve esta ambigüedad mediante la interpretación de C&lt;\10&gt; como una contrareferencia cuando, al menos, se han abierto, antes, 10 paréntesis de apertura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://jobs.perl.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225443Z" changeid="explorer">
        <seg>http://jobs.perl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A zero-width positive look-behind assertion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T211527Z" changeid="explorer">
        <seg>Una aserción antecedente positiva de ancho cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval qq[\n#line 200 &quot;foo bar&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval qq[\n#line 200 &quot;foo bar&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @transformed = map { ...; } @input; # ; disambiguates</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @transformado = map { ...; } @entrada; # ; desambigüedad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># @fields is (1, 'A', 2, undef, 3)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># @campos es (1, 'A', 2, undef, 3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The whatever
is a syntax error if Perl doesn't guess that the C&lt;{ ... }&gt; is a
block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225849Z" changeid="explorer">
        <seg>El lo-que-sea es un error de sintaxis si Perl no supone que C&lt;{ ... }&gt; sea un bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if -f $File::Find::fullname &amp;&amp; /\.pm$/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225447Z" changeid="explorer">
        <seg>if -f $File::Find::fullname &amp;&amp; /\.pm$/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$fh = \*STDOUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$fh = \*STDOUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If in doubt about
this behavior, the left operand can be quoted explicitly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230008Z" changeid="explorer">
        <seg>En caso de duda acerca de este comportamiento, el operando de la izquierda puede ser entrecomillado de forma explícita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default all sockets operate
on bytes, but for example if the socket has been changed using
binmode() to operate with the C&lt;:encoding(utf8)&gt; I/O layer (see
L&lt;/open&gt;, or the C&lt;open&gt; pragma, L&lt;open&gt;), the I/O will operate on UTF-8
encoded Unicode characters, not bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto todos los sockets operan en bytes, pero por ejemplo, si el socket ha sido cambiado usando binmode() para operar con la capa de E/S C&lt;:encoding(utf8)&gt; (ver el pragma C&lt;open&gt;, L&lt;open&gt;), la E/S operará en caracteres codificados en UTF-8, no bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has been ported to IBM's OS/400 PASE environment.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T190759Z" changeid="explorer">
        <seg>Perl ha sido adaptada al entorno de IBM OS/400 PASE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Under NFS this will use the time of the NFS server, not the time of
the local machine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bajo NFS se utilizará la hora del servidor NFS, no el tiempo de la máquina local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print sort @harry;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print sort @harry;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1  ARRAY(0x803d40)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032548Z" changeid="explorer">
        <seg>1  ARRAY(0x803d40)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this bothers you, then your
notion of Authorship needs some revision.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222733Z" changeid="explorer">
        <seg>Si esto te molesta, entonces el concepto de Autoría necesita un poco de revisión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sub NAME (PROTO) : ATTRS BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sub NOMBRE (PROTO) : ATRIBS BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The work started in 2002 and is still ongoing.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004334Z" changeid="explorer">
        <seg>El trabajo se inició en 2002 y sigue en curso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This must
be a power of two from 1 to 32 (or 64, if your platform supports
that).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto debe ser una potencia de dos desde 1 a 32 (o 64, si la plataforma lo admite).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;namespace&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;namespace&gt; X&lt;espacio de nombres&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing of C&lt;\N{...}&gt; is also done here, and compiled into an intermediate
form for the regex compiler.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procesamiento de C&lt;\N{...}&gt; también se hace aquí, y compilado en una forma intermedia para el compilador de expresiones regulares (RE).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>q, L, or ll interpret integer as C type &quot;long long&quot;, &quot;unsigned long long&quot;,
               or &quot;quad&quot; (typically 64-bit integers)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181823Z" changeid="explorer">
        <seg>q, L, or ll interpreta un entero como un &quot;long long&quot;, &quot;unsigned long long&quot;,
               o &quot;quad&quot; del C (típicamente enteros de 64-bit)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If umask(2) is not implemented and you are
not trying to restrict access for yourself, returns C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si umask(2) no está implementado y usted no está tratando de restringir el acceso por sí mismo, devuelve C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/regexp_unicode_prop.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010032Z" changeid="explorer">
        <seg>=item t/op/regexp_unicode_prop.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.effectiveperlprogramming.com/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003421Z" changeid="explorer">
        <seg>http://www.effectiveperlprogramming.com/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Auto-increment and Auto-decrement
X&lt;increment&gt; X&lt;auto-increment&gt; X&lt;++&gt; X&lt;decrement&gt; X&lt;auto-decrement&gt; X&lt;--&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T232441Z" changeid="explorer">
        <seg>=head2 Auto incremento y auto decremento
X&lt;increment&gt; X&lt;auto-increment&gt; X&lt;++&gt; X&lt;decrement&gt; X&lt;auto-decrement&gt; X&lt;--&gt; X&lt;incremento&gt; X&lt;auto incremento&gt; X&lt;decremento&gt; X&lt;auto decremento&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general though, we try to
limit this list to books published in the past five years.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003832Z" changeid="explorer">
        <seg>Sin embargo, en general intentaremos limitar esta lista a libros publicados en los últimos cinco años.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pattern match succeeds and C&lt;$1&gt; is defined, although it
matched &quot;nothing&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El patrón de búsqueda tiene éxito y C&lt;$1&gt; está definida, aunque no ha correspondido con &quot;nada&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $quoted_substring = quotemeta($substring);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T193753Z" changeid="explorer">
        <seg>my $subcadena_escapada = quotemeta($subcadena);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are pros and cons of each technique, which 
should be considered when you design your API.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015728Z" changeid="explorer">
        <seg>Hay pros y contras de cada técnica, lo que debería tenerse en cuenta al diseñar su API.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each
major version has significant differences that earlier versions cannot
support.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T225720Z" changeid="explorer">
        <seg>Cada versión principal incorpora diferencias importantes que no son compatibles con las versiones anteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the first step at which the presence
of the C&lt;//x&gt; modifier is relevant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este es el primer caso en el que la presencia del modificador C&lt;//x&gt; es relevante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl58delta 	Perl changes in version 5.8.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl58delta 	Cambios en la versión 5.8.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the system design is itself object-oriented</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020100Z" changeid="explorer">
        <seg>Cuando el diseño del sistema es en sí orientado a objetos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation update</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Actualización de la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$        Match the end of the line (or before newline at the end)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042537Z" changeid="explorer">
        <seg>$	Coincide con el final de línea (o antes del nuevo línea del final)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &gt; &gt;&gt; and C&lt;&lt; &lt; &gt;&gt; modifiers can also be used on C&lt;()&gt; groups 
to force a particular byte-order on all components in that group, 
including all its subgroups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los modificadores C&lt;&lt; &gt; &gt;&gt; y C&lt;&lt; &lt; &gt;&gt; también se pueden utilizar en los grupos C&lt;()&gt; para obligar a un particular orden de bytes en todos los componentes de ese grupo, que incluye todos sus subgrupos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,}?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n,}?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that fails, or
you didn't use that, then try adjusting other optimization options
(-LNO, -INLINE, -O3 to -O2, etcetera).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003303Z" changeid="explorer">
        <seg>Si eso no funciona, o no lo ha usado, intente, a continuación, ajustar otras opciones de optimización (-LNO,-inline, O3-a-O2, etc).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Documentation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013809Z" changeid="explorer">
        <seg>=head2 Documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If single quotes
are used, no interpretation is done on the replacement string (the C&lt;/e&gt;
modifier overrides this, however).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se utilizan comillas simples, no se realiza ninguna interpretación en la cadena de reemplazo (sin embargo, el modificador C&lt;/e&gt; reemplaza a ésta).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>time ^ $$</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>time ^ $$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;can't fcntl F_GETFL: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;no puedo hacer fcntl F_GETFL: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;S{min,max}?&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050016Z" changeid="explorer">
        <seg>=item C&lt;S{min,max}?&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 GETTING HELP</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000102Z" changeid="explorer">
        <seg>=head1 CÓMO OBTENER AYUDA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Terms and List Operators (Leftward)
X&lt;list operator&gt; X&lt;operator, list&gt; X&lt;term&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T190307Z" changeid="explorer">
        <seg>=head2 Términos y Operadores de listas (por la izquierda)
X&lt;list operator&gt; X&lt;operator, list&gt; X&lt;term&gt; X&lt;operador lista&gt; X&lt;operador, lista&gt; X&lt;término&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line up corresponding items vertically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alinear elementos correspondientes verticalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub byage {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub por_edad {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perlhaiku&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005518Z" changeid="explorer">
        <seg>=item L&lt;perlhaiku&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%2s&gt;&quot;, &quot;long&quot;;   # prints &quot;&lt;long&gt;&quot; (does not truncate)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014640Z" changeid="explorer">
        <seg>printf &quot;&lt;%2s&gt;&quot;, &quot;long&quot;;   # imprie &quot;&lt;long&gt;&quot; (no lo trunca)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decode everything you receive, encode everything you send out.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235412Z" changeid="explorer">
        <seg>Descodifique todo lo que reciba y codifique todo lo que envíe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(3,1,1);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>set_vec(3,1,1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ge  greater than or equal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ge  mayor o igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the C&lt;b&gt; and C&lt;B&gt; formats pack a string that's that many bits long.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, los formatos C&lt;b&gt; y C&lt;B&gt; empaquetan una cadena con una dada longitud de bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item msgsnd ID,MSG,FLAGS
X&lt;msgsnd&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191527Z" changeid="explorer">
        <seg>=item msgsnd ID,MSG,FLAGS
X&lt;msgsnd&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225550Z" changeid="explorer">
        <seg>undef;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endpwent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endpwent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&lt; \k&lt;NAME&gt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T214547Z" changeid="explorer">
        <seg>=item C&lt;&lt; \k&lt;NOMBRE&gt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-x&gt;[I&lt;dir&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-x&gt;[I&lt;dir&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That algorithm was not stable, so I&lt;could&gt; go quadratic.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014348Z" changeid="explorer">
        <seg>Este algoritmo no era estable, y I&lt;podría&gt; ser cuadrático.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is used by
C&lt;AUTOLOAD()&gt; subroutines that wish to load another subroutine and then
pretend that the other subroutine had been called in the first place
(except that any modifications to C&lt;@_&gt; in the current subroutine are
propagated to the other subroutine.)  After the C&lt;goto&gt;, not even C&lt;caller()&gt;
will be able to tell that this routine was called first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se usa por subrutinas C&lt;AUTOLOAD()&gt; que desean cargar otra subrutina y fingen que esta otra subrutina ha sido llamada en primer lugar (excepto que cualquier modificación a C&lt;@_&gt; en la subrutina actual se propaga a la otra). Después del C&lt;goto&gt;, ni siquiera C&lt;caller()&gt; será capaz de decir qué rutina fue llamada en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;my&gt; declares the listed variables to be local (lexically) to the
enclosing block, file, or C&lt;eval&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;my&gt; declara las variables enumeradas como locales (léxicamente) en el bloque, archivo, o C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
means that Perl no longer handles signals immediately but instead
&quot;between opcodes&quot;, when it is safe to do so.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T152507Z" changeid="explorer">
        <seg>Esto significa que Perl ya no gestiona las señales de forma inmediata, sino que &quot;entre los códigos de operación&quot;, cuando es más seguro hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There have been many fixes in the area of anonymous subs, lexicals and
closures.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010407Z" changeid="explorer">
        <seg>Ha habido muchas correcciones en el área de las subs anónimas, léxicas y clausuras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please see L&lt;perltie/SCALAR&gt; for the full details and
caveats.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por favor, vea L&lt;perltie/SCALAR&gt; para ver todos los detalles y advertencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?:\s(&quot;?)([^&quot;]+)\g2)?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223633Z" changeid="explorer">
        <seg>(?:\s(&quot;?)([^&quot;]+)\g2)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>seek(HANDLE, 0, 0);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>seek(HANDLE, 0, 0);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;virtual_port&gt; now works properly with the https protocol</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025141Z" changeid="explorer">
        <seg>C&lt;virtual_port&gt; ahora funciona correctamente con el protocolo https</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's the equivalent of &quot;!&quot; except for the very low precedence.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es el equivalente de &quot;!&quot; excepto por tener una precedencia muy baja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my($filename, $input) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my($archivo, $entrada) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some modules might have special reporting requirements, such as a
Sourceforge or Google Code tracking system, so you should check the
module documentation too.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231231Z" changeid="explorer">
        <seg>Es posible que algunos módulos tengan requisitos de notificación específicos, como usar un sistema de seguimiento de errores de Sourceforge o Google Code, por lo que es recomendable consultar también la documentación de los módulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./Configure</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ ./Configure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;File::Glob&gt; for details, including
C&lt;bsd_glob&gt; which does not treat whitespace as a pattern separator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;File::Glob&gt; para los detalles, incluyendo C&lt;bsd_glob&gt; que no trata al espacio en blanco como separador de patrones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 B:: modules inheritance changed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T041436Z" changeid="explorer">
        <seg>=head2 Cambiada la herencia en los módulos B::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else {
            print &quot;FAIL\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233920Z" changeid="explorer">
        <seg>} else {
            print &quot;FALLO\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;/ab/&gt; means match &quot;a&quot; AND (then) match &quot;b&quot;,
although the attempted matches are made at different positions because &quot;a&quot;
is not a zero-width assertion, but a one-width assertion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T172205Z" changeid="explorer">
        <seg>C&lt;/ab/&gt; significa coincidir con &quot;a&quot; Y (entonces) coincidir con &quot;b&quot;, aunque el intento de las coincidencias se realicen en diferentes posiciones, porque &quot;a&quot; no es una aserción de ancho cero, sino una aserción de ancho uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @ARRAY[0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @ARRAY[0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;umask&gt; value is such a number
representing disabled permissions bits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de C&lt;umask&gt; es un número que representa los bits de lso permisos que quedan desactivados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are the quote-like operators that apply to pattern
matching and related activities.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí están los operadores, parecidos a los de entrecomillado, que se aplican a las actividades relacionadas con la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rec = {
                witch =&gt; 'Mable the Merciless',
                cat   =&gt; 'Fluffy the Ferocious',
                date  =&gt; '10/31/1776',</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T042902Z" changeid="explorer">
        <seg>$rec = {
                bruja =&gt; 'Mable la Implacable',
                gato  =&gt; 'Fluffy el Feroz',
                fecha =&gt; '10/31/1776',</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%g    a floating-point number, in %e or %f notation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%g    un número en punto flotante, en notación %e o %f</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus zero-length matches
alternate with one-character-long matches.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T232754Z" changeid="explorer">
        <seg>Así, las coincidencias de longitud cero se alternan con una coincidencia de un carácter de longitud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef @ary;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef @ary;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12345</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>12345</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 2006, I&lt;TPJ&gt; merged with Dr.
Dobbs Journal (online edition).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230912Z" changeid="explorer">
        <seg>En 2006, I&lt;TPJ&gt; se fusionó con Dr. Dobbs Journal (edición en línea).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Portability of Perl on various recent compilers on Windows has been
improved (Borland C++, Visual C++ 7.0).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T034443Z" changeid="explorer">
        <seg>La portabilidad de Perl en distintos compiladores recientes de Windows ha sido mejorada (Borland C++, Visual C++ 7.0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,15, 1) = 1   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,15, 1) = 1   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make other distribution arrangements with the Copyright Holder.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hacer otros acuerdos de distribución con el Titular del Copyright.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To return all but the last
character, use C&lt;substr($string, 0, -1)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para devolver todos menos el último carácter, use C&lt;substr($string, 0, -1)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following equivalences apply:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232249Z" changeid="explorer">
        <seg>Se aplica la siguiente equivalencia:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(1,32,17);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225604Z" changeid="explorer">
        <seg>set_vec(1,32,17);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is only fancy fancy: if you use
the return value of C&lt;-f $file&gt; as an argument to another filetest
operator, no special magic will happen.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto solo es fascinantemente elegante: si usa el valor devuelto de C&lt;-f $archivo&gt; como un argumento para otro operador de test de archivo, no ocurrirá ninguna magia especial)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use recursive subroutines with sort(), thanks to Robin Houston.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200230Z" changeid="explorer">
        <seg>Ahora puede utilizar subrutinas recursivas con sort(), gracias a Robin Houston.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;basename&gt; now returns C&lt;/&gt; for parameter C&lt;/&gt;, to make C&lt;basename&gt;
consistent with the shell utility of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031413Z" changeid="explorer">
        <seg>C&lt;basename&gt; ahora devuelve C&lt;/&gt; para el parámetro C&lt;/&gt;, para hacer C&lt;basename&gt;
consistente con la utilidad shell del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If SCALAR
has no string value but does have a numeric value, that value will be
passed rather than a pointer to the string value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si ESCALAR no tiene un valor string sino que tiene un valor numérico, este valor será el que se pase, en lugar de un puntero al valor del string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(?|  (?&lt;a&gt; x ) (?&lt;b&gt; y )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T125325Z" changeid="explorer">
        <seg>/(?|  (?&lt;a&gt; x ) (?&lt;b&gt; y )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may not be
the same as the compilation-time locale, and can differ from one match
to another if there is an intervening call of the
L&lt;setlocale() function|perllocale/The setlocale function&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T165154Z" changeid="explorer">
        <seg>Ésta puede no ser la misma que la configuración regional en tiempo de compilación, y pueden diferir de una coincidencia a otra, si hay una llamada a la función L&lt;setlocale() perllocale/La función setlocale&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perliol		C API for Perl's implementation of IO in Layers</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000530Z" changeid="explorer">
        <seg>perliol		API en C para implementar en Perl las capas de E/S</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no, lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Cephes::Fraction fractions via the Cephes library</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T215323Z" changeid="explorer">
        <seg>Math::Cephes::Fraction	fracciones vía la biblioteca Cephes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># A &quot;reverse comma operator&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Un &quot;operador coma inverso&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What machines support perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225317Z" changeid="explorer">
        <seg>=head2 ¿Qué equipos son compatibles con perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Oh, you weren't talking ASCII?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110405T000703Z" changeid="explorer">
        <seg>¡Ah, no se refería a ASCII!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your module may be object oriented (OO) or not, or it may have both kinds 
of interfaces available.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015716Z" changeid="explorer">
        <seg>Su módulo puede estar orientado a objetos (POO) o no, o puede tener ambos tipos de interfaces disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;has nondigits&quot;	if     /\D/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no dígitos&quot;           if     /\D/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (?=...) (?!...) (?&lt;=...) (?&lt;!...)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050831Z" changeid="explorer">
        <seg>=item (?=...) (?!...) (?&lt;=...) (?&lt;!...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN: 978-0-596-00173-5 [1st edition July 2005]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003538Z" changeid="explorer">
        <seg>ISBN: 978-0-596-00173-5 [1ª edición - Julio de 2005]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hashref   ${$$foo[1]}[2] aka $foo-&gt;[1][2]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224149Z" changeid="explorer">
        <seg>anónimo     ${$$foo[1]}[2] equivale a $foo-&gt;[1][2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>qw{}	     Word list		  no</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>qw{}	   Lista palabras	  no</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improved behaviour on Symbian OS.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025841Z" changeid="explorer">
        <seg>Mejorado el comportamiento en el SO Symbian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If F&lt;sys/ioctl.ph&gt; doesn't
exist or doesn't have the correct definitions you'll have to roll your
own, based on your C header files such as F&lt;&lt; &lt;sys/ioctl.h&gt; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si F&lt;sys/ioctl.ph&gt; no existe o no tiene las definiciones correctas, tendrá que incorporar las suyas propias, basadas en sus archivos de cabecera C como las de F&lt;&lt; &lt;sys/ioctl.h&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, crypt() dies with
C&lt;Wide character in crypt&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no, crypt() muere con C&lt;Wide character in crypt&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Platform Specific Changes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005630Z" changeid="explorer">
        <seg>=head2 Cambios específicos de cada plataforma</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This poses a problem for content such as book
lists.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003746Z" changeid="explorer">
        <seg>Esto supone un problema para mantener una lista de libros actualizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $handle = IO::File-&gt;new;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $handle = IO::File-&gt;new;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments are forced into the integer format if not strings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234041Z" changeid="explorer">
        <seg>Fuerzan la conversión de los argumentos al formato de entero si no son cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also cannot exit out of the sort block or subroutine using any of the
loop control operators described in L&lt;perlsyn&gt; or with C&lt;goto&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También no puede salir fuera del bloque de ordenación o de la subrutina utilizando cualquiera de los operadores de control de bucle descritos en L&lt;perlsyn&gt; o con C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX qw(strtod);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225622Z" changeid="explorer">
        <seg>use POSIX qw(strtod);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider
offering a choice of levels for warning and debug messages, an option to
send messages to a separate file, a way to specify an error-handling
routine, or other such features.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023702Z" changeid="explorer">
        <seg>Considere la posibilidad de ofrecer una selección de niveles de alerta y mensajes de depuración, una opción para enviar mensajes a un archivo separado, una forma de especificar una rutina de control de errores, o de otras características.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $sentence = 'The quick brown fox jumped over the lazy dog';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012544Z" changeid="explorer">
        <seg>my $instruccion = 'El rápido zorro marrón saltó sobre el perezoso perro';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} while $kid &gt; 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} while $hijo &gt; 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@colors{'red','blue','green'} 
                   = (0xff0000, 0x0000ff, 0x00ff00);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043038Z" changeid="explorer">
        <seg>@colores{'rojo','azul','verde'} 
                   = (0xff0000, 0x0000ff, 0x00ff00);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As part of the C&lt;ExtUtils::MakeMaker&gt; upgrade, the
C&lt;ExtUtils::MakeMaker::bytes&gt; and C&lt;ExtUtils::MakeMaker::vmsish&gt; modules
have been removed from this distribution.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190703Z" changeid="explorer">
        <seg>Como parte de la actualización de C&lt;ExtUtils::MakeMaker&gt;, los módulos C&lt;ExtUtils::MakeMaker::bytes&gt; y C&lt;ExtUtils::MakeMaker::vmsish&gt; han sido eliminados de esta distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(LIST)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(LISTA)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($paragraph =~ /\p{Ll}['&quot;)]*[.!?]+['&quot;)]*\s/g) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025229Z" changeid="explorer">
        <seg>while ($parrafo =~ /\p{Ll}['&quot;)]*[.!?]+['&quot;)]*\s/g) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: This extended regular expression feature is considered
experimental, and may be changed without notice.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T215334Z" changeid="explorer">
        <seg>B&lt;AVISO&gt;: Esta característica de expresión regular extendida está considerada experimental, y puede ser modificada sin previo aviso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substr(&quot;0&quot; x 32 . &quot;11110101011011011111011101111&quot;, -32)));</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225516Z" changeid="explorer">
        <seg>substr(&quot;0&quot; x 32 . &quot;11110101011011011111011101111&quot;, -32)));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, include a C&lt;use v5.10&gt; or later to the current scope.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234223Z" changeid="explorer">
        <seg>O de otra forma, incluya un C&lt;use v5.10&gt; o posterior en el ámbito actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$vec = Bit::Vector-&gt;new_Bin(32, &quot;11011110101011011011111011101111&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225516Z" changeid="explorer">
        <seg>$vec = Bit::Vector-&gt;new_Bin(32, &quot;11011110101011011011111011101111&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use DB_File;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use DB_File;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes a directory opened by C&lt;opendir&gt; and returns the success of that
system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cierra un directorio abierto por C&lt;opendir&gt; y devuelve el éxito de la llamada del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's better to have numerous simple routines than a few monolithic ones.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020612Z" changeid="explorer">
        <seg>Es mejor tener muchas rutinas sencillas que unas pocas monolíticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#{$aref} ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052937Z" changeid="explorer">
        <seg>$#{$aref} ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is false as long as its left operand is false.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es falso, siempre y cuando su operando izquierdo sea falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BUGS/CAVEATS/etc</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024543Z" changeid="explorer">
        <seg>ERRORES/ADVERTENCIAS/etc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more detail on each item in this checklist, see below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215922Z" changeid="explorer">
        <seg>Para más detalles sobre cada elemento de esta lista, vea más adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 COMMON PITFALLS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031124Z" changeid="explorer">
        <seg>=head1 ERRORES COMUNES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\$(\w+)/${$1}/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/\$(\w+)/${$1}/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are running under C&lt;use strict&gt; (and if you aren't, why in
the world aren't you?), you'll have to add some declarations to
make it happy:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030351Z" changeid="explorer">
        <seg>Si está ejecutando bajo C&lt;use strict&gt; (y si no lo está haciendo, ¿por qué demonios no?), tendrá que agregar algunas declaraciones para hacerle feliz:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//	 m{}	   Pattern match	  yes*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>//	 m{}	    Coincidencia	  sí*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most C&lt;C&gt; source files now have comments at the top explaining their purpose,
which should help anyone wishing to get an overview of the implementation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212758Z" changeid="explorer">
        <seg>La mayoría de los archivos de código fuente C&lt;C&gt; ya tienen comentarios en la parte superior explicando su propósito, que debe ayudar a cualquier persona que desee obtener una visión general de la aplicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They take
only one byte per character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234442Z" changeid="explorer">
        <seg>Ocupan un solo byte por carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syscall returns whatever value returned by the system call it calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Syscall devuelve cualquier valor devuelto por la llamada al sistema que llama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The associated
handler is called with the error text and can change the error
message, if it sees fit, by calling C&lt;die&gt; again.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020252Z" changeid="explorer">
        <seg>El identificador de archivo asociado es llamado con el texto del error y puede cambiar el mensaje de error, si le parece, llamando de nuevo a C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can preallocate space for a hash by assigning to the keys() function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede pre-reservar espacio para un hash asignando a la función keys().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = (foo =&gt; 11, bar =&gt; 22, baz =&gt; 33);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = (foo =&gt; 11, bar =&gt; 22, baz =&gt; 33);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it returns
inconsistent results (sometimes saying C&lt;$x[1]&gt; is less than C&lt;$x[2]&gt; and
sometimes saying the opposite, for example) the results are not
well-defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si devuelve resultados inconsistentes (algunas veces diciendo que C&lt;$x[1]&gt; es menor que C&lt;$x[2]&gt; y otras veces diciendo lo opuesto, por ejemplo) los resultados no están definidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FUNCTION is a reference to, or the name of,
the function whose prototype you want to retrieve.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FUNCIÓN es una referencia a, o el nombre de, la función cuyo prototipo se desea recuperar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example, assuming array lengths are passed before arrays:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplo, suponiendo que las longitudes de array se pasan antes que los propios arrays:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This caused the false idiom such as:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T174825Z" changeid="explorer">
        <seg>Esto permitía hacer el falso modismo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlpacktut&gt; for an introduction to this function.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215534Z" changeid="explorer">
        <seg>Vea L&lt;perlpacktut&gt; para una introducción a esta función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shifting by a negative number
of bits is also undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desplazando por un número negativo de bits también está indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tell() on pipes, fifos, and sockets usually returns -1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tell() en tuberías, colas, y sockets, por lo general, devuelve -1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;child exited with value %d\n&quot;, $?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;hijo terminó con valor %d\n&quot;, $?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Documentation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T201201Z" changeid="explorer">
        <seg>=head1 Documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 DESCRIPTION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 DESCRIPCIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001312Z" changeid="explorer">
        <seg>Es decir,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
operator is not as well defined for negative operands, but it will
execute faster.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este operador no está tan bien definido para operandos negativos, pero se ejecutará más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-00313-5 [2nd Edition August 2003]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003028Z" changeid="explorer">
        <seg>ISBN 978-0-596-00313-5 [2ª edición - Agosto de 2003]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly for the C&lt;:encoding&gt;
pragma: in that case pretty much any characters can be sent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, para el pragma C&lt;:encoding&gt;: en este caso casi todos los caracteres se pueden enviar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@old) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@viejo) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to this
limitation,  the exponent of the binary number is also restricted when it
is represented as a floating point number.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232518Z" changeid="explorer">
        <seg>Además de esta limitación, el exponente del número binario también está restringido cuando se representa como un número de punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Maybe you should, too.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T195925Z" changeid="explorer">
        <seg>Es posible que a usted también le resulte útil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef   Array     array contains undef     grep !defined, @$b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef       Array      array contiene undef             grep !defined, @$b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the working directory to EXPR, if possible.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia el directorio de trabajo a EXPR, si es posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Ram is a cookbook with hundreds of examples of using Perl to
accomplish specific tasks:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003019Z" changeid="explorer">
        <seg>El &quot;Libro del Carnero&quot; es un recetario que incluye cientos de ejemplos del uso de Perl para realizar tareas específicas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># sort lexically</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ordenación léxica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore perl 5.8.1 introduces a &quot;backdoor&quot; to restore the pre-5.8.0
(pre-5.7.3, really) signal behaviour.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T010041Z" changeid="explorer">
        <seg>Por lo tanto, perl 5.8.1 introduce una &quot;puerta trasera&quot; para restaurar el comportamiento pre-5.8.0 (pre-5.7.3, en realidad) de las señales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These modifiers are restored at the end of the enclosing group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234807Z" changeid="explorer">
        <seg>Estos modificadores son reiniciados al final del grupo que lo alberga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 AUTHORS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T155536Z" changeid="zipf">
        <seg>=head1 AUTORES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># using a prototype allows you to use any comparison subroutine</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># usando un prototipo permite usar cualquier subrutina de comparación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the
character in the 100th position (indexed by 0) in Unicode is
C&lt;LATIN CAPITAL LETTER A WITH MACRON&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T220808Z" changeid="explorer">
        <seg>El nombre del carácter en la posición 100 (basado en 0) en Unicode es C&lt;LATIN CAPITAL LETTER A WITH MACRON&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;xsubpp&gt; will compile XS code into C code by embedding the constructs
necessary to let C functions manipulate Perl values and creates the glue
necessary to let Perl access those functions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234633Z" changeid="explorer">
        <seg>F&lt;xsubpp&gt; compila el código XS y genera código C; para ello, incrusta las construcciones necesarias para que las funciones C puedan manipular valores Perl y agregar el código necesario para que Perl pueda acceder a esas funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Acknowledgments</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T152831Z" changeid="explorer">
        <seg>=head2 Reconocimientos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.beos - Perl version 5.8+ on BeOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.beos - Perl versión 5.8+ en BeOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its bytes represent an unsigned integer in base 128,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sus bytes representan un entero sin signo en base 128,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\C             Match a single C-language char (octet) even if that is
                   part of a larger UTF-8 character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T044521Z" changeid="explorer">
        <seg>\C             Coincide con un char (octeto, en lenguaje C) incluso si es
                   parte de un carácter UTF-8 más grande.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(VMS, S&lt;Plan 9&gt;, VOS)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015039Z" changeid="explorer">
        <seg>(VMS, S&lt;Plan 9&gt;, VOS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Linux (x86, ARM, IA64)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110220T234355Z" changeid="explorer">
        <seg>=item Linux (x86, ARM, IA64)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If CMD is C&lt;IPC_STAT&gt;,
then ARG must be a variable that will hold the returned C&lt;msqid_ds&gt;
structure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si CMD es C&lt;IPC_STAT&gt;, entonces ARG debe ser una variable que contendrá la estructura C&lt;msqid_ds&gt; devuelta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This escape mechanism is also required
for the character used as the pattern delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212419Z" changeid="explorer">
        <seg>Este mecanismo de escape también es necesario para el carácter utilizado como delimitador de patrones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Package
modified in such a way shall still be considered the Standard Version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un paquete modificado de esa manera todavía puede ser considerado Versión Estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of the machine architecture on which it runs, the 
example above should print the following table:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Independientemente de la arquitectura de la máquina en la que se ejecuta, el ejemplo anterior debe imprimir el cuadro siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = $sky =~ tr/*/*/;	# count the stars in $sky</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = $sky =~ tr/*/*/;	# cuenta los asteriscos en $sky</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require &quot;Foo::Bar&quot;;   # not a bareword because of the &quot;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require &quot;Foo::Bar&quot;;   # no una palabra suelta por las &quot;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will lead you to other important man pages, including how to set your
C&lt;$MANPATH&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230241Z" changeid="explorer">
        <seg>Esto le llevará a otras páginas de manual importantes, como la que explica cómo configurar C&lt;$MANPATH&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;DB&gt; upgraded to version 1.01</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025950Z" changeid="explorer">
        <seg>C&lt;DB&gt; actualizado a la versión 1.01</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the values are not copied, which means modifying them will
modify the contents of the hash:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que los valores no son copiados, lo que significa que modificarles modificará el contenido del hash:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>modularity and reusability using innumerable modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001142Z" changeid="explorer">
        <seg>modularidad y capacidad de reutilización gracias a numerosos módulos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;elt $i $j is $AoA[$i][$j]&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110704T234430Z" changeid="explorer">
        <seg>say &quot;elt $i $j is $AoA[$i][$j]&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See I&lt;What is CPAN?&gt; in L&lt;perlfaq2&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231427Z" changeid="explorer">
        <seg>Vea I&lt;¿Qué es CPAN?&gt; en L&lt;perlfaq2&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On POSIX systems, you can detect this condition this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas POSIX, puede detectar esta condición de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't cd to spool: $!\n&quot; unless chdir '/usr/spool/news';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo cd a spool: $!\n&quot; unless chdir '/usr/spool/news';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=for comment
Consistent formatting of this file is achieved with:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T013208Z" changeid="explorer">
        <seg>=for comment
Para aplicar un formato uniforme a este archivo, use:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$home =  $ENV{HOME}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224301Z" changeid="explorer">
        <seg>$home =  $ENV{HOME}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;PerlIO&gt; upgraded to version 1.04</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034017Z" changeid="explorer">
        <seg>C&lt;PerlIO&gt; actualizado a la versión 1.04</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For floating-point conversions (C&lt;e f g E F G&gt;), numbers are usually assumed
to be the default floating-point size on your platform (double or long double),
but you can force &quot;long double&quot; with C&lt;q&gt;, C&lt;L&gt;, or C&lt;ll&gt; if your
platform supports them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las conversiones de punto flotante (C&lt;e f g E F G&gt;), se asume que los números son por lo general de punto flotante del tamaño de su plataforma (doble o doble largo), pero se puede forzar &quot;long double&quot; con C&lt;q&gt;, C&lt;L&gt;, o C&lt;ll&gt; si la plataforma es compatible con ellas.&lt;/q&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@hash{qw[key1 key2]}) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach (@hash{qw[key1 key2]}) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The
string specified with C&lt;=~&gt; need not be an lvalue--it may be the
result of an expression evaluation, but remember the C&lt;=~&gt; binds
rather tightly.)  See also L&lt;perlre&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220135Z" changeid="explorer">
        <seg>(La cadena especificada con C&lt;=~&gt; no tiene por qué ser un I&lt;ivalor&gt;; puede ser el resultado de una evaluación de una expresión, pero recuerde que C&lt;=~&gt; enlaza más firmemente). Vea también L&lt;perlre&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;@big_array&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225457Z" changeid="explorer">
        <seg>print &quot;@big_array&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to create a new module</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031940Z" changeid="explorer">
        <seg>Cómo crear un nuevo módulo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $SIG{ALRM} = sub { die &quot;alarm\n&quot; }; # NB: \n required</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local $SIG{ALRM} = sub { die &quot;alarma\n&quot; }; # NB: \n necesario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 MAD</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112036Z" changeid="explorer">
        <seg>=head2 MAD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.8 and later will
emulate socketpair using IP sockets to localhost if your system implements
sockets but not socketpair.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl 5.8 y siguientes emularán socketpair usando sockets IP a localhost si el sistema implementa sockets pero no socketpair.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlamiga		Perl notes for AmigaOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlamiga		Notas para AmigaOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This one is actually a change introduced in 5.10.0, but it was missed
from that release's perldelta, so it is mentioned here instead.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190821Z" changeid="explorer">
        <seg>Este es en realidad un cambio introducido en 5.10.0, pero se perdió en la publicación de perldelta, por lo que se menciona aquí y ahora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means C&lt;&lt; &lt;$x&gt; &gt;&gt; is always a readline() from
an indirect handle, but C&lt;&lt; &lt;$hash{key}&gt; &gt;&gt; is always a glob().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T021218Z" changeid="explorer">
        <seg>Esto significa que C&lt;&lt; &lt;$x&gt; &gt;&gt; siempre es un readline() de un identificador de archivo indirecto, pero C&lt;&lt; &lt;$hash{clave}&gt; &gt;&gt; siempre es un glob().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhurd		Perl notes for Hurd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlhurd		Notas para Hurd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's documented in extravagant detail in L&lt;perlfunc&gt; and L&lt;perlopentut&gt;,
but in short:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225305Z" changeid="explorer">
        <seg>Esta función se describe de forma muy detallada en L&lt;perlfunc&gt; y L&lt;perlopentut&gt;. A continuación se muestra un resumen de cómo se usa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sub NAME (PROTO) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sub NOMBRE (PROTO) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you get in the habit of using C&lt;&quot;\n&quot;&gt; for networking,
you may be burned some day.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se metes en el hábito de usar C&lt;&quot;\n&quot;&gt; en la gestión de redes, es posible que un día se queme.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/wantarray&gt;
for how you would dynamically discern your function's calling
context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlfunc/wantarray&gt; para saber cómo se averiguaría dinámicamente el contexto en el cual se llamó a una función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CONTEXTS  SIGILS             ARRAYS        HASHES</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224112Z" changeid="explorer">
        <seg>CONTEXTOS  SIGILOS             ARRAYS        HASHES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only hexadecimal digits are valid between the braces.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T202451Z" changeid="explorer">
        <seg>Solo están permitidos los dígitos hexadecimales entre las llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;while&gt; statement executes the block as long as the expression is
L&lt;true|/&quot;Truth and Falsehood&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013344Z" changeid="explorer">
        <seg>La instrucción C&lt;while&gt; ejecuta el bloque mientras la expresión sea L&lt;verdadera|/&quot;Verdad y Falsedad&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typeglobs are also a way to create a local filehandle using the local()
operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003649Z" changeid="explorer">
        <seg>Typeglobs son también una manera de crear un identificador de archivo local usando el operador local().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (minimum) width</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item ancho (mínimo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$straddr = inet_ntoa($iaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$direccion = inet_ntoa($idireccion);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>^ =encoding \h+ \K latin1 ?x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030402Z" changeid="explorer">
        <seg>^ =encoding \h+ \K latin1 ?x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using as compiler GCC-2.95.x rev(DG/UX)
an easy solution for configuring perl in your DG/UX
machine is to run the command:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está utilizando como compilador el GCC-2.95.x revisión DG/UX, una solución fácil para la configuración de perl en su máquina DG/UX es ejecutar el comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and UTF-8 (or UTF-EBCDIC in EBCDIC platforms) in byte mode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y UTF-8 (o UTF-EBCDIC en plataformas EBCDIC) en modo byte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># these examples are subject to system-specific variation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># estos ejemplos están sujetos a variaciones específicas del sistema</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the result of</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto, el resultado de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripted variables such as C&lt;$a[3]&gt; or
C&lt;&lt; $href-&gt;{key}[0] &gt;&gt; are also interpolated, as are array and hash slices.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Variables con subrangos, como C&lt;$a[3]&gt; o C&lt;&lt; $href-&gt;{clave}[0] &gt;&gt; son también interpoladas, así como trozos de array y hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getsockopt SOCKET,LEVEL,OPTNAME
X&lt;getsockopt&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173801Z" changeid="explorer">
        <seg>=item getsockopt SOCKET,NIVEL,OPCIÓN
X&lt;getsockopt&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get started, run this command:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222145Z" changeid="explorer">
        <seg>Para comenzar, ejecute este comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} continue {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} continue {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a module or pragma only needs to be loaded 
conditionally, this can be done using the L&lt;if&gt; pragma:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si un módulo o pragma sólo necesita ser cargado en forma condicional, esto se puede hacer uso del pragma L&lt;if&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ary = (1, 3, sort 4, 2);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ary = (1, 3, sort 4, 2);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the
most interesting features have shown up in the latest versions of Perl
5, and some Perl 5 modules allow you to use some Perl 6 syntax in your
programs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004338Z" changeid="explorer">
        <seg>Algunas de las características más interesantes de Perl 6 se han incluido en las versiones más recientes de Perl 5, y algunos módulos de Perl 5 le permiten usar la sintaxis de Perl 6 en sus programas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If CMD is C&lt;IPC_STAT&gt;,
then ARG must be a variable that will hold the returned C&lt;shmid_ds&gt;
structure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si CMD es C&lt;IPC_STAT&gt;, entonces ARG debe ser una variable que contendrá la estructura C&lt;shmid_ds&gt; devuelta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LENGTH is negative, leaves that
many characters off the end of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LONGITUD es negativa, deja fuera a tantos caracteres del final de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Packing with a I&lt;length-item&gt; of C&lt;a&gt; or C&lt;Z&gt; may
introduce C&lt;&quot;\000&quot;&gt; characters, which Perl does not regard as legal in
numeric strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Empaquetando con un I&lt;longitud-item&gt; de C&lt;a&gt; o C&lt;Z&gt; puede introducir caracteres C&lt;&quot;\000&quot;&gt;, que Perl no considerará como legal en cadenas numéricas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Loop Control
X&lt;loop control&gt; X&lt;loop, control&gt; X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt; X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T041503Z" changeid="explorer">
        <seg>=head2 Control de bucles
X&lt;loop control&gt; X&lt;loop, control&gt; X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt; X&lt;continue&gt; X&lt;control de bucles&gt; X&lt;bucle, control&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to substitute
for a simple identifier, an expression that produces a reference
to the value at runtime.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También, es posible sustituir un simple identificador por una expresión que produzca una referencia al valor en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are usually written as &quot;the C&lt;/x&gt; modifier&quot;, even though the delimiter
in question might not really be a slash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos, se describen normalmente como &quot;el modificador C&lt;/x&gt;&quot;, incluso aunque el delimitador en cuestión podría no ser en realidad una barra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also means that modifying
a variable twice in the same statement will lead to undefined behavior.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T104419Z" changeid="explorer">
        <seg>Esto también significa que la modificación de una variable dos veces en la misma instrucción dará lugar a un comportamiento indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exit EXPR
X&lt;exit&gt; X&lt;terminate&gt; X&lt;abort&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T172829Z" changeid="explorer">
        <seg>=item exit EXPR
X&lt;exit&gt; X&lt;terminate&gt; X&lt;abort&gt; X&lt;abortar&gt; X&lt;terminar&gt; X&lt;salir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sys/libcall error</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224343Z" changeid="explorer">
        <seg>error de sys/libcall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-S  File is a socket.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004722Z" changeid="explorer">
        <seg>-S  Archivo es un socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For cleaner embedding you can also
force this for all APIs by defining at compile time the cpp define
PERL_NO_SHORT_NAMES.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001230Z" changeid="explorer">
        <seg>Para una incorporación más limpia también puede forzar esto para todas las API definiendo, en tiempo de compilación, el B&lt;define&gt; PERL_NO_SHORT_NAMES para cpp.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl operators have the following associativity and precedence,
listed from highest precedence to lowest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los operadores Perl tienen la asociatividad y precedencia siguientes, enumerados de mayor a menor prioridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions new in perl5
X&lt;perl5&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165256Z" changeid="explorer">
        <seg>=item Funciones nuevas en perl5
X&lt;perl5&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$HOST = $host  =~ tr/a-z/A-Z/r;   # same thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035303Z" changeid="explorer">
        <seg>$HOST = $host  =~ tr/a-z/A-Z/r;	# lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrecharclass/POSIX Character Classes&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T213037Z" changeid="explorer">
        <seg>Vea L&lt;perlrecharclass/POSIX Character Classes&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require 5.006_001;  # ditto; preferred for backwards compatibility</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require 5.006_001;  # idem; preferido para mantener la compatibilidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Acknowledgements</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T231043Z" changeid="explorer">
        <seg>=head1 Agradecimientos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The core distribution can now run its regression tests in parallel on
Unix-like platforms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T001407Z" changeid="explorer">
        <seg>La distribución principal ahora puede ejecutar sus pruebas de regresión en paralelo en las plataformas de tipo Unix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and for writing:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y para escritura:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\E          end either case modification or quoted section, think vi</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043957Z" changeid="explorer">
        <seg>\E		fin de modificación de tamaño de caja o sección entrecomillada, como en vi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bar = 20;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bar = 20;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each call disables the
previous timer, and an argument of C&lt;0&gt; may be supplied to cancel the
previous timer without starting a new one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada llamada desactiva el temporizador anterior, y se puede indicar un argumento C&lt;0&gt; para cancelar el temporizador anterior sin empezar uno nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The I&lt;Perl-Zeitung&gt; is a German-speaking magazine for Perl beginners
(see http://perl-zeitung.at.tf ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230748Z" changeid="explorer">
        <seg>I&lt;Perl-Zeitung&gt; es otra revista en alemán para programadores Perl principiantes (visite http://perl-zeitung.at.tf ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POSIX 1003.1 compliant library</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001440Z" changeid="explorer">
        <seg>biblioteca compatible con POSIX 1003.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that function names are considered more readable
with parentheses after their name, that is C&lt;function()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note como los nombres de función se vuelven más legibles con los paréntesis detrás de su nombre, como esta C&lt;funcion()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;foreach&gt; probably won't do what you expect if VAR is a tied or other
special variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;foreach&gt; probablemente no hará lo esperado si VAR está enlazada a otra variable especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interpolation combines with the facts that the opening
and closing parentheses are optional (except when necessary for
precedence) and lists may end with an optional comma to mean that
multiple commas within lists are legal syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta interpolación se combina con el hecho de que la apertura y cierre de paréntesis son opcionales (excepto cuando sea necesario para la precedencia) y las listas pueden terminar con una coma opcional, significando que comas múltiples dentro de las listas es sintaxis legal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Customary  Generic        Meaning	     Interpolates</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>  Normal   Genérico     Significado	     Interpola</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item semget KEY,NSEMS,FLAGS
X&lt;semget&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200438Z" changeid="explorer">
        <seg>=item semget KEY,NSEMS,FLAGS
X&lt;semget&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.ActiveState.com/Products/Komodo/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>http://www.ActiveState.com/Products/Komodo/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-bracketing delimiters use the same character fore and aft, but the four
sorts of ASCII brackets (round, angle, square, curly) all nest, which means
that</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230958Z" changeid="explorer">
        <seg>Delimitadores no emparejados usan el mismo carácter delante y detrás, pero los otros cuatro delimitadores (paréntesis, corchetes, ángulos y llaves) pueden ser anidados, lo que significa que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may seem a bit weird,
but that's okay, because it is weird.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ésto puede parecer un poco raro, pero eso está bien, porque es raro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It derives from the
ubiquitous C programming language and to a lesser extent from sed,
awk, the Unix shell, and at least a dozen other tools and languages.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T195855Z" changeid="explorer">
        <seg>Se deriva del extendido lenguaje de programación C y, en menor medida, de sed, awk, la shell de Unix, y al menos una docena más de lenguajes y herramientas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># inspired by :1,$g/fred/s//WILMA/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># inspirado por :1,$g/fred/s//WILMA/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
the LABEL is omitted, the command refers to the innermost enclosing
loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la ETIQUETA se omite, el comando se refiere al bucle más interior en que se encuentre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;XSLoader&gt; for faster loading</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032950Z" changeid="explorer">
        <seg>Usa C&lt;XSLoader&gt; para acelerar la carga</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@sauces = &lt;&lt;End_Lines =~ m/(\S.*\S)/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@salsas = &lt;&lt;Fin_lineas =~ m/(\S.*\S)/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, C&lt;print()&gt; can also take an optional first argument specifying
which filehandle to print to:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225354Z" changeid="explorer">
        <seg>Sin embargo, C&lt;print()&gt; también puede consumir un primer argumento opcional que especifique el identificador de archivo en el que se debe imprimir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VSTRING</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VSTRING</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?&lt;!pattern)&gt;
X&lt;(?&lt;!)&gt; X&lt;look-behind, negative&gt; X&lt;lookbehind, negative&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212643Z" changeid="explorer">
        <seg>=item C&lt;(?&lt;!patrón)&gt;
X&lt;(?&lt;!)&gt; X&lt;antecedente, negativo&gt; X&lt;antecedente, negativo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But there are saner ways
of accomplishing this than using C&lt;/o&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T204718Z" changeid="explorer">
        <seg>(Pero hay formas más sanas de lograr esto que usando C&lt;/o&gt;.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = 0644;   chmod $mode, &quot;foo&quot;;      # this is best</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = 0644;   chmod $modo, &quot;foo&quot;;      # este es el mejor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to know which files you could not remove, try them one
at a time:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere saber qué archivos no pudo eliminar, trátelos de uno en uno:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one-third of the time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>un tercio de las ocasiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item int EXPR
X&lt;int&gt; X&lt;integer&gt; X&lt;truncate&gt; X&lt;trunc&gt; X&lt;floor&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174013Z" changeid="explorer">
        <seg>=item int EXPR
X&lt;int&gt; X&lt;integer&gt; X&lt;truncate&gt; X&lt;trunc&gt; X&lt;floor&gt; X&lt;truncar&gt; X&lt;trunca&gt; X&lt;entero&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example counts all the possible matching strings in a
pattern (without actually matching any of them).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T011857Z" changeid="explorer">
        <seg>El siguiente ejemplo cuenta todas las posibles cadenas coincidentes con un patrón (sin que se produzca una coincidencia con ninguna de ellas, por efecto del C&lt;(*FAIL)&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following pattern matches a function foo() which may contain
balanced parentheses as the argument.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185246Z" changeid="explorer">
        <seg>El siguiente patrón coincide con una función foo() que puede contener paréntesis balanceados como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># list context</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># contexto lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;delete local&gt; now allows you to locally delete a hash entry.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T151836Z" changeid="explorer">
        <seg>C&lt;delete local&gt; ahora le permite borrar localmente una entrada de un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special case for C&lt;split&gt;, the empty pattern C&lt;//&gt; specifically
matches the empty string; this is not be confused with the normal use
of an empty pattern to mean the last successful match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como un caso especial para C&lt;split&gt;, el patrón vacío C&lt;//&gt; específicamente coincide con la cadena vacía; esto no ha de ser confundido con el uso normal de un patrón vacío que significa la última coincidencia exitosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may be 0, 1, or several different ways that the
definition might succeed against a particular string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110905T013028Z" changeid="explorer">
        <seg>Puede ser 0, 1, u otras formas diferentes en que la definición podría tener éxito contra una cierta cadena de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item symlink OLDFILE,NEWFILE
X&lt;symlink&gt; X&lt;link&gt; X&lt;symbolic link&gt; X&lt;link, symbolic&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204039Z" changeid="explorer">
        <seg>=item symlink VIEJO,NUEVO
X&lt;symlink&gt; X&lt;link&gt; X&lt;symbolic link&gt; X&lt;link, symbolic&gt; X&lt;enlace simbólico&gt; X&lt;enlace&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A list value may also be subscripted like a normal array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una lista de valores también pueden ser indexadas como un array normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>introduce the perlivp utility for verifying the Perl installation
(IVP = Installation Verification Procedure)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>introducir la utilidad perlivp para comprobar la instalación de Perl (PIV = Procedimiento de Verificación de la instalación)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @list= 0..9;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>my @list= 0..9;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, C&lt;$::sail&gt; is equivalent to
C&lt;$main::sail&gt; (as well as to C&lt;$main'sail&gt;, still seen in ancient
code, mostly from Perl 4).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, C&lt;$::sail&gt; es equivalente a C&lt;$main::sail&gt; (y también a C&lt;$main'sail&gt;, algo que se puede ver en código muy antiguo, escrito en su mayoría en Perl 4).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;podchecker|podchecker&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233502Z" changeid="explorer">
        <seg>=item L&lt;podchecker|podchecker&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not modify the values
of this hash, as they are the actual values stored in the optree.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No modifique los valores de este hash, ya que son los valores reales almacenados en el árbol de operaciones internas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may apply bug fixes, portability fixes and other modifications
derived from the Public Domain or from the Copyright Holder.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede solicitar correcciones de errores, de portabilidad y otras modificaciones derivadas del Dominio Público o del Titular del Copyright.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>i	Do case-insensitive pattern matching.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>i	Hace coincidencia de patrones independiente del tamaño de caja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ( ($home, $user) = (getpwent)[7,0]) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ( ($home, $user) = (getpwent)[7,0]) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When naming your module, consider the following:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015250Z" changeid="explorer">
        <seg>Al escribir el nombre del módulo, considere lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a successful match, the C&lt;$REGERROR&gt; variable will be set to FALSE, and
the C&lt;$REGMARK&gt; variable will be set to the name of the last
C&lt;(*MARK:NAME)&gt; pattern executed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T012839Z" changeid="explorer">
        <seg>En una coincidencia exitosa, la variable C&lt;$REGERROR&gt; se establecerá a FALSE, y la variable C&lt;$REGMARK&gt; se establecerá al nombre del último patrón C&lt;(*MARK:NOMBRE)&gt; ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously, it
needed to be specified explicitly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Anteriormente, era necesario que se especificara de forma explícita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It calls any
defined C&lt;END&gt; routines first, but these C&lt;END&gt; routines may not
themselves abort the exit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exit() llama primero a cualquier rutina definida C&lt;END&gt;, pero estas rutinas C&lt;END&gt; pueden abortar la salida por sí mismas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIST is omitted, prints
C&lt;$_&gt; to the currently selected output handle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T005147Z" changeid="explorer">
        <seg>Si la LISTA se omite, se imprime C&lt;$_&gt; al actual canal de salida seleccionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might have expected test 3 to fail because it seems to a more
general purpose version of test 1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170455Z" changeid="explorer">
        <seg>Estará esperando a que el test 3 fallara, ya que parece una versión más general del test 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>most significant digit first, with as few digits as possible.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>primero el dígito más significativo, con el menor número posible de dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a, $b, undef, $c) = &amp;foo;       # Ignore third value returned</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a, $b, undef, $c) = &amp;foo;       # Ignora tercer valor devuelto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most
common Perl platforms (Unix and Unix-like, Microsoft platforms, and
VMS) have large enough testing and expert population that they are
doing well.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T002413Z" changeid="explorer">
        <seg>Las plataformas más comunes de Perl (Unix y familia, las plataformas Microsoft y VMS) tiene pruebas lo suficientemente grandes y una población de expertos que lo están haciendo bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
is the internal function implementing the C&lt;\l&gt; escape in
double-quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la función interna que implementa el escapado C&lt;\l&gt; en las cadenas entre comillas dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given($_) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>given($_) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(*COMMIT)&gt;
X&lt;(*COMMIT)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050631Z" changeid="explorer">
        <seg>=item C&lt;(*COMMIT)&gt;
X&lt;(*COMMIT)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lexical scoping</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ámbito léxico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and look for AUTOCONF or MPEAUTOCONF near the bottom</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y mire por AUTOCONF o MPEAUTOCONF cerca del final</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Relational Operators
X&lt;relational operator&gt; X&lt;operator, relational&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235014Z" changeid="explorer">
        <seg>=head2 Operadores relacionales
X&lt;relational operator&gt; X&lt;operator, relational&gt; X&lt;operador relacional&gt; X&lt;operador, relacional&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	++ --</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	++ --</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030713Z" changeid="explorer">
        <seg>En otras palabras:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;ptar&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234917Z" changeid="explorer">
        <seg>=item L&lt;ptar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wikiquote has the witticisms from Larry along with their source,
including his usenet postings and source code comments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232126Z" changeid="explorer">
        <seg>En Wikiquote están registradas las citas ingeniosas de Larry, junto con su fuente.
Se incluyen mensajes de usenet y comentarios de códigos fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no EXPR
is given, returns an empty list in list context, the undefined value in
scalar context, and (of course) nothing at all in void context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se indica EXPR, devuelve una lista vacía en contexto de lista, el valor indefinido en el contexto escalar, y (por supuesto) nada en absoluto en el contexto vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly,
C&lt;chomp $a, $b&gt; is interpreted as C&lt;chomp($a), $b&gt; rather than
as C&lt;chomp($a, $b)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Similarmente, C&lt;chomp $a, $b&gt; es interpretado como C&lt;chomp($a), $b&gt; en vez de un C&lt;chomp($a, $b)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;|cat -n | expand -4 | lpr&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T234229Z" changeid="explorer">
        <seg>open(FOO, &quot;|cat -n | expand -4 | lpr&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, Perl permits the following widely-supported conversions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, Perl permite las siguientes conversiones ampliamente soportadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only change I've made, that affects BONE systems is the
recognition of whether it is a BONE system or not in C&lt;hints/beos.sh&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110803T113834Z" changeid="explorer">
        <seg>El único cambio que he hecho, que afecta a los sistemas BONE es el reconocimiento de si se trata de un sistema BONE o no, en C&lt;hints/beos.sh&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -CS -ne 'printf &quot;%v04X\n&quot;, $_ for unpack(&quot;C0A*&quot;, $_)'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003543Z" changeid="explorer">
        <seg>perl -CS -ne 'printf &quot;%v04X\n&quot;, $_ for unpack(&quot;C0A*&quot;, $_)'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>roll-your-own magic variables (including multiple simultaneous DBM
implementations)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001158Z" changeid="explorer">
        <seg>permite al usuario crear sus propias &quot;variables mágicas&quot; (incluidas varias implementaciones simultáneas de DBM)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just because you I&lt;CAN&gt; do something a particular way doesn't mean that
you I&lt;SHOULD&gt; do it that way.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo porque usted I&lt;PUEDA&gt; hacer algo de una determinada manera no significa que usted I&lt;DEBA&gt; hacerlo de esa manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So,
C&lt;&quot;\Q\t\E&quot;&gt; is converted to C&lt;quotemeta(&quot;\t&quot;)&gt;, which is the same
as C&lt;&quot;\\\t&quot;&gt; (since TAB is not alphanumeric).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, C&lt;&quot;\Q\t\E&quot;&gt; es convertido a C&lt;quotemeta(&quot;\t&quot;)&gt;, que es lo mismo que C&lt;&quot;\\\t&quot;&gt; (porque TAB no es alfanumérico).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that anything inside
a C&lt;\Q...\E&gt; stays unaffected by C&lt;/x&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También tenga en cuenta que cualquier cosa dentro de un C&lt;\Q...\E&gt; queda afectado por el C&lt;/x&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%vd&quot;, &quot;AB\x{100}&quot;;           # prints &quot;65.66.256&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%vd&quot;, &quot;AB\x{100}&quot;;           # imprime &quot;65.66.256&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldgux		Perl notes for DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldgux		Notas para DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your
primary audience is a reasonably experienced developer with at least 
a moderate understanding of your module's application domain, who's just 
downloaded your module and wants to start using it as quickly as possible.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031646Z" changeid="explorer">
        <seg>Su público principal es un desarrollador bastante experimentado con al menos un conocimiento moderado del dominio de aplicación de su módulo, que acaba de descargar su módulo y quiere empezar a utilizarlo tan pronto como sea posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State variables are similar
to C&lt;my&gt; variables, but are declared with the C&lt;state&gt; keyword in place of
C&lt;my&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T000318Z" changeid="explorer">
        <seg>Las variables C&lt;state&gt; son similares a las variables C&lt;my&gt;, pero son declaradas con la palabra clave C&lt;state&gt; en lugar de C&lt;my&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;http://vm.marist.edu/~neale/vmoe.html&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101628Z" changeid="explorer">
        <seg>L&lt;http://vm.marist.edu/~neale/vmoe.html&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These special patterns are generally of the form C&lt;(*VERB:ARG)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T013012Z" changeid="explorer">
        <seg>Estos patrones especiales son, generalmente, de la forma C&lt;(*VERBO:ARG)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlobj&gt;, L&lt;perlboot&gt;, L&lt;perltoot&gt;, L&lt;perltooc&gt;,
and L&lt;perlbot&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001335Z" changeid="explorer">
        <seg>Se describe en L&lt;perlobj&gt;, L&lt;perlboot&gt;, L&lt;perltoot&gt;, L&lt;perltooc&gt; y L&lt;perlbot&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	| ^</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	| ^</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>matches a chunk of non-parentheses, possibly included in parentheses
themselves.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T202558Z" changeid="explorer">
        <seg>coincide con un trozo de no-paréntesis, posiblemente ellos mismos incluidos entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub&gt; for other scoping issues.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub&gt; para otras cuestiones sobre el ámbito o contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by David N. Blank-Edelman</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003454Z" changeid="explorer">
        <seg>David N. Blank-Edelman</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add Devel::PPPort</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadido Devel::PPPort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;/g&gt; modifier specifies global pattern matching--that is,
matching as many times as possible within the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El modificador C&lt;/g&gt; especifica concordancia global del patrón - es decir, coincidencia tantas veces como sea posible dentro de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please see its README file
in L&lt;http://perl5.git.perl.org/metaconfig.git/&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014917Z" changeid="explorer">
        <seg>Consulte el archivo README (en L&lt;http://perl5.git.perl.org/metaconfig.git/&gt;) para obtener información detallada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'aaabaaab' =~ /a+b?(*COMMIT)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T143510Z" changeid="explorer">
        <seg>'aaabaaab' =~ /a+b?(*COMMIT)(?{print &quot;$&amp;\n&quot;; $contador++})(*FAIL)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;PerlIO::via&gt; iterate over layers properly now</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034047Z" changeid="explorer">
        <seg>C&lt;PerlIO::via&gt; ahora itera bien sobre las capas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while( 1 ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>while( 1 ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use constant FOO =&gt; &quot;something&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use constant FOO =&gt; &quot;algo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Single Quotes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Comillas simples</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may not charge a fee for this Package itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted no puede cobrar una cuota por el Paquete mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you have to
be careful not to include the pattern delimiter in the comment--perl has
no way of knowing you did not intend to close the pattern early.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que hay que tener cuidado de no incluir el delimitador de patrón en el comentario: perl no tiene manera de saber que no tiene intención de cerrar el patrón tan pronto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;code&gt; is evaluated
at run time, at the moment this subexpression may match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T182021Z" changeid="explorer">
        <seg>El C&lt;código&gt; es evaluado en tiempo de ejecución, en el momento en que esta subexpresión puede coincidir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Getopt::Long&gt; upgraded to version 2.35</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032300Z" changeid="explorer">
        <seg>C&lt;Getopt::Long&gt; actualizado a la versión 2.35</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl.org?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231242Z" changeid="explorer">
        <seg>¿Y perl.org?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (-x $file &amp;&amp; (($d) = stat(_)) &amp;&amp; $d &lt; 0) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (-x $archivo &amp;&amp; (($d) = stat(_)) &amp;&amp; $d &lt; 0) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a true read(2) system call, see C&lt;sysread&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener una auténtica llamada del sistema read(2), ver C&lt;sysread&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Compress::Zlib&gt; is an interface to the zlib compression library.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T201020Z" changeid="explorer">
        <seg>C&lt;Compress::Zlib&gt; es un interfaz a la biblioteca de compresión zlib.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use 5.010;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033235Z" changeid="explorer">
        <seg>use 5.010;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple examples to open a file for reading:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplos sencillos para abrir un archivo en modo lectura:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It had been reported that running under perl's debugger when processing
Unicode data could cause unexpectedly large slowdowns.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044928Z" changeid="explorer">
        <seg>Se ha informado de que ejecutando el depurador de Perl cuando se tratan datos Unicode, podría causar una ralentización inesperadamente grande.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;KELVIN SIGN&gt;, for example matches the letters &quot;k&quot; and
&quot;K&quot;; and C&lt;LATIN SMALL LIGATURE FF&gt; matches the sequence &quot;ff&quot;, which,
if you're not prepared, might make it look like a hexadecimal constant,
presenting another potential security issue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T173246Z" changeid="explorer">
        <seg>El C&lt;KELVIN SIGN&gt;, por ejemplo, coincide con las letras &quot;k&quot; y &quot;K&quot;, y C&lt;LATIN SMALL LIGATURE FF&gt; coincide con la secuencia &quot;ff&quot;, que, si no está preparado, puede hacer que se vea como una constante hexadecimal, presentando otro problema potencial de seguridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To disambiguate, use a space
or change the order of the flags:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213638Z" changeid="explorer">
        <seg>Para eliminar la ambigüedad, use un espacio o cambie el orden de las opciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, I'll be glad to provide one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T223226Z" changeid="explorer">
        <seg>Si no, estaré encantado de darle una.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays and slices are interpolated into double-quoted strings
by joining the elements with the delimiter specified in the C&lt;$&quot;&gt;
variable (C&lt;$LIST_SEPARATOR&gt; if &quot;use English;&quot; is specified), 
space by default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Arrays y porciones son interpoladas dentro de cadenas con dobles comillas, uniendo los elementos con el delimitador especificado en la variable &lt;C$&quot;&gt; (C&lt;$LIST_SEPARATOR&gt; si se especifica &quot;use English;&quot;), siendo el espacio en blanco el valor por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ordinal
value of a character is called a B&lt;code point&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234333Z" changeid="explorer">
        <seg>El valor ordinal de un carácter se denomina B&lt;código de carácter&gt; (I&lt;code point&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $i ( 0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $i ( 0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;/&gt; X&lt;slash&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;/&gt; X&lt;slash&gt; X&lt;barra diagonal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A powerful tool for optimizing such beasts is what is known as an
&quot;independent group&quot;,
which does not backtrack (see L&lt;/C&lt;&lt; (?&gt;pattern) &gt;&gt;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T211408Z" changeid="explorer">
        <seg>Una poderosa herramienta para la optimización de estas bestias es lo que se conoce como un &quot;grupo independiente&quot;, que no hace marcha atrás (vea L&lt;/C&lt;&lt; (?&gt;patrón) &gt;&gt;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When perl is configured to use ithreads, it will use re-entrant library calls
in preference to non-re-entrant versions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando Perl está configurado para usar ithreads, usará llamadas de biblioteca reentrantes preferentemente sobre versiones no-reentrantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the smart match
implicitly dereferences any non-blessed hash or array ref, so the &quot;Hash&quot;
and &quot;Array&quot; entries apply in those cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la coincidencia inteligente, implícitamente, desreferencia cualquier referencia hash o array no bendecida, así que las entradas &quot;Hash&quot; y &quot;Array&quot; se aplican en estos casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DIRHANDLEs have their own namespace separate from FILEHANDLEs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011356Z" changeid="explorer">
        <seg>Los IDENTIFICADOR_DIR tienen su propio espacio de nombres separados de los IDENTIFICADORes de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also
L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, C&lt;IPC::SysV::Semaphore&gt;
documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215733Z" changeid="explorer">
        <seg>Vea también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, y C&lt;IPC::Semaphore&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For reasons of security, this construct is forbidden if the regular
expression involves run-time interpolation of variables, unless the
perilous C&lt;use re 'eval'&gt; pragma has been used (see L&lt;re&gt;), or the
variables contain results of the C&lt;qr//&gt; operator (see
L&lt;perlop/&quot;qr/STRINGE&lt;sol&gt;msixpodual&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T201732Z" changeid="explorer">
        <seg>Por razones de seguridad, esta construcción está prohibida si la expresión regular incluye interpolación de variables en tiempo de ejecución, a menos que el peligroso pragma C&lt;use re 'eval'&gt; esté en uso (vea L&lt;re&gt;), o las variables contengan resultados del operador C&lt;qr//&gt; (vea L&lt;perlop/&quot;qr/CADENAE&lt;sol&gt;msixpodual&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub systell { sysseek($_[0], 0, SEEK_CUR) }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub systell { sysseek($_[0], 0, SEEK_CUR) }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iterator is implicitly reset when C&lt;each&gt; has reached
the end as just described; it can be explicitly reset by calling C&lt;keys&gt; or
C&lt;values&gt; on the hash or array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El iterador es implícitamente restablecido cuando C&lt;each&gt; ha llegado al final como se acaba de describir; puede ser explícitamente restablecido llamando a C&lt;keys&gt; o C&lt;values&gt; sobre el hash o array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you have to write</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tiene que escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Modules and Pragmata</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Módulos y Pragmata</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command-line utility, used to print or to check SHA digests, comes
with the new C&lt;Digest::SHA&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013522Z" changeid="explorer">
        <seg>Esta utilidad de línea de comandos, se utiliza para imprimir o comprobar resúmenes SHA; viene con el nuevo módulo C&lt;Digest::SHA&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Module ();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Módulo ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 ]) { s/peter/paul/ }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>10 ]) { s/pedro/pablo/ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A continue block is often used to reset line counters
or C&lt;m?pat?&gt; one-time matches:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T212144Z" changeid="explorer">
        <seg>Un bloque C&lt;continue&gt; se usa a menudo para reiniciar contadores de línea o patrones C&lt;m?patrón?&gt; de un sólo uso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a return value of C&lt;-1&gt; could mean that child processes are
being automatically reaped, as described in L&lt;perlipc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que un valor devuelto de C&lt;-1&gt; podría significar que los procesos hijos se están automáticamente desechando, como se describe en L&lt;perlipc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Encoding&gt; (as a verb) is the conversion from I&lt;text&gt; to I&lt;binary&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234646Z" changeid="explorer">
        <seg>B&lt;Codificar&gt; consiste en convertir I&lt;texto&gt; a I&lt;binario&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example to test whether Nagle's algorithm is enabled on a socket:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T234646Z" changeid="explorer">
        <seg>Aquí hay un ejemplo para comprobar si el algoritmo de Nagle está habilitado en un I&lt;socket&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to check for C&lt;defined&gt; on the return from C&lt;fcntl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No necesita comprobar con C&lt;defined&gt; al regreso de C&lt;fcntl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A patch for FreeBSD libc is available
(see http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631 )
which has been integrated into FreeBSD 4.6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un parche para la libc de FreeBSD está disponible (ver http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631 ) y ha sido integrado en FreeBSD 4.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'aaaa' =~ /a++a/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'aaaa' =~ /a++a/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231614Z" changeid="explorer">
        <seg>m{ (?: NO_CERO_LONGITUD | CERO_LONGITUD )* }x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;ST&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050100Z" changeid="explorer">
        <seg>=item C&lt;ST&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl was made to be
a glue language, and one of the things it glues together is commands.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl fue creado para ser un lenguaje pegamento, y una de las cosas que aglutina, son los comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item say FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011946Z" changeid="explorer">
        <seg>=item say IDENTIFICADOR_ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-52069-4 [May 2009]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003521Z" changeid="explorer">
        <seg>ISBN 978-0-596-52069-4 [Mayo de 2009]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;split&gt; with no arguments
really does a S&lt;C&lt;split(' ', $_)&gt;&gt; internally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;split&gt; sin argumentos realmente es internamente un S&lt;C&lt;split(' ', $_)&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but is more efficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pero es más eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Exists\n&quot;  if exists &amp;subroutine;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Existe\n&quot;   if exists  &amp;subrutina;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation typo fixed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Arreglado un error ortográfico en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILENAME is
omitted, does a C&lt;chroot&gt; to C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ARCHIVO se omite, hace un C&lt;chroot&gt; a C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new feature called I&lt;assertions&gt; will be available.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014203Z" changeid="explorer">
        <seg>Una nueva característica llamada I&lt;assertions&gt; estará disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlos400 has been added to tell about the installation and use
of Perl in OS/400 PASE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T181003Z" changeid="explorer">
        <seg>perlos400 ha sido añadido para hablar acerca de la instalación y el uso de Perl en OS/400 PASE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr [abc]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr [abc]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 I/O flow (the actual 5 minute tutorial)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235013Z" changeid="explorer">
        <seg>=head2 Flujo de E/S (el auténtico tutorial, en 5 minutos)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Efficient but
                   dangerous.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050709Z" changeid="explorer">
        <seg>Eficiente pero
                   peligroso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The extra switch disables the execution of AutoRun commands
from the registry, which is generally considered undesirable when
running external programs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142329Z" changeid="explorer">
        <seg>Esta opción adicional deshabilita la ejecución de los comandos AutoRun del registro, que generalmente se considera indeseable cuando se ejecutan programas externos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225933Z" changeid="explorer">
        <seg>Si los</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>probably doesn't do what you expect at first glance.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>probablemente no hace lo que usted espera, a primera vista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, &quot;&gt;&quot;, &quot;output.txt&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T001006Z" changeid="explorer">
        <seg>open(my $fh, &quot;&gt;&quot;, &quot;output.txt&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Utility Changes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Cambios en las herramientas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;in bytes&gt;: even if the filehandle has been set to
operate on characters (for example by using the C&lt;:encoding(utf8)&gt; open
layer), tell() will return byte offsets, not character offsets
(because implementing that would render seek() and tell() rather slow).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012116Z" changeid="explorer">
        <seg>Nota sobre lo de I&lt;en bytes&gt;: incluso si el identificador de archivo se ha puesto para operar en caracteres (por ejemplo usando la capa de open C&lt;:encoding(utf8)&gt;), tell() devolverá desplazamientos en bytes, no en caracteres (porque implementando esto convertirían en lentas a seek() y tell()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ftp://ftp.cs.pdx.edu/pub/elvis/ http://www.fh-wedel.de/elvis/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>ftp://ftp.cs.pdx.edu/pub/elvis/ http://www.fh-wedel.de/elvis/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the lower bound
is not optional.)  The &quot;*&quot; quantifier is equivalent to C&lt;{0,}&gt;, the &quot;+&quot;
quantifier to C&lt;{1,}&gt;, and the &quot;?&quot; quantifier to C&lt;{0,1}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, el límite inferior no es opcional). El cuantificador &quot;*&quot; es equivalente a C&lt;{0,}&gt;, el cuantificador &quot;+&quot; a C&lt;{1,}&gt;, y el cuantificador &quot;?&quot; a C&lt;{0,1}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;unless&gt; can even be followed by one or more C&lt;elsif&gt;
statements, though you may want to think twice before using that particular
language construct, as everyone reading your code will have to think at least
twice before they can understand what's going on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013335Z" changeid="explorer">
        <seg>C&lt;unless&gt; puede, incluso, ser seguido por una o más instrucciones C&lt;elsif&gt;, aunque quizás quiera pensarlo dos veces antes de usar esta construcción del lenguaje tan particular, lo mismo que cualquiera que al leer su código tendrá que pensar al menos dos veces antes de entender qué ha querido decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The layout of directories in F&lt;ext&gt; has been revised.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T020108Z" changeid="explorer">
        <seg>La disposición de los directorios en F&lt;ext&gt; ha sido revisada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print sqrt(-4);    # prints 2i</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print sqrt(-4);    # imprime 2i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing with Unicode circled letters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo con letras Unicode acentuadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>package customre;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001805Z" changeid="explorer">
        <seg>package customre;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Others are experimental
and may change without warning or be completely removed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros son experimentales y pueden cambiar sin previo aviso o ser retirados por completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readpipe
X&lt;readpipe&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194435Z" changeid="explorer">
        <seg>=item readpipe
X&lt;readpipe&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your destructors (the DESTROY
subroutines) have assumed any particular ordering to the global
destruction, there might be problems ahead.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135901Z" changeid="explorer">
        <seg>Si sus destructores (las subrutinas DESTROY) han asumido cualquier tipo de orden para la destrucción global, podrían ocurrir problemas más adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$baz = &quot;\n&quot;;		# a one-character string</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$baz = &quot;\n&quot;;		# una cadena de un carácter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in B&lt;csh&gt;, no translation is done on the return data--newlines
remain newlines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de B&lt;csh&gt;, no se realiza traducción en el retorno de los datos: los caracteres de fin de línea siguen siendo caracteres de fin de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@data) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225456Z" changeid="explorer">
        <seg>foreach (@data) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practical hint: you almost never need to use C&lt;eof&gt; in Perl, because the
input operators typically return C&lt;undef&gt; when they run out of data or 
encounter an error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T233259Z" changeid="explorer">
        <seg>Truco práctico: casi nunca necesita usar C&lt;eof&gt; en Perl, porque los operadores de entrada normalmente devuelven C&lt;undef&gt; cuando no hay más datos, o si se produce un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwnam</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015007Z" changeid="explorer">
        <seg>=item getpwnam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpragma		Perl modules: writing a user pragma</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000447Z" changeid="explorer">
        <seg>perlpragma		Programación de un pragma de usuario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Count=$count\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003111Z" changeid="explorer">
        <seg>print &quot;Contador=$contador\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's more than one
reason you're encouraged to restrict your delimiters to non-alphanumeric,
non-whitespace choices.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay más motivos que nos alientan para restringir sus delimitadores a elecciones no alfanuméricas ni espacios en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some more examples; be aware that when using an explicit
index, the C&lt;$&gt; may need escaping:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Éstos son algunos ejemplos más; sea consciente de que cuando se utiliza un índice explícito, el C&lt;$&gt; puede ser necesario escaparlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 To OO or not to OO?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015641Z" changeid="explorer">
        <seg>=head2 ¿POO o no POO?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (&amp;aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (&amp;aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlguts/&quot;Magic Variables&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001541Z" changeid="explorer">
        <seg>Vea también L&lt;perlguts/&quot;Variables Mágicas&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;(?R)&gt; recurses to
the beginning of the whole pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T184208Z" changeid="explorer">
        <seg>C&lt;(?R)&gt; re-ejecuta hasta el comienzo de todo el patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that &quot;script&quot; and &quot;scripting&quot; are terms that have been seized by
unscrupulous or unknowing marketeers for their own nefarious purposes,
they have begun to take on strange and often pejorative meanings,
like &quot;non serious&quot; or &quot;not real programming&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231917Z" changeid="explorer">
        <seg>Ahora que mercaderes sin escrúpulos ni conocimientos se han apropiado de los términos &quot;script&quot; y &quot;scripting&quot; para sus viles propósitos, se les ha empezado a asociar significados extraños, generalmente peyorativos, como &quot;programación poco seria&quot; o &quot;programación menor&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Windows, Vanilla Perl ( http://vanillaperl.com/ ) and Strawberry Perl
( http://strawberryperl.com/ ) come with a
bundled C compiler.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225830Z" changeid="explorer">
        <seg>Para Windows, Vanilla Perl ( http://vanillaperl.com/ ) y Strawberry Perl
( http://strawberryperl.com/ ) incorporan un compilador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4 uid      numeric user ID of file's owner</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>4 uid      ID numérico del usuario propietario del archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with filehandle reads, an automatic C&lt;defined&gt; is
generated when the glob occurs in the test part of a C&lt;while&gt;,
because legal glob returns (e.g. a file called F&lt;0&gt;) would otherwise
terminate the loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014608Z" changeid="explorer">
        <seg>Al igual que cuando un identificador de archivo lee, un C&lt;defined&gt; es generado cuando la expansión se produce en la parte de prueba de un C&lt;while&gt;, porque una expansión legal así lo devuelve (por ejemplo, un archivo llamado F&lt;0&gt;); de otra manera terminaría el bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( (&quot;\020\020&quot; &amp; &quot;\101\101&quot;) !~ /[^\000]/) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225517Z" changeid="explorer">
        <seg>if ( (&quot;\020\020&quot; &amp; &quot;\101\101&quot;) !~ /[^\000]/) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} @old;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} @viejo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># foo eq &quot;ABCD&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># foo es &quot;ABCD&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some words in English work this way, like &quot;fish&quot;
and &quot;sheep&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existen algunas palabras en Español que funcionan de esa manera, como &quot;crisis&quot;, &quot;ciempiés&quot; o &quot;lunes&quot;, que actúan de singular o plural dependiendo del contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
Boolean context is just a special kind of scalar context where no 
conversion to a string or a number is ever performed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El contexto booleano es simplemente un tipo especial de contexto escalar para el cual ni siquiera se llega a realizar ninguna conversión a cadena o a número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options can now take multiple values at once (experimental)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032610Z" changeid="explorer">
        <seg>Las opciones ahora pueden tomar múltiples valores al mismo tiempo (experimental)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation enhancements and typo fixes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031016Z" changeid="explorer">
        <seg>Ajustes y correcciones en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a system
error, returns the undefined value and sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay un error del sistema, devuelve el valor indefinido y actualiza C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the very least it will let some poor
schmuck bounce on the % key in B&lt;vi&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo menos esto hará que algún pobre inútil pueda usar la tecla % en B&lt;vi&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $i = 0;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>my $i = 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;in bytes&gt;: even if the filehandle has been set to
operate on characters (for example by using the C&lt;:encoding(utf8)&gt; open
layer), tell() will return byte offsets, not character offsets (because
that would render seek() and tell() rather slow).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013221Z" changeid="explorer">
        <seg>Nota sobre lo de I&lt;en bytes&gt;: incluso si el identificador de archivo se ha puesto para operar en caracteres (por ejemplo usando la capa de open C&lt;:encoding(utf8)&gt;), tell() devolverá desplazamientos en bytes, no en caracteres (porque implementando esto convertirían en lentas a seek() y tell()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;.&gt;, where it means relative to the start of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;.&gt;, donde significa relativo al inicio de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vea más abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following escape sequences are available in constructs that interpolate,
and in transliterations:
X&lt;\t&gt; X&lt;\n&gt; X&lt;\r&gt; X&lt;\f&gt; X&lt;\b&gt; X&lt;\a&gt; X&lt;\e&gt; X&lt;\x&gt; X&lt;\0&gt; X&lt;\c&gt; X&lt;\N&gt; X&lt;\N{}&gt;
X&lt;\o{}&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T231242Z" changeid="explorer">
        <seg>Las siguientes secuencias de escape están disponibles en construcciones que interpolan, y en transliteraciones:
X&lt;\t&gt; X&lt;\n&gt; X&lt;\r&gt; X&lt;\f&gt; X&lt;\b&gt; X&lt;\a&gt; X&lt;\e&gt; X&lt;\x&gt; X&lt;\0&gt; X&lt;\c&gt; X&lt;\N&gt; X&lt;\N{}&gt; X&lt;\o{}&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlretut&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045827Z" changeid="explorer">
        <seg>L&lt;perlretut&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.solutionsoft.com/perl.htm</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>http://www.solutionsoft.com/perl.htm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Especially noteworthy are the bug in Calc that caused div and mod to
fail for some large values, and the fixes to the handling of bad inputs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T173415Z" changeid="explorer">
        <seg>Destaca de forma notable el fallo en Calc que causaba que div y mod fallaran para ciertos valores grandes, y los arreglos para el manejo de las entradas erróneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless (open($input, &quot;&lt;&quot;, $filename)) {
            print STDERR &quot;Can't open $filename: $!\n&quot;;
            return;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004219Z" changeid="explorer">
        <seg>unless (open($entrada, $archivo)) {
            print STDERR &quot;No puedo abrir $archivo: $!\n&quot;;
            return;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL while (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA while (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [5]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225328Z" changeid="explorer">
        <seg>=item [5]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print($foo, exit);	# Obviously not what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print($foo, exit);	# Obviamente, no lo que quiere hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of Perl 5.9.1, as a form of purely syntactic sugar, you can stack file
test operators, in a way that C&lt;-f -w -x $file&gt; is equivalent to
C&lt;-x $file &amp;&amp; -w _ &amp;&amp; -f _&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como en Perl 5.9.1, una dulce forma, puramente sintáctica, puede apilar operadores de test de archivo, de forma que C&lt;-f -w -x $archivo&gt; es equivalente a C&lt;-x $archivo &amp;&amp; -w _ &amp;&amp; -f _&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { ... };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { ... };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to the rule of dispatch based on the rightmost argument type,
when an object overloading C&lt;~~&gt; appears on the right side of the
operator, the overload routine will always be called (with a 3rd argument
set to a true value, see L&lt;overload&gt;.) However, when the object will
appear on the left, the overload routine will be called only when the
rightmost argument is a simple scalar.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T161542Z" changeid="explorer">
        <seg>De acuerdo con la regla de reparto basada en el tipo del argumento de la derecha, cuando un objeto sobrecarga C&lt;~~&gt; aparece en el lado derecho del operador, la rutina de sobrecarga siempre será llamada (con un tercer argumento establecido a un valor verdadero, consulte L&lt;overload&gt;.) Sin embargo, cuando el objeto aparece a la izquierda, la rutina de sobrecarga será llamada sólo cuando el argumento de la derecha sea un escalar simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ExtUtils::MakeMaker remains at version 6.17, as later stable releases currently
available on CPAN have some issues with core modules on some core platforms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ExtUtils::MakeMaker se mantiene en la versión 6.17, debido a que las últimas versiones estables actualmente disponibles en CPAN tienen algunos problemas con los módulos básicos en algunas plataformas principales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that doesn't
work, try looking in C&lt;/usr/local/lib/perl5/pod&gt; for documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230257Z" changeid="explorer">
        <seg>Si esto no funciona, pruebe a buscar la documentación en C&lt;/usr/local/lib/perl5/pod&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EOF</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EOF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;clock_nanosleep()&gt; and C&lt;clock()&gt; functions added</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040758Z" changeid="explorer">
        <seg>Funciones añadidas C&lt;clock_nanosleep()&gt; y C&lt;clock()&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certain operations
return list values in contexts wanting a list, and scalar values
otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ciertas operaciones devuelven una lista de valores en contextos que esperan una lista, y valores escalares en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EOC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EOC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
should reduce the number of calls to C&lt;realloc&gt; without actually using any
extra memory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T052138Z" changeid="explorer">
        <seg>Esto debería reducir el número de llamadas a C&lt;realloc&gt; sin tener que llegar a utilizar ningún otro espacio de memoria adicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/^\d+$/ &amp;&amp; $_ &lt; 75) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/^\d+$/ &amp;&amp; $_ &lt; 75) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two major contexts: list and scalar.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T000203Z" changeid="explorer">
        <seg>Hay dos tipos principales de contexto: lista y escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EOL</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EOL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EOT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EOT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But
anything more complicated in the subscript will be interpreted as an
expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero cualquier otra cosa más complicada, en el subíndice, se interpretará como una expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [6]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225402Z" changeid="explorer">
        <seg>=item [6]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlreapi&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001156Z" changeid="explorer">
        <seg>Vea L&lt;perlreapi&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrepository&gt; for more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190331Z" changeid="explorer">
        <seg>Vea L&lt;perlrepository&gt; para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># do something here...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T190551Z" changeid="explorer">
        <seg># hacer algo aquí...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Jan Dubois)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112239Z" changeid="explorer">
        <seg>(Jan Dubois)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Is there an ISO or ANSI certified version of Perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230213Z" changeid="explorer">
        <seg>=head2 ¿Existe alguna versión de Perl con certificación ISO o ANSI?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;cmp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;cmp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You just know it will be done sometime
before or after the value is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo sabe que se hará en algún momento antes o después de que el valor sea devuelto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is
I&lt;only&gt; meant to be used to assert that the running Perl is of a earlier
version than its argument and I&lt;not&gt; to undo the feature-enabling side effects
of C&lt;use VERSION&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024733Z" changeid="explorer">
        <seg>I&lt;Sólo&gt; es para ser usado para asegurarse de que el perl que se está ejecutando es de una versión anterior a su argumento y I&lt;no&gt; para deshacer los efectos colaterales activados por C&lt;use VERSION&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($days[3], $days[4], $days[5]) = qw/Wed Thu Fri/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($dias[3], $dias[4], $dias[5]) = qw/Mié Jue Vie/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions
to the regex syntax.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002940Z" changeid="explorer">
        <seg>A partir de Perl 5.10.0, Perl soporta varias extensiones específicas Python/PCRE en la sintaxis de expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chdir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The triple-dot operator, C&lt;...&gt;, sometimes called the &quot;whatever operator&quot;, the
&quot;yada-yada operator&quot;, or the &quot;I&lt;et cetera&gt;&quot; operator, is a placeholder for
code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225211Z" changeid="explorer">
        <seg>El operador triple punto, C&lt;...&gt;, a veces llamado el &quot;operador lo-que-sea&quot;, el &quot;operador blablablá&quot;, o el operador &quot;I&lt;etcétera&gt;&quot;, es un marcador de posición para código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596003135/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003041Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596003135/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, modifiers are resolved at compile time, so constructs
like (?i:(?1)) or (?:(?i)(?1)) do not affect how the sub-pattern will
be processed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T191158Z" changeid="explorer">
        <seg>Además, los modificadores son resueltos en tiempo de compilación, por lo que construcciones como (?i:(?1)) o (?:(?i)(?1)) no afectan al modo en el que el sub-patrón será procesado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [7]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225427Z" changeid="explorer">
        <seg>=item [7]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ODBM_File</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014831Z" changeid="explorer">
        <seg>=item ODBM_File</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[RT #51636]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003944Z" changeid="explorer">
        <seg>[RT #51636]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alex Waugh &lt;alex@alexwaugh.com&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alex Waugh &lt;alex@alexwaugh.com&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may cause programs which used to execute seemingly
correctly without warnings and errors to fail when run under 5.8.1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T175602Z" changeid="explorer">
        <seg>Esto puede hacer que los programas que lo usaban para ejecutar, de forma aparente, sin advertencias ni errores, fallen cuando se ejecute en 5.8.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>makes $this an alias for $that, @this an alias for @that, %this an alias
for %that, &amp;this an alias for &amp;that, etc.  Much safer is to use a reference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005416Z" changeid="explorer">
        <seg>hace que $este sea un alias de $ese, @este sea un alias de @ese, %este sea un alias de %ese, etc. Es mucho más seguro usar una referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item do BLOCK
X&lt;do&gt; X&lt;block&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171422Z" changeid="explorer">
        <seg>=item do BLOQUE
X&lt;do&gt; X&lt;block&gt; X&lt;bloque&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is not
currently able to do this when the multiple characters are in the pattern and
are split between groupings, or when one or more are quantified.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162236Z" changeid="explorer">
        <seg>Perl no es capaz, actualmente, de hacer esto cuando los grupos de caracteres están en el patrón y se dividen en agrupaciones, o cuando uno o más de ellos se han cuantificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$wid += $jet;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$wid += $jet;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Config;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Config;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't use C&lt;exit&gt; to abort a subroutine if there's any chance that
someone might want to trap whatever error happened.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No use C&lt;exit&gt; para abortar una subrutina si existe la posibilidad de que alguien pueda capturar el error que ocurrió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [8]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T211047Z" changeid="explorer">
        <seg>=item [8]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internal cleanup and portability fixes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Limpieza interna y arreglos en la portabilidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push $aref,  qw(some more values);  # WRONG!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031152Z" changeid="explorer">
        <seg>push $aref,  qw(some more values);  # ¡MAL!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval `cat stat.pl`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval `cat stat.pl`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*s&gt;',  0, &quot;string&quot;;   # prints &quot;&lt;&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*s&gt;',  0, &quot;cadena&quot;;   # imprime &quot;&lt;&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directory contains I&lt;all&gt; of the modules and their tests,
unlike other core modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014406Z" changeid="explorer">
        <seg>A diferencia de otros módulos del núcleo, este directorio contiene I&lt;todos&gt; los módulos y sus pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you add new tests (or new
modules with tests), you may need to update the F&lt;t/TEST&gt; file so that the
tests are run.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014533Z" changeid="explorer">
        <seg>Si agrega pruebas nuevas (o módulos nuevos con pruebas), es posible que tenga que actualizar el archivo F&lt;t/TEST&gt; para que se ejecuten.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>END</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>END</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>temporarily makes $Here::blue an alias for $There::green, but doesn't
make @Here::blue an alias for @There::green, or %Here::blue an alias for
%There::green, etc.  See L&lt;perlmod/&quot;Symbol Tables&quot;&gt; for more examples
of this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>temporalmente hace que $Aqui::azul sea un alias de $Ahi::verde, pero no hace que @Aqui::azul sea un alias de @Ahi::verde, o que %Aqui::azul sea un alias de %Ahi::verde, etc. Ver L&lt;perlmod/&quot;Tablas de símbolos&quot;&gt; para más ejemplos sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Digest</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Digest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If more than one value is listed, the list must
be placed in parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se lista más de un valor, esa lista debe ser puesta entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item link</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014848Z" changeid="explorer">
        <seg>=item link</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It magically differs from
a string containing the same characters: C&lt;ref(qr/x/)&gt; returns &quot;Regexp&quot;,
even though dereferencing the result returns undef.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De manera mágica se distingue de una cadena que contenga los mismos caracteres: C&lt;ref(qr/x/)&gt; devuelve &quot;Regexp&quot;, incluso aunque desreferenciando el resultado devuelva undef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use whitespace and the C&lt;&lt; =&gt; &gt;&gt; operator to lay them out more
nicely:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224923Z" changeid="explorer">
        <seg>Puede usar espacio en blanco y el operador C&lt;&lt; =&gt; &gt;&gt; para expresarlos de manera más clara:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/regexp_unicode_prop_thr.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010034Z" changeid="explorer">
        <seg>=item t/op/regexp_unicode_prop_thr.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are not allowed to override the byte-order within a group
that already has a byte-order modifier suffix.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No está autorizado a anular la ordenación de bytes dentro de un grupo que ya tenga un sufijo de modificador de ordenación de bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This was only 4 times slower on a string with 1000000 C&lt;a&gt;s.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T215250Z" changeid="explorer">
        <seg>Esto sólo fue 4 veces más lento en una cadena con un 1.000.000 de C&lt;a&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef %HASH;    # forget %HASH ever existed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef %HASH;    # hacer que %HASH nunca existió</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your naming should be consistent.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021316Z" changeid="explorer">
        <seg>Su nombramiento debe ser coherente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To capture a command's STDERR but discard its STDOUT (ordering is
important here):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Capturar el STDERR de un comando pero descartar su STDOUT (aquí, el orden es importante):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tie VARIABLE,CLASSNAME,LIST
X&lt;tie&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204806Z" changeid="explorer">
        <seg>=item tie VARIABLE,CLASE,LISTA
X&lt;tie&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perllocale&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perllocale&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you make changes to uconfig.sh, run</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si realiza cambios en uconfig.sh, ejecute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endnetent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endnetent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/pat_thr.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010024Z" changeid="explorer">
        <seg>=item t/op/pat_thr.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might also want to check out
L&lt;perlfaq8/&quot;How do I keep my own module/library directory?&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225925Z" changeid="explorer">
        <seg>Es posible que también le interese consultar &quot;¿Qué tengo que hacer para mantener mi propio directorio de módulos/bibliotecas?&quot; en L&lt;perlfaq8&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;srand()&gt; is not called explicitly, it is called implicitly without a
parameter at the first use of the C&lt;rand&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182715Z" changeid="explorer">
        <seg>Si C&lt;srand()&gt; no es llamada de forma explícita, es llamada implícitamente en el primer uso del operador C&lt;rand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$caps[$a] cmp $caps[$b]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$mayusculas[$a] cmp $mayusculas[$b]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should set C&lt;$VERSION&gt; only once per package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe ajustar el valor de C&lt;$VERSION&gt; solo una vez por paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;aaaa&quot;,&quot;abcd&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;aaaa&quot;,&quot;abcd&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Devel::Peek&gt; upgraded to version 1.03</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030142Z" changeid="explorer">
        <seg>C&lt;Devel::Peek&gt; actualizado a la versión 1.03</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a general rule, backslashes
between C&lt;\Q&gt; and C&lt;\E&gt; may lead to counterintuitive results.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como regla general, las contrabarras entre C&lt;\Q&gt; y C&lt;\E&gt; pueden dar lugar a resultados no intuitivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are trying to use this instead of C&lt;write&gt; to capture the output,
you may find it easier to open a filehandle to a scalar
(C&lt;&lt; open $fh, &quot;&gt;&quot;, \$output &gt;&gt;) and write to that instead.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010653Z" changeid="explorer">
        <seg>Si está intentando usar esto en lugar de C&lt;write&gt; para capturar la salida, puede encontrar que sea más sencillo abrir un identificador de archivo en un escalar (C&lt;&lt; open $fh, &quot;&gt;&quot;, \$salida &gt;&gt;) y escribir en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IFMT($mode)    the part of $mode containing the file type
            which can be bit-anded with (for example) S_IFREG
                        or with the following functions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052210Z" changeid="explorer">
        <seg>S_IFMT($modo)    la parte de $modo conteniendo los bit del tipo
            de archivo que puede ser bit-andeado con (por ejemplo) S_IFREG
                        o con las siguientes funciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is just like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--------------------------------------------------------------------------</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004944Z" changeid="explorer">
        <seg>--------------------------------------------------------------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item say FILEHANDLE LIST
X&lt;say&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011930Z" changeid="explorer">
        <seg>=item say IDENTIFICADOR_ARCHIVO LISTA
X&lt;say&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;+&quot; returns the sum of two numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;+&quot; devuelve la suma de dos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlce		Perl notes for WinCE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlce		Notas para WinCE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although if your manager accused you of seeking job security (or rapid
insecurity) through inscrutable code, it would be hard to argue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200119Z" changeid="explorer">
        <seg>Pero su jefe le puede acusar de estar buscando un trabajo de seguridad (o rápida inseguridad) usando código inescrutable, y le será difícil excusarse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2401 6.2 all platform kernel rollup</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004342Z" changeid="explorer">
        <seg>2401 6.2 acumulativo kernel para todas las plataformas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot; if $on_a_tty }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot; if $en_un_tty }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %fruit_color = (</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234357Z" changeid="zipf">
        <seg>my %color_fruta = (</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a NAME, it's an anonymous
function declaration, so does return a value: the CODE ref of the closure
just created.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015311Z" changeid="explorer">
        <seg>Sin un NOMBRE, es una declaración de una función anónima, y devuelve un valor: la referencia al CÓDIGO de la clausura que acaba de crear.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>study;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>study;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when processing a file like F&lt;/etc/termcap&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, cuando se procesa un archivo como F&lt;/etc/termcap&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do B&lt;not&gt; call C&lt;srand()&gt; (i.e., without an argument) more than once per
process.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183430Z" changeid="explorer">
        <seg>B&lt;No&gt; llame a srand() (e.d., sin un argumento) más de una vez por proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Perl Books</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230700Z" changeid="explorer">
        <seg>=head2 Libros sobre Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?|pattern)&gt;
X&lt;(?|)&gt; X&lt;Branch reset&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232558Z" changeid="explorer">
        <seg>=item C&lt;(?|patrón)&gt;
X&lt;(?|)&gt; X&lt;Branch reset&gt; X&lt;reinicio de rama&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Smart match and overloading</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005207Z" changeid="explorer">
        <seg>=head3 Coincidencia inteligente y sobrecarga</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If DIRHANDLE is an undefined
scalar variable (or array or hash element), the variable is assigned a
reference to a new anonymous dirhandle; that is, it's autovivified.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T001611Z" changeid="explorer">
        <seg>Si IDENTIFICADOR_DIR es una variable escalar indefinida (o elemento array o hash), a la variable se le asigna una referencia a un nuevo identificador de directorio anónimo; es decir, es autovivificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Decoding&gt; is the conversion from I&lt;binary&gt; to I&lt;text&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234726Z" changeid="explorer">
        <seg>B&lt;Descodificar&gt; consiste en convertir I&lt;binario&gt; a I&lt;texto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is I&lt;NOT&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>I&lt;NO&gt; es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its truth or falsehood determines how the modifier will behave.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su verdad o falsedad determina cómo se comportará el modificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only available after Perl 5.10.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T235420Z" changeid="explorer">
        <seg>Solamente disponible a partir de Perl 5.10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>email: hom00@utsglobal.com</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>email: hom00@utsglobal.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This zero-width pattern is similar to C&lt;(*PRUNE)&gt;, except that on
failure it also signifies that whatever text that was matched leading up
to the C&lt;(*SKIP)&gt; pattern being executed cannot be part of I&lt;any&gt; match
of this pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T011306Z" changeid="explorer">
        <seg>Este patrón de ancho cero es similar a C&lt;(*PRUNE)&gt;, con la excepción de que en caso de fallo también significa que cualquier texto que haya sido encontrado antes del patrón C&lt;(*SKIP)&gt; que se está ejecutando, no puede formar parte de I&lt;ninguna&gt; búsqueda de este patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;sysopen $path: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;sysopen $ruta: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, merely returns the current umask.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, simplemente devuelve la umask actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
v-less form (1.2.3) will become a &quot;version object&quot; when used with C&lt;use&gt;,
C&lt;require&gt;, and C&lt;$VERSION&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T005615Z" changeid="explorer">
        <seg>La forma v-less (1.2.3) se convertirá en un &quot;objeto de versión&quot; cuando se utilice con C&lt;use&gt;, C&lt;require&gt; y C&lt;$VERSION&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special variable C&lt;$#array&gt; tells you the index of the last element
of an array:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224852Z" changeid="explorer">
        <seg>La variable especial C&lt;$#array&gt; indica el índice del último elemento de un array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\f                  form feed         (FF)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T185955Z" changeid="explorer">
        <seg>\f		avance de página			(FF)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any of the bit masks can also be undef.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera de las máscaras de bits también puede ser undef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matches as C&lt;SSS...S&gt; (repeated as many times as necessary).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235713Z" changeid="explorer">
        <seg>Coincide con C&lt;SSS...S&gt; (repetida tantas veces como sea necesario).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On Linux the legacy process name will be set with L&lt;prctl(2)&gt;, in
addition to altering the POSIX name via C&lt;argv[0]&gt; as perl has done
since version 4.000.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T053547Z" changeid="explorer">
        <seg>En Linux el nombre del proceso se establecerá con L&lt;prctl(2)&gt;, además de alterar el nombre a través de POSIX C&lt;argv[0]&gt; igual a como perl lo ha hecho desde la versión 4.000.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0.8 0.8 0.9 0.9 1.0 1.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225512Z" changeid="explorer">
        <seg>0.8 0.8 0.9 0.9 1.0 1.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The directives alter the behaviour of the filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004832Z" changeid="explorer">
        <seg>Las directivas alteran el comportamiento del identificador del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort(find_records(@key));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort(busca_registros(@claves));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opens a directory named EXPR for processing by C&lt;readdir&gt;, C&lt;telldir&gt;,
C&lt;seekdir&gt;, C&lt;rewinddir&gt;, and C&lt;closedir&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Abre un directorio llamado EXPR para ser procesado por C&lt;readdir&gt;, C&lt;telldir&gt;, C&lt;seekdir&gt;, C&lt;rewinddir&gt;, y C&lt;closedir&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator may be assigned to if both the 2nd and 3rd arguments are
legal lvalues (meaning that you can assign to them):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054108Z" changeid="explorer">
        <seg>El operador puede ser asignado si tanto el segundo y tercer argumentos son I&lt;ivalores&gt; legales (lo que significa que les puede asignar valores):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a random integer between C&lt;0&gt; and C&lt;9&gt;, inclusive.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>devuelve un número entero aleatorio entre C&lt;0&gt; y C&lt;9&gt;, inclusive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NOTE: This section presents an abstract approximation of regular
expression behavior.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T145043Z" changeid="explorer">
        <seg>NOTA: en esta sección se presenta una aproximación abstracta del comportamiento de las expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exit() function does not always exit immediately.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función exit() no siempre sale de forma inmediata.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Q  An unsigned quad value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Q  Un valor cuádruplo sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only one you
need to know about for now is C&lt;$_&gt; which is the &quot;default variable&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224836Z" changeid="explorer">
        <seg>La única que tiene que conocer por ahora es C&lt;$_&gt;, la &quot;variable predeterminada&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;eval_sv()&gt; failing a taint test could corrupt the stack - this has been
fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T211626Z" changeid="explorer">
        <seg>C&lt;eval_sv()&gt; fallando una prueba de pringado podría corromper la pila - ha sido arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 5.8.0 all filehandles, including the standard filehandles,
were implicitly set to be in Unicode UTF-8 if the locale settings
indicated the use of UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T140700Z" changeid="explorer">
        <seg>En Perl 5.8.0 todos los identificadores de archivo, incluidos los identificadores de archivo estándar, se establecían implícitamente en Unicode UTF-8 si la configuración regional indicaba el uso de UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regular expressions provide a terse and powerful programming language.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230215Z" changeid="explorer">
        <seg>Las expresiones regulares proporcionan un lenguaje de programación conciso y poderoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod/&quot;Perl Modules&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod/&quot;Módulos Perl&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\N{name}    named Unicode character or character sequence</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043652Z" changeid="explorer">
        <seg>\N{nombre}	carácter o secuencia de caracteres Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @mixed   = (&quot;camel&quot;, 42, 1.23);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234015Z" changeid="zipf">
        <seg>my @mezcla   = (&quot;camello&quot;, 42, 1.23);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is especially significant, given that C&lt;__DIE__&gt; hooks can call
C&lt;die&gt; again, which has the effect of changing their error messages:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es especialmente significativo, dado que las llamadas C&lt;__DIE__&gt; pueden llamar de nuevo a C&lt;die&gt;, que tiene el efecto de cambiar los mensajes de error:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, a quantified subpattern is &quot;greedy&quot;, that is, it will match as
many times as possible (given a particular starting location) while still
allowing the rest of the pattern to match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma predeterminada, un sub-patrón cuantificado es &quot;avaricioso&quot;, es decir, que coincidirá con tantas veces como sea posible (dado un determinado lugar de partida), mientras que aún permita que el resto del patrón coincida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you C&lt;fork&gt; without ever waiting on your children, you will
accumulate zombies.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted hace un C&lt;fork&gt; sin luego esperar a sus hijos, irá acumulando zombies.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsymbian 	Perl notes for Symbian</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000913Z" changeid="explorer">
        <seg>perlsymbian 	Notas para Symbian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print { $files[$i] } &quot;stuff\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print { $archivos[$i] } &quot;cosas\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = [ split &quot; &quot;, scalar(&lt;&gt;) ];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030420Z" changeid="explorer">
        <seg>$AoA[$i] = [ split &quot; &quot;, scalar(&lt;&gt;) ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfunc		Perl built-in functions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000258Z" changeid="explorer">
        <seg>perlfunc		Funciones integradas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VMS now supports C&lt;getgrgid&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T011230Z" changeid="explorer">
        <seg>VMS ahora soporta C&lt;getgrgid&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a negated expression C&lt;!(...)&gt; or C&lt;not (...)&gt;, or a logical
exclusive-or C&lt;(...) xor (...)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>una expresión negada C&lt;!(...)&gt; o C&lt;not (...)&gt;, o una operación lógica exclusiva-or C&lt;(...) xor (...)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; le &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; le &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5 gid      numeric group ID of file's owner</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5 gid      ID numérico del grupo del propietario del archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other modules should begin with a capital letter and use mixed
case, but probably without underscores due to limitations in primitive
file systems' representations of module names as files that must fit into a
few sparse bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros módulos deben comenzar con una letra mayúscula y usar luego una mezcla de mayúsculas y minúsculas, pero probablemente sin guiones bajos debido a limitaciones en la representación de nombres de módulos como archivos en sistemas de archivos primitivos que deben ajustarse a unos pocos bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
instance</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This prints out your environment like the printenv(1) program,
but in a different order:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto imprime su entorno como el programa printenv(1), sólo que en un orden diferente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$tX = sprintf(&quot;%.${POINTS}g&quot;, $X);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$tX = sprintf(&quot;%.${PUNTOS}g&quot;, $X);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;Test::Harness&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003437Z" changeid="explorer">
        <seg>=item C&lt;Test::Harness&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to write true lexically scoped pragmas will be introduced.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014639Z" changeid="explorer">
        <seg>Se ha introducido la capacidad de escribir verdaderos pragmas con alcance léxico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The debugger now works with lvalue subroutines.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153540Z" changeid="explorer">
        <seg>El depurador ahora trabaja con subrutinas de tipo I&lt;ivalor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Sorry...\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;Lo siento...\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>May be interrupted if the process receives a signal such as C&lt;SIGALRM&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser interrumpido si el proceso recibe una señal como C&lt;SIGALRM&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;&quot;pack&quot;&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;&quot;pack&quot;&gt; para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any function in the list below may be used either with or without
parentheses around its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier función en la lista de abajo puede ser usada tanto con paréntesis como sin ellos, rodeando sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>process($file, &quot;fh00&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004145Z" changeid="explorer">
        <seg>procesa($archivo, &quot;fh00&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is a high-level programming language with an eclectic heritage
written by Larry Wall and a cast of thousands.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T195844Z" changeid="explorer">
        <seg>Perl es un lenguaje de programación de alto nivel con una herencia ecléctica, creado por Larry Wall con la ayuda de miles de programadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.openbsd - Perl version 5 on OpenBSD systems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.openbsd - Perl versión 5 sobre sistemas OpenBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply C&lt;int()&gt; to the value returned by C&lt;rand()&gt; if you want random
integers instead of random fractional numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aplique C&lt;int()&gt; al valor devuelto por C&lt;rand()&gt; si quiere obtener enteros aleatorios en lugar de fraccionarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Where should I post source code?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230633Z" changeid="explorer">
        <seg>=head2 ¿Dónde debo publicar código fuente?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.8.0 release and
the 5.9.0 release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030533Z" changeid="explorer">
        <seg>Este documento describe las diferencias entre la versión 5.8.0 y la versión 5.9.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;caller&gt;, C&lt;continue&gt;, C&lt;die&gt;, C&lt;do&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;exit&gt;,
C&lt;goto&gt;, C&lt;last&gt;, C&lt;next&gt;, C&lt;redo&gt;, C&lt;return&gt;, C&lt;sub&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201740Z" changeid="explorer">
        <seg>C&lt;caller&gt;, C&lt;continue&gt;, C&lt;die&gt;, C&lt;do&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;exit&gt;,
C&lt;goto&gt;, C&lt;last&gt;, C&lt;next&gt;, C&lt;redo&gt;, C&lt;return&gt;, C&lt;sub&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An C&lt;our&gt; declaration may also have a list of attributes associated
with it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una declaración C&lt;our&gt; también puede tener una lista de atributos asociados a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular with GCC-2.7.2.x accept all the defaults
and *watch* out for the message:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, con GCC-2.7.2.x acepte todos los valores por defecto, y *busque* por el siguiente mensaje:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in( @INC )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225446Z" changeid="explorer">
        <seg>in( @INC )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Something like a UUCP or PPP chat
script or an expect script fits the bill nicely, as do configuration
scripts run by a program at its start up, such F&lt;.cshrc&gt; or F&lt;.ircrc&gt;,
for example.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231722Z" changeid="explorer">
        <seg>Algo como un script de chat UUCP o PPP, o un script de automatización con la utilidad expect, se ajusta muy bien a esta definición, igual que los scripts de configuración ejecutados en el inicio de un programa, como F&lt;.cshrc&gt; o F&lt;.ircrc&gt;,
por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shift EXPR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181145Z" changeid="explorer">
        <seg>=item shift EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check
the documentation on an individual feature to verify its current
status.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consulte la documentación de cada característica individual para verificar su estado actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @$aref, qw(a few more);        # ok</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031206Z" changeid="explorer">
        <seg>push @$aref, qw(a few more);        # ok</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Data::Dumper</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015035Z" changeid="explorer">
        <seg>=item Data::Dumper</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;$in&gt;) {     # assigns each line in turn to $_</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110204T164808Z" changeid="zipf">
        <seg>while (&lt;$entrada&gt;) {     # asigna una línea cada vez a $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write C&lt;/&gt;I&lt;sequence-item&gt; and the repeat count is obtained by
popping off the last element from the stack.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Escriba C&lt;/&gt;I&lt;secuencia-item&gt; y el contador de repeticiones se obtiene extrayéndolo del último elemento de la pila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [1]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225007Z" changeid="explorer">
        <seg>=item [1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($login, $passwd, $remainder) = split(/:/, $_, 3);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($login, $contraseña, $resto) = split(/:/, $_, 3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BEGIN { require Module }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BEGIN { require Módulo }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This doesn't apply to sysread()
and syswrite().)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001732Z" changeid="explorer">
        <seg>(esto no se aplica a sysread() ni a syswrite()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regexp</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Regexp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596004767</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003609Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596004767</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can
use the defined() operator to determine whether a scalar value is
defined (this has no meaning on arrays or hashes), and the undef()
operator to produce an undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede usar el operador defined() para determinar si un valor escalar está definido (esto no tiene significado si se aplica a arrays o hashes), y el operador undef() para producir un valor no definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New Core Modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200917Z" changeid="explorer">
        <seg>=head2 Nuevos módulos principales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each such format, pack() generates 4 bits of result.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T002619Z" changeid="explorer">
        <seg>Para cada formato así, pack() genera 4 bits del resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [2]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225042Z" changeid="explorer">
        <seg>=item [2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example: C&lt;&lt; ^(?&gt;a*)ab &gt;&gt; will never match, since C&lt;&lt; (?&gt;a*) &gt;&gt;
(anchored at the beginning of string, as above) will match I&lt;all&gt;
characters C&lt;a&gt; at the beginning of string, leaving no C&lt;a&gt; for
C&lt;ab&gt; to match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T011408Z" changeid="explorer">
        <seg>Por ejemplo: C&lt;&lt; ^(?&gt;a*)ab &gt;&gt; nunca coincidirá, ya que C&lt;&lt; (?&gt;a*) &gt;&gt; (anclada al comienzo de la cadena, como antes) encontrará I&lt;todos&gt; los caracteres C&lt;a&gt; al comienzo de la cadena, sin dejar ninguna otra para C&lt;ab&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no syseof() function, which is ok, since eof() doesn't work
well on device files (like ttys) anyway.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay función syseof(), que está bien, ya que, de todos modos, eof() no funciona bien con los archivos de dispositivo (como los ttys).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, C&lt;/a&gt; behaves like the C&lt;/u&gt; modifier, in that
case-insensitive matching uses Unicode semantics; for example, &quot;k&quot; will
match the Unicode C&lt;\N{KELVIN SIGN}&gt; under C&lt;/i&gt; matching, and code
points in the Latin1 range, above ASCII will have Unicode rules when it
comes to case-insensitive matching.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000027Z" changeid="explorer">
        <seg>De lo contrario, C&lt;/a&gt; se comporta como el modificador C&lt;/u&gt;, en que la comparación que no distingue entre mayúsculas y minúsculas utiliza semántica Unicode; por ejemplo, &quot;k&quot; coincidirá con el Unicode C&lt;\N{KELVIN SIGN}&gt; bajo C&lt;/i&gt;, y los puntos de código en el rango de Latin1, por encima de ASCII tendrá reglas Unicode cuando se trata de coincidencias que no distingan entre mayúsculas y minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;&lt; UNIVERSAL/&quot;$obj-&gt;DOES( ROLE )&quot; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T001041Z" changeid="explorer">
        <seg>Vea L&lt;&lt; UNIVERSAL/&quot;$obj-&gt;DOES( ROL )&quot; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = 'xyz'; print $x,&quot;\n&quot;;    # prints 1xyz4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = 'xyz'; print $x,&quot;\n&quot;;    # imprime 1xyz4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Math::Complex module (part of the standard perl distribution)
defines mathematical functions that work on both the reals and the
imaginary numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo Math::Complex (parte de la distribución estándar de Perl) define funciones matemáticas que funcionan tanto para reales como números imaginarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other escape sequences such as C&lt;\200&gt; and C&lt;\t&gt; and backslashed
characters such as C&lt;\\&gt; and C&lt;\-&gt; are replaced with appropriate
expansions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las otras secuencias de escape, como C&lt;\200&gt; y C&lt;\t&gt; y caracteres escapados con contrabarras, como C&lt;\\&gt; y C&lt;\-&gt;, son reemplazadas con los literales apropiados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it succeeds it
returns true; otherwise it returns false and sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000419Z" changeid="explorer">
        <seg>Si tiene éxito devuelve verdadero; en caso contrario devuelve falso y asigna C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a b c !;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a b c !;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Dumpvalue&gt; upgraded to version 1.12</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030551Z" changeid="explorer">
        <seg>C&lt;Dumpvalue&gt; actualizado a la versión 1.12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Beginning Perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003328Z" changeid="explorer">
        <seg>=item I&lt;Beginning Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [3]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225114Z" changeid="explorer">
        <seg>=item [3]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some pure-perl code that perl was using to retrieve Unicode properties and
transliteration mappings has been reimplemented in XS.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013923Z" changeid="explorer">
        <seg>Algunos códigos escritos en puro perl que se estaban usando para recuperar las propiedades Unicode y las asignaciones de transcripción ha sido reimplementados en XS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;STRING&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;CADENA&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A regexp in C&lt;STDOUT&gt;'s destructor used to coredump, because the regexp pad
was already freed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T211104Z" changeid="explorer">
        <seg>Una expresión regular en el destructor de C&lt;STDOUT&gt; se usa en el volcado del núcleo, ya que la plataforma de expresiones regulares ya fue liberada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># whole record case-insensitively otherwise</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># el registro, independientemente del tamaño de caja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>! ~ \ u+ u-             &lt;=&gt;        cmp           tpj.com</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043348Z" changeid="explorer">
        <seg>! ~ \ u+ u-             &lt;=&gt;        cmp           tpj.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a here-doc within a delimited construct, such as in C&lt;s///eg&gt;,
the quoted material must come on the lines following the final delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si utiliza un documento incrustado en una construcción delimitada, como en C&lt;s///eg&gt;, el material entrecomillado debe venir en las siguientes líneas al delimitador final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;I have %d dog%s.\n&quot;, $n,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Tengo %d perro%s.\n&quot;, $n,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently you have the choice between ExtUtils::MakeMaker and the
more platform independent Module::Build, allowing modules to be installed in a
consistent manner.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030850Z" changeid="explorer">
        <seg>Actualmente tiene la posibilidad de elegir entre ExtUtils::MakeMaker y la más independiente de la plataforma, Module::Build, permitiendo módulos que se instalen de una forma coherente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when( /^[+-]?\d+\z/ )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225621Z" changeid="explorer">
        <seg>when( /^[+-]?\d+\z/ )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Switching in a loop</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Conmutando en un bucle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A few general-purpose tools are shipped with perl, mostly because they
came along modules included in the perl distribution.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234703Z" changeid="explorer">
        <seg>También se distribuyen con perl algunas herramientas de propósito general, básicamente porque forman parte de módulos incluidos en la distribución de perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifiers
that relate to the interpretation of the regular expression inside
are listed below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los modificadores que se relacionan con la interpretación de la expresión regular del interior se enumeran a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These modifiers are especially useful 
given how C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt;, and C&lt;V&gt; don't cover signed integers, 
64-bit integers, or floating-point values.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003145Z" changeid="explorer">
        <seg>Estos modificadores son especialmente útiles dado que C&lt;n&gt;, C&lt;N&gt;, C&lt;v&gt; y C&lt;V&gt; no cubren valores enteros con signo, enteros de 64 bits, o de punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation clarified and errors corrected.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Documentación clarificada y errores corregidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can only use the triple-dot operator to stand in for a complete statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225417Z" changeid="explorer">
        <seg>Sólo se puede utilizar el operador triple punto en lugar de una instrucción completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 16  ==       4096 00000000000010000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 16  ==       4096 00000000000010000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item [4]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225146Z" changeid="explorer">
        <seg>=item [4]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If I&lt;not&gt; used in this way, the result of evaluation of
C&lt;code&gt; is put into the special variable C&lt;$^R&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T222027Z" changeid="explorer">
        <seg>Si I&lt;no&gt; se usa de esta manera, el resultado de la evaluación de C&lt;código&gt; se pone en la variable especial C&lt;$^R&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$old_filter = $db-&gt;filter_fetch_key  ( sub { ... } );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T153014Z" changeid="zipf">
        <seg>$filtro_antiguo = $db-&gt;filter_fetch_key  ( sub { ... } );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a couple of exceptions to the above rule.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T220831Z" changeid="explorer">
        <seg>Hay un par de excepciones a la regla anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The Arrow Operator
X&lt;arrow&gt; X&lt;dereference&gt; X&lt;&lt; -&gt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T232403Z" changeid="explorer">
        <seg>=head2 El operador flecha
X&lt;arrow&gt; X&lt;dereference&gt; X&lt;&lt; -&gt; &gt;&gt; X&lt;flecha&gt; X&lt;desreferencia&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To email a bug report, send it to
bug-E&lt;lt&gt;distribution-nameE&lt;gt&gt;@rt.cpan.org . For example, if you
wanted to report a bug in C&lt;Business::ISBN&gt;, you could send a message to
bug-Business-ISBN@rt.cpan.org .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231225Z" changeid="explorer">
        <seg>Para notificar un informe de error, envíe un mensaje de correo electrónico a 
bug-E&lt;lt&gt;nombre-distribuciónE&lt;gt&gt;@rt.cpan.org . Por ejemplo, si desea notificar un error de C&lt;Business::ISBN&gt;, debe enviar un mensaje a bug-Business-ISBN@rt.cpan.org .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, contrary to the
expectations of shell programmers, back-quotes do I&lt;NOT&gt; interpolate
within double quotes, nor do single quotes impede evaluation of
variables when used within double quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, contrariamente a las expectativas de los programadores de shell, las comillas invertidas I&lt;NO&gt; interpolan entre comillas dobles, ni las comillas simples impiden la evaluación de las variables cuando se usan dentro de comillas dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For threaded Perls certain system database functions like getpwent()
and getgrent() now grow their result buffer dynamically, instead of
failing.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T011100Z" changeid="explorer">
        <seg>Para Perls con soporte de I&lt;threads&gt;, ciertas funciones de base de datos del sistema como getpwent() y getgrent(), ahora hacen crecer sus búfer de resultados de forma dinámica, en lugar de fallar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>was simply wrong because there are no &quot;[] ranges&quot; in tr///.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002027Z" changeid="explorer">
        <seg>simplemente estaba mal, porque no existen &quot;rangos []&quot; en tr///.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE: while (&lt;STDIN&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050903Z" changeid="explorer">
        <seg>LINEA: while (&lt;STDIN&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use 5.010;  # so we can use say()</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T025903Z" changeid="explorer">
        <seg>use 5.010;  # para que podamos usar say()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Miscellaneous functions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones varias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading from non-string scalars (like the special variables, see
L&lt;perlvar&gt;) now works.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T174149Z" changeid="explorer">
        <seg>Leer de escalares que no sean cadenas (como las variables especiales, vea L&lt;perlvar&gt;) ahora funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receive and decode</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235025Z" changeid="explorer">
        <seg>Recibir y descodificar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takes extra time to study SCALAR (C&lt;$_&gt; if unspecified) in anticipation of
doing many pattern matches on the string before it is next modified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toma tiempo extra para estudiar ESCALAR (C&lt;$_&gt; si no se especifica) en previsión de hacer muchos patrones de coincidencia en la cadena antes de que sea modificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.   string concatenation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055544Z" changeid="explorer">
        <seg>.   concatenación de cadenas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/%INC&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/%INC&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other
languages have borrowed syntax from Perl, particularly its regular
expression extensions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros lenguajes han tomado prestada la sintaxis de Perl, particularmente sus extensiones de expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsymbian&gt; for more
information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014054Z" changeid="explorer">
        <seg>Vea L&lt;perlsymbian&gt; para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If OFFSET and LENGTH specify a substring that is partly outside the
string, only the part within the string is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si DESPLAZAMIENTO y LONGITUD especifican una subcadena que está parcialmente fuera de la cadena, sólo la parte de dentro de la cadena se devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The '$' symbol works
semantically like the English word &quot;the&quot; in that it indicates a
single value is expected.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El signo '$' funciona semánticamente como en Español la palabra &quot;el&quot;, indicando que se espera un único valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If most of your users have to
type a few almost identical lines of code when they start using your
module, it's a sign that you should have made that behaviour a default.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021240Z" changeid="explorer">
        <seg>Si la mayoría de los usuarios tienen que escribir unas pocas líneas casi idénticas de código cuando empiezan a usar su módulo, es una señal de que debería haber hecho este comportamiento por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exit $!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171117Z" changeid="explorer">
        <seg>exit $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These various prefixes correspond to the fopen(3) modes of C&lt;r&gt;,
C&lt;r+&gt;, C&lt;w&gt;, C&lt;w+&gt;, C&lt;a&gt;, and C&lt;a+&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T002624Z" changeid="explorer">
        <seg>Estos prefijos se corresponden con los modos de la función fopen(3) de C&lt;r&gt;, C&lt;r+&gt;, C&lt;w&gt;, C&lt;w+&gt;, C&lt;a&gt; y C&lt;a+&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = (stat($filename))[2];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = (stat($archivo))[2];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exists EXPR
X&lt;exists&gt; X&lt;autovivification&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T172219Z" changeid="explorer">
        <seg>=item exists EXPR
X&lt;exists&gt; X&lt;autovivification&gt; X&lt;autovivificación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Context
X&lt;context&gt; X&lt;scalar context&gt; X&lt;list context&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T012610Z" changeid="explorer">
        <seg>=head2 Contexto
X&lt;context&gt; X&lt;scalar context&gt; X&lt;list context&gt; X&lt;contexto&gt; X&lt;contexto escalar&gt; X&lt;contexto lista&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exit $?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171132Z" changeid="explorer">
        <seg>exit $?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;cond_timedwait&gt; has been added.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se ha añadido C&lt;cond_timedwait&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $var;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000903Z" changeid="explorer">
        <seg>my $var;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;next&gt; explicitly iterates the other loop
rather than merely terminating the inner one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;next&gt; explícitamente itera sobre el otro bucle en vez de meramente terminar el interno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are certain application spaces which are already very, very well
served by CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031156Z" changeid="explorer">
        <seg>Hay ciertos espacios de aplicación que ya están muy, muy bien servidos por CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	&lt;&lt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	&lt;&lt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;encoding(utf-8-strict)&gt; with partial characters now works</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034121Z" changeid="explorer">
        <seg>C&lt;encoding(utf-8-strict)&gt; ahora funciona con caracteres no completos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;#&gt;
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El carácter C&lt;#&gt; también es considerado un metacarácter que antecede a un comentario, al igual que en el código normal de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlvms/&quot;$?&quot;&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153217Z" changeid="explorer">
        <seg>Vea L&lt;perlvms/&quot;$?&quot;&gt; para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Something like C&lt;&quot;\Q\\E&quot;&gt; has
no C&lt;\E&gt; inside.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algo como C&lt;&quot;\Q\\E&quot;&gt; no tiene dentro a C&lt;\E&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/re.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010040Z" changeid="explorer">
        <seg>=item t/op/re.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ordering of the matches is the same as for the
chosen subexpression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T000912Z" changeid="explorer">
        <seg>El orden de las coincidencias es el mismo que para la subexpresión seleccionada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 FINDING YOUR WAY AROUND</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T013231Z" changeid="explorer">
        <seg>=head1 ORIENTACIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>STDOUT will typically be line buffered if
output is to the terminal and block buffered otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231603Z" changeid="explorer">
        <seg>STDOUT will typically be line buffered if
output is to the terminal and block buffered otherwise.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbot		Perl OO tricks and examples</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000215Z" changeid="explorer">
        <seg>perlbot		Trucos y ejemplos de POO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Malloc wrapping</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T103026Z" changeid="explorer">
        <seg>=head2 Envolviendo a Malloc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LINEA:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\a                  alarm (bell)      (BEL)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T185945Z" changeid="explorer">
        <seg>\a		alarma (campana)			(BEL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo, 20,  4) = 2;      # 'PerlPerlPe'   . &quot;\x02&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052405Z" changeid="explorer">
        <seg>vec($foo, 20,  4) = 2;      # 'PerlPerlPe'   . &quot;\x02&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>His presentation &quot;UTF-8 in the wild&quot; (Dutch
Perl Workshop 2006) inspired me to publish my thoughts and write this tutorial.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235513Z" changeid="explorer">
        <seg>Su presentación &quot;UTF-8 in the wild&quot; (Dutch Perl Workshop 2006) me sirvió de inspiración para publicar mis ideas y escribir este tutorial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\L          lowercase till \E (think vi)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043851Z" changeid="explorer">
        <seg>\L		pasar a minúscula hasta \E (como en vi)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^\s+//;           # trim leading whitespace</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^\s+//;           # quita los primeros espacios en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>world&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233559Z" changeid="zipf">
        <seg>a todos&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Under VMS, the
variable C&lt;$ENV{SYS$LOGIN}&gt; is also checked, and used if it is set.) If
neither is set, C&lt;chdir&gt; does nothing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Bajo VMS, la variable C&lt;$ENV{SYS$LOGIN}&gt; es también comprobada y usada si está puesta). Si ninguna está puesta, C&lt;chdir&gt; no hace nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>STORESIZE this, count</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>STORESIZE este, contador</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;assertions::compat&gt;, also available on CPAN, allows the use of assertions on
perl versions prior to 5.9.0 (that is the first one to natively support
them).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013009Z" changeid="explorer">
        <seg>C&lt;assertions::compat&gt;, también disponible en CPAN, permite el uso de aserciones en versiones perl anteriores a 5.9.0 (que fue el primero en soportarlas nativamente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of each publically accessible method or subroutine, including
parameters and return values</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024036Z" changeid="explorer">
        <seg>El uso de cada método o subrutina públicamente accesible, incluidos los parámetros y valores devueltos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;==&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;==&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Simple Statements
X&lt;statement&gt; X&lt;semicolon&gt; X&lt;expression&gt; X&lt;;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012859Z" changeid="explorer">
        <seg>=head2 Instrucciones simples
X&lt;statement&gt; X&lt;semicolon&gt; X&lt;expression&gt; X&lt;;&gt; X&lt;instrucción&gt; X&lt;punto y coma&gt; X&lt;expresión&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional state for the subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estado opcional para la subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note
however that look-ahead and look-behind are NOT the same thing.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T210219Z" changeid="explorer">
        <seg>Tenga en cuenta, sin embargo, que antecedente y consiguiente NO son la misma cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given ($something) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>given ($algo) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One effect of these rules is that -bareword is equivalent
to the string &quot;-bareword&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Uno de los efectos de estas reglas es -palabra es equivalente a la cadena &quot;-palabra&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#  0         1          2      3            4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># 0         1         2       3           4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@tmp = somefunc($i);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@tmp = algunafuncion($i);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is semantically equivalent to the list:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es semánticamente equivalente a la lista:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>__END__</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>__END__</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;File::Basename&gt; upgraded to version 2.74, with changes contributed by Michael Schwern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031239Z" changeid="explorer">
        <seg>C&lt;File::Basename&gt; actualizado a la versión 2.74, con cambios aportados por Michael Schwern.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unix datagram sockets aren't implemented in
Haiku yet.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los datagramas sockect Unix aún no están implementados en Haiku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.bebits.com/app/4030</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://www.bebits.com/app/4030</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of Perl 5.11.2 you can use a bare C&lt;readdir&gt; in a C&lt;while&gt; loop,
which will set C&lt;$_&gt; on every iteration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de Perl 5.11.2 puede usar un simple C&lt;readdir&gt; en un bucle C&lt;while&gt;, que actualizará C&lt;$_&gt; en cada iteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;map&gt; is now context
aware, and will not construct a list if called in void context.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171008Z" changeid="explorer">
        <seg>C&lt;map&gt; ahora depende del contexto, y no construirá una lista si es llamado en contexto vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be prepared for a wait.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Prepárese para una espera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document may be distributed under the same terms as Perl itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T152819Z" changeid="explorer">
        <seg>Este documento puede ser distribuido bajo los mismos términos que los del propio Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;shasum&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013437Z" changeid="explorer">
        <seg>=head2 C&lt;shasum&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($i = 0; $i &lt;= $max; $i++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232637Z" changeid="explorer">
        <seg>for ($i = 0; $i &lt;= $max; $i++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;FILEHANDLE&gt; may also be spelled C&lt;readline(*FILEHANDLE)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014108Z" changeid="explorer">
        <seg>&lt;IDENTIFICADOR_ARCHIVO&gt; también puede ser escrito como C&lt;readline(*IDENTIFICADOR_ARCHIVO)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;shasum&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235008Z" changeid="explorer">
        <seg>=item L&lt;shasum&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used as an lvalue, C&lt;keys&gt; allows you to increase the number of hash buckets
allocated for the given hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usado como valor a la izquierda (lvalue), C&lt;keys&gt; le permite incrementar el número de alojamientos de memoria hash para el hash indicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl runs on Windows 95 as well, but it
cannot be built there, for lack of a reasonable command interpreter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl se ejecuta en Windows 95 también, pero no se puede compilar ahí, por falta de un intérprete de comandos razonable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this was not true
of versions of Perl before 5.004, so if your script will run under older
Perl versions, it should call C&lt;srand&gt;; otherwise most programs won't call
C&lt;srand()&gt; at all.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182847Z" changeid="explorer">
        <seg>Sin embargo, esto no fue cierto para las versiones de Perl anteriores a la 5.004, así que si su programa se va a ejecutar en versiones anteriores de Perl, debería llamar a C&lt;srand&gt;; de lo contrario, la mayor parte de los programas no llamarán nunca a C&lt;srand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$*&gt;, which was deprecated in favor of the C&lt;/s&gt; and C&lt;/m&gt; regexp
modifiers, has been removed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142708Z" changeid="explorer">
        <seg>C&lt;$*&gt;, que estaba en desuso en favor de los modificadores de exp. reg. C&lt;/s&gt; y C&lt;/m&gt;, ha sido eliminada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $cycle; # FFFFFF</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>print $cycle; # FFFFFF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most common CPAN version numbering scheme looks like this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025419Z" changeid="explorer">
        <seg>El esquema de numeración de versiones más común en CPAN es el siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no C&lt;systell&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe la función C&lt;systell&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc/&quot;Using open() for IPC&quot;&gt; for more examples of this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc/&quot;Usando open() por IPC&quot;&gt; para más ejemplos de sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n = 12.34e-56;	    # exponential notation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232306Z" changeid="explorer">
        <seg>$n = 12.34e-56;         # notación exponencial</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Numeric functions
X&lt;numeric&gt; X&lt;number&gt; X&lt;trigonometric&gt; X&lt;trigonometry&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200922Z" changeid="explorer">
        <seg>=item Funciones numéricas
X&lt;numeric&gt; X&lt;number&gt; X&lt;trigonometric&gt; X&lt;trigonometry&gt; X&lt;numérico&gt; X&lt;número&gt; X&lt;trigonométrica&gt; X&lt;trigonomía&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How come?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Por qué?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;code&gt; is not interpolated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T182536Z" changeid="explorer">
        <seg>El C&lt;código&gt; no es interpolado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5123delta	Perl changes in version 5.12.3</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141515Z" changeid="explorer">
        <seg>perl5123delta	Cambios en la versión 5.12.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is now known to build again in LynxOS.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T183248Z" changeid="explorer">
        <seg>Se sabe que Perl se compila también ahora en LynxOS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>redo LINE unless eof(); # not eof(ARGV)!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>redo LINEA unless eof(); # ¡no es eof(ARGV)!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;Z&gt; always packs a trailing null, except
when the count is 0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T002457Z" changeid="explorer">
        <seg>Por lo tanto C&lt;Z&gt; siempre empaqueta un valor nulo adicional, excepto cuando el contador es 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But see the &quot;\&quot; operator for taking a reference.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220105Z" changeid="explorer">
        <seg>(Vea, sin embargo, el operador &quot;\&quot; para tomar una referencia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't get a list
like C&lt;(1,2,3)&gt; into being in scalar context, because the compiler knows
the context at compile time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede conseguir que una lista como C&lt;(1,2,3)&gt; se convierta en contexto escalar porque el compilador conoce el contexto en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this is slightly more flexible than the behavior of some
B&lt;tr&gt; programs, which delete anything they find in the SEARCHLIST,
period.) If the C&lt;/s&gt; modifier is specified, sequences of characters
that were transliterated to the same character are squashed down
to a single instance of the character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tenga en cuenta que esto es un poco más flexible que el comportamiento de algunos programas B&lt;tr&gt;, que eliminan todo lo que encuentre en la LISTA_BÚSQUEDA, y punto). Si se especifica el modificador C&lt;/s&gt;, las secuencias de caracteres que se transliteren al mismo carácter son reducidos hasta una única instancia del carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>package Foo;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>package Foo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invalid [] range &quot;%s&quot; in transliteration operator</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001955Z" changeid="explorer">
        <seg>Rango &quot;%s&quot; inválido [] en el operador de transliteración</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225511Z" changeid="explorer">
        <seg>use POSIX;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The syntax descriptions omit the
parentheses.)  If you use parentheses, the simple but occasionally 
surprising rule is this: It I&lt;looks&gt; like a function, therefore it I&lt;is&gt; a
function, and precedence doesn't matter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Las descripciones sintácticas omiten los paréntesis). Si usa los paréntesis, la simple (pero ocasionalmente sorprendente) regla es esta: Si I&lt;se parece&gt; a una función, por eso I&lt;es&gt; una función y la precedencia no importará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A slice accesses several elements of a list, an array, or a hash
simultaneously using a list of subscripts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234735Z" changeid="explorer">
        <seg>Una porción accede a varios elementos de una lista, un array, o un hash, de forma simultánea, usando una lista de índices.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can manipulate C&lt;@_&gt; in other ways too:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233225Z" changeid="zipf">
        <seg>También podemos manipular C&lt;@_&gt; de otras maneras:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This applies equally to method names, parameter names, and anything else
which is visible to the user (and most things that aren't!)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021513Z" changeid="explorer">
        <seg>Esto se aplica igualmente a los nombres de los métodos, los nombres de los parámetros, y cualquier otra cosa que sea visible para el usuario (¡y la mayoría de cosas que no lo son!)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ok 2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ok 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ok 3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ok 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On error, C&lt;unlink&gt; will not tell you which files it could not remove.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de error, C&lt;unlink&gt; no indicará qué archivos no se han podido borrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ok 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ok 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider always blessing objects in CLASSNAMEs that are mixed case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considerar siempre bautizar objetos de NOMBRECLASE que mezcle mayúsculas y minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-w  File is writable by effective uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004514Z" changeid="explorer">
        <seg>-w  Archivo es escribible por el uid/gid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5130delta - what is new for perl v5.13.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052412Z" changeid="explorer">
        <seg>perl5130delta - qué hay de nuevo en perl v5.13.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print MEMORY &quot;foo!\n&quot;;                   # output will appear in $var</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print MEMORIA &quot;foo!\n&quot;;              # la salida aparecerá en $var</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OpenEdition (UNIX System Services) does not (yet) support the #!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T111736Z" changeid="explorer">
        <seg>OpenEdition (UNIX System Services) (aún) no soporta el #!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is now support for Symbian S60 3.2 SDK and S60 5.0 SDK.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153156Z" changeid="explorer">
        <seg>Ahora hay soporte para Symbian S60 3.2 SDK y S60 5.0 SDK.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#x&gt;',  12;   # prints &quot;&lt;0xc&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#x&gt;',  12;   # imprime &quot;&lt;0xc&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's another example.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003436Z" changeid="explorer">
        <seg>Aquí hay otro ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Simple matching</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T234126Z" changeid="zipf">
        <seg>=item Detección de coincidencias sencilla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Select the riscos hint file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Seleccione el archivo de pistas para riscos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
the C&lt;open&gt; involved a pipe, the return value happens to be the pid of
the subprocess.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el C&lt;open&gt; contiene una tubería, el valor de retorno pasa a ser el pid del subproceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: not all implementations are
capable of returning the $timeleft.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota: no todas las implementaciones son capaces de devolver $tiempo_restante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($answer = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($respuesta = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the first integer after the first = sign, or the</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># el primer entero después del signo =, o, de otra forma, todo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The typical input/output flow of a program is:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235020Z" changeid="explorer">
        <seg>El flujo de entrada/salida típico de un programa es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub unlock {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub unlock {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub new { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub new { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, subroutines are named with an initial '&amp;', though this
is optional when unambiguous, just as the word &quot;do&quot; is often redundant
in English.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de lo anterior, las subrutinas se nombran empezando por '&amp;', aunque ésto es opcional cuando no provoque ambigüedad, igual que el sujeto de una frase en español es a menudo redundante cuando va implícito en el verbo, como en &quot;(yo) tengo lo que usted necesita&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5 gid    5 year-1900  5 wantarray    $!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224342Z" changeid="explorer">
        <seg>5 gid    5 año-1900   5 wantarray       $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a filetest operator, with the exception of C&lt;-s&gt;, C&lt;-M&gt;, C&lt;-A&gt;, and C&lt;-C&gt;,
that return numerical values, not boolean ones.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>un operador de test de archivo, con la excepción de C&lt;-s&gt;, C&lt;-M&gt;, C&lt;-A&gt;, y C&lt;-C&gt;, que devuelven valores numéricos, no booleanos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time all must be OK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta vez, todo debe estar bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+           Match 1 or more times</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042637Z" changeid="explorer">
        <seg>+	Coincide con 1 o más veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Produces a fatal error if used on a
machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Produce un error fatal si se usa en una máquina que no implemente flock(2), bloqueo fcntl(2), o lockf(3).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/win32/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014702Z" changeid="explorer">
        <seg>=item * F&lt;t/win32/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for filehandles, files, or directories
X&lt;file&gt; X&lt;filehandle&gt; X&lt;directory&gt; X&lt;pipe&gt; X&lt;link&gt; X&lt;symlink&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004359Z" changeid="explorer">
        <seg>=item Funciones para identificadores de archivo, archivos y directorios
X&lt;file&gt; X&lt;filehandle&gt; X&lt;directory&gt; X&lt;pipe&gt; X&lt;link&gt; X&lt;symlink&gt; X&lt;archivo&gt; X&lt;identificador de archivo&gt; X&lt;enlace&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are upgrading from an earlier release such as 5.6.1, first read
the L&lt;perl58delta&gt;, which describes differences between 5.6.0 and
5.8.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005500Z" changeid="explorer">
        <seg>Si está actualizando desde una versión anterior como la 5.6.1, primero lea L&lt;perl58delta&gt;, que describe las diferencias entre 5.6.0 y la 5.8.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And note that C&lt;/x&gt; doesn't affect
space interpretation within a single multi-character construct.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163356Z" changeid="explorer">
        <seg>Y tenga en cuenta que C&lt;/x&gt; no afecta a la interpretación del espacio en el interior de la construcción de un multicarácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push $AoA[0], &quot;wilma&quot;, &quot;betty&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032346Z" changeid="explorer">
        <seg>push $AoA[0], &quot;wilma&quot;, &quot;betty&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;perl -i&gt; could C&lt;fchmod(stdin)&gt; by mistake.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110749Z" changeid="explorer">
        <seg>C&lt;perl -i&gt; podría hacer C&lt;fchmod(stdin)&gt; por error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On many Unix systems,
fdopen() fails when file descriptors exceed a certain value, typically 255.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005027Z" changeid="explorer">
        <seg>En muchos sistemas Unix, fdopen() falla cuando los descriptores de archivo exceden de un valor determinado, por lo general, 255.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Dave Cross</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003620Z" changeid="explorer">
        <seg>Dave Cross</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different definitions of Perl are given in L&lt;perl&gt;, L&lt;perlfaq1&gt; and
no doubt other places.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224627Z" changeid="explorer">
        <seg>En L&lt;perl&gt;, L&lt;perlfaq1&gt; y en muchos otros sitios se incluyen definiciones de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Capture groups</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045651Z" changeid="explorer">
        <seg>=head3 Grupos de captura</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort &amp;find_records(@key);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort &amp;busca_registros(@claves);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(&quot;, &quot;, reverse &quot;world&quot;, &quot;Hello&quot;); # Hello, world</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(&quot;, &quot;, reverse &quot;mundo&quot;, &quot;Hola&quot;); # Hola, mundo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On Win32, Perl can now use non-IFS compatible LSPs, which allows Perl to
work in conjunction with firewalls such as McAfee Guardian.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En Win32, Perl ahora puede usar no-IFS compatibles con LSP, que permite a Perl trabajar en conjunto con cortafuegos como McAfee Guardian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta asignación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ **= 3;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225557Z" changeid="explorer">
        <seg>$_ **= 3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some new features were added, e.g. the broot() method, you can now pass
parameters to config() to change some settings at runtime, and it is now
possible to trap the creation of NaN and infinity.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T173609Z" changeid="explorer">
        <seg>Algunas nuevas características han sido añadidas, por ejemplo, al método broot() ahora puede pasarle parámetros a config() para cambiar algunos ajustes en tiempo de ejecución, y ahora es posible atrapar la creación de NaN e infinity.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>| ^              REGEX METACHARS            REGEX MODIFIERS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224225Z" changeid="explorer">
        <seg>| ^              METACARACTERES EXP. REG.       MODIFICADORES EXP. REG.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ActiveState: Windows, Linux, Mac OS X, Solaris, AIX and HP-UX</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225750Z" changeid="explorer">
        <seg>ActiveState: Windows, Linux, Mac OS X, Solaris, AIX y HP-UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using a character valid in an identifier, whitespace is required
after the C&lt;m&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se utiliza un carácter válido en un identificador, se requiere espacios en blanco después de la C&lt;m&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are only required
occasionally to clarify issues of precedence.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224757Z" changeid="explorer">
        <seg>Solo son necesarios en algunos casos para aclarar la precedencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As documented in L&lt;overload&gt;, this conversion will work only over
literal parts of regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002554Z" changeid="explorer">
        <seg>Como se documenta en L&lt;overload&gt;, esta conversión funcionará solo en las partes literales de las expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	|| //</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	|| //</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-e 'print autoformat $_, {all=&gt;1}' $*&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225534Z" changeid="explorer">
        <seg>-e 'print autoformat $_, {all=&gt;1}' $*&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($self, $filename) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($self, $archivo) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;warn()&gt; or C&lt;carp()&gt; a message to STDERR.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023329Z" changeid="explorer">
        <seg>Un mensaje C&lt;warn()&gt; o C&lt;carp()&gt; a STDERR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can get at lists of keys and values with C&lt;keys()&gt; and
C&lt;values()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224932Z" changeid="explorer">
        <seg>Puede obtener una lista de las claves y los valores con C&lt;keys()&gt; y C&lt;values()&gt; respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can exclude the beginning point by
waiting for the sequence number to be greater than 1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede excluir el punto de partida esperando por un número de secuencia mayor que 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>INSTALLATION</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T203651Z" changeid="zipf">
        <seg>INSTALACIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;corelist&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234644Z" changeid="explorer">
        <seg>=item L&lt;corelist&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod a+x /boot/common/bin/perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod a+x /boot/common/bin/perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So by storing a reference as the value of an array or hash
element, you can easily create lists and hashes within lists and
hashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224952Z" changeid="explorer">
        <seg>Así, almacenando una referencia como el valor de un elemento de array o hash, puede crear fácilmente listas y hashes dentro de listas y hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function shmctl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC shmctl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;i!&gt; and C&lt;I!&gt; are also allowed, but only for completeness' sake:
they are identical to C&lt;i&gt; and C&lt;I&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;i!&gt; y C&lt;I!&gt; también están permitidos, pero solo a efectos de completar: son idénticos a C&lt;i&gt; y C&lt;I&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>inet_ntoa($myaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>inet_ntoa($myaddr);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl Foundation is an advocacy organization for the Perl language
which maintains the web site ( http://www.perl.org/ ) as a general
advocacy site for the Perl language.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231317Z" changeid="explorer">
        <seg>The Perl Foundation es una organización que respalda al lenguaje Perl y mantiene un sitio web ( http://www.perl.org/ ) como recurso general de apoyo a Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have to use the default
variable C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tiene que usar la variable por defecto C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Styles and techniques will therefore differ,
although some effort has been made to not vary styles too widely in the
same sections.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004527Z" changeid="explorer">
        <seg>Por esta razón, habrá diversos estilos y técnicas, pero se ha procurado que en una misma sección los estilos no varíen demasiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlipc		Perl interprocess communication</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000402Z" changeid="explorer">
        <seg>perlipc		Comunicación entre procesos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;pack&gt;, I&lt;sequence-item&gt; may have a repeat count, in which case
the minimum of that and the number of available items is used as the argument
for I&lt;length-item&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para C&lt;pack&gt;, I&lt;secuencia-item&gt; puede tener un contador de repeticiones, en cuyo caso el mínimo de él y del número de elementos disponibles es usado como el argumento para &lt;longitud-item&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hmm... that's still a bit ugly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194255Z" changeid="explorer">
        <seg>Hmm ... que aún es un poco feo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::BigInt upgraded to version 1.73</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::BigInt actualizado a la versión 1.73</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike most Unix utilities, Perl does not
arbitrarily limit the size of your data--if you've got the memory,
Perl can slurp in your whole file as a single string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001039Z" changeid="explorer">
        <seg>A diferencia de la mayoría de las utilidades Unix, Perl no limita de forma arbitraria el tamaño de los datos; si el sistema dispone de memoria suficiente, puede &quot;succionar&quot; un archivo completo como una sola cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do one thing and do it well</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013440Z" changeid="explorer">
        <seg>Haga una cosa y hágala bien</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should in general be leery of using functions that could
potentially return lists in scalar context without explicitly stating
such.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe, por lo general, desconfiar del uso de funciones que podrían devolver listas en contexto escalar sin constancia explícita de ello.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\()   list of refs
                          NUMBERS vs STRINGS  LINKS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224152Z" changeid="explorer">
        <seg>\()   lista referencias
                          NÚMEROS  CADENAS         VÍNCULOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($tX, $tY);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($tX, $tY);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^\d+/              string starts with one or more digits</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235606Z" changeid="zipf">
        <seg>/^\d+/              cadena que empieza por uno o varios dígitos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal arrays are ordered lists of scalars indexed
by number, starting with 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los arrays normales son listas ordenadas de escalares indexadas por números, empezando por 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode is encoded using several competing encodings, of which UTF-8 is the
most used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234403Z" changeid="explorer">
        <seg>Existen varias codificaciones de Unicode en competencia, de las cuales la más utilizada es UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;THIS and THAT are dups\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;THIS Y THAT son duplicados\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated to version 3.49.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052628Z" changeid="explorer">
        <seg>Actualizado a la versión 3.49.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also, in the Bourne shell tradition, specify an EXPR beginning
with C&lt;&lt; &gt;&amp; &gt;&gt;, in which case the rest of the string is interpreted
as the name of a filehandle (or file descriptor, if numeric) to be
duped (as C&lt;dup(2)&gt;) and opened.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004306Z" changeid="explorer">
        <seg>Puede también, en la tradición de Bourne shell, especificar una EXPR comenzando con C&lt;&lt; &gt;&amp; &gt;&gt;, en cuyo caso el resto de la cadena se interpreta como el nombre de un identificador de archivo (o descriptor de archivo, si es numérico) para que sea duplicado (con C&lt;dup(2)&gt;) y luego abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless the C&lt;/r&gt; option is used, the string specified with C&lt;=~&gt; must be a
scalar variable, an array element, a hash element, or an assignment to one
of those; in other words, an lvalue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031717Z" changeid="explorer">
        <seg>A menos que se use la opción C&lt;/r&gt;, la cadena especificada con C&lt;=~&gt; debe ser una variable escalar, un elemento de un array, un elemento hash, o una asignación a una de estas, es decir, un I&lt;ivalor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use state variables, one needs to enable them by using</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T000448Z" changeid="explorer">
        <seg>Para utilizar las variables C&lt;state&gt;, es necesario que las active mediante el uso de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But, Unicode properties can have spaces, so
in C&lt;\p{...}&gt; there can be spaces that follow the Unicode rules, for which see
L&lt;perluniprops/Properties accessible through \p{} and \P{}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220357Z" changeid="explorer">
        <seg>Pero, las propiedades Unicode pueden tener espacios, por lo que en C&lt;\p{...}&gt; puede haber espacios que sigan las reglas Unicode, para lo cual vea L&lt;perluniprops.pod/Propiedades accesibles a través de \p{} y \P{}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives users the freedom of
choice: if they want protected files, they might choose process umasks
of C&lt;022&gt;, C&lt;027&gt;, or even the particularly antisocial mask of C&lt;077&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto ofrece a los usuarios la libertad de elección: si quieren archivos protegidos, podrían elegir un umasks para el proceso de C&lt;022&gt;, C&lt;027&gt;, o incluso la máscara, particularmente antisocial, de C&lt;077&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When LAYER is present, using binmode on a text file makes sense.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T153202Z" changeid="explorer">
        <seg>Tiene sentido que CAPA esté presente, al usar binmode sobre un archivo de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to learn more about Perl 6, or have a desire to help in
the crusade to make Perl a better place then read the Perl 6 developers
page at http://dev.perl.org/perl6/ and get involved.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230105Z" changeid="explorer">
        <seg>Si desea obtener más información sobre Perl 6 o ayudar en la cruzada para mejorar Perl, visite la página para desarrolladores de Perl 6 en http://dev.perl.org/perl6/ y anímese a participar en el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you have to look for strings that you don't know till
runtime, you can build an entire loop as a string and C&lt;eval&gt; that to
avoid recompiling all your patterns all the time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si usted tiene que buscar en cadenas que no sabe hasta el tiempo de ejecución, puede crear un bucle completo como una cadena y luego hacerle un C&lt;eval&gt;, para evitar tener que volver a recompilar todos los patrones todo el tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computing MROs can be expensive.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115007Z" changeid="explorer">
        <seg>Calcular MRO puede ser costoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatic tab indexes are now disabled and new C&lt;-tabindex&gt; pragma has
been added to turn automatic indexes back on</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025349Z" changeid="explorer">
        <seg>Ahora están desactivados los índices automáticos de tabulación, y se ha añadido un nuevo pragma para volverlos a activar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a binary string, you would do things like:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234603Z" changeid="explorer">
        <seg>Con una cadena binaria puede realizar operaciones como estas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following are equivalent:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo siguiente es equivalente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Configure&gt; now invokes callbacks regardless of the value of the variable
they are called for.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;Configure&gt; ahora invoca retrollamadas, independientemente del valor de la variable que se requiera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gmtime</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gmtime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Self-explanatory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002108Z" changeid="explorer">
        <seg>Se explica por sí mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the major modules (C&lt;Tk&gt;, C&lt;CGI&gt;, C&lt;libwww-perl&gt;) have their own
mailing lists.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230931Z" changeid="explorer">
        <seg>La mayoría de los módulos importantes (C&lt;Tk&gt;, C&lt;CGI&gt;, C&lt;libwww-perl&gt;) tienen su propia lista de correo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl		Perl overview (this section)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000143Z" changeid="explorer">
        <seg>perl		Información general sobre Perl (esta sección)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your stdio requires a seek or eof between reads and writes on a
particular stream, so does Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001721Z" changeid="explorer">
        <seg>Si stdio requiere ejecutar seek o eof entre lecturas y escrituras para una secuencia determinada, Perl también lo requerirá</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tr/SEARCHLIST/REPLACEMENTLIST/cdsr
X&lt;tr&gt; X&lt;y&gt; X&lt;transliterate&gt; X&lt;/c&gt; X&lt;/d&gt; X&lt;/s&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T214212Z" changeid="explorer">
        <seg>=item tr/LISTA_BÚSQUEDA/LISTA_REEMPLAZO/cdsr
X&lt;tr&gt; X&lt;y&gt; X&lt;transliterate&gt; X&lt;/c&gt; X&lt;/d&gt; X&lt;/s&gt;
X&lt;transliterar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$_&gt; is lexical in the scope where the C&lt;grep&gt; appears (because it has
been declared with C&lt;my $_&gt;) then, in addition to being locally aliased to
the list elements, C&lt;$_&gt; keeps being lexical inside the block; i.e., it
can't be seen from the outside, avoiding any potential side-effects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$_&gt; es léxica en el ámbito de aplicación donde C&lt;grep&gt; aparece (porque se ha declarado con C&lt;my $_&gt;) entonces, además de ser un alias local a los elementos de la lista, C&lt;$_&gt; se mantiene léxica dentro del bloque; es decir, no puede ser vista desde el exterior, evitando cualquier potencial efecto colateral.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when ($_ &lt; 100) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when ($_ &lt; 100) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;xor&quot; returns the exclusive-OR of the two surrounding expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;xor&quot; devuelve la OR exclusiva de las dos expresiones que la rodean.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;*&quot; multiplies two numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;*&quot; multiplica dos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the key 12345 will get stored in the DBM database as the 5 byte string
&quot;12345&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T154234Z" changeid="zipf">
        <seg>la clave 12345 se almacenará en la base de datos DBM como una cadena de 5 bytes, &quot;12345&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the LABEL is
omitted, the command refers to the innermost enclosing loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la ETIQUETA se omite, el comando se refiere al bucle más interior en que se encuentre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The added randomness may affect applications.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135304Z" changeid="explorer">
        <seg>La aleatoriedad añadida puede afectar a las aplicaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a, b, c !;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a, b, c !;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good places to look for pre-existing modules include
http://search.cpan.org/ and asking on modules@perl.org</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014637Z" changeid="explorer">
        <seg>Un buen lugar para buscar módulos pre-existentes incluye http://search.cpan.org/ y preguntar en modules@perl.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The
following all specify the same class of three characters: C&lt;[-az]&gt;,
C&lt;[az-]&gt;, and C&lt;[a\-z]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T213011Z" changeid="explorer">
        <seg>(Los siguientes ejemplos especifican la misma clase de tres caracteres: C&lt;[-az]&gt;, C&lt;[az-]&gt; y C&gt;[a\-z]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can get more documentation, tutorials and community support
online at L&lt;http://www.perl.org/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000114Z" changeid="explorer">
        <seg>Puede obtener más documentación, tutoriales y soporte de la comunidad en línea en L&lt;http://www.perl.org/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to use a typeglob to save away
a filehandle, do it this way:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003626Z" changeid="explorer">
        <seg>Si necesita utilizar un typeglob para guardar un identificador de archivo, hágalo de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;POSIX&gt; upgraded to version 1.09</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034523Z" changeid="explorer">
        <seg>C&lt;POSIX&gt; actualizado a la versión 1.09</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$re = qr/^bar/; &quot;foo\nbar&quot; =~ /$re/m;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005243Z" changeid="explorer">
        <seg>$re = qr/^bar/; &quot;foo\nbar&quot; =~ /$re/m;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item uc EXPR
X&lt;uc&gt; X&lt;uppercase&gt; X&lt;toupper&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210028Z" changeid="explorer">
        <seg>=item uc EXPR
X&lt;uc&gt; X&lt;uppercase&gt; X&lt;toupper&gt; X&lt;mayúsculas&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$@&gt; is empty then the string C&lt;&quot;Died&quot;&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$@&gt; está vacío entonces se usa la cadena C&lt;&quot;Died&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;/o&gt; is described in the next section.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T232543Z" changeid="explorer">
        <seg>C&lt;/o&gt; se describe en la siguiente sección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the mode contains both the file type and its permissions, you
should mask off the file type portion and (s)printf using a C&lt;&quot;%o&quot;&gt;
if you want to see the real permissions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que el modo contiene el tipo de archivo y sus permisos, debe desenmascarar la porción de tipo de archivo y usar (s)printf con C&lt;&quot;%o&quot;&gt; si desea ver los permisos reales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when ([1,3,5,7,9]) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when ([1,3,5,7,9]) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An exception is raised if
VERSION is greater than the version of the current Perl interpreter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se genera una excepción si VERSIÓN es mayor que la versión actual del intérprete de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perllocale&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045832Z" changeid="explorer">
        <seg>L&lt;perllocale&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More utf8 bugs fixed, notably in how C&lt;chomp&gt;, C&lt;chop&gt;, C&lt;send&gt;, and
C&lt;syswrite&gt; and interact with utf8 data.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110208Z" changeid="explorer">
        <seg>Más errores de utf8 arreglados, sobre todo en cómo C&lt;chomp&gt;, C&lt;chop&gt;, C&lt;send&gt;, y C&lt;syswrite&gt; interactuan con datos utf8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The immediate, previous releases (i.e. perl5.8.x ) are usually maintained
for a while, although not at the same level as the current releases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200816Z" changeid="explorer">
        <seg>Las versiones anteriores más recientes (en este caso, perl5.10.x) suelen mantenerse durante un tiempo, aunque en menor medida que las versiones actuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (s/\\$//) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (s/\\$//) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl statements end in a semi-colon:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T180809Z" changeid="zipf">
        <seg>Las instrucciones de Perl deben terminar con un signo de punto y coma:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What is perl.com?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231234Z" changeid="explorer">
        <seg>=head2 ¿Qué es perl.com?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(*** The previous line contains the naughty word &quot;$1&quot;.\n)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(*** La línea anterior contiene la palabra juguetona &quot;$1&quot;.\n)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= += -= *= etc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005844Z" changeid="explorer">
        <seg>= += -= *= etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = @foo[$#foo-4 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = @foo[$#foo-4 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with C&lt;$1&gt; being the line number for the next line, and C&lt;$3&gt; being
the optional filename (specified with or without quotes).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>con C&lt;$1&gt; siendo el número de línea para la línea siguiente y C&lt;$3&gt; siendo el nombre de archivo opcional (especificado con o sin comillas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cybernetic pyrotechnics.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pirotecnia cibernética.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a*b is 1/11</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033514Z" changeid="explorer">
        <seg>a*b is 1/11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-C [I&lt;number/list&gt;] &gt;]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-C [I&lt;número/lista&gt;] &gt;]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The left argument is what is
supposed to be searched, substituted, or transliterated instead of the default
$_.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El argumento de la izquierda es lo que se supone que debe ser registrado, sustituido o transcrito en lugar del predeterminado $_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item reverse LIST
X&lt;reverse&gt; X&lt;rev&gt; X&lt;invert&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194714Z" changeid="explorer">
        <seg>=item reverse LISTA
X&lt;reverse&gt; X&lt;rev&gt; X&lt;invert&gt; X&lt;invertir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhacktips	Tips for Perl core C code hacking</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T015323Z" changeid="explorer">
        <seg>perlhacktips	Consejos para modificar el código C del núcleo de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 4) = 8   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 4) = 8   ==      32768 00000000000000010000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*d&gt;',  1, 0;   # prints &quot;&lt;0&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*d&gt;',  1, 0;   # imprime &quot;&lt;0&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 128 ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 128 ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shmget KEY,SIZE,FLAGS
X&lt;shmget&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200615Z" changeid="explorer">
        <seg>=item shmget CLAVE,TAMAÑO,BANDERAS
X&lt;shmget&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If MODE is C&lt;&lt; &gt; &gt;&gt;, the file is opened for output, with existing files
first being truncated (&quot;clobbered&quot;) and nonexisting files newly created.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T002214Z" changeid="explorer">
        <seg>Si MODO es C&lt;&lt; &gt; &gt;&gt;, el archivo es abierto para salida. Los archivos que ya existan serán truncados (&quot;sobreescritos&quot;); y los que no existan serán creados como nuevos archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This keyword is enabled by the C&lt;&quot;switch&quot;&gt; feature: see
L&lt;feature&gt; for more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022951Z" changeid="explorer">
        <seg>Esta palabra clave se activa con la característica C&lt;&quot;switch&quot;&gt;: vea L&lt;feature&gt; para más información</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of EXPR with all non-&quot;word&quot;
characters backslashed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor de EXPR con todos los caracteres que no sean &quot;palabra&quot; con una barra invertida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Designing your API</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020510Z" changeid="explorer">
        <seg>=head2 El diseño de su API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prior to Perl version 5.9.1, the result of using an lvalue multiple times was
unspecified.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203453Z" changeid="explorer">
        <seg>Antes de la versión Perl 5.9.1, no estaba especificado el resultado de usar varias veces un I&lt;ivalor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use named parameters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021531Z" changeid="explorer">
        <seg>Use parámetros con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @AoA, [ split ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @AoA, [ split ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item select</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item select</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Win32)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014837Z" changeid="explorer">
        <seg>(Win32)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>microperl is supposed to be a really minimal perl, even more
minimal than miniperl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>microperl se supone que es realmente un perl mínimo, incluso aún más que el mínimo miniperl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning in November 2002, I&lt;TPJ&gt;
moved to a reader-supported monthly e-zine format in which subscribers
can download issues as PDF documents.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230908Z" changeid="explorer">
        <seg>En noviembre de 2002, I&lt;TPJ&gt; se convirtió en un boletín electrónico mensual ofrecido como suscripción que se podía descargar en formato PDF.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In newer FreeBSD releases Perl 5.8.0 compilation failed because of
trying to use F&lt;malloc.h&gt;, which in FreeBSD is just a dummy file, and
a fatal error to even try to use.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T183140Z" changeid="explorer">
        <seg>En las versiones más recientes de FreeBSD Perl 5.8.0 la compilación falló debido a que trata de utilizar F&lt;malloc.h&gt;, que en FreeBSD es solo un archivo ficticio, y es un error fatal incluso el tratar de usarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;-&gt; X&lt;negation, arithmetic&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;-&gt; X&lt;negation, arithmetic&gt; X&lt;negación, aritmética&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When
a numeric value is passed as an argument to such an operator, it will be
converted to the format understood by the operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232635Z" changeid="explorer">
        <seg>Cuando se pasa un valor numérico como argumento a un operador así, se convierte a un formato comprensible para el operador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212540Z" changeid="explorer">
        <seg>Por ejemplo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo,  0, 32) = 0x5065726C; # 'Perl'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($foo,  0, 32) = 0x5065726C; # 'Perl'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto&gt;-EXPR form expects a label name, whose scope will be resolved
dynamically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-EXPR espera un nombre de etiqueta, cuyo ámbito será resuelto dinámicamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str is now in UTF-8 format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001235Z" changeid="explorer">
        <seg>$str está ahora en formato UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus Perl allows such constructs, by I&lt;forcefully breaking
the infinite loop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231152Z" changeid="explorer">
        <seg>Así, Perl permite tales construcciones, I&lt;forzando la ruptura del bucle infinito&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The caret allows for simpler stringification of compiled regular
expressions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T194651Z" changeid="explorer">
        <seg>El circunflejo permite la conversión sencilla a cadena de caracteres de las expresiones regulares compiladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach my $arg (@ARGV) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach my $arg (@ARGV) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the new position, or the undefined value on failure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001819Z" changeid="explorer">
        <seg>Devuelve la nueva posición, o el valor indefinido en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($n == 1) ? &quot;&quot; : &quot;s&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224900Z" changeid="explorer">
        <seg>($n == 1) ? &quot;&quot; : &quot;s&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>no warnings;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no warnings;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To capture a command's STDERR and STDOUT together:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para capturar el STDOUT y STDERR del comando, juntos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($vec =~ tr/\0// / length $vec &gt; 0.95) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>if ($vec =~ tr/\0// / length $vec &gt; 0.95) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A few functions take no arguments at all, and therefore work as neither
unary nor list operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unas pocas funciones no toman ningún argumento, por lo que funcionan tanto como operadores unarios como operadores de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 1) = 1   ==          8 00010000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 1) = 1   ==          8 00010000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eventually, when a C&lt;write&gt; is done, the contents of
C&lt;$^A&gt; are written to some filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010631Z" changeid="explorer">
        <seg>Finalmente, cuando se hace un C&lt;write&gt;, los contenidos de C&lt;$^A&gt; se escriben al identificador de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Larry Wall, Nicholas Clark)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112038Z" changeid="explorer">
        <seg>(Larry Wall, Nicholas Clark)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($him, $her)   = @folks[0,-1];              # array slice</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($el, $ella)    = @gente[0,-1];              # porción array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,17, 1) = 1   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,17, 1) = 1   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if successful, false 
on error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000656Z" changeid="explorer">
        <seg>Devuelve verdadero si tuvo éxito, falso en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is what you want for text files, but it can be disastrous for
binary files.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022939Z" changeid="explorer">
        <seg>Esto es lo que usted quiere para los archivos de texto, pero puede ser desastroso para archivos binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you feel the urge to write Perl modules, L&lt;perlnewmod&gt; will give you
good advice.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121048Z" changeid="zipf">
        <seg>Si desea escribir módulos de Perl, L&lt;perlnewmod&gt; le ayudará a empezar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unknown 'strict' tag(s) '@ISA'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T175610Z" changeid="explorer">
        <seg>Unknown 'strict' tag(s) '@ISA'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item defined-or operator</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233502Z" changeid="explorer">
        <seg>=item Operador definido-or</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl
bug database at http://rt.perl.org/perlbug/ .  There may also be
information at http://www.perl.org/ , the Perl Home Page.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T231354Z" changeid="explorer">
        <seg>Si encuentra algo que piensa que es un error, podría verificar los artículos publicados recientemente en el grupo de noticias comp.lang.perl.misc y la base de datos de errores de perl en http://rt.perl.org/bugs . Hay también información en la página principal de Perl, http://www.perl.org/ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above recipes describe the ordering of matches I&lt;at a given position&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T000949Z" changeid="explorer">
        <seg>Las recetas anteriores describen el orden de las coincidencias I&lt;en una determinada posición&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given $foo {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>given $foo {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}xg );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050232Z" changeid="explorer">
        <seg>}xg );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To pass a
literal dollar-sign through to the shell you need to hide it with a
backslash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para pasar un signo de dólar literal al shell, necesita escaparlo con una barra invertida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### redo always comes here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>### redo siempre viene aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
produces a warning if warnings are enabled.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213607Z" changeid="explorer">
        <seg>Genera una advertencia si las advertencias están habilitadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bracketing construct C&lt;( ... )&gt; creates capture groups (also referred to as
capture buffers).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045738Z" changeid="explorer">
        <seg>La construcción de paréntesis C&lt;( ... )&gt; crea grupos de captura (también referidos como búferes de captura).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lcfirst EXPR
X&lt;lcfirst&gt; X&lt;lowercase&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175239Z" changeid="explorer">
        <seg>=item lcfirst EXPR
X&lt;lcfirst&gt; X&lt;lowercase&gt; X&lt;minúscula&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, assume
nothing about the returned string itself nor about how many bytes 
of SALT may matter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T024207Z" changeid="explorer">
        <seg>En otras palabras, no asuma nada sobre la cadena devuelta, ni sobre la cantidad de bytes de SALTO pueden importar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last update: 2008-10-29</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Última actualización: 2008-10-29</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;last&gt;, C&lt;next&gt;, or C&lt;redo&gt; may appear within a C&lt;continue&gt;
block; C&lt;last&gt; and C&lt;redo&gt; behave as if they had been executed within
the main block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;last&gt;, C&lt;next&gt; o C&lt;redo&gt; puede aparecer dentro de un bucle C&lt;continue&gt;; C&lt;last&gt; y C&lt;redo&gt; se comportarán como si se hubieran ejecutado dentro del bloque principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>++ --                   == !=      eq ne         cpan.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>++ --                   == !=      eq ne         cpan.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlink @goners;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlink @goners;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That won't work at all, because C&lt;.*&gt; was greedy and gobbled up the
whole string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233431Z" changeid="explorer">
        <seg>Eso no funciona de ninguna manera, porque C&lt;.*&gt; era codicioso y engulló toda la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;in bytes&gt;: even if the filehandle has been set to operate
on characters (for example by using the C&lt;:encoding(utf8)&gt; I/O layer),
tell() will return byte offsets, not character offsets (because
implementing that would render sysseek() unacceptably slow).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013022Z" changeid="explorer">
        <seg>Nota sobre lo de I&lt;en bytes&gt;: incluso si el identificador de archivo se ha puesto para operar en caracteres (por ejemplo usando la capa de E/S C&lt;:encoding(utf8)&gt;), tell() devolverá desplazamientos en bytes, no en caracteres (porque implementando esto convertirían en inaceptablemente lentas a seek() y tell()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might also try C&lt;perldoc perl&gt; in case your system doesn't
have a proper C&lt;man&gt; command, or it's been misinstalled.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230254Z" changeid="explorer">
        <seg>Si su sistema no ofrece un comando C&lt;man&gt;, o se ha desinstalado, también puede usar C&lt;perldoc perl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is a clever way of making your one-line
conditional blocks more English like:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225135Z" changeid="explorer">
        <seg>Sin embargo, puede escribir los bloques condicionales de una sola línea de manera que recuerden a una frase en inglés:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use 5.6.1;      # ditto</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use 5.6.1;      # ídem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::FixedPrecision   calculate with a fixed precision</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035344Z" changeid="explorer">
        <seg>Math::FixedPrecision		calcula con una precisión fija</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@eldest = sort { $age{$b} &lt;=&gt; $age{$a} } keys %age;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@eldest = sort { $edad{$b} &lt;=&gt; $edad{$a} } keys %edad;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TIEARRAY classname, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TIEARRAY clase, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CPAN indicates the base directory of a CPAN mirror, and the
rest of the path is the path from that directory to the file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230126Z" changeid="explorer">
        <seg>CPAN indica el directorio raíz de un servidor reflejado de CPAN, y el resto de la ruta de acceso es la ruta desde ese directorio al archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
claims that there is no 123 in the string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170101Z" changeid="explorer">
        <seg>Afirma que no hay un 123 en la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if
it succeeded, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tiene éxito; de lo contrario, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -Dcc=gcc -Duse64bitint</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002922Z" changeid="explorer">
        <seg>sh Configure -Dcc=gcc -Duse64bitint</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$re =~ s{
                \\ ( \\ | Y . )
              }
              { $rules{$1} or invalid($re,$1) }sgex;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002212Z" changeid="explorer">
        <seg>$re =~ s{
                \\ ( \\ | Y . )
              }
              { $reglas{$1} or invalido($re,$1) }sgex;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;sendfile&quot; will have internal linkage.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003755Z" changeid="explorer">
        <seg>&quot;sendfile&quot; tendrá un enlazado interno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;keys&gt;, C&lt;each&gt;, and C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;keys&gt;, C&lt;each&gt; y C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>socketpair(Rdr, Wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>socketpair(Rdr, Wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Sticky\n&quot; if -k _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Sticky\n&quot; if -k _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setgrent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setgrent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use only on a
scalar value, an array (using C&lt;@&gt;), a hash (using C&lt;%&gt;), a subroutine
(using C&lt;&amp;&gt;), or a typeglob (using C&lt;*&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use solamente sobre un valor escalar, un array (usando C&lt;@&gt;), un hash (con C&lt;%&gt;), una subrutina (con C&lt;&amp;&gt;), o un typeglob (usando C&lt;*&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So rewriting this way produces what
you'd expect; that is, case 5 will fail, but case 6 succeeds:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171549Z" changeid="explorer">
        <seg>Así que volviéndolo a escribir de esta manera produce lo que se espera, es decir, el caso 5 fallará, pero el caso 6 tendrá éxito:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you really want to continue using the C&lt;$*&gt;-variable but not to see
the deprecation warnings, use:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011808Z" changeid="explorer">
        <seg>Si realmente desea seguir utilizando la variable C&lt;$*&gt; pero no quiere ver la advertencia de obsolescencia, utilice:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;overload&gt; upgraded to version 1.04</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034002Z" changeid="explorer">
        <seg>C&lt;overload&gt; actualizado a la versión 1.04</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Files: &quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Archivos: &quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a -= 1;        # same as $a = $a - 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a -= 1;        # igual que $a = $a - 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is something like
adding a row at a time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es algo así como la adición de una fila cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in some shells, you can enclose the variable name in braces to
disambiguate it from following alphanumerics (and underscores).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que en algunos entornos de líneas de comandos, puede encerrar el nombre de la variable entre llaves para eliminar la ambigüedad de los ulteriores caracteres alfanuméricos (y guiones bajos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's say you'd like to match a number at the end
of a string, and you also want to keep the preceding part of the match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233046Z" changeid="explorer">
        <seg>Digamos que quisiera buscar la coincidencia con un número al final de una cadena, y también que desea mantener la parte anterior a esa coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 $AUTOLOAD can now be tainted</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T235943Z" changeid="explorer">
        <seg>=head2 $AUTOLOAD ahora puede ser contaminada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sort SUBNAME LIST
X&lt;sort&gt; X&lt;qsort&gt; X&lt;quicksort&gt; X&lt;mergesort&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200852Z" changeid="explorer">
        <seg>=item sort NOMBRE_SUB LISTA
X&lt;sort&gt; X&lt;qsort&gt; X&lt;quicksort&gt; X&lt;mergesort&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(ab(cd|ef)((gi)|j))/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113522Z" changeid="explorer">
        <seg>/(ab(cd|ef)((gi)|j))/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop control statements don't work in an C&lt;if&gt; or C&lt;unless&gt;, since
they aren't loops.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013439Z" changeid="explorer">
        <seg>Las instrucciones de control de bucle no funcionan en un C&lt;if&gt; o C&lt;unless&gt;, porque no son bucles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defined( $_ = &lt;$fh&gt; ) or die &quot;readline failed: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>defined( $_ = &lt;$fh&gt; ) or die &quot;readline falló: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line number</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224349Z" changeid="explorer">
        <seg>número de línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Algorithm::Loops qw(NextPermuteNum);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>use Algorithm::Loops qw(NextPermuteNum);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$b = 4/6;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033330Z" changeid="explorer">
        <seg>$b = 4/6;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following matches:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222525Z" changeid="explorer">
        <seg>Por ejemplo, lo siguiente coincide:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The internal structure of the C&lt;ext/&gt; directory in the perl source has
been reorganised.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190412Z" changeid="explorer">
        <seg>La estructura interna del directorio C&lt;ext/&gt; en el código fuente de perl, se ha reorganizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt; &gt; &lt;= &gt;= lt gt le ge   unless ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt; &gt; &lt;= &gt;= lt gt le ge   unless ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a short, but incomplete summary:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un breve resumen, aunque incompleto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlgpl has been added: it is the GNU General Public License in pod
format, making it easier for modules to refer to it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180919Z" changeid="explorer">
        <seg>perlgpl ha sido añadido: es la Licencia General Pública GNU en formato pod, haciendo más fácil para los módulos referirse a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Is it a Perl program or a Perl script?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231629Z" changeid="explorer">
        <seg>=head2 ¿Se debe decir programa Perl o script Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if it's an integer I&lt;n&gt;, the offset is relative to the start of the
I&lt;n&gt;th innermost C&lt;( )&gt; group, or to the start of the string if I&lt;n&gt; is
bigger then the group level.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T002215Z" changeid="explorer">
        <seg>Y si es un número entero I&lt;n&gt;, el desplazamiento es relativo al inicio del I&lt;n&gt;-ésimo grupo C&lt;()&gt; más interno, o al inicio de la cadena si I&lt;n&gt; es más grande que el número de grupos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrun&gt;
for the C&lt;-M&gt; and C&lt;-m&gt; command-line options to Perl that give C&lt;use&gt;
functionality from the command-line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlrun&gt; para las opciones en línea de comandos C&lt;-M&gt; y C&lt;-m&gt; para Perl que dan la funcionalidad de C&lt;use&gt; en la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my(@b) = splice(@_,0,shift);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my(@b) = splice(@_,0,shift);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@b = (1,undef)[1,0,2];  # @b has three elements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@b = (1,undef)[1,0,2];  # @b tiene tres elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SWITCH: {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SWITCH: {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%-12s &quot;, $pat;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233905Z" changeid="explorer">
        <seg>printf &quot;%-12s &quot;, $patron;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET
X&lt;syswrite&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013031Z" changeid="explorer">
        <seg>=item syswrite IDENTIFICADOR_ARCHIVO,ESCALAR,LONGITUD,DESPLAZAMIENTO
X&lt;syswrite&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$baz = 0+$foo &amp; 0+$bar;	# both ops explicitly numeric</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$baz = 0+$foo &amp; 0+$bar;	# ambas op. explícitamente numéricas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The substitution operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador de sustitución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identical to C&lt;(?PARNO)&gt; except that the
parenthesis to recurse to is determined by name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T191759Z" changeid="explorer">
        <seg>Idéntico a C&lt;(?PARNO)&gt; salvo que el paréntesis a re-ejecutar se determina por su nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously callbacks were only invoked in the
C&lt;case $variable $define)&gt; branch.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Retrollamadas anteriores solo se invocaban en la rama C&lt;case $variable $define)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the rest is either
converted to literal strings to match, or else is ignored (as is
whitespace and C&lt;#&gt;-style comments if C&lt;//x&gt; is present).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo lo demás es o bien convertido en cadenas de literales para ser cotejados, o bien es ignorado (como lo es el espacio en blanco y los comentarios C&lt;#&gt;, si C&lt;//x&gt; está presente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;INSTALL&gt; file for how to build Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El archivo F&lt;INSTALL&gt; (INSTALAR) de cómo construir Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's just F&lt;perlbug&gt; installed under
another name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234445Z" changeid="explorer">
        <seg>No es más que F&lt;perlbug&gt; instalado con otro nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of the 5.8.0 release, sysopen()/sysread()/syswrite() do not behave
like they used to in 5.6.1 and earlier with respect to &quot;text&quot; mode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T004543Z" changeid="explorer">
        <seg>A partir de la versión 5.8.0, sysopen()/sysread()/syswrite() no se comportan como lo hacían antes en 5.6.1 y anteriores, con respecto al modo &quot;texto&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;perldoc&gt; has been rewritten from scratch to be more robust and
feature rich.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180529Z" changeid="explorer">
        <seg>C&lt;perldoc&gt; ha sido reescrito desde cero para ser más robusto y rico en características.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further investigation
is needed to get this working better.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Será necesaria una investigación adicional para que esto funcione mejor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($colors{'red'}, $colors{'blue'}, $colors{'green'})
                   = (0xff0000, 0x0000ff, 0x00ff00);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043057Z" changeid="explorer">
        <seg>($colores{'rojo'}, $colores{'azul'}, $colores{'verde'})
                   = (0xff0000, 0x0000ff, 0x00ff00);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also exit(), warn(), and the Carp module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también exit(), warn() y el módulo Carp.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>native integer        --&gt; native floating point	(*)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113009Z" changeid="explorer">
        <seg>entero nativo         --&gt; punto flotante nativo (*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T193215Z" changeid="explorer">
        <seg>De otra forma:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because both scalars and lists are
automatically interpolated into lists.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es porque ambos tipos, escalares y listas, son automáticamente interpolados en listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More subtle problem is reliance on the order of &quot;global destruction&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135735Z" changeid="explorer">
        <seg>Un problema más sutil es la confianza en el orden de la &quot;destrucción global&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the highlights include:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014808Z" changeid="explorer">
        <seg>Algunos elementos destacados son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Irix 6.3
and later are okay.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004454Z" changeid="explorer">
        <seg>Irix 6.3 y siquientes están bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print while defined($_ = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print while defined($_ = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?=S)&gt;, C&lt;(?&lt;=S)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045939Z" changeid="explorer">
        <seg>=item C&lt;(?=S)&gt;, C&lt;(?&lt;=S)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { die &quot;foo lives here&quot; };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { die &quot;foo vive aquí&quot; };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else {
            # handle all other possible exceptions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043919Z" changeid="explorer">
        <seg>else {
            # controla todas las otras posibles excepciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sort( &lt;STDIN&gt; )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sort( &lt;STDIN&gt; )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sub NAME : ATTRS BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sub NOMBRE : ATRIBS BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Return value</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T222642Z" changeid="explorer">
        <seg>=head3 Valor de retorno</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File descriptors (and sometimes locks on those descriptors)
are shared, while everything else is copied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descriptores de archivo (y algunas veces bloqueos en estos descriptores) son compartidos, mientras que todo lo demás es copiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item listen SOCKET,QUEUESIZE
X&lt;listen&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175443Z" changeid="explorer">
        <seg>=item listen SOCKET,TAMAÑO_COLA
X&lt;listen&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ( prompt(); &lt;STDIN&gt;; prompt() ) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ( prompt(); &lt;STDIN&gt;; prompt() ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buyer beware.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los compradores quedan advertidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since this switch could not have been used
by anyone, it has been repurposed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T141912Z" changeid="explorer">
        <seg>Dado que esta opción quizás no podría haber sido utilizada más por cualquier persona, se ha reutilizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Object    invokes ~~ overloading on $object, or dies</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  Objeto     invoca ~~ sobrecargado en $objeto, o muere</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return \@ints;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225602Z" changeid="explorer">
        <seg>return \@ints;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 4) = 4   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 4) = 4   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It doesn't
change your current working directory, which is unaffected.)  For security
reasons, this call is restricted to the superuser.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(No cambia su actual directorio de trabajo actual, que no queda afectado). Por razones de seguridad, esta llamada está reservada al superusuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>qr{}	      Pattern		  yes*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>qr{}	      Patrón		  sí*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current leading implementation of Perl 6 is Rakudo (
http://rakudo.org ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004341Z" changeid="explorer">
        <seg>Actualmente la implementación más avanzada de Perl 6 es Rakudo (
http://rakudo.org ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 4.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus in the
pattern</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T213804Z" changeid="explorer">
        <seg>Así, en el patrón</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implements the C library function of the same name, which on most
systems returns the current login from F&lt;/etc/utmp&gt;, if any.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011840Z" changeid="explorer">
        <seg>Implementa la función de la biblioteca C del mismo nombre, que en la mayoría de los sistemas devuelve el login actual desde F&lt;/etc/utmp&gt;, si existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Actually, there
aren't really functions in this sense, just list operators and unary
operators behaving as functions because you put parentheses around
the arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En realidad, no son realmente funciones en ese sentido, solo son operadores de lista y operadores unarios que se comportan como funciones porque usted pone paréntesis a los argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You probably cannot mix C&lt;alarm&gt; and C&lt;sleep&gt; calls, because C&lt;sleep&gt;
is often implemented using C&lt;alarm&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es probable que no se pueden mezclar las llamadas C&lt;alarm&gt; y C&lt;sleep&gt;, debido a que C&lt;sleep&gt; a menudo está implementado en C&lt;alarm&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str remains in UTF-8 format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001258Z" changeid="explorer">
        <seg>$str sigue estando en formato UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These hooks are also permitted to set the %INC entry
corresponding to the files they have loaded.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos enganches también están autorizados para establecer la entradas %INC correspondientes a los archivos que se hayan cargado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%10.6x&gt;', 1;    # prints &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%10.6x&gt;', 1;    # imprime &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consistent naming of subroutines or methods</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013619Z" changeid="explorer">
        <seg>Denominación consistente de subrutinas o métodos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/seek&gt; for some details about mixing reading and writing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/seek&gt; para más detalles acerca de mezclar lectura y escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;parent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005436Z" changeid="explorer">
        <seg>=item C&lt;parent&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a list consisting of all the keys of the named hash, or the indices
of an array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una lista consistente de todas las claves del hash indicado, o los índices de un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will print 'A' and then terminate, as it considers the match to
be zero-width, and thus will not match at the same position twice in a
row.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Imprimirá 'A' y entonces termina, pues considera la coincidencia de un ancho cero, y por lo tanto no coincidirá en la misma posición dos veces para la misma cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 5.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print while &lt;STDIN&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print while &lt;STDIN&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With
an explicit repeat count for pack, the packed string is adjusted to that
length.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con un contador de repeticiones explícito para el empaquetado, la cadena de empaquetado se ajusta a esa longitud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Perl 5 Pocket Reference&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003226Z" changeid="explorer">
        <seg>=item I&lt;Perl 5 Pocket Reference&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl593delta - what is new for perl v5.9.3</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T191459Z" changeid="explorer">
        <seg>perl593delta - qué hay de nuevo en perl v5.9.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item msgctl ID,CMD,ARG
X&lt;msgctl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191436Z" changeid="explorer">
        <seg>=item msgctl ID,CMD,ARG
X&lt;msgctl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is then interpreted as an external
command, and the output of that command is the value of the
backtick string, like in a shell.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entonces es interpretado como un comando externo, y la salida de ese comando es el valor de la cadena entrecomillada, como en un I&lt;shell&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item syscall</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015543Z" changeid="explorer">
        <seg>=item syscall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that you understand how C&lt;require&gt; looks for files with a
bareword argument, there is a little extra functionality going on behind
the scenes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora que sabe cómo C&lt;require&gt; busca archivos con un argumento simple, hay una funcionalidad extra que pasa por detrás de las cámaras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As I'm
sure you have already guessed, this is a problem that DBM Filters can
fix very easily.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T153930Z" changeid="zipf">
        <seg>Como ya se habrá imaginado, éste es un problema que se puede solucionar fácilmente con filtros DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;!&quot; performs logical negation, i.e., &quot;not&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El unario &quot;!&quot; realiza la negación lógica, es decir, &quot;not&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To read your private value, use the macro
C&lt;MRO_GET_PRIVATE_DATA()&gt;, passing it the C&lt;mro_meta&gt; structure from the
stash, and a pointer to your C&lt;mro_alg&gt; structure:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115155Z" changeid="explorer">
        <seg>Para leer su valor privado, use la macro C&lt;MRO_GET_PRIVATE_DATA()&gt;, pasándole la estructura C&lt;mro_meta&gt; del esquema, y un puntero a la estructura C&lt;mro_alg&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, Perl matching doesn't fully conform to the current Unicode C&lt;/i&gt;
recommendations, which ask that the matching be made upon the NFD
(Normalization Form Decomposed) of the text.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162810Z" changeid="explorer">
        <seg>Además, el sistema de coincidencias de Perl no se ajusta plenamente a las recomendaciones actuales de Unicode con C&lt;/i&gt;, que piden que la coincidencia se haga en el NFD (I&lt;Normalization Form Decomposed&gt;) del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$old_filter = $db-&gt;filter_store_value( sub { ... } );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T224836Z" changeid="zipf">
        <seg>$filtro_antiguo = $db-&gt;filter_store_value( sub { ... } );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows your code to work with the standard L&lt;crypt|/crypt&gt; and
with more exotic implementations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto permite a su código trabajar con el estándar L&lt;crypt|/crypt&gt; y con implementaciones más exóticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add the if pragma</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadido el pragma if</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can now have custom character name aliases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171646Z" changeid="explorer">
        <seg>Ahora puede tener personalizados alias como nombres de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\ca      chr(1)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034622Z" changeid="explorer">
        <seg>\ca      chr(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Pari             provides access to the Pari C library</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035400Z" changeid="explorer">
        <seg>Math::Pari			ofrece acceso a la biblioteca Pari, en C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Tutorials</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000154Z" changeid="explorer">
        <seg>=head2 Tutoriales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of it as a goto with an intervening core dump and reincarnation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Piense en él como un goto entre un volcado del núcleo y una reencarnación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at goop line 345.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at goop line 345.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># assign a reference to array of array references</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># asignar una referencia a un array de referencias de array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of match is called I&lt;smart match&gt;, and it's also possible to use
it outside of switch statements, via the new C&lt;~~&gt; operator (enabled via
the C&lt;use feature '~~'&gt; directive).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103358Z" changeid="explorer">
        <seg>Este tipo de emparejamientos se llaman I&lt;smart match&gt; (emparejamiento o coincidencia inteligente), y también es posible utilizarlo fuera de las instrucciones switch, a través del nuevo operador C&lt;~~&gt; (activado a través de la directiva C&lt;use feature '~~'&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^\s+//;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^\s+//;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, you have to open each element of
C&lt;@ARGV&gt; yourself since C&lt;eof&gt; handles C&lt;ARGV&gt; differently.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En este caso, tiene que abrir cada elemento de C&lt;@ARGV&gt; debido a que C&lt;eof&gt; maneja C&lt;ARGV&gt; de otra manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns C&lt;1&gt; on success, false
otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013225Z" changeid="explorer">
        <seg>Devuelve C&lt;1&gt; en caso de éxito; falso en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore a decision was made to backtrack the feature and change it
from implicit silent default to explicit conscious option.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T152129Z" changeid="explorer">
        <seg>Por lo tanto se tomó la decisión de dar marcha atrás a esta característica y se cambió, desde una manera por defecto implícita y silenciosa a otra opción explícita y consciente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to remove the line terminator from your here-docs,
use C&lt;chomp()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea quitar el carácter de fin de línea de los documentos incrustados, utilice C&lt;chomp()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The require function will actually look for the &quot;F&lt;Foo/Bar.pm&gt;&quot; file in the
directories specified in the C&lt;@INC&gt; array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función require realmente buscará el archivo &quot;F&lt;Foo/Bar.pm&gt;&quot; en los directorios especificados en el array C&lt;@INC&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can get an overview of all the files with this command:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T015009Z" changeid="explorer">
        <seg>Puede ver una descripción general de todos los archivos con el siguiente comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5141delta	Perl changes in version 5.14.1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111002T122036Z" changeid="explorer">
        <seg>perl5141delta	Cambios en la versión 5.14.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 3.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item waitpid PID,FLAGS
X&lt;waitpid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210951Z" changeid="explorer">
        <seg>=item waitpid PID,BANDERAS
X&lt;waitpid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcall		Perl calling conventions from C</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000516Z" changeid="explorer">
        <seg>perlcall		Convenciones de llamada desde C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$count = () = $string =~ /\d+/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cuenta = () = $cadena =~ /\d+/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SYNOPSIS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SINOPSIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare a
subroutine without defining it by saying C&lt;sub name&gt;, thus:
X&lt;subroutine, declaration&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede declarar una subrutina sin definirla diciendo C&lt;sub nombre&gt;, como: X&lt;subrutina, declaración&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With non-alphabetical characters, the result is based on the 4 least-significant
bits of the input character, i.e., on C&lt;ord($char)%16&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con caracteres no-alfabéticos, el resultado se basa en los 4 bits menos significativos del carácter de entrada, es decir, en C&lt;ord($carácter)%16&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, exiting
69 (EX_UNAVAILABLE) from a I&lt;sendmail&gt; incoming-mail filter will cause
the mailer to return the item undelivered, but that's not true everywhere.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, saliendo con 69 (EX_UNAVAILABLE) desde un filtrado de un correo entrante hacia I&lt;sendmail&gt; hará que el despachador de correo devuelva el elemento sin entregar, pero no siempre es cierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new warning, C&lt;$# is no longer supported&gt;, has been added.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192333Z" changeid="explorer">
        <seg>Una nueva advertencia, C&lt;$# is no longer supported&gt;, ha sido añadida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using
uppercase filehandles also improves readability and protects you
from conflict with future reserved words.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003438Z" changeid="explorer">
        <seg>Utilizar identificadores de archivo en mayúsculas mejora la legibilidad de los programas y les protege de conflictos con futuras palabras reservadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Creating Custom RE Engines</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001113Z" changeid="explorer">
        <seg>=head2 Creando motores RE personalizados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you should be very careful that the outer bracket type
is a round one, that is, a parenthesis.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora, debe tener mucho cuidado de que el paréntesis externo debe ser eso: un paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A special thanks to Damian Conway, who didn't only suggest important changes,
but also took the time to count the number of listed features and make a
Perl 6 version to show that Perl will stay Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224420Z" changeid="explorer">
        <seg>Debemos un agradecimiento especial a Damian Conway, quien no sólo sugirió importantes cambios, sino que también se entretuvo en contar el número de características incluidas y creó una versión para Perl 6 con el fin de demostrar que Perl seguirá siendo Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Perl uses doubles (or long doubles, if configured) internally for
all numeric calculation, converting from double into float and thence 
to double again loses precision, so C&lt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&gt;)
will not in general equal $foo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a Perl utiliza dobles (o dobles largos, si está configurado) internamente para todos cálculos numéricos, convirtiendo de doble en flotante y de allí a doble de nuevo, pierde precisión, por lo que C&lt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&gt;) no será, generalmente, igual a $foo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Array     match against an array element[3]
                                               grep $a ~~ $_, @$b</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T065848Z" changeid="explorer">
        <seg>Cualq.      Array      busca en un array elemento[3]    grep $a ~~ $_, @$b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select($rout=$rin, $wout=$win, $eout=$ein, $timeout);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select($rout=$rin, $wout=$win, $eout=$ein, $tiempo_espera);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This could also be achieved by writing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171738Z" changeid="explorer">
        <seg>Esto también puede lograrse escribiendo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can get commercial support of Perl if you wish, although for most
users the informal support will more than suffice.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200518Z" changeid="explorer">
        <seg>Si lo desea, puede obtener soporte comercial para Perl, pero a la mayoría de los usuarios les bastará con el soporte informal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can create a module C&lt;customre&gt; to do
this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001759Z" changeid="explorer">
        <seg>Podemos crear un módulo C&lt;customre&gt; para hacer esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an invalid
character is encountered, a warning will be issued and the invalid
character and all subsequent characters (valid or invalid) within the
braces will be discarded.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T202549Z" changeid="explorer">
        <seg>Si se encuentra un carácter inválido, se emitirá una advertencia y el carácter inválido y todos los demás caracteres (válidos o no) dentro de las llaves serán descartados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you hit
EOF on your read and then sleep for a while, you (probably) have to stick in a
dummy seek() to reset things.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una vez que llegue al EOF en lectura y si se echa a dormir por un tiempo, (probablemente) tendrá que tocarlo con un ficticio seek() para restablecer las cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Tom Christiansen and Nathan Torkington,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003023Z" changeid="explorer">
        <seg>Tom Christiansen y Nathan Torkington,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should resolve problems with initializing and destroying the Perl
interpreter more than once in a single process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto debería resolver los problemas con la inicialización y destrucción del intérprete de Perl presente más de una vez en un único proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also get the precision from the next argument using C&lt;.*&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede obtener la precisión del siguiente argumento usando C&lt;.*&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlobj		Perl objects</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000336Z" changeid="explorer">
        <seg>perlobj		Objetos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub { no warnings 'uninitialized'; s/\0$// } );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190138Z" changeid="zipf">
        <seg>sub { no warnings 'uninitialized'; s/\0$// } );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If TEMPLATE requires fewer arguments
than given, extra arguments are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si PLANTILLA requiere menos argumentos de los que se le dan, los argumentos adicionales son ignorados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$iaddr = inet_aton(&quot;127.1&quot;); # or whatever address</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$iaddr = inet_aton(&quot;127.1&quot;); # o la dirección que sea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the child process, the filehandle isn't opened--I/O happens from/to
the new STDOUT/STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011311Z" changeid="explorer">
        <seg>En el proceso hijo, el identificador de archivo no se abre: la E/S sucede desde/hasta el nuevo STDOUT/STDIN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$program =~ s {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$programa =~ s {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;use locale&gt; is in effect, the case map used by C&lt;\l&gt;, C&lt;\L&gt;,
C&lt;\u&gt;, and C&lt;\U&gt; is taken from the current locale.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T233350Z" changeid="explorer">
        <seg>Si C&lt;use locale&gt; está en vigor, el mapeo de tamaños de caja usado por C&lt;\l&gt;, C&lt;\L&gt;, C&lt;\u&gt; y C&lt;\U&gt; es tomado de la localización actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># all in one</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T014158Z" changeid="explorer">
        <seg> all in one</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, Perl defines the following:
X&lt;\g&gt; X&lt;\k&gt; X&lt;\K&gt; X&lt;backreference&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110220T230137Z" changeid="explorer">
        <seg>Ademas, Perl define lo siguiente:
X&lt;\g&gt; X&lt;\k&gt; X&lt;\K&gt; X&lt;backreference&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A special form is the C&lt;(DEFINE)&gt; predicate, which never executes its
yes-pattern directly, and does not allow a no-pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213446Z" changeid="explorer">
        <seg>Una forma especial es el predicado C&lt;(DEFINE)&gt;, que nunca ejecuta directamente su patrón-sí, y no permite un patrón-no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># record flocking enforcement, a platform-dependent feature.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># bloqueo forzado de registro, una característica dependiente de la plataforma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bytes are
irrelevant here, and so are encodings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234518Z" changeid="explorer">
        <seg>En este contexto, los bytes y las codificaciones son irrelevantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The byteorder on the platform where Perl was built is also available
via L&lt;Config&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El orden de los bytes en la plataforma donde Perl fue compilado está también disponible vía L&lt;Config&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hash{$a} &lt;=&gt; $hash{$b}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225610Z" changeid="explorer">
        <seg>$hash{$a} &lt;=&gt; $hash{$b}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$now_string = localtime;  # e.g., &quot;Thu Oct 13 04:54:34 1994&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ahora = gmtime;  # ej., &quot;Thu Oct 13 04:54:34 1994&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item -X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Tom Christiansen and Nathan Torkington</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003445Z" changeid="explorer">
        <seg>Tom Christiansen y Nathan Torkington</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 8   ==          8 00010000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 8   ==          8 00010000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LENGTH is negative, removes the elements from OFFSET onward
except for -LENGTH elements at the end of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LONGIIUD es negativa, elimina los elementos desde DESPLAZAMIENTO hacia adelante, excepto -LONGITUD elementos al final del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item defined EXPR
X&lt;defined&gt; X&lt;undef&gt; X&lt;undefined&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170445Z" changeid="explorer">
        <seg>=item defined EXPR
X&lt;defined&gt; X&lt;undef&gt; X&lt;undefined&gt; X&lt;definido&gt; X&lt;indefinido&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item require VERSION
X&lt;require&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194605Z" changeid="explorer">
        <seg>=item require VERSIÓN
X&lt;require&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;piconv&gt; is a Perl version of B&lt;iconv&gt;, a character encoding converter
widely available for various Unixen today.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234721Z" changeid="explorer">
        <seg>B&lt;piconv&gt; es una versión Perl de B&lt;iconv&gt;, un conversor de codificaciones de caracteres de uso muy extendido en el mundo Unix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Setuid/Setgid/Stickiness/SaveText.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Setuid/Setgid/Stickiness/SaveText.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Binding Operators
X&lt;binding&gt; X&lt;operator, binding&gt; X&lt;=~&gt; X&lt;!~&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234339Z" changeid="explorer">
        <seg>=head2 Operadores de vinculación
X&lt;binding&gt; X&lt;operator, binding&gt; X&lt;=~&gt; X&lt;!~&gt; X&lt;vinculación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Removed &quot;Attempt to clear a restricted hash&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001612Z" changeid="explorer">
        <seg>=head2 Eliminado &quot;I&lt;Attempt to clear a restricted hash&gt;&quot; (Intento de limpiar un hash restringido)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next LINE if /^#/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next LINEA if /^#/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; for function, variable and module names (and more
generally anything that can be considered part of code, like filehandles
or specific values).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015828Z" changeid="explorer">
        <seg>use C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; por función, variable y nombres de módulos (y más generalmente cualquier cosa que pueda ser considerada parte del código, como identificadores de archivo o valores específicos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CE.B1.CF.89</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003605Z" changeid="explorer">
        <seg>CE.B1.CF.89</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;caller&gt;, C&lt;import&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;, C&lt;package&gt;, C&lt;state&gt;, C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234341Z" changeid="explorer">
        <seg>C&lt;caller&gt;, C&lt;import&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;, C&lt;package&gt;, C&lt;state&gt;, C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item push ARRAY,LIST
X&lt;push&gt; X&lt;stack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192813Z" changeid="explorer">
        <seg>=item push ARRAY,LISTA
X&lt;push&gt; X&lt;stack&gt; X&lt;pila&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($i = 0; $i &lt; 1.01; $i += 0.05) { printf &quot;%.1f &quot;,$i}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225512Z" changeid="explorer">
        <seg>for ($i = 0; $i &lt; 1.01; $i += 0.05) { printf &quot;%.1f &quot;,$i}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may want to remove it from your link line.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004734Z" changeid="explorer">
        <seg>Si lo desea puede eliminarlo de su línea de enlazado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words,
list operators tend to gobble up all arguments that follow, and
then act like a simple TERM with regard to the preceding expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, los operadores de lista tienden a devorar todos los argumentos que le siguen, y luego actuar como un simple TÉRMINO con respecto a la expresión precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are any key/value pairs, it returns true;
more precisely, the value returned is a string consisting of the
number of used buckets and the number of allocated buckets, separated
by a slash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si tiene algún par clave/valor, devuelve verdadero; más exactamente, el valor devuelto es una cadena que consiste en el número de cajones utilizados y el número de cajones reservados, separados por una barra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying a negative flag after the caret is an error, as the flag is
redundant.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T195131Z" changeid="explorer">
        <seg>Especificar una bandera negativa después del circunflejo es un error, ya que la bandera es redundante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to bug fixes, C&lt;format&gt;'s features have been enhanced.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de las correcciones de errores, las características de C&lt;format&gt; han sido mejoradas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a=3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a=3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The identifier C&lt;_&gt; is now forced to be a bareword after a filetest
operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T191800Z" changeid="explorer">
        <seg>Se fuerza a que el identificador C&lt;_&gt; sea considerada una palabra suelta después de un operador de test de fichero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not supported.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015026Z" changeid="explorer">
        <seg>No soportado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;S|T&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050050Z" changeid="explorer">
        <seg>=item C&lt;S|T&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another consequence of using binmode() (on some systems) is that
special end-of-file markers will be seen as part of the data stream.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otra consecuencia de usar binmode() (en algunos sistemas) es que las marcas especiales de fin-de-archivo serán vistas como parte del flujo de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$is_his = (stat($filename)-&gt;uid == pwent($whoever)-&gt;uid);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$is_his = (stat($archivo)-&gt;uid == pwent($loquesea)-&gt;uid);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You are not allowed to C&lt;open&gt; to a command that pipes both in I&lt;and&gt;
out, but see L&lt;IPC::Open2&gt;, L&lt;IPC::Open3&gt;, and
L&lt;perlipc/&quot;Bidirectional Communication with Another Process&quot;&gt; for
alternatives.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215451Z" changeid="explorer">
        <seg>(No se le permite hacer un C&lt;open&gt; a un comando que entube tanto en la entrada I&lt;como&gt; en la salida, pero vea L&lt;IPC::Open2&gt;, L&lt;IPC::Open3&gt;, y L&lt;perlipc/&quot;Comunicación bidireccional con otro proceso&quot;&gt; para alternativas sobre esto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 5.8.0 this</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031406Z" changeid="explorer">
        <seg>En 5.8.0, esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like special scalars and arrays, there are also special hashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224937Z" changeid="explorer">
        <seg>De la misma manera que hay escalares y arrays especiales, también hay hashes especiales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13179</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13179</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So avoid C&lt;$&amp;&gt;, C&lt;$'&gt;, and C&lt;$`&gt;
if you can, but if you can't (and some algorithms really appreciate
them), once you've used them once, use them at will, because you've
already paid the price.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que evite C&lt;$&amp;&gt;, C&lt;$'&gt;, y C&lt;$`&gt; si puede, pero si no puede (y algunos algoritmos realmente los necesitan), una vez que los use aunque sea una sola vez, úselos a voluntad, ya que ya habrá pagado el precio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlop/&quot;Quote and Quote-like Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185014Z" changeid="explorer">
        <seg>Ver L&lt;perlop/&quot;Comillas y Operadores de comillas&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If what's within the angle brackets is neither a filehandle nor a simple
scalar variable containing a filehandle name, typeglob, or typeglob
reference, it is interpreted as a filename pattern to be globbed, and
either a list of filenames or the next filename in the list is returned,
depending on context.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014446Z" changeid="explorer">
        <seg>Si lo que está dentro de los ángulos no es ni un identificador de archivo ni una variable escalar simple que contenga un nombre de identificador de archivo, I&lt;typeglob&gt;, o referencia a I&lt;typeglob&gt;, se interpreta como un patrón de nombre de archivo para ser expandido, y será devuelta la lista de nombres de archivo o el siguiente nombre de archivo de la lista, dependiendo del contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you're using
lexically-scoped private variables created with C&lt;my()&gt;, you'll
have to make sure
your format or subroutine definition is within the same block scope
as the my if you expect to be able to access those private variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si está usando variables privadas en un contexto local creadas con C&lt;my()&gt;, deberá asegurarse que su definición de formato o subrutina están dentro del mismo bloque que el C&lt;my&gt; si quiere acceder a estas variables privadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;PERL_DONT_CREATE_GVSV&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014008Z" changeid="explorer">
        <seg>=head2 C&lt;PERL_DONT_CREATE_GVSV&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, because Perl is frequently (but not always, and certainly not by
definition) an interpreted language, you can write your programs and test
them without an intermediate compilation step, allowing you to experiment
and test/debug quickly and easily.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230412Z" changeid="explorer">
        <seg>Por último, como Perl es frecuentemente un lenguaje interpretado (aunque no siempre y, desde luego, no por definición), puede escribir sus programas y probarlos sin un paso de compilación intermedia, lo que le permite experimentar y probar/depurar de manera rápida y sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's tempting to add extra features
until your code is a monolithic system rather than a set of modular
building blocks.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031530Z" changeid="explorer">
        <seg>Es tentador añadir características adicionales hasta que su código sea un sistema monolítico en lugar de un conjunto de bloques de construcción modulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must also do
this when interpolating a variable into a string to separate the
variable name from a following double-colon or an apostrophe, since
these would be otherwise treated as a package separator:
X&lt;interpolation&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110803T113903Z" changeid="explorer">
        <seg>También debe hacer esto cuando la interpolación de una variable en una cadena para separar el nombre de una variable del carácter dos puntos o un apóstrofo, ya que de otro modo serían tratados como un separador de paquete:
X&lt;interpolation&gt; X&lt;interpolación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $AoA[0][0];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193222Z" changeid="explorer">
        <seg>print $AoA[0][0];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval '$answer = $a / $b'; warn $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval '$respuesta = $a / $b'; warn $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interprets EXPR as a hex string and returns the corresponding value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Interpreta EXPR como una cadena en hexadecimal y devuelve el valor correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I said foo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He dicho foo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bits of a byte are
numbered in a little-endian-ish way, as in C&lt;0x01&gt;, C&lt;0x02&gt;,
C&lt;0x04&gt;, C&lt;0x08&gt;, C&lt;0x10&gt;, C&lt;0x20&gt;, C&lt;0x40&gt;, C&lt;0x80&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los bits de un byte se numeran de la forma little-endian, como en C&lt;0x01&gt;, C&lt;0x02&gt;, C&lt;0x04&gt;, C&lt;0x08&gt;, C&lt;;0x10&gt;, C&lt;0x20&gt;, C&lt;0x40&gt;; C&lt;0x80&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (;&lt;STDIN&gt;;) { print; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (;&lt;STDIN&gt;;) { print; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@dots = grep { /^\./ &amp;&amp; -f &quot;$some_dir/$_&quot; } readdir($dh);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@dots = grep { /^\./ &amp;&amp; -f &quot;$algun_dir/$_&quot; } readdir($dh);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;perl.exe&gt; on Windows now has a &quot;Camel&quot; logo icon.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T105602Z" changeid="explorer">
        <seg>C&lt;perl.exe&gt; en Windows ahora tiene un icono de un &quot;Camello&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: Difficult material (and prose) ahead.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230149Z" changeid="explorer">
        <seg>B&lt;ADVERTENCIA&gt;: sigue material (y prosa) difícil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some have been
part of the core language for many years.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos han sido parte del núcleo del lenguaje durante muchos años.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;STDIN&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;STDIN&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If protected by C&lt;\&gt;, C&lt;$&gt; will be quoted to became
C&lt;&quot;\\\$&quot;&gt;; if not, it is interpreted as the start of an interpolated
scalar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está protegido por un C&lt;\&gt;, C&lt;$&gt; será escapado para convertirse en C&lt;&quot;\\\$&quot;&gt;; si no, es interpretado como el inicio de un escalar interpolado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode semantics are used for the case change.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175102Z" changeid="explorer">
        <seg>Semántica Unicode es utilizada para el cambio de tamaño de caja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your bug report, along with the
output of C&lt;perl -V&gt;, will be sent off to perlbug@perl.org to be
analysed by the Perl porting team.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su informe de error, junto con la salida de C&lt;perl -V&gt;, serán enviados a perlbug@perl.org para ser analizado por el equipo de adaptación de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ++</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T233928Z" changeid="explorer">
        <seg>=item ++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See select(2) and fcntl(2) for further details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013614Z" changeid="explorer">
        <seg>Vea select(2) y fcntl(2) para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just don't forget that you have to put a semicolon on the end
to finish the statement, as Perl doesn't know you're not going to
try to do this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012733Z" changeid="explorer">
        <seg>Pero no olvide que tiene que poner un punto y coma al final para terminar la instrucción, ya que Perl no sabe que no vamos a tratar de hacer esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?(condition)yes-pattern|no-pattern)&gt;
X&lt;(?()&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T192132Z" changeid="explorer">
        <seg>=item C&lt;(?(condición)patrón-sí|patrón-no)&gt;
X&lt;(?()&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Learning Perl&gt;  (the &quot;Llama Book&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003100Z" changeid="explorer">
        <seg>=item I&lt;Learning Perl&gt;  (el &quot;Libro de la Llama&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the Carp module for other kinds of warnings using its
carp() and cluck() functions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215859Z" changeid="explorer">
        <seg>Vea el módulo Carp para otros tipos de avisos mediante sus funciones carp() y cluck().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Round number to 3 digits after decimal point</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Redondea número a 3 dígitos después del punto decimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This program will print only the line containing &quot;Bar&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este programa imprimirá sólo la línea que contiene &quot;Bar&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Support for the POSIX C&lt;clock_gettime()&gt; and C&lt;clock_getres()&gt; has been added</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040835Z" changeid="explorer">
        <seg>Se ha añadido soporte para las funciones POSIX C&lt;clock_gettime()&gt; y C&lt;clock_getres()&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Perls 5.8.0 and later, PerlIO is (most often) the default.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005130Z" changeid="explorer">
        <seg>Para las versiones de Perl 5.8.0 y posteriores, PerlIO es (casi siempre) el valor predeterminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/$unquoted\Q$quoted\E$unquoted/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/$noescapados\Q$escapados\E$noescapados/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Module::CoreList&gt; no longer contains the C&lt;%:patchlevel&gt; hash.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190734Z" changeid="explorer">
        <seg>C&lt;Module::CoreList&gt; ya no contiene el hash C&lt;%:patchlevel&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># U0-mode, so the UTF-8 bytes get joined into characters</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un modo U0, así que los bytes UTF-8 se han unidos en caracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlapi		Perl API listing (autogenerated)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000524Z" changeid="explorer">
        <seg>perlapi		Lista de API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Growing Your Own</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Creciendo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;stat&gt; is passed the special filehandle consisting of an underline, no
stat is done, but the current contents of the stat structure from the
last C&lt;stat&gt;, C&lt;lstat&gt;, or filetest are returned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012718Z" changeid="explorer">
        <seg>Si a C&lt;stat&gt; se le pasa el identificador de archivo especial consistente en un subrayado, no se hacen estadísticas, sino que se devuelven el contenido actual de la estructura de estadísticas de la última llamada C&lt;stat&gt;, C&lt;lstat&gt;, o test de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># (warning: assumes no { or } in strings)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># (aviso: asumes que no hay { o } en cadenas)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regexp objects (those created with C&lt;qr&gt;) now have S-magic rather than
R-magic.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001318Z" changeid="explorer">
        <seg>Objetos Regexp (los creados con C&lt;qr&gt;) ahora tienen S-magic en lugar de R-magic.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tutorial speaks in rather absolute terms, and provides only a limited view
of the wealth of character string related features that Perl has to offer.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234231Z" changeid="explorer">
        <seg>En este tutorial hablamos en términos absolutos, y solo proporcionamos una visión limitada de las muchas características relacionadas con el procesamiento de cadenas de caracteres que Perl ofrece.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides a
checklist against which modules can be compared to determine whether
they conform to best practice, without necessarily describing in detail
how to achieve this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013037Z" changeid="explorer">
        <seg>Proporciona una lista de control contra el que los módulos se pueden comparar para determinar si se ajustan a las mejores prácticas, sin que necesariamente se describe en detalle cómo lograrlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is at this stage that C&lt;split()&gt; silently optimizes C&lt;/^/&gt; to
mean C&lt;/^/m&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es en esta etapa en que C&lt;split()&gt;, silenciosamente, optimiza C&lt;/^/&gt; para que signifique C&lt;/^/m&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@fields = split /(A)|B/, &quot;1A2B3&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@campos = split /(A)|B/, &quot;1A2B3&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string = &quot;-9 55 48 -2 23 -76 4 14 -44&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225535Z" changeid="explorer">
        <seg>$string = &quot;-9 55 48 -2 23 -76 4 14 -44&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/^def/) { $def = 1; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/^def/) { $def = 1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is
implemented using C's pow(3) function, which actually works on doubles
internally.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto se realiza mediante la función del C pow(3), que en realidad trabaja internamente con dobles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This trick is used by Pugs.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T235813Z" changeid="explorer">
        <seg>(Este truco es usado por Pugs.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How that string gets evaluated is entirely subject to the command
interpreter on your system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El cómo esta cadena es evaluada, está sujeta enteramente al intérprete de comandos de su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most modern systems
always sleep the full amount.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de los sistemas modernos siempre duermen la cantidad correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section hopes to clarify how Perl handles quoted constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta sección pretende aclarar la manera en que Perl maneja las construcciones entrecomilladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you've unpacked the distribution, run Configure (see INSTALL for
full discussion of the Configure options), and then run make, then
&quot;make test&quot; then &quot;make install&quot; (this last step may require UID=0
privileges).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101747Z" changeid="explorer">
        <seg>Una vez que haya descomprimido la distribución, ejecute B&lt;Configure&gt; (consulte INSTALL para una descripción completa de las opciones de configuración), y luego ejecutar B&lt;make&gt;, y luego &quot;make test&quot; y luego &quot;make install&quot; (este último paso puede requerir privilegios UID=0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function shmget.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC shmget(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, because C&lt;eval&gt; traps otherwise-fatal errors, it is useful for
determining whether a particular feature (such as C&lt;socket&gt; or C&lt;symlink&gt;)
is implemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que, como C&lt;eval&gt; atrapa errores considerados fatales, es útil para determinar cuando una característica en particular (como C&lt;socket&gt; o C&lt;symlink&gt;) está implementada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>| ([^,]+),?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225537Z" changeid="explorer">
        <seg>| ([^,]+),?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/\*	# Match the opening delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/\*	# Busca el delimitador de apertura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $x = qr{ ... (??{ $x }) ... };</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110309Z" changeid="explorer">
        <seg>my $x = qr{ ... (??{ $x }) ... };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LVALUE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LVALUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub splice_2D {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053021Z" changeid="explorer">
        <seg>sub splice_2D {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Switch&gt; is buggy and should be avoided.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235455Z" changeid="explorer">
        <seg>C&lt;Switch&gt; es defectuoso y debe ser evitado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use the modified Package only within your corporation or organization.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>utilice el Paquete modificado sólo dentro de su empresa u organización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 HP-UX: HP cc warnings about sendfile and sendpath</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003616Z" changeid="explorer">
        <seg>=head2 HP-UX: advertencias de HP cc sobre sendfile y sendpath</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There has been a fair amount of refactoring of the C&lt;C&gt; source code, partly to
make it tidier and more maintainable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051338Z" changeid="explorer">
        <seg>Se ha hecho una buena cantidad de refactorizaciones del código fuente C&lt;C&gt;, en parte para que sea más ordenado y más fácil de mantener.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># This loop reads from STDIN, and prints non-blank lines:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121857Z" changeid="zipf">
        <seg># Este bucle lee de STDIN e imprime las líneas que no estén vacías:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So anything
that looks like \\, \(, \), \&lt;, \&gt;, \{, or \} is always
interpreted as a literal character, not a metacharacter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que cualquier cosa que se parezca a \\, \(, \), \&lt;, \&gt;, \{, or \} es siempre interpretado como un carácter literal, no un metacarácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to Perl modules
X&lt;module&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T011836Z" changeid="explorer">
        <seg>=item Palabras clave relativas a los módulos Perl
X&lt;module&gt; X&lt;módulo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>binmode() is important not only for readline() and print() operations,
but also when using read(), seek(), sysread(), syswrite() and tell()
(see L&lt;perlport&gt; for more details).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>binmode() no sólo es importante para las operaciones readline() y print(), sino también cuando se usan read(), seek(), sysread(), syswrite() y tell() (ver L&lt;perlport&gt; para más detalles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $count (10,9,8,7,6,5,4,3,2,1,'BOOM') {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $cuenta_atras (10,9,8,7,6,5,4,3,2,1,'BOOM') {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wrong</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191347Z" changeid="explorer">
        <seg>mal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signal dispatch has been moved from the runloop into control ops.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052621Z" changeid="explorer">
        <seg>El despacho de señales ha sido movido del bucle de ejecución a los operadores de control.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MAD, which stands for I&lt;Misc Attribute Decoration&gt;, is a
still-in-development work leading to a Perl 5 to Perl 6 converter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T001934Z" changeid="explorer">
        <seg>MAD, que significa I&lt;Misc Attribute Decoration&gt;, es un trabajo todavía en desarrollo que conduce a un convertidor de Perl 5 a Perl 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
feature was implemented by the indefatigable Nicholas Clark, based on an idea
by Mike Giroux.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T053004Z" changeid="explorer">
        <seg>Esta característica se implementó por el infatigable Nicholas Clark, basado en una idea de Mike Giroux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Configure</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Configure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0x78 0x56 0x34 0x12  # little-endian</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0x78 0x56 0x34 0x12  # little-endian (byte inferior antes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$group_read    = ($mode &amp; S_IRGRP) &gt;&gt; 3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$grupo_lectura  = ($modo &amp; S_IRGRP) &gt;&gt; 3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} while $cheering;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225514Z" changeid="explorer">
        <seg>} while $sonrias;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;-|&quot;, &quot;cat&quot;, &quot;-n&quot;, $file);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T233714Z" changeid="explorer">
        <seg>open(FOO, &quot;-|&quot;, &quot;cat&quot;, &quot;-n&quot;, $archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line up your transliterations when it makes sense:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alinear transliteraciones cuando tengan sentido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item state TYPE EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item state TIPO EXPR : ATRIBS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the content is interpolated
as though it were double quoted and then executed via the shell, with
the results of the execution returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, el contenido es interpolado como si estuviera entrecomillado doble y luego ejecutado a través del shell, devolviendo los resultados de la ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A source code patch against the Perl 5.8.1 sources will be available
in CPAN as F&lt;authors/id/H/HM/HMBRAND/dor-5.8.1.diff&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014510Z" changeid="explorer">
        <seg>Un parche para las feuntes del código Perl 5.8.1 estará disponibles en CPAN como F&lt;authors/id/H/HM/HMBRAND/dor-5.8.1.diff&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;h2xs&gt; implements new option C&lt;--use-xsloader&gt; to force use of
C&lt;XSLoader&gt; even in backwards compatible modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041727Z" changeid="explorer">
        <seg>C&lt;h2xs&gt; implementa una nueva opción: C&lt;--use-xsloader&gt;, para forzar el uso de C&lt;XSLoader&gt; incluso en módulos retro-compatibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;for&gt;/C&lt;foreach&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225557Z" changeid="explorer">
        <seg>Use C&lt;for&gt;/C&lt;foreach&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because BLOCKs are always
bounded by curly brackets, there is never any ambiguity about which
C&lt;if&gt; an C&lt;else&gt; goes with.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como los BLOQUES están siempre rodeados de llaves, nunca hay ambigüedad sobre dónde van el C&lt;if&gt; y el C&lt;else&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $path = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $ruta = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: Particularly complicated regular expressions can take
exponential time to solve because of the immense number of possible
ways they can use backtracking to try for a match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T172303Z" changeid="explorer">
        <seg>B&lt;ADVERTENCIA&gt;: Especialmente complicadas expresiones regulares pueden tomar un tiempo exponencial en resolverse debido a la inmensa cantidad de formas posibles que puede utilizar para tratar de dar marcha atrás para lograr una coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;feature&gt; and L&lt;perlsyn/&quot;Switch statements&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234129Z" changeid="explorer">
        <seg>Vea L&lt;feature&gt; y L&lt;perlsyn/&quot;Instrucciones Switch&quot;&gt;.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(OLDERR,     &quot;&gt;&amp;&quot;, \*STDERR) or die &quot;Can't dup STDERR: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004455Z" changeid="explorer">
        <seg>open(OLDERR,     &quot;&gt;&amp;&quot;, \*STDERR) or die &quot;No puedo duplicar STDERR: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item msgrcv ID,VAR,SIZE,TYPE,FLAGS
X&lt;msgrcv&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191451Z" changeid="explorer">
        <seg>=item msgrcv ID,VAR,SIZE,TYPE,FLAGS
X&lt;msgrcv&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@alphabet = (&quot;A&quot; ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224356Z" changeid="explorer">
        <seg>@alfabeto = (&quot;A&quot; ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the inverse cosine operation, you may use the C&lt;Math::Trig::acos()&gt;
function, or use this relation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la inversa de la operación coseno, puede usar la función C&lt;Math::Trig::acos()&gt;, o usar esta relación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://perldoc.perl.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225438Z" changeid="explorer">
        <seg>http://perldoc.perl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 4) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 4) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.14_15_92          # a very important number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3.14_15_92          # un número muy importante</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;/x&gt; tells
the regular expression parser to ignore most whitespace that is neither
backslashed nor within a character class.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163322Z" changeid="explorer">
        <seg>C&lt;/x&gt; indica al analizador de expresiones regulares que ignore la mayoría de los espacios en blanco que no estén escapados con barras invertidas o que no estén dentro de una clase de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6: got ABC</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171639Z" changeid="explorer">
        <seg>6: tenemos ABC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Packaging Tools</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T032031Z" changeid="explorer">
        <seg>=item Herramientas de empaquetado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the shared memory
segment id, or C&lt;undef&gt; on error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014128Z" changeid="explorer">
        <seg>Devuelve el id del segmento de memoria compartida, o C&lt;undef&gt; en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual
random order is subject to change in future versions of Perl, but it
is guaranteed to be the same order as either the C&lt;keys&gt; or C&lt;each&gt;
function would produce on the same (unmodified) hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El actual orden aleatorio está sujeto a cambio en futuras versiones de Perl, pero se garantiza que sea el mismo orden que las funciones C&lt;keys&gt; o C&lt;each&gt; producirían (mientras que el hash no haya sido modificado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@idx = ();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>@idx = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following modules and pragmata have been updated since Perl 5.8.1:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los siguientes módulos y pragmata se han actualizado desde Perl 5.8.1:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exec PROGRAM LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exec PROGRAMA LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;--compat-version&gt; argument checking has been improved</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030228Z" changeid="explorer">
        <seg>La comprobación de argumentos de C&lt;--compat-version&gt; ha sido mejorada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1: '', pos=7</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1: '', pos=7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes various features of Linux that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documentos describe varias características de Linux que afectarán a cómo Perl versión 5 (de ahora en adelante sólo Perl) es compilado y/o ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may
no longer invoke the set uid perl directly, so to preserve backwards
compatibility with scripts that invoke #!/usr/bin/suidperl the only set uid
binary is now C&lt;sperl5.8.&gt;I&lt;n&gt; (C&lt;sperl5.8.4&gt; for this release).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T103834Z" changeid="explorer">
        <seg>Es posible que ya no invoque a perl con el uid activado, directamente, así que para mantener la compatibilidad anterior con I&lt;scripts&gt; que llaman a #!/usr/bin/suidperl el único binario con uid activado es ahora C&lt;sperl5.8.&gt;I&lt;n&gt; (C&lt;sperl5.8.4&gt; para esta versión).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if
successful, false on error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013642Z" changeid="explorer">
        <seg>Devuelve verdadero si tuvo éxito, falso en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following modules and pragmata have been updated since Perl 5.8.0:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171510Z" changeid="explorer">
        <seg>Los siguientes módulos y pragmata se han actualizado desde Perl 5.8.0:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Retrieve $x, $y, ...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Recupera $x, $y, ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you read this file _as_is_, just ignore the funny characters you see.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si lees este archivo _tal_como_es_, ignora los caracteres curiosos que veas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, with this modifier, C&lt;\d&gt; always means precisely the
digits C&lt;&quot;0&quot;&gt; to C&lt;&quot;9&quot;&gt;; C&lt;\s&gt; means the five characters C&lt;[ \f\n\r\t]&gt;;
C&lt;\w&gt; means the 63 characters C&lt;[A-Za-z0-9_]&gt;; and likewise, all the
Posix classes such as C&lt;[[:print:]]&gt; match only the appropriate
ASCII-range characters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T211920Z" changeid="explorer">
        <seg>Es decir, con esta modificación, C&lt;\d&gt; siempre representa exactamente a los dígitos C&lt;&quot;0&quot;&gt; a C&lt;&quot;9&quot;&gt;; C&lt;\s&gt; representa a los cinco caracteres C&lt;[ \f\n\r\t]&gt;; C&lt;\w&gt; representa a los 63 caracteres C&lt;[A-Za-z0-9_]&gt;; y, del mismo modo, todas las clases Posix, como C&lt;[[:print:]]&gt; solo coinciden con el rango apropiado de caracteres ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, the pointer to the string value is passed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no, se pasa el puntero al valor de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the child pid to the
parent process, C&lt;0&gt; to the child process, or C&lt;undef&gt; if the fork is
unsuccessful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el pid del hijo al proceso padre, C&lt;0&gt; al proceso hijo, o C&lt;undef&gt; si no se consiguió el fork.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl now builds on OpenVMS I64</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl ahora se compila en OpenVMS I64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single quotes indicate the text is to be treated literally with no
interpolation of its content.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las comillas simples indican que el texto se va a tratar literalmente, sin interpolación de su contenido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operation of interpolation should not be confused
with the operation of matching a backreference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T225902Z" changeid="explorer">
        <seg>La operación de interpolación no se debe confundir con la operación de coincidencia con una contrareferencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Build</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE:&gt; While the notation of this construct is the same as the similar
function in .NET regexes, the behavior is not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T213704Z" changeid="explorer">
        <seg>B&lt;NOTA:&gt; Si bien la notación de esta construcción es la misma que la función similar en las expresiones regulares en .NET, el comportamiento no lo es.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/0/ ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/0/ ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, modifying an element of a
list returned by sort() (for example, in a C&lt;foreach&gt;, C&lt;map&gt; or C&lt;grep&gt;)
actually modifies the element in the original list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, modificar un elemento de la lista devuelto por grep (por ejemplo, en un C&lt;foreach&gt;, C&lt;map&gt; o C&lt;grep&gt;) modifica el elemento en la lista original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A test that looks at such stringification thus doesn't need to have the
system default flags hard-coded in it, just the caret.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T194953Z" changeid="explorer">
        <seg>Una prueba que examina esta conversión a cadena de caracteres no tiene por qué tener las banderas por defecto del sistema puesta en el propio código, sólo el circunflejo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But in practice, the
distinction between code point and character is blurred, so the terms often
are used interchangeably.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234344Z" changeid="explorer">
        <seg>(en la práctica, la distinción entre los conceptos de código de carácter y carácter es difusa, por lo que se suelen utilizar ambos términos indistintamente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;no VERSION&quot; will now correctly deparse with B::Deparse, as will certain
constant expressions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230254Z" changeid="explorer">
        <seg>&quot;no VERSION&quot; será ahora correctamente decompilado con B::Deparse, así como ciertas expresiones constantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%D    a synonym for %ld</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%D    un sinónimo para %ld</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If using crypt() on a Unicode string (which I&lt;potentially&gt; has
characters with codepoints above 255), Perl tries to make sense
of the situation by trying to downgrade (a copy of)
the string back to an eight-bit byte string before calling crypt()
(on that copy).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T154157Z" changeid="explorer">
        <seg>Si usa crypt() en una cadena Unicode (que I&lt;potencialmente&gt; tiene caracteres con codificación superior al 255), Perl intenta darle sentido a la situación intentando hacer una degradación (una copia) de la cadena a una cadena de bytes antes de llamar a crypt() (sobre esa copia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T182330Z" changeid="explorer">
        <seg>Por lo tanto,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also many Perl books available, covering a wide variety of topics,
from various publishers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T221819Z" changeid="explorer">
        <seg>También hay muchos libros disponibles en Perl, que cubren una amplia variedad de temas, de diversos editores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are allowed to use underscores (underbars) in numeric literals
between digits for legibility.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está permitido el uso de guiones bajos en literales numéricos entre los dígitos para aumentar la legibilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They often work the same, but
see L&lt;perltrap&gt; for information about how they differ.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A menudo funcionan de la misma forma, pero mire L&lt;perltrap&gt; para ver cómo difieren.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;-Dusedevel&quot; may be required to configure Perl 5.7.2 non-interactively.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214419Z" changeid="explorer">
        <seg>&quot;-Dusedevel&quot; puede ser necesario para configurar Perl 5.7.2 de forma no interactiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Core Enhancements</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T140852Z" changeid="explorer">
        <seg>=head1 Mejoras del núcleo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>uts juno 4 4.4 9672 370</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T213939Z" changeid="explorer">
        <seg>uts juno 4 4.4 9672 370</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets FILEHANDLE's system position in bytes using lseek(2).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T020643Z" changeid="explorer">
        <seg>Establece la posición del IDENTIFICADOR_ARCHIVO en bytes usando lseek(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Various bug fixes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Varios errores corregidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item select RBITS,WBITS,EBITS,TIMEOUT
X&lt;select&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200425Z" changeid="explorer">
        <seg>=item select RBITS,WBITS,EBITS,TIEMPO_ESPERA
X&lt;select&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See L&lt;perlsyn/&quot;Compound Statements&quot;&gt;.)
You can refer to them by absolute number (using C&lt;&quot;$1&quot;&gt; instead of C&lt;&quot;\g1&quot;&gt;,
etc); or by name via the C&lt;%+&gt; hash, using C&lt;&quot;$+{I&lt;name&gt;}&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T160058Z" changeid="explorer">
        <seg>(Vea L&lt;perlsyn/&quot;Instrucciones complejas&quot;&gt;.) Puede referirse a ellos con un número absoluto (usando C&lt;&quot;$1&quot;&gt; en lugar de C&lt;&quot;\g1&quot;&gt;, etc); o por nombre vía el hash C&lt;%+&gt;, usando C&lt;&quot;$+{I&lt;nombre&gt;}&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can control which DBM library you use by loading that library
before you call dbmopen():</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede controlar qué biblioteca DBM usará cargando la biblioteca antes de llamar a dbmopen():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,12, 1) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,12, 1) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function
implementing the C&lt;&lt; &lt;*.c&gt; &gt;&gt; operator, but you can use it directly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es la función interna que implementa el operador C&lt;&lt; &lt;*.c&gt; &gt;&gt;, pero puede usarla directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a very large
user community and an extensive literature.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231021Z" changeid="explorer">
        <seg>Tiene una gran comunidad de usuarios y existe mucha información sobre el lenguaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item  *</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015113Z" changeid="explorer">
        <seg>=item *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 4) = 2   ==         32 00000100000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 4) = 2   ==         32 00000100000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From now on all applications embedding perl will behave as if perl
were compiled with -DPERL_USE_SAFE_PUTENV.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212609Z" changeid="explorer">
        <seg>A partir de ahora todas las aplicaciones que incrusten perl se comportarán como si se estuviera compilado con -DPERL_USE_SAFE_PUTENV.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's
easy to program Unicode capable software, but it does require discipline to do
it right.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T233218Z" changeid="explorer">
        <seg>Es fácil programar software compatible con Unicode, pero hacerlo bien requiere disciplina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where do I post questions?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230347Z" changeid="explorer">
        <seg>¿Dónde puedo publicar preguntas?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Work will continue on the bytecompiler and byteloader.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T002354Z" changeid="explorer">
        <seg>Se seguirá trabajando en el bytecompiler y byteloader.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item print</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item print</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $out $record;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T225640Z" changeid="zipf">
        <seg>print $salida $registro;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generalized form of backticks is C&lt;qx//&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma generalizada de las comillas invertidas es C&lt;qx//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, use C&lt;&quot;\n&quot;&gt; when
you mean a &quot;newline&quot; for your system, but use the literal ASCII when you
need an exact character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, utilice C&lt;&quot;\n&quot;&gt; cuando se refiera a una &quot;nueva línea&quot; para su sistema, pero use el literal ASCII cuando necesite un carácter exacto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 64  ==         64 00000010000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 64  ==         64 00000010000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing of C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt;, C&lt;\E&gt;,
and interpolation happens (almost) as with C&lt;qq//&gt; constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procesamiento de C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt;, C&lt;\E&gt; e interpolación ocurre (casi) como en las construcciones C&lt;qq//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_SIZE  	   if $opt_s;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_SIZE  	   if $opt_s;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlrequick&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045825Z" changeid="explorer">
        <seg>L&lt;perlrequick&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Win32::GetFolderPath</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015336Z" changeid="explorer">
        <seg>=item Win32::GetFolderPath</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value is parsed every time the C&lt;eval&gt; executes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que el valor es interpretado cada vez que se ejecuta C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does not
even aim to be entirely accurate.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224541Z" changeid="explorer">
        <seg>Tampoco explica el lenguaje en detalle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># reset line numbering on each input file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># reiniciar el numerado de líneas en cada archivo de entrada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from resetting the iterator,
C&lt;values @array&gt; in list context is the same as plain C&lt;@array&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de restablecer el iterador, C&lt;values @array&gt; en contexto lista es la mismo que un simple C&lt;@array&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directory contains dual-life modules where the CPAN module is
canonical.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014452Z" changeid="explorer">
        <seg>Este directorio contiene módulos de evolución dual en los que el módulo de CPAN es la versión canónica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.0f&gt;', 1;  # prints &quot;&lt;1&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.0f&gt;', 1;  # imprime &quot;&lt;1&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$re = qr{ (                    # paren group 1 (full function)
              foo
              (                  # paren group 2 (parens)
                \(
                  (              # paren group 3 (contents of parens)
                  (?:
                   (?&gt; [^()]+ )  # Non-parens without backtracking
                  |
                   (?2)          # Recurse to start of paren group 2
                  )*
                  )
                \)
              )
            )
          }x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185515Z" changeid="explorer">
        <seg>$re = qr{ (                    # paréntesis grupo 1 (toda la función)
              foo
              (                  # paréntesis grupo 2 (paréntesis)
                \(
                  (              # paréntesis grupo 3 (contenidos de paréntesis)
                  (?:
                   (?&gt; [^()]+ )  # No-paréntesis sin retroceso
                  |
                   (?2)          # Recursivo para empezar el paréntesis grupo 2
                  )*
                  )
                \)
              )
            )
          }x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DO                                      \S, \W and \D negate</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224317Z" changeid="explorer">
        <seg>CORRECTO                                        \S, \W y \D negación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo,  3, 16) = 0x726C; # 'PerlPerl'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($foo,  3, 16) = 0x726C; # 'PerlPerl'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's more convenient
than writing out the individual elements as a list of separate
scalar values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más conveniente que escribir los elementos individuales como una lista de valores escalares separados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditionally the result is a string of 13 bytes: two first bytes of
the salt, followed by 11 bytes from the set C&lt;[./0-9A-Za-z]&gt;, and only
the first eight bytes of PLAINTEXT mattered.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tradicionalmente, el resultado es una cadena de 13 bytes: los dos primeros son el salto, seguido de 11 bytes del conjunto C&lt;[./0-9A-Za-z]&gt;, y sólo los primeros ocho bytes del I&lt;digest&gt; interesan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And it's faster because
Perl executes a C&lt;foreach&gt; statement more rapidly than it would the
equivalent C&lt;for&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013449Z" changeid="explorer">
        <seg>Y es más rápido porque Perl ejecuta una instrucción C&lt;foreach&gt; más rápidamente que su equivalente en un bucle C&lt;for&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Another Example: Key is a C int.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T160054Z" changeid="zipf">
        <seg>=head2 Otro ejemplo: las claves son enteros de C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form, known as
v-strings, provides an alternative, more readable way to construct
strings, rather than use the somewhat less readable interpolation form
C&lt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma, conocida como &quot;v-strings&quot;, ofrece una alternativa, más legible, para construir cadenas, en lugar de una forma de interpolación mucho menos legible como C&lt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are upgrading from an earlier release such as 5.12.1, first read
L&lt;perl5122delta&gt;, which describes differences between 5.12.1 and
5.12.2.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225835Z" changeid="explorer">
        <seg>Si está actualizando desde una versión anterior como la 5.12.1, primero lea L&lt;perl5122delta&gt;, que describe las diferencias entre 5.12.1 y la 5.12.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Bitwise operators during C&lt;use integer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234043Z" changeid="explorer">
        <seg>=item Operadores bit a bit con C&lt;use integer&gt; activo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't rely on
it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No confíe en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 minor bug fix for Win32</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001527Z" changeid="explorer">
        <seg>1 error menor arreglado para Win32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13162</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13162</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The important difference between
them is that test 3 contains a quantifier (C&lt;\D*&gt;) and so can use
backtracking, whereas test 1 will not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170531Z" changeid="explorer">
        <seg>La diferencia importante entre ellos es que el test 3 contiene un cuantificador (C&lt;\D*&gt;) y por lo tanto puede utilizar la marcha atrás, mientras que el test 1, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item splice ARRAY or EXPR,OFFSET</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181316Z" changeid="explorer">
        <seg>=item splice ARRAY o EXPR,DESPLAZAMIENTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| die &quot;can't open &lt; $file: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235402Z" changeid="explorer">
        <seg>|| die &quot;no puedo abrir &lt; $archivo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open 'foo' for input: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir 'foo' para entrada: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># These do the print before evaluating exit:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Esto llama al print antes de evaluar exit:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes minimal matching can help a lot.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T152040Z" changeid="explorer">
        <seg>A veces una coincidencia mínima puede ayudar un montón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variable names are recognized as intended</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034315Z" changeid="explorer">
        <seg>Los nombres de variables se reconocen según lo previsto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify a series of alternatives for a pattern using &quot;|&quot; to
separate them, so that C&lt;fee|fie|foe&gt; will match any of &quot;fee&quot;, &quot;fie&quot;,
or &quot;foe&quot; in the target string (as would C&lt;f(e|i|o)e&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T223305Z" changeid="explorer">
        <seg>Puede especificar una serie de alternativas para un patrón usando &quot;|&quot; para separarlos, por lo que C&lt;fee|fie|foe&gt; coincide con cualquier &quot;fee&quot;, &quot;fie&quot;, o &quot;foe&quot; en la cadena objetivo (al igual que C&lt;f(e|i|o)e&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 14854</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 14854</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have a backlog of unresolved bugs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenemos un retraso de errores sin resolver.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Jarkko Hietaniemi and Andy Lester worked to mark as much data as possible in
the C source files as C&lt;static&gt;, to increase the proportion of the executable
file that the operating system can share between process, and thus reduce
real memory usage on multi-user systems.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T042637Z" changeid="explorer">
        <seg>Jarkko Hietaniemi y Andy Lester trabajaron para marcar como C&lt;static&gt; la mayor cantidad de datos en los archivos de código fuente en C, para incrementar la proporción del archivo ejecutable que el sistema operativo puede compartir entre procesos, y reducir así la cantidad de memoria utilizada en sistemas multiusuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;foreach&gt; modifier is an iterator: it executes the statement once
for each item in the LIST (with C&lt;$_&gt; aliased to each item in turn).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013118Z" changeid="explorer">
        <seg>El modificador C&lt;foreach&gt; es un iterador: ejecuta la instrucción una vez por cada elemento en la LISTA (con C&lt;$_&gt; asociado a cada elemento en cada iteración).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;Exporter&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;Exporter&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slavish adherence to portability concerns shouldn't get
in the way of your getting your job done.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Adhesión servil a los requerimientos de portabilidad no debe impedirle obtener el trabajo hecho).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPEN this, mode, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>OPEN este, modo, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This was
once used in a common idiom to disable or quote the special meanings
of regular expression metacharacters in a string that you want to
use for a pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se usó una vez como un modismo común para desactivar o citar los significados especiales de los metacaracteres de expresiones regulares en una cadena que desea utilizar para un patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example disabling Nagle's algorithm on a socket:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un ejemplo para deshabilitar el algoritmo de Nagle del socket:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cd /boot/common/lib; ln -s perl5/5.14.2/BePC-haiku/CORE/libperl.so .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111002T143731Z" changeid="explorer">
        <seg>cd /boot/common/lib; ln -s perl5/5.14.2/BePC-haiku/CORE/libperl.so .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $line  = &lt;$in&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T003553Z" changeid="zipf">
        <seg>my $linea  = &lt;$entrada&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.12.0 release and the
5.13.0 release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052426Z" changeid="explorer">
        <seg>Este documento describe las diferencias entre la versión 5.12.0 y la versión 5.13.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item link OLDFILE,NEWFILE
X&lt;link&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175420Z" changeid="explorer">
        <seg>=item link ARCHIVO_VIEJO,ARCHIVO_NUEVO
X&lt;link&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = qw/first second third/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150223Z" changeid="explorer">
        <seg>@a = qw/primero segundo tercero/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those functions ignore the buffering, while tell() does not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110307T000840Z" changeid="explorer">
        <seg>Esas funciones ignoran el sistema de búfer, mientras que tell(), no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+   addition</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235206Z" changeid="zipf">
        <seg>+   suma</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'foo(bar(baz)+baz(bop))'=~/$re/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185545Z" changeid="explorer">
        <seg>'foo(bar(baz)+baz(bop))'=~/$re/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax error will be
reported close to the C&lt;}&gt;, but you'll need to change something near the C&lt;{&gt;
such as using a unary C&lt;+&gt; to give Perl some help:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El error de sintaxis será reportado cerca de C&lt;}&gt;, pero tendrá que cambiar algo cerca de C&lt;{&gt;, como en el uso de un unario C&lt;+&gt;, para darle un poco de ayuda a Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When verifying an existing digest string you should use the digest as
the salt (like C&lt;crypt($plain, $digest) eq $digest&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando verifique un string i&lt;digest&gt; debe usar el propio I&lt;digest&gt; como el salto (como C&lt;crypt($plano, $digest) eq $digest&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlvar - Perl predefined variables</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235401Z" changeid="explorer">
        <seg>perlvar		Variables predefinidas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(at least in platforms of ASCII progeny)  Perl 5.8.1 restores the
more natural interpretation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005917Z" changeid="explorer">
        <seg>(al menos en las plataformas de la progenie ASCII). Perl 5.8.1 restauró la interpretación más natural</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Tied Arrays with Negative Array Indices</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170049Z" changeid="explorer">
        <seg>=head2 Arrays enlazados con índices de array negativos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++$j;  # prints 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ++$j;  # imprime 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5101delta	Perl changes in version 5.10.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5101delta	Cambios en la versión 5.10.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no C&lt;import&gt;
method can be found then the call is skipped, even if there is an AUTOLOAD
method.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se puede encontrar ningún método C&lt;import&gt; entonces la llamada se pasa por alto, incluso si hay un método AUTOLOAD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$old_filter = $db-&gt;filter_store_key  ( sub { ... } );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T223748Z" changeid="explorer">
        <seg>$filtro_antiguo = $db-&gt;filter_store_key  ( sub { ... } );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will be treated as a boolean match because the rules say both a regex match and
an explicit test on $_ will be treated as boolean.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T214934Z" changeid="explorer">
        <seg>será tratado como una coincidencia booleana porque las reglas dicen que tanto una expresión regular de una coincidencia y una prueba explícita sobre $_ serán tratados como booleanos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?: (?&lt;= ^ ) | (?&lt;= \s ) )  # after start-of-string or whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025353Z" changeid="explorer">
        <seg>(?: (?&lt;= ^ ) | (?&lt;= \s ) )  # después de inicio-de-cadena o espacio en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
feature can be extremely useful to give perl hints about where it
shouldn't backtrack.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta característica puede ser muy útil para dar pistas a perl sobre dónde no debe dar marcha atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash    Array     hash keys intersection   grep { exists $a-&gt;{$_} } @$b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hash        Array      claves hash intersección         grep { exists $a-&gt;{$_} } @$b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE: while (defined($line = &lt;ARGV&gt;)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LINEA: while (defined($linea = &lt;ARGV&gt;)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	== != &lt;=&gt; eq ne cmp ~~</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	== != &lt;=&gt; eq ne cmp ~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{ exec ('foo') }; print STDERR &quot;couldn't exec foo: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{ exec ('foo') }; print STDERR &quot;no puedo exec foo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This way
C&lt;~~&gt; will not break encapsulation by matching against the
object's internal representation as a reference.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190131Z" changeid="explorer">
        <seg>(De esta forma C&lt;~~&gt; no romperá la encapsulación al hacer la comparación con la representación interna del objeto a través de la referencia.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the file is successfully
compiled, C&lt;do&gt; returns the value of the last expression evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T160006Z" changeid="explorer">
        <seg>Si el archivo se compila bien, C&lt;do&gt; devuelve el valor de la última expresión evaluada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sqrt EXPR
X&lt;sqrt&gt; X&lt;root&gt; X&lt;square root&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201252Z" changeid="explorer">
        <seg>=item sqrt EXPR
X&lt;sqrt&gt; X&lt;root&gt; X&lt;square root&gt; X&lt;raíz cuadrada&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($nfound,$timeleft) =</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($n_encontrados,$tiempo_restanto) =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But with C&lt;&lt; open(A, &quot;&gt;&gt;&amp;=B&quot;) &gt;&gt;, the filehandles will share
the same underlying system file descriptor.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004846Z" changeid="explorer">
        <seg>Pero con C&lt;&lt; open(A, &quot;&gt;&gt;&amp;=B&quot;) &gt;&gt;, los identificadores de archivo compartirán el mismo descriptor de archivo subyacente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets and returns the random number seed for the C&lt;rand&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182542Z" changeid="explorer">
        <seg>Establece y devuelve la semilla de números aleatorios para el operador C&lt;rand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$pattern =~ s/(\W)/\\$1/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$patrón =~ s/(\W)/\\$1/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prints a string or a list of strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Imprime una cadena o una lista de cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus Perl provides the &quot;possessive&quot; quantifier form
as well.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, Perl proporciona también el cuantificador &quot;posesivo&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 List assignment to %ENV works</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 La asignación de lista a %ENV funciona</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>comp.lang.perl.modules       Use and development of Perl modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230400Z" changeid="explorer">
        <seg>comp.lang.perl.modules       Uso y desarrollo de módulos Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The embedding examples of L&lt;perlembed&gt; have been reviewed to be
up to date and consistent: for example, the correct use of
PERL_SYS_INIT3() and PERL_SYS_TERM().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T001314Z" changeid="explorer">
        <seg>Los ejemplos incluidos en L&lt;perlembed&gt; han sido revisados para estar al día y ser consistentes: por ejemplo, el uso correcto de PERL_SYS_INIT3() y PERL_SYS_TERM().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in this example, C&lt;goto-EXPR&gt; is exempt from the &quot;looks like a
function&quot; rule.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165038Z" changeid="explorer">
        <seg>Como se muestra en este ejemplo, C&lt;goto-EXPR&gt; está exento de la regla &quot;se parece a una función&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESTE PAQUETE SE PROPORCIONAL &quot;TAL CUAL&quot; Y SIN NINGUNA GARANTÍA EXPRESA O IMPLÍCITA, INCLUYENDO, SIN LIMITACIÓN, LAS GARANTÍAS IMPLÍCITAS DE COMERCIALIDAD E IDONEIDAD PARA UN PROPÓSITO PARTICULAR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T193248Z" changeid="explorer">
        <seg>o:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getnetbyaddr ADDR,ADDRTYPE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getnetbyaddr DIRECCIÓN,TIPODIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the
following code waits on semaphore $semnum of semaphore id $semid:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A modo de ejemplo, el siguiente código espera en un semáforo $semnum del semáforo con identificador $semid:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They never should have been
available with the shorter names, and if you application depends on
them, you should (be ashamed and) contact perl5-porters to discuss
what are the proper APIs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T001912Z" changeid="explorer">
        <seg>Nunca deberían haber estado disponibles con los nombres más acortados, y si su aplicación depende de ellos, debe (y avergonzarse de ello) contactar con los  perl5-porters para discutir cuáles son las API adecuadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's important that the
blocks are the right shape, and that the developer shouldn't have to use
a big block when all they need is a small one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014909Z" changeid="explorer">
        <seg>Sin embargo, es importante que los bloques estén en la forma correcta, y que el desarrollador no debería tener que utilizar un bloque grande cuando todo lo que necesita es uno pequeño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc&gt; for details,
and for other examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc&gt; para más detalles, y para otros ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike
B&lt;sed&gt;, we use the \&lt;I&lt;digit&gt;&gt; form in only the left hand side.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de B&lt;sed&gt;, utilizamos el formato \&lt;I&lt;dígito&gt;&gt; sólo en el lado izquierdo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scripts run by the superuser
may thus need to do a stat() to determine the actual mode of the file,
or temporarily set their effective uid to something else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Scripts ejecutados por el superusuario pueden necesitar hacer un stat() para determinar el modo actual del archivo, o temporalmente poner su uid efectivo a otro valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($line);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($linea);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to replace
parts of the EXPR and return what was there before in one operation,
just as you can with splice().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto le permite reemplazar partes de la EXPR y devolver lo que había antes, en una operación, tal como se puede hacer con splice().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To go the other way (produce a number
in octal), use sprintf() or printf():</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para hacer lo contrario (producir un número en octal), use sprintf() o printf():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Storing a reference to a constant value in a symbol
table is equivalent to a full typeglob referencing a constant subroutine,
but using about 400 bytes less memory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T033324Z" changeid="explorer">
        <seg>Almacenar una referencia a un valor constante en una tabla de símbolos es equivalente a un completo typeglob referenciando a una subrutina constante, pero usando unos 400 bytes menos de memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Smart match changes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233522Z" changeid="explorer">
        <seg>=head2 Cambios en la coincidencia inteligente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then it will
try to match C&lt;(?!123)&gt; with &quot;123&quot;, which fails.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170907Z" changeid="explorer">
        <seg>Entonces tratará de hacer coincidir C&lt;(?!123)&gt; con &quot;123&quot;, por lo que falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/eg;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225541Z" changeid="explorer">
        <seg>/eg;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ceil   = ceil(3.5);   # 4</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225511Z" changeid="explorer">
        <seg>$ceil   = ceil(3.5);   # 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The recommended order of sections in Perl module documentation is:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024504Z" changeid="explorer">
        <seg>El orden recomendado de las secciones de documentación de un módulo Perl es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>explorer perldgux.html</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>explorer perldgux.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; or C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; for file names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; o C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; para nombres de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?(1) \) )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195915Z" changeid="explorer">
        <seg>(?(1) \) )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 14832</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 14832</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the supplied
camel for anything other than a perl executable's icon is specifically not
covered, and anyone wishing to redistribute perl binaries I&lt;with&gt; the icon
should check directly with O'Reilly beforehand.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110000Z" changeid="explorer">
        <seg>El uso del camello suministrado, para cualquier otra cosa que fuera más allá de ser el icono de un archivo ejecutable perl no está específicamente cubierto, y cualquiera que quiera redistribuir binarios perl I&lt;con&gt; el icono debe consultar antes, y directamente, con O'Reilly.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{}    anon.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224147Z" changeid="explorer">
        <seg>{}    ref. hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the documentation for C&lt;ExtUtils::MakeMaker&gt; or C&lt;Module::Build&gt; for more
on how to specify C&lt;configure_requires&gt; when creating a distribution for CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010403Z" changeid="explorer">
        <seg>Consulte la documentación de C&lt;ExtUtils::MakeMaker&gt; o C&lt;Module::Build&gt; para más información sobre cómo especificar C&lt;configure_requires&gt; cuando se crea una distribución para CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>display_day();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021401Z" changeid="explorer">
        <seg>muestra_día();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying VERSION as a literal of the form v5.6.1 should generally be
avoided, because it leads to misleading error messages under earlier
versions of Perl that do not support this syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Especificando VERSIÓN como un literal de la forma v5.6.1, debe, generalmente, evitarse, porque lleva crear mensajes de error equívocos en las versiones anteriores de Perl que no admiten esta sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current value of C&lt;$,&gt; (if any) is printed between each LIST item.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T005731Z" changeid="explorer">
        <seg>El valor actual de C&lt;$,&gt; (si lo tiene) es impreso entre cada elemento de la LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Final: 'q', pos=8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Final: 'q', pos=8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_ATIME 	   if $opt_u;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_ATIME 	   if $opt_u;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,m}       Match at least n but not more than m times</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042711Z" changeid="explorer">
        <seg>{n,m}	Coincide al menos n veces, pero no más de m veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?{ $res = $cnt })                # On success copy to
                                       # non-localized location.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T201443Z" changeid="explorer">
        <seg>(?{ $res = $cnt })		# En éxito, copiar a una variable no-localizada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Wrong, will now warn</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051027Z" changeid="explorer">
        <seg># Incorrecto, mostrará un aviso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the F&lt;Changes&gt; file in the distribution for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el archivo F&lt;Changes&gt; en la distribución para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say '$foo is undefined';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>say '$foo es indefinido';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it succeeds it returns true; otherwise it returns false and
sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011817Z" changeid="explorer">
        <seg>Si tiene éxito devuelve verdadero; en caso contrario devuelve falso y asigna C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add space after
the C&lt;s&gt; when using a character allowed in identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Añadir un espacio después de la C&lt;s&gt; cuando se utilice un carácter permitido en identificadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recursing deeper than 50 times without consuming any input
string will also result in a fatal error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185757Z" changeid="explorer">
        <seg>Realizar un proceso recursivo más de 50 veces sin consumir ninguna cadena de entrada resultará en un error fatal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This assumes that
doubles must be aligned to the size of double.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto supone que los dobles deben estar alineados con el tamaño de un doble.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open '@_': $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir '@_': $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How do I make it work?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225931Z" changeid="explorer">
        <seg>¿Cómo puedo hacer que funcione?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $y;               # prints nothing; $y has fallen out of scope</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121341Z" changeid="zipf">
        <seg>print $y;               # no imprime nada; $y está fuera del ámbito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The character C&lt;-&gt; is treated specially and therefore C&lt;\-&gt; is treated
as a literal C&lt;-&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El carácter C&lt;-&gt; es tratado de forma especial y por lo tanto C&lt;\-&gt; es tratado como un literal C&lt;-&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsub		Perl subroutines</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsub		Subrutinas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;Package&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Paquete&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose that we want to enable a new RE escape-sequence C&lt;\Y|&gt; which
matches at a boundary between whitespace characters and non-whitespace
characters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001444Z" changeid="explorer">
        <seg>Supongamos que se desea habilitar una nueva secuencia de escape RE C&lt;\Y|&gt; que coincide en el límite entre los espacios en blanco y los caracteres no son blancos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl583delta	Perl changes in version 5.8.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl583delta	Cambios en la versión 5.8.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Firstly, copy the source and build a native copy of perl for your host
system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En primer lugar, copiar el código fuente y crear una copia nativa de perl de su sistema principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.8.1 does build and work well with Cygwin 1.3: with (uname -a)
C&lt;CYGWIN_NT-5.0 ... 1.3.22(0.78/3/2) 2003-03-18 09:20 i686 ...&gt;
a 100% &quot;make test&quot;  was achieved with C&lt;Configure -des -Duseithreads&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003534Z" changeid="explorer">
        <seg>Perl 5.8.1 se compila y funciona bien con Cygwin 1.3: con (uname-a) C&lt;CYGWIN_NT-5.0 ... 1.3.22(0.78/3/2) 2003-03-18 09:20 i686 ...&gt; se consiguió un 100% de un &quot;make test&quot; con C&lt;Configure -des -Duseithreads&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mkdir $tmpdir, 0700	or die &quot;can't mkdir $tmpdir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>mkdir $tmpdir, 0700	or die &quot;no puedo hacer mkdir $tmpdir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to intermix your source code
and your documentation text freely, as in</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto le permite entremezclar código fuente y texto de la documentación libremente, como por ejemplo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See L&lt;/&quot;Smart matching in detail&quot;&gt; for more
information on smart matching.) But when EXPR is one of the below
exceptional cases, it is used directly as a boolean:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver L&lt;/&quot;Coincidencia inteligente en detalle&quot;&gt; para más información sobre coincidencia inteligente) Pero cuando EXPR es una de las excepciones abajo indicadas, se usa directamente como un booleano:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators such as C&lt;++&gt;, C&lt;--&gt;, C&lt;+=&gt;,
C&lt;-=&gt;, and C&lt;.=&gt;, that operate on undefined left values such as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operadores como C&lt;++&gt;, C&lt;--&gt;, C&lt;+=&gt;, C&lt;-=&gt; y C&lt;.=&gt;, que operan sobre valores no definidos como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If all fields are empty, they are considered to be trailing.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si todos los campos están vacíos, se consideran que están al final).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>although without duplicating any side effects that dereferencing the lvalue
might trigger, such as from tie().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pero sin duplicar los efectos laterales que, desreferenciando el valor de la izquierda, se podrían desencadenar, como por ejemplo, de tie().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Miscellaneous</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Varios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certainly not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230215Z" changeid="explorer">
        <seg>Por supuesto que no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq7		Perl Language Issues</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000245Z" changeid="explorer">
        <seg>perlfaq7		Problemas del lenguaje Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that at sites with lots of users and groups the
functions no longer fail by returning only partial results.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T011127Z" changeid="explorer">
        <seg>Esto significa que en los sitios con una gran cantidad de usuarios y grupos, las funciones ya no fallarán devolviendo solo resultados parciales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.bixby.org/mark/perlix.html</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://www.bixby.org/mark/perlix.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, they do what you want, unless you want
consistency.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, ellos hacen lo que usted quiere, siempre que quiera coherencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
information is here to help you avoid the same mistakes and the extra
work that would inevitably be required to fix them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013217Z" changeid="explorer">
        <seg>Esta información está aquí para ayudarle a evitar los mismos errores y el trabajo extra que, inevitablemente, tendría que invertir en arreglarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example: [[:upper:]] matches any
                   uppercase character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T044250Z" changeid="explorer">
        <seg>Ejemplo: [[:upper:]] coincide con cualquier
                    carácter en mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty trailing fields, on the other
hand, are produced when there is a match at the end of the string (and
when LIMIT is given and is not 0), regardless of the length of the match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Campos vacíos consecuentes, por el contrario, se producen cuando hay una coincidencia al final de la cadena (y cuando LÍMITE se ha dado y no es 0), independientemente de la longitud de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the name tells you the particular
value to which it refers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resto del nombre indica a qué valor particular se accede.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, characters C&lt;&quot;0&quot;&gt;
and C&lt;&quot;1&quot;&gt; generate bits 0 and 1, as do characters C&lt;&quot;\000&quot;&gt; and C&lt;&quot;\001&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, los caracteres C&lt;&quot;0&quot;&gt; y C&lt;&quot;1&quot;&gt; generan los bits 0 y 1, al igual que los caracteres C&lt;&quot;\000&quot;&gt; y C&lt;&quot;\001&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This script was primarily a
technology demonstrator for Perl 5.8.0, but you can use piconv in the
place of iconv for virtually any case.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234915Z" changeid="explorer">
        <seg>Este script se desarrolló simplemente como una demostración de tecnología para Perl 5.8.0, pero puede usar piconv para cualquier tarea para la que usaría iconv.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;http://unicode.org/reports/tr36&gt; for a detailed discussion of Unicode
security issues.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220423Z" changeid="explorer">
        <seg>Vea L&lt;http://unicode.org/reports/tr36&gt; para una discusión detallada de los problemas de seguridad en Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Why waste brainpower on a one-shot when you
might want to do something like it again?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Por qué perder la energía cerebral de un acierto cuando puede volver a usarlo otra vez?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%map = (
                 red   =&gt; 0x00f,
                 blue  =&gt; 0x0f0,
                 green =&gt; 0xf00,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T042723Z" changeid="explorer">
        <seg>%map = (
                 rojo  =&gt; 0x00f,
                 azul  =&gt; 0x0f0,
                 verde =&gt; 0xf00,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An environment variable is used, rather than parallel make itself, because
L&lt;TAP::Harness&gt; needs to be able to schedule individual non-conflicting test
scripts itself, and there is no standard interface to C&lt;make&gt; utilities to
interact with their job schedulers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T002712Z" changeid="explorer">
        <seg>Se utiliza una variable de entorno, en lugar de ejecutarse por sí mismo en paralelo, porque L&lt;TAP::Harness&gt; tiene que ser capaz, por sí mismo, de programar scripts de test individuales sin que haya conflictos entre ellos, y no hay un interfaz estándar de C&lt;make&gt; para interactuar con las programaciones de sus trabajos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@info = stat($file) or die;     # better, now @info gets its due</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@info = stat($archivo) or die;     # mejor, ahora @info obtiene el valor correcto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Fetching network info
X&lt;network&gt; X&lt;protocol&gt; X&lt;host&gt; X&lt;hostname&gt; X&lt;IP&gt; X&lt;address&gt; X&lt;service&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202457Z" changeid="explorer">
        <seg>=item Obteniendo información de la red
X&lt;network&gt; X&lt;protocol&gt; X&lt;host&gt; X&lt;hostname&gt; X&lt;IP&gt; X&lt;address&gt; X&lt;service&gt; X&lt;red&gt; X&lt;protocolo&gt; X&lt;servidor&gt; X&lt;dirección&gt; X&lt;servicio&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(C&lt;croak()&gt; is a better version of C&lt;die()&gt; for use within 
modules, which reports its errors from the perspective of the caller.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023512Z" changeid="explorer">
        <seg>(C&lt;croak()&gt; es una versión mejorada de C&lt;die()&gt; para usar dentro de los módulos, que reporta sus errores desde la perspectiva del llamador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Release notes or changelogs should be produced for each release of your
software describing user-visible changes to your module, in terms
relevant to the user.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025040Z" changeid="explorer">
        <seg>Notas de versión o las listas de cambios deben producirse para cada versión de su software que describa los cambios visibles de su módulo, en términos relevantes para el usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%2\$d %d\n&quot;,    12, 34;        # will print &quot;34 12\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%2\$d %d\n&quot;,    12, 34;        # imprimirá &quot;34 12\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item BBEdit and BBEdit Lite</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T010236Z" changeid="explorer">
        <seg>=item BBEdit y BBEdit Lite</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>7 size   7 yearday    7 is_require   $$    process ID</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224346Z" changeid="explorer">
        <seg>7 size   7 día año    7 is_require      $$    Id. proceso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is generally easier to read
C&lt;$var_names_like_this&gt; than C&lt;$VarNamesLikeThis&gt;, especially for
non-native speakers of English.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Generalmente es más fácil leer C&lt;$var_nombres_como_este&gt; que C&lt;$VarNombresComoEste&gt;, especialmente para los que no sean castellanoparlantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, it is not limited to using regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, no está limitado a usar expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redeclaration of &quot;sendfile&quot; with a different storage class specifier:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003734Z" changeid="explorer">
        <seg>Redeclaración de &quot;sendfile&quot; con un especificador de clase de almacenamiento diferente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item crypt PLAINTEXT,SALT
X&lt;crypt&gt; X&lt;digest&gt; X&lt;hash&gt; X&lt;salt&gt; X&lt;plaintext&gt; X&lt;password&gt;
X&lt;decrypt&gt; X&lt;cryptography&gt; X&lt;passwd&gt; X&lt;encrypt&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item crypt TEXTOPLANO,SALTO
X&lt;crypt&gt; X&lt;digest&gt; X&lt;hash&gt; X&lt;salt&gt; X&lt;plaintext&gt; X&lt;password&gt; X&lt;decrypt&gt; X&lt;cryptography&gt; X&lt;passwd&gt; X&lt;contraseña&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, for backward (and we do mean &quot;backward&quot;) compatibility, Perl
permits these unnecessary but widely-supported conversions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por último, para compatibilidad anterior (y nos referimos a &quot;hacia atrás&quot;), Perl permite estas innecesarias, pero ampliamente soportadas conversiones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\U		uppercase all characters till \E seen</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232600Z" changeid="explorer">
        <seg>\U		mayúsculas hasta encontrar \E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;q#foo#&gt; is parsed as the string C&lt;foo&gt;, while C&lt;q #foo#&gt; is the
operator C&lt;q&gt; followed by a comment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;q#foo#&gt; es analizado como la cadena C&lt;foo&gt;, mientras que C&lt;q #foo#&gt; es el operador C&lt;q&gt; seguido por un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use FILEHANDLE alone to
print the content of C&lt;$_&gt; to it, you must use a real filehandle like
C&lt;FH&gt;, not an indirect one like C&lt;$fh&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T005457Z" changeid="explorer">
        <seg>Para utilizar solamente IDENTIFICADOR_ARCHIVO para imprimir en él, el contenido de C&lt;$_&gt;, debe ser un identificador de archivo real, como C&lt;FH&gt;, no uno indirecto como C&lt;$fh&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and print &quot;\$1 = $1\n&quot;,
                  &quot;\$2 = $2\n&quot;,
                  &quot;\$3 = $3\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185622Z" changeid="explorer">
        <seg>and print &quot;\$1 = $1\n&quot;,
                  &quot;\$2 = $2\n&quot;,
                  &quot;\$3 = $3\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;\001\000\002\000&quot; on little-endian</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175243Z" changeid="explorer">
        <seg># &quot;\001\000\002\000&quot; en little-endian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make test 2&gt;&amp;1 | tee make-test.out</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make test 2&gt;&amp;1 | tee make-test.out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;Quote and Quote-like Operators&gt; toward the end of this section,
as well as L&lt;/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220002Z" changeid="explorer">
        <seg>Vea también L&lt;Comillas y Operadores de comillas&gt; hacia el final de esta sección, así como L&lt;/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the string happens to be encoded as UTF-8 internally (and thus has
the UTF8 flag set), this is ignored by C&lt;vec&gt;, and it operates on the
internal byte string, not the conceptual character string, even if you
only have characters with values less than 256.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena pasa a ser codificado como UTF-8 de forma interna (y por tanto tiene la bandera UTF8 establecida), esto se ignora por C&lt;vec&gt;, y opera en la cadena de bytes interna, no la cadena de caracteres conceptuales, incluso si sólo tiene caracteres con valores inferiores a 256.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>should be enough, the Configure should automatically probe for the
correct 64-bit settings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002949Z" changeid="explorer">
        <seg>debería ser suficiente, la opción Configure automáticamente debería buscar la configuración correcta para 64 bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length limit on values (not keys) in the %ENV hash has been raised
from 255 bytes to 32640 bytes (except when the PERL_ENV_TABLES setting
overrides the default use of logical names for %ENV).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000247Z" changeid="explorer">
        <seg>El límite de longitud en los valores (no claves) en el hash %ENV se ha elevado de 255 bytes a 32640 bytes (excepto cuando el ajuste PERL_ENV_TABLES sobreescribe el uso predeterminado de los nombres lógicos de %ENV).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copying a file onto itself used to fail.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031554Z" changeid="explorer">
        <seg>Copiando un archivo sobre sí mismo provocará un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of the ioctl() built-in function was accidentally
broken in 5.8.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000852Z" changeid="explorer">
        <seg>El valor de retorno de la función incorporada ioctl() se rompió accidentalmente en 5.8.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;Z*Z*&quot;, pack(&quot;Z*Z*&quot;, ..)) was broken</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;Z*Z*&quot;, pack(&quot;Z*Z*&quot;, ..)) estaba roto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1  &quot;marge&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032556Z" changeid="explorer">
        <seg>1  &quot;marge&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for real %HASHes
X&lt;hash&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201218Z" changeid="explorer">
        <seg>=item Funciones %HASH reales
X&lt;hash&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the RE above, which is intentionally obfuscated for illustration, the
delimiter is C&lt;m&gt;, the modifier is C&lt;mx&gt;, and after delimiter-removal the
RE is the same as for C&lt;m/ ^ a \s* b /mx&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la RE anterior, que está intencionalmente ofuscada para su ilustración, el delimitador es C&lt;m&gt;, el modificador es C&lt;mx&gt;, y después de la eliminación de los delimitadores, la RE es la misma que C&lt;m/ ^ a \s* b /mx&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Qt</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225455Z" changeid="explorer">
        <seg>=item Qt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;child died with signal %d, %s coredump\n&quot;,
            ($?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052232Z" changeid="explorer">
        <seg>printf &quot;hijo muerto con señal %d, %s coredump\n&quot;,
            ($?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @AoA, [ @tmp ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @AoA, [ @tmp ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named captures are implemented as being aliases to 
numbered groups holding the captures, and that interferes with the
implementation of the branch reset pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T200347Z" changeid="explorer">
        <seg>Las capturas nominadas son implementadas como alias a los grupos numerados que almacenan las capturas, y esto interfiere con la implementación del patrón de reinicio de rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>translates a list of numbers to the corresponding characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>traduce una lista de números a sus caracteres correspondientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod 0644, &lt;*.c&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod 0644, &lt;*.c&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;POSIX&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001442Z" changeid="explorer">
        <seg>Se describe en L&lt;POSIX&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;upload_hook()&gt; and C&lt;append()&gt; now works in function-oriented mode</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025221Z" changeid="explorer">
        <seg>C&lt;upload_hook()&gt; y C&lt;append()&gt; ahora funcionan en el modo orientado a función</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The position in the file of FILEHANDLE is left unchanged.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013354Z" changeid="explorer">
        <seg>La posición en el archivo de IDENTIFICADOR_ARCHIVO no cambia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item make test</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024927Z" changeid="explorer">
        <seg>=item make test</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The numbers underneath show in
which group the captured content will be stored.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T200306Z" changeid="explorer">
        <seg>Los números de abajo muestran en qué grupo de captura será almacenado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#ARRAY) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#ARRAY) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl qw( :mode );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl qw( :mode );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that just as in C, Perl doesn't define B&lt;when&gt; the variable is
incremented or decremented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que, al igual que en C, Perl no define B&lt;cuando&gt; la variable se incrementa o disminuye.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlapi&gt;, L&lt;perlintern&gt;, L&lt;perlmodlib&gt; and L&lt;perltoc&gt; are now all
generated at build time, rather than being shipped as part of the release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152708Z" changeid="explorer">
        <seg>L&lt;perlapi&gt;, L&lt;perlintern&gt;, L&lt;perlmodlib&gt; y L&lt;perltoc&gt; son ahora generados en tiempo de compilación, en lugar de ser empaquetados como parte de la distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;:unique&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192338Z" changeid="explorer">
        <seg>=head2 C&lt;:unique&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to classes and object-orientation
X&lt;object&gt; X&lt;class&gt; X&lt;package&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T011851Z" changeid="explorer">
        <seg>=item Palabras clave relativas a las clases y orientación a objetos
X&lt;object&gt; X&lt;class&gt; X&lt;package&gt; X&lt;objeto&gt; X&lt;clase&gt; X&lt;paquete&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $x;  our $x;	# warns</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040527Z" changeid="explorer">
        <seg>my $x;  our $x;	# avisa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/foo/bar/el;     # &quot;e&quot; and &quot;l&quot; flags</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213715Z" changeid="explorer">
        <seg>s/foo/bar/el;     # opciones &quot;e&quot; y &quot;l&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$b&gt; is negative, then C&lt;$a % $b&gt; is C&lt;$a&gt; minus the
smallest multiple of C&lt;$b&gt; that is not less than C&lt;$a&gt; (i.e. the
result will be less than or equal to zero).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$b&gt; es negativo, entonces C&lt;$a % $b&gt; es C&lt;$a&gt; menos el múltiplo más pequeño de C&lt;$b&gt; que no es menor que C&lt;$a&gt; (es decir el resultado será menor o igual a cero).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The handling of complex expressions by the C&lt;given&gt;/C&lt;when&gt; switch
statement has been enhanced.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102827Z" changeid="explorer">
        <seg>El manejo de expresiones complejas por C&lt;given&gt;/C&lt;when&gt; de la instrucción switch ha sido mejorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no more entries, returns the undefined value in
scalar context and the empty list in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay más entradas, devuelve el valor indefinido en el contexto escalar y la lista vacía en el contexto de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Effect of pragmas in eval</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200245Z" changeid="explorer">
        <seg>=head2 Efecto de los pragma en eval</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this produces nine strings, one for
each pairing of fruits and colors:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, esto produce nueve cadenas, una por cada par de frutas y colores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This flag tells Perl to interpret the supplied string as a vector of
integers, one for each character in the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta bandera le dice a Perl que interprete la cadena indicada como un vector de enteros, uno para cada carácter en la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may distribute the programs of this Package in object code or
executable form, provided that you do at least ONE of the following:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede distribuir los programas de este Paquete en código objeto o en formato ejecutable, siempre que usted haga por lo menos UNO de los puntos siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Detached threads are now also supported on Windows.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T104929Z" changeid="explorer">
        <seg>I&lt;Threads&gt; desligados son ahora también compatibles con Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;next&gt; cannot be used to exit a block which returns a value such as
C&lt;eval {}&gt;, C&lt;sub {}&gt;, or C&lt;do {}&gt;, and should not be used to exit
a grep() or map() operation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000946Z" changeid="explorer">
        <seg>C&lt;next&gt; no se puede utilizar para salir de un bloque que devuelve un valor, como en C&lt;eval {}&gt;, C&lt;sub {}&gt; o C&lt;do {}&gt;, y no debe ser utilizado para salir de una operación grep() o map().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if you used C&lt;*&gt;'s in the internal groups instead of limiting them
to 0 through 5 matches, then it would take forever--or until you ran
out of stack space.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T211206Z" changeid="explorer">
        <seg>Y si ha utilizado algún C&lt;*&gt; en los grupos internos en lugar de limitarlos a 0 a 5 coincidencias, entonces se ejecutará para siempre o hasta que se quede sin espacio de pila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An integer OPTVAL is shorthand for pack(&quot;i&quot;, OPTVAL).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un entero como OPCIÓN_VALOR es la abreviatura de pack(&quot;i&quot;, OPCIÓN_VALOR).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5004delta - what's new for perl5.004</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5004delta - qué hay de nuevo para perl5.004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Perl script or program consists of one or more statements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un script o programa Perl consta de una o varias instrucciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can find out whether your Perl supports long
doubles via L&lt;Config&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede averiguar si su Perl soporta dobles a través de L&lt;Config&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlreref has been added: it is a regular expressions quick reference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T181018Z" changeid="explorer">
        <seg>perlreref ha sido añadido: es una referencia rápida para expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Backtracking
X&lt;backtrack&gt; X&lt;backtracking&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T144944Z" changeid="explorer">
        <seg>=head2 I&lt;Backtracking&gt; (Vuelta atrás)
X&lt;backtrack&gt; X&lt;backtracking&gt; X&lt;vuelta atrás&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NOTE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 NOTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;gt&quot; returns true if the left argument is stringwise greater
than the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;gt&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente mayor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordering of two matches for C&lt;S&gt; is the same as for C&lt;S&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235621Z" changeid="explorer">
        <seg>Ordenación de dos coincidencias para C&lt;S&gt; es lo mismo que para C&lt;S&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 1-59059-097-X [1st edition July 2003]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003506Z" changeid="explorer">
        <seg>ISBN 1-59059-097-X [1ª edición - Julio de 2003]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, the benefit of a language is closely related to the skill of
the people using that language.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232324Z" changeid="explorer">
        <seg>En general, las ventajas que ofrece un lenguaje están muy relacionadas con la destreza de los usuarios del lenguaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try that on an
undefined variable, you'll take an exception.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031032Z" changeid="explorer">
        <seg>Si intenta hacer esto en una variable no definida, recibirá una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIMIT is unspecified or zero, trailing null fields are
stripped (which potential users of C&lt;pop&gt; would do well to remember).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LÍMITE no está especificado o es cero, los campos vacíos finales son descartados (que los potenciales usuarios de C&lt;pop&gt; harían bien en recordar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $f = myopen(&quot;&lt;/etc/motd&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $f = miopen(&quot;&lt;/etc/motd&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Tk</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225454Z" changeid="explorer">
        <seg>=item Tk</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also explicitly specify the argument number to use for
the join string using something like C&lt;*2$v&gt;; for example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede especificar, explícitamente, el número de argumento a utilizar para la combinación de cadena usando algo como C&lt;*2$v&gt;; por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's still in development in both its syntax and
design.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004332Z" changeid="explorer">
        <seg>Su sintaxis y su diseño aún están en fase de desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = 'ABC123';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050354Z" changeid="explorer">
        <seg>$x = 'ABC123';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example, even under C&lt;use integer&gt;, if you take the C&lt;sqrt(2)&gt;, you'll
still get C&lt;1.4142135623731&gt; or so.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T215039Z" changeid="explorer">
        <seg>Por ejemplo, incluso bajo C&lt;use integer&gt;, si escribe C&lt;sqrt(2)&gt;, seguirá obteniendo, más o menos, C&lt;1.4142135623731&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gethostbyaddr ADDR,ADDRTYPE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gethostbyaddr DIRECCIÓN,TIPODIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function binds a variable to a package class that will provide the
implementation for the variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función une una variable a una clase de paquete que ofrecerá la implementación para esa variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open netscape history file: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir el archivo histórico del netscape: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perllocale&gt; and L&lt;POSIX&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perllocale&gt; y L&lt;POSIX&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-x  File is executable by effective uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004521Z" changeid="explorer">
        <seg>-x  Archivo es ejecutable por el uid/gid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the output produced should be the following:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185656Z" changeid="explorer">
        <seg>la salida producida debe ser la siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now set C&lt;-W&gt; from the C&lt;PERL5OPT&gt; environment variable</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010611Z" changeid="explorer">
        <seg>Ahora puede establecer C&lt;-W&gt; desde la variable de entorno C&lt;PERL5OPT&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.14); # same as @list = (2 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3.14); # lo mismo que @lista = (2 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
F&lt;dprofpp&gt; utility analyzes the output of this profiler and tells you
which subroutines are taking up the most run time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231929Z" changeid="explorer">
        <seg>La utilidad F&lt;dprofpp&gt; analiza los resultados del perfilador e indica cuáles son las subrutinas que consumen más tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Newton&quot; =&gt; &quot;Isaac&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;Newton&quot; =&gt; &quot;Isaac&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the empty list if C&lt;stat&gt; fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la lista vacía si C&lt;stat&gt; falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last if /^--$/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last if /^--$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complete Perl documentation is available with the Perl distribution.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230231Z" changeid="explorer">
        <seg>La distribución de Perl incluye la documentación completa de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$other_execute =  $mode &amp; S_IXOTH;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$otros_ejecutar =  $modo &amp; S_IXOTH;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a scheme is sometimes preferable to matching
particular string values of C&lt;$@&gt; with regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal esquema es algunas veces preferible a emparejar ciertas cadenas de valores de C&lt;$@&gt; usando expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $bar{'blurfl'};      # Compare to: delete $bar{'blurfl'};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef $bar{'blurfl'};      # Comparar a: delete $bar{'blurfl'};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, C&lt;L&lt;use locale|perllocale&gt;&gt; sets the default modifier to C&lt;/l&gt;;
and C&lt;L&lt;use feature 'unicode_strings|feature&gt;&gt; or
C&lt;L&lt;use 5.012|perlfunc/use VERSION&gt;&gt; (or higher) set the default to
C&lt;/u&gt; when not in the same scope as either C&lt;L&lt;use locale|perllocale&gt;&gt;
or C&lt;L&lt;use bytes|bytes&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T235539Z" changeid="explorer">
        <seg>De lo contrario, C&lt;L&lt;use locale|perllocale&gt;&gt; establece el modificador por defecto a C&lt;/l&gt;; y C&lt;L&lt;use feature 'unicode_strings|feature&gt;&gt; o C&lt;L&lt;use 5.012|perlfunc/use VERSION&gt;&gt; (o superior) establece el valor por defecto a C&lt;/u&gt; cuando no estén en el mismo ámbito, tanto si está C&lt;L&lt;use locale|perllocale&gt;&gt; o C&lt;L&lt;use bytes|bytes&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A named array in scalar context is quite different from what would at
first glance appear to be a list in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un array con nombre, en contexto escalar, es muy diferente de lo que en un primer vistazo pudiera ser una lista en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod($perm | 0600, $fh);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod($permisos | 0600, $fh);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provide a README file and perhaps also release notes, changelog, etc</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014006Z" changeid="explorer">
        <seg>Proporcione un archivo README y quizás también notas de la versión, de cambios, etc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this operator produces an assignable result, using assignments
without parentheses will get you in trouble.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que este operador produce un resultado asignable, usar asignaciones sin paréntesis hará que se meta en problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Undefines the value of EXPR, which must be an lvalue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203504Z" changeid="explorer">
        <seg>Indefine el valor de EXPR, que debe ser un I&lt;ivalor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\K        [6]  Keep the stuff left of the \K, don't include it in $&amp;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224725Z" changeid="explorer">
        <seg>\K        [6]  Olvidar lo que está a la izquierda de \K, no incluir en $&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$time = (stat($file))[8];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004220Z" changeid="explorer">
        <seg>$acceso = (stat($archivo))[8];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To reiterate, this modifier provides protection for applications that
don't wish to be exposed to all of Unicode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000203Z" changeid="explorer">
        <seg>Repetimos, este modificador proporciona protección para las aplicaciones que no quieran estar expuestas a todo el Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;do&gt; can read the file but cannot compile it, it returns C&lt;undef&gt; and sets
an error message in C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T232941Z" changeid="explorer">
        <seg>Si C&lt;do&gt; puede leer el archivo pero no puede compilarlo, devuelve C&lt;undef&gt; y pone un mensaje de error en C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If you put a space it
will be treated as a null identifier, which is valid, and matches the
first empty line.)  The terminating string must appear by itself
(unquoted and with no surrounding whitespace) on the terminating line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si pone un espacio será tratado como un identificador nulo, que es válido, y coincide con la primera línea en blanco). La cadena de terminación debe aparecer a sí mismo (sin comillas y sin espacios en blanco que la rodee) en la línea de terminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual
random order is subject to change in future versions of Perl, but it
is guaranteed to be the same order as either the C&lt;values&gt; or C&lt;each&gt;
function produces (given that the hash has not been modified).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El actual orden aleatorio está sujeto a cambio en futuras versiones de Perl, pero se garantiza que sea el mismo orden que las funciones C&lt;values&gt; o C&lt;each&gt; producirían (mientras que el hash no haya sido modificado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CFLAGS=-I/path/to/flock/server/headers ./configure.gnu \</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CFLAGS=-I/path/to/flock/server/headers ./configure.gnu \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+       prefix non-negative number with a plus sign</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>+       prefija un número no negativo con un signo más</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (\&amp;complicated_check) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (\&amp;confirmacion_complicada) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using look-ahead assertions and negations, this can all get even
trickier.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T165912Z" changeid="explorer">
        <seg>Cuando se utiliza con aserciones consecuentes y negaciones, todo esto puede ser incluso aún más complicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example, C&lt;0666 &amp; ~027&gt; is 0640.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;0666 &amp; ~027&gt; es 0640.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;|&quot; returns its operands ORed together bit by bit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;|&quot; devuelve la operación OR, bit a bit, de sus operandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getlogin</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getlogin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 I/O Operators
X&lt;operator, i/o&gt; X&lt;operator, io&gt; X&lt;io&gt; X&lt;while&gt; X&lt;filehandle&gt;
X&lt;&lt; &lt;&gt; &gt;&gt; X&lt;@ARGV&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185607Z" changeid="explorer">
        <seg>=head2 Operadores E/S
X&lt;operator, i/o&gt; X&lt;operator, io&gt; X&lt;io&gt; X&lt;while&gt; X&lt;filehandle&gt;
X&lt;&lt; &lt;&gt; &gt;&gt; X&lt;@ARGV&gt; X&lt;operador, e/s&gt; X&lt;operador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlgit		Using git with the Perl repository</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141217Z" changeid="explorer">
        <seg>perlgit		Usando git con el repositorio de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl bug
database at http://rt.perl.org/perlbug/ .  There may also be
information at http://www.perl.org/ , the Perl Home Page.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T053007Z" changeid="explorer">
        <seg>Si encuentra algo que piensa que es un error, podría verificar los artículos publicados recientemente en el grupo de noticias comp.lang.perl.misc y la base de datos de errores de perl en http://rt.perl.org/bugs . Hay también información en la página principal de Perl, http://www.perl.org/ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item NEXT</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015232Z" changeid="explorer">
        <seg>=item NEXT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?= $ | \s )                # in front of end-of-string or whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025701Z" changeid="explorer">
        <seg>(?= $ | \s )                # delante de un final-de-cadena o espacio en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item IO</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014819Z" changeid="explorer">
        <seg>=item IO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;continue&gt; block, if any, is not executed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bloque C&lt;continue&gt;, si está, no es ejecutado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5123delta - what is new for perl v5.12.3</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111002T143053Z" changeid="explorer">
        <seg>perl5123delta - qué hay de nuevo en perl v5.12.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as an lvalue, specifying a
substring that is entirely outside the string raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203409Z" changeid="explorer">
        <seg>Cuando se utiliza como un I&lt;ivalor&gt;, especificando una subcadena que está totalmente fuera de la cadena lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example in L&lt;perlipc/&quot;Sockets: Client/Server Communication&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el ejemplo en L&lt;perlipc/&quot;Sockets: Comunicación Cliente/Servidor&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.nntp.perl.org/group/perl.vmsperl/2010/11/msg15419.html</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230840Z" changeid="explorer">
        <seg>http://www.nntp.perl.org/group/perl.vmsperl/2010/11/msg15419.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/&quot;(?&gt;(?:(?&gt;[^&quot;\\]+)|\\.)*)&quot;/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/&quot;(?&gt;(?:(?&gt;[^&quot;\\]+)|\\.)*)&quot;/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists &amp;{$ref-&gt;{A}{B}{$key}})   { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists &amp;{$ref-&gt;{A}{B}{$clave}})   { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 - empty hashes or arrays will match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 - hash o array vacíos coincidirán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When writing, if STRING is too long, only SIZE
bytes are used; if STRING is too short, nulls are written to fill out
SIZE bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al escribir, si CADENA es demasiado larga, sólo se utilizan TAMAÑO bytes; si CADENA es demasiado corta, se escriben nulos para llenar TAMAÑO bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lc EXPR
X&lt;lc&gt; X&lt;lowercase&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174212Z" changeid="explorer">
        <seg>=item lc EXPR
X&lt;lc&gt; X&lt;lowercase&gt; X&lt;minúscula&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To refer to the current contents of a group later on, within
the same pattern, use C&lt;\g1&gt; (or C&lt;\g{1}&gt;) for the first, C&lt;\g2&gt; (or C&lt;\g{2}&gt;)
for the second, and so on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T000846Z" changeid="explorer">
        <seg>Para hacer referencia más tarde a los contenidos actuales de un grupo de captura, dentro del mismo patrón, use C&lt;\g1&gt; (o C&lt;\g{1}&gt;) para el primero, C&lt;\g2&gt; (o C&lt;\g{2}&gt;) para el segundo, y así sucesivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $dbase, &quot;+&lt;dbase.mine&quot;)          # ditto</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004018Z" changeid="explorer">
        <seg>open(my $dbase, &quot;+&lt;dbase.mine&quot;)          # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>display_year();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021351Z" changeid="explorer">
        <seg>muestra_año();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A question mark was chosen for this and for the minimal-matching
construct because 1) question marks are rare in older regular
expressions, and 2) whenever you see one, you should stop and
&quot;question&quot; exactly what is going on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un signo de interrogación fue elegido para esto y para la construcción mínima de coincidencia porque: 1) signos de interrogación son poco frecuentes en expresiones regulares antiguas, y 2) cada vez que veas uno, debe pararse y &quot;cuestionarse&quot; exactamente lo que está pasando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Switch statement changes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102810Z" changeid="explorer">
        <seg>=head2 Cambios en la instrucción Switch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpeername SOCKET
X&lt;getpeername&gt; X&lt;peer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173520Z" changeid="explorer">
        <seg>=item getpeername SOCKET
X&lt;getpeername&gt; X&lt;peer&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|  a   | undef|</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225611Z" changeid="explorer">
        <seg>|  a   | undef|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $y = &quot;bar&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232629Z" changeid="explorer">
        <seg>my $y = &quot;bar&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the shell, type</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el shell, escriba</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/undef&gt;, L&lt;/exists&gt;, L&lt;/ref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/undef&gt;, L&lt;/exists&gt;, L&lt;/ref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concatenation now works correctly
when C&lt;use bytes;&gt; is in scope.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110236Z" changeid="explorer">
        <seg>La concatenación funciona ahora correctamente cuando el C&lt;use bytes;&gt; está activo en el ámbito actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl may compile the pattern at the moment of execution of the qr()
operator, using qr() may have speed advantages in some situations,
notably if the result of qr() is used standalone:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222859Z" changeid="explorer">
        <seg>Debido a que Perl puede compilar el patrón en el momento de la ejecución del operador qr(), usarlo puede tener ventajas de velocidad en algunas situaciones, notablemente si el resultado de qr() se utiliza de forma independiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Perl assumes that it must do most of its arithmetic in
floating point.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma predeterminada, Perl se supone que debe hacer la mayor parte de su aritmética en punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $@ if $@;                # prints &quot;bar lives here&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $@ if $@;                # imprime &quot;bar vive aquí&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Numeric comparison</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235219Z" changeid="zipf">
        <seg>=item Comparación numérica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The text is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El texto es ignorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all methods indicated above need be implemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No todos los métodos indicados es necesario implementarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item reset</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item reset</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?#text)&gt;
X&lt;(?#)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230512Z" changeid="explorer">
        <seg>=item C&lt;(?#text)&gt;
X&lt;(?#)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PAT++               (?&gt;PAT+)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232342Z" changeid="explorer">
        <seg>PAT++               (?&gt;PAT+)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $code = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T015921Z" changeid="explorer">
        <seg>my $code = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&gt;=&quot; returns true if the left argument is numerically greater
than or equal to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&gt;=&quot; devuelve verdadero si el argumento de la izquierda es numéricamente mayor o igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDERR &quot;stderr 2\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print STDERR &quot;stderr 2\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(*FAIL)&gt; C&lt;(*F)&gt;
X&lt;(*FAIL)&gt; X&lt;(*F)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050545Z" changeid="explorer">
        <seg>=item C&lt;(*FAIL)&gt; C&lt;(*F)&gt;
X&lt;(*FAIL)&gt; X&lt;(*F)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Differences from Perl 6</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Diferencias con Perl 6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently implemented pragmas are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las pragmas actualmente implementadas son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @files;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T005548Z" changeid="explorer">
        <seg>my @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The perlfunc(1) entry on
C&lt;umask&gt; discusses the choice of MASK in more detail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La entrada perlfunc(1) sobre C&lt;umask&gt; discute la elección de la máscara con más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Version 8 Regular Expressions
X&lt;regular expression, version 8&gt; X&lt;regex, version 8&gt; X&lt;regexp, version 8&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T200129Z" changeid="explorer">
        <seg>=head2 Expresiones regulares versión 8
X&lt;regular expression, version 8&gt; X&lt;regex, version 8&gt; X&lt;regexp, version 8&gt; X&lt;expresión regular, versión 8&gt; X&lt;regex, versión 8&gt; X&lt;regexp, versión 8&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can find out whether your Perl supports quads via L&lt;Config&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182520Z" changeid="explorer">
        <seg>Puede averiguar si su Perl soporta quads a través de L&lt;Config&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;\$foo is alive and $foo!&quot;;     # does show up</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;\$foo está vivo y $foo!&quot;;     # lo muestra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The numbers refer to the Perl repository change numbers; see
L&lt;Changes58&gt; (or L&lt;Changes&gt; in Perl 5.8.1).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215126Z" changeid="explorer">
        <seg>Los números se refieren a los números de cambio en el repositorio Perl; vea L&lt;Changes58&gt; (o L&lt;Cambios&gt; en Perl 5.8.1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Slices
X&lt;slice&gt; X&lt;array, slice&gt; X&lt;hash, slice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035909Z" changeid="explorer">
        <seg>=head2 Porciones
X&lt;slice&gt; X&lt;array, slice&gt; X&lt;hash, slice&gt; X&lt;porción&gt; X&lt;array, porción&gt; X&lt;hash, porción&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;alarm&gt;, C&lt;exec&gt;, C&lt;fork&gt;, C&lt;getpgrp&gt;, C&lt;getppid&gt;, C&lt;getpriority&gt;, C&lt;kill&gt;,
C&lt;pipe&gt;, C&lt;qx//&gt;, C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;sleep&gt;, C&lt;system&gt;,
C&lt;times&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;alarm&gt;, C&lt;exec&gt;, C&lt;fork&gt;, C&lt;getpgrp&gt;, C&lt;getppid&gt;, C&lt;getpriority&gt;, C&lt;kill&gt;, C&lt;pipe&gt;, C&lt;qx/STRING/&gt;, C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;sleep&gt;, C&lt;system&gt;, C&lt;times&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open my $fh, &quot;@_&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open my $fh, &quot;@_&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On ASCII platforms,
this means that the code points between 128 and 255 take on their
Latin-1 (ISO-8859-1) meanings (which are the same as Unicode's), whereas
in strict ASCII their meanings are undefined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T171440Z" changeid="explorer">
        <seg>En plataformas ASCII significa que los puntos de código entre 128 y 255 toman sus significados desde el Latin-1 (ISO-8859-1) (que son los mismos que los de Unicode), mientras que en un ASCII estricto sus significados no están definidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example to define a &quot;systell&quot; function:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, para definir una función &quot;systell&quot;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;PerlIO&gt;, L&lt;perlrun&gt;, and the discussion about the
PERLIO environment variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;PerlIO&gt;, L&lt;perlrun&gt; y la discusión sobre la variable de entorno PERLIO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(ARTICLE) or die &quot;Can't find article $ARTICLE: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003920Z" changeid="explorer">
        <seg>open(ARTICULO) or die &quot;No puedo encontrar el artículo $ARTICULO: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;!~&quot; with a non-destructive substitution (s///r) or transliteration
(y///r) is a syntax error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T184733Z" changeid="explorer">
        <seg>Binario &quot;!~&quot; con una sustitución no destructiva (s///r) o transliteración (y///r) es un error sintáctico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Integer Arithmetic
X&lt;integer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011135Z" changeid="explorer">
        <seg>=head2 Aritmética entera
X&lt;integer&gt; X&lt;entero&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If another branch in the inner parentheses was matched, such as in the
string 'ACDE', then the C&lt;D&gt; and C&lt;E&gt; would have to be matched as well.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T144921Z" changeid="explorer">
        <seg>Si coincide otra rama en el paréntesis más interior, como en el caso de la cadena 'ACDE', entonces la C&lt;D&gt; y C&lt;E&gt; también tendrían que coincidir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--$p while $idx[$p-1] &gt; $idx[$p];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>--$p while $idx[$p-1] &gt; $idx[$p];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I've replaced fork()/exec() with spawn()
and the standalone exec() with spawn().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102228Z" changeid="explorer">
        <seg>He reemplazado fork()/exec() y el solitario exec() con spawn().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authors of similar modules, or modules with similar
names, may be a good place to start.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015532Z" changeid="explorer">
        <seg>Los autores de los módulos similares, o módulos con nombres similares, puede ser un buen lugar para comenzar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%*.*s&gt;&quot;, $a, $b, $c;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;&lt;%*.*s&gt;&quot;, $a, $b, $c;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the one- and two-argument forms of the call, the mode and filename
should be concatenated (in that order), preferably separated by white
space.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T002728Z" changeid="explorer">
        <seg>En las formas de la llamada de uno y de dos argumentos, el modo y el nombre del archivo debe ser concatenados (en ese orden), preferiblemente separados por espacio en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with Perl 5.14, C&lt;unshift&gt; can take a scalar EXPR, which must hold
a reference to an unblessed array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183729Z" changeid="explorer">
        <seg>A partir de Perl 5.14, C&lt;unshift&gt; puede tomar una EXPR escalar, que debe contener la referencia a un hash o un array no bendecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endgrent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endgrent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print @mpeg;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225556Z" changeid="explorer">
        <seg>print @mpeg;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo{join($;, $a, $b, $c)}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T014045Z" changeid="explorer">
        <seg>$foo{join($;, $a, $b, $c)}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/apples?/) {
            say &quot;I like apples.&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234518Z" changeid="explorer">
        <seg>when (/manzanas?/) {
            say &quot;Me gustan las manzanas.&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item perl Makefile.PL</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024924Z" changeid="explorer">
        <seg>=item perl Makefile.PL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can actually chomp anything that's an lvalue, including an assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede recortar cualquier cosa que sea un lvalue (valor a la izquierda), incluyendo una asignación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A numeric repeat count may optionally be enclosed in brackets, as
in C&lt;pack(&quot;C[80]&quot;, @arr)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un número de repeticiones podría estar opcionalmente encerrada entre paréntesis, como en C&lt;pack(&quot;C[80]&quot;, @arr)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will now imply:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T015847Z" changeid="explorer">
        <seg>ahora implicará:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = 123456789123456789;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033303Z" changeid="explorer">
        <seg>$x = 123456789123456789;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If C&lt;use locale&gt; is set, then this depends on the current locale.)
Today it is more common to use the quotemeta() function or the C&lt;\Q&gt;
metaquoting escape sequence to disable all metacharacters' special
meanings like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si C&lt;use locale&gt; está establecido, entonces esto depende de la localización actual). Hoy es más común el uso de la función quotemeta() o de la secuencia de escapado C&lt;\Q&gt; para desactivar los significados especiales de los metacaracteres, como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system 'stty', 'icanon', 'eol', '^@'; # ASCII NUL</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system 'stty', 'icanon', 'eol', '^@'; # ASCII NUL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return log($n)/log(10);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return log($n)/log(10);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always check C&lt;$@&gt; first, as compilation
could fail in a way that also sets C&lt;$!&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T155907Z" changeid="explorer">
        <seg>Siempre revise C&lt;$@&gt; en primer lugar, la compilación puede fallar de una manera que también actualice C&lt;$!&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 List value constructors
X&lt;list&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035721Z" changeid="explorer">
        <seg>=head2 Constructores de lista de valores
X&lt;list&gt; X&lt;lista&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation enhancements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mejoras en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
has been fixed [RT #49003].</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003935Z" changeid="explorer">
        <seg>Esto ha sido corregido [RT #49003].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.hurd - Perl version 5 on Hurd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.hurd - Perl versión 5 sobre Hurd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can put a C&lt;+&gt; in front of the C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt; to
indicate that you want both read and write access to the file; thus
C&lt;&lt; +&lt; &gt;&gt; is almost always preferred for read/write updates--the 
C&lt;&lt; +&gt; &gt;&gt; mode would clobber the file first.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T002453Z" changeid="explorer">
        <seg>Puede poner un C&lt;+&gt; en frente de C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt; para indicar que desea acceder al archivo tanto en lectura como en escritura; así, C&lt;&lt; +&lt; &gt;&gt; casi siempre es la forma preferida para la lectura/escritura de actualizaciones -el modo C&lt;&lt; +&gt; &gt;&gt; primero sobreescribirá el archivo-.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nicholas Clark created the pluggable interface, 
refactored Brandon's implementation to work with it, and wrote this document.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115737Z" changeid="explorer">
        <seg>Nicholas Clark creó el interfaz enchufable, la implementación refactorizada de Brandon para trabajar con él, y escribió este documento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many memory leaks have been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031148Z" changeid="explorer">
        <seg>Muchas fugas de memoria han sido corregidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name =&gt; &quot;wibble&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021556Z" changeid="explorer">
        <seg>nombre =&gt; &quot;wibble&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if the filehandle has been marked as C&lt;:utf8&gt; Unicode
characters are read instead of bytes (the LENGTH, OFFSET, and the
return value of sysread() are in Unicode characters).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012927Z" changeid="explorer">
        <seg>Tenga en cuenta que si el identificador de archivo ha sido marcado como  C&lt;:utf8&gt;, son leídos caracteres Unicode en lugar de bytes (la LONGITUD, el DESPLAZAMIENTO y el valor de retorno de sysread() están descritos en forma de número de caracteres Unicode).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; put perl.tar /QOpenSys</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T134638Z" changeid="explorer">
        <seg>&gt; put perl.tar /QOpenSys</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some years ago, comp.lang.perl was divided into those groups, and
comp.lang.perl itself officially removed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230407Z" changeid="explorer">
        <seg>Hace unos años se dividió el grupo comp.lang.perl en estos grupos y después se eliminó oficialmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
order of preference:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030134Z" changeid="explorer">
        <seg>En orden de preferencia:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A problem where C&lt;Data::Dumper&gt; would sometimes update the iterator state
of hashes has been fixed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025934Z" changeid="explorer">
        <seg>Un problema donde C&lt;Data::Dumper&gt; a veces actualizaba el estado del iterador de hashes, ha sido arreglado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open($fh, &quot;&gt;&quot;, \$variable) || ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003805Z" changeid="explorer">
        <seg>open($fh, &quot;&gt;&quot;, \$variable) || ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the rules and rigors of ANSI C, on some systems you have to do a
seek whenever you switch between reading and writing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a las normas y rigores de la norma ANSI C, en algunos sistemas tendrá que hacer una búsqueda cada vez que alterne entre la lectura y la escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will configure and compile perl for your platform, run the regression
tests, and install perl in a subdirectory &quot;localperl&quot; of your home directory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T221939Z" changeid="explorer">
        <seg>Esto configurará y compilará perl para su plataforma, ejecutará las pruebas de regresión, e instalará perl en un subdirectorio &quot;localperl&quot; de su directorio principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will probably work for an executable script invoked as C&lt;scriptname&gt;,
while:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>probablemente funcionará para un script ejecutable invocado como C&lt;nombredelscript&gt;, mientras que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Building Perl on WinCE has been much enhanced, see F&lt;README.ce&gt;
and F&lt;README.perlce&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010315Z" changeid="explorer">
        <seg>La construcción de Perl en WinCE se ha mejorado mucho, vea F&lt;README.ce&gt; y F&lt;README.perlce&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Array::Iterator::Circular;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>use Array::Iterator::Circular;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Commonly available C&lt;S_IF*&gt; constants are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comúnmente disponibles las constantes C&lt;S_IF*&gt; son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;README&gt; file for general stuff.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El archivo F&lt;README&gt; (LEEME) para asuntos generales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run into any trouble whatsoever or you need to install a customized
version of Perl, you should read the detailed instructions in the &quot;INSTALL&quot;
file that came with this distribution.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222024Z" changeid="explorer">
        <seg>Si surge algún problema o si es necesario instalar una versión personalizada de Perl, debería leer las instrucciones detalladas en el archivo &quot;INSTALL&quot; que viene con esta distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/oranges?/) {
            print &quot;I don't like oranges.&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T235525Z" changeid="explorer">
        <seg>when (/naranjas?/) {
            print &quot;No me gustan las naranjas.&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are all documented in L&lt;perlfunc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Están todas documentadas en L&lt;perlfunc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The C&lt;:encoding(utf8)&gt; layer
also works the same way.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010924Z" changeid="explorer">
        <seg>(La capa C&lt;:encoding(utf8)&gt; también funciona del mismo modo.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the template in brackets contains alignment
commands (such as C&lt;x![d]&gt;), its packed length is calculated as if the
start of the template had the maximal possible alignment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la plantilla que figura entre corchetes contiene los comandos de alineación (como C&lt;x![d]&gt;), su longitud se calculará como si el comienzo de la plantilla tuviera la máxima alineación posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the list above LIMIT would have been 4 by
default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la lista de arriba LÍMITE hubiera sido 4 por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, a reminder of an impending feature removal.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T010414Z" changeid="explorer">
        <seg>Por último, un recordatorio de una eliminación inminente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EXPR is executed as a system command.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EXPR es ejecutada como un comando del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Tie::Cycle;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>use Tie::Cycle;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the substr() function as an lvalue, in which case EXPR
must itself be an lvalue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203351Z" changeid="explorer">
        <seg>Puede utilizar la función substr() como un I&lt;ivalor&gt;, en cuyo caso la EXPR debe ser en si mismo un I&lt;ivalor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/Math/Complex...................exp: OVERFLOW</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214815Z" changeid="explorer">
        <seg>lib/Math/Complex...................exp: OVERFLOW</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support fchown(2), you may pass filehandles among the
files.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005400Z" changeid="explorer">
        <seg>En sistemas que soporten fchown(2), puede pasar identificadores de archivo entre los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(contributed by brian d foy)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200542Z" changeid="explorer">
        <seg>(contribución de brian d foy)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use C&lt;alarm&gt; to time out a system call you need to use an
C&lt;eval&gt;/C&lt;die&gt; pair.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere usar C&lt;alarm&gt; controlar la duración de una llamada del sistema necesita una pareja C&lt;eval&gt;/C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting object code and the
C&lt;perl&gt; binary may well be smaller than 5.8.7, in particular due to a change
contributed by Dave Mitchell which reworked the warnings code to be
significantly smaller.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051458Z" changeid="explorer">
        <seg>El código objeto resultante y el C&lt;perl&gt; binario pueden ser menores que 5.8.7, en particular, debido a un cambio aportado por Dave Mitchell, que rehízo el código de las advertencias para que fuera significativamente menor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$scalar = delete $hash{foo};             # $scalar is 11</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$scalar = delete $hash{foo};             # $scalar es 11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dumpValue $prettily @_;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032303Z" changeid="explorer">
        <seg>dumpValue $bellamente @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our $foo;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>our $foo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $db = tie(%hash, 'SDBM_File', $filename, O_RDWR|O_CREAT, 0640)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T131910Z" changeid="zipf">
        <seg>my $db = tie(%hash, 'SDBM_File', $archivo, O_RDWR|O_CREAT, 0640)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 0-201-61571-1 [1st edition 2001]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003559Z" changeid="explorer">
        <seg>ISBN 0-201-61571-1 [1ª edición - 2001]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub/&quot;Localized deletion of elements
of composite types&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub/&quot;Eliminación local de elementos de tipos compuestos&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @compiled = map qr/$_/i, @$patterns;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @compilados = map qr/$_/i, @$patrones;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's also a negated version of it:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T002702Z" changeid="zipf">
        <seg>También existe la versión negada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are available only if you enable the C&lt;&quot;switch&quot;&gt; feature.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022201Z" changeid="explorer">
        <seg>Estas están disponibles solo si activa la característica C&lt;&quot;switch&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In place sort optimised (eg C&lt;@a = sort @a&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T105126Z" changeid="explorer">
        <seg>Optimizado sort ejecutado sobre la misma variable (ej.: C&lt;@a = sort @a&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/x/) { say '$foo contains an x'; continue }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/x/) { say '$foo contiene una x'; continue }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;delete&gt; on an array no longer leaks memory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T211413Z" changeid="explorer">
        <seg>El uso de C&lt;delete&gt; en un array ya no provoca fugas de memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
C&lt;@addrs&gt; value returned by a successful call is a list of raw
addresses returned by the corresponding library call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto C&lt;@addrs&gt; por una exitosa llamada es una lista de las direcciones en crudo devueltas por la correspondiente llamada a la biblioteca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is an error to refer to a name not defined by a C&lt;&lt; (?&lt;NAME&gt;) &gt;&gt;
earlier in the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T214957Z" changeid="explorer">
        <seg>Es un error referirse a un nombre no definido anteriormente en el patrón por un C&lt;&lt; (?&lt;NOMBRE&gt;) &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is
omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may also be
information at F&lt;http://www.perl.com/&gt;, the Perl Home Page.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T010222Z" changeid="explorer">
        <seg>También puede haber información en F&lt;http://www.perl.com/&gt;, la página oficial de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
the C-comment deletion code in L&lt;perlop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vea el código en C para eliminar comentarios en L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is useful
syntactically for separating a function name from a parenthesized expression
that would otherwise be interpreted as the complete list of function
arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es útil para separar sintácticamente un nombre de función de una expresión entre paréntesis que, de otro modo, sería interpretada como la lista completa de argumentos de la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;time+86_400&gt; always means
C&lt;time() + 86_400&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;time+86_400&gt; siempre significa C&lt;time() + 86_400&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$login = getlogin || getpwuid($&lt;) || &quot;Kilroy&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$login = getlogin || getpwuid($&lt;) || &quot;Kilroy&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl provides customary quote characters
for these behaviors, but also provides a way for you to choose your
quote character for any of them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl no solo proporciona caracteres normales de entrecomillado para estos comportamientos, sino que también proporciona una manera para que usted elija su carácter de entrecomillado para cualquiera de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the left value is greater than the right value then it
returns the empty list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el valor de la izquierda es mayor que el valor de la derecha entonces devuelve la lista vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
particular, though the first such conversion may be time-consuming,
repeated operations will not need to redo the conversion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234137Z" changeid="explorer">
        <seg>Así, aunque la primera conversión tarde un poco más, al repetir una operación no será necesario repetir la conversión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8 atime  8 is_dst     8 hints        $.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224347Z" changeid="explorer">
        <seg>8 atime  8 is_dst     8 hints           $.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $list[$_] foreach 0 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234915Z" changeid="zipf">
        <seg>print $lista[$_] foreach 0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use here documents instead of repeated C&lt;print()&gt; statements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use documentos incluídos en vez de repetir instrucciones C&lt;print()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the bug you are reporting has security implications, which make it
inappropriate to send to a publicly archived mailing list, then please send
it to perl5-security-report@perl.org.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T231455Z" changeid="explorer">
        <seg>Si el fallo que está reportando tiene implicaciones de seguridad, que lo hace inadecuado para ser enviado a una lista de correo pública, por favor, envíelo a perl5-security-report@perl.org.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a syntax error or runtime error, or a C&lt;die&gt; statement is
executed, C&lt;eval&gt; returns C&lt;undef&gt; in scalar context
or an empty list--or, for syntax errors, a list containing a single
undefined value--in list context, and C&lt;$@&gt; is set to the error
message.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T233652Z" changeid="explorer">
        <seg>Si hay algún error de sintaxis o en tiempo de ejecución, o se ejecuta una instrucción C&lt;die&gt;, C&lt;eval&gt; devuelve un valor C&lt;undef&gt; en contexto escalar o una lista vacía -o, para errores sintácticos, una lista conteniendo un único valor indefinido- en contexto de lista, y C&lt;$@&gt; es inicializado al mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first (and for a long time, only) periodical devoted to All Things
Perl, I&lt;The Perl Journal&gt; contains tutorials, demonstrations, case
studies, announcements, contests, and much more.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230835Z" changeid="explorer">
        <seg>La primera publicación periódica (y, durante mucho tiempo, la única) dedicada al mundo Perl, I&lt;The Perl Journal&gt; contiene tutoriales, demostraciones, estudios de casos, anuncios, concursos y mucho más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, if the REPLACEMENTLIST is shorter
than the SEARCHLIST, the final character is replicated till it is long
enough.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, si la LISTA_REEMPLAZO es más corta que la LISTA_BÚSQUEDA, el carácter final es replicado hasta que sea lo suficientemente larga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is not ok, as the regex engine will end up trying to compile the
pattern C&lt;\&gt;, which it will consider a syntax error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no es correcto, porque el motor de expresiones regulares acabará tratando de compilar el patrón C&lt;\&gt;, que va generar un error de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item wait</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item wait</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># read in config files: system first, then user</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># leer en archivos de configuración: primero el sistema, luego el usuario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (?{ CODE })</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T194721Z" changeid="explorer">
        <seg>=item (?{ CÓDIGO })</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any non-whitespace delimiter may replace the slashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier delimitador distinto del espacio en blanco puede sustituir a las barras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Jon Bentley</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003726Z" changeid="explorer">
        <seg>Jon Bentley</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, if the handle is not marked with an encoding but you
attempt to write characters with code points over 255, raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T023613Z" changeid="explorer">
        <seg>Alternativamente, si el gestor no está marcado con una codificación pero intenta escribir caracteres con puntos de código superiores a 255, se genera una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my (@AoA, $i, $line);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my (@AoA, $i, $linea);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Defined\n&quot;   if defined $array[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Definido\n&quot;  if defined $array[$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Will both leave the sentence as is.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012633Z" changeid="explorer">
        <seg>Ambas dejará la instrucción como estaba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl cannot be compiled with threading support ATM.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl no puede ser compilado con soporte multihilo ATM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See B::Bytecode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031027Z" changeid="explorer">
        <seg>Vea B::Bytecode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print (1+2)+4;    # Also prints 3!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print (1+2)+4;	# ¡También imprime 3!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the pattern C&lt;A (*PRUNE) B&gt;,
where A and B are complex patterns.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T011314Z" changeid="explorer">
        <seg>Considere el patrón C&lt;A (*PRUNE) B&gt;, donde A y B son patrones complejos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to compile Perl 32-bit.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002345Z" changeid="explorer">
        <seg>para compilar Perl de 32 bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because C&lt;chomp $cwd = `pwd`;&gt;
is interpreted as C&lt;(chomp $cwd) = `pwd`;&gt;, rather than as
C&lt;chomp( $cwd = `pwd` )&gt; which you might expect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es porque C&lt;chomp $cwd = `pwd`;&gt; es interpretado como C&lt;(chomp $cwd) = `pwd`;&gt;, en vez de un C&lt;chomp( $cwd = `pwd` )&gt; que es lo que se esperaba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;DB_File&gt;
or the F&lt;Config&gt; module for interesting C&lt;tie&gt; implementations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;DB_File&gt; o el módulo F&lt;Config&gt; para interesantes implementaciones de C&lt;tie&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not a decimal number&quot; unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es número real&quot;    unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The standard C&lt;Math::BigInt&gt;, C&lt;Math::BigRat&gt;, and C&lt;Math::BigFloat&gt; modules,
along with the C&lt;bigint&gt;, C&lt;bigrat&gt;, and C&lt;bitfloat&gt; pragmas, provide
variable-precision arithmetic and overloaded operators, although
they're currently pretty slow.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033230Z" changeid="explorer">
        <seg>Los módulos estándar C&lt;Math::BigInt&gt;, C&lt;Math::BigRat&gt;, y C&lt;Math::BigFloat&gt;, junto con los I&lt;pragmas&gt; C&lt;bigint&gt;, C&lt;bigrat&gt; y C&lt;bigfloat&gt;, proporcionan aritmética con precisión variable y sobrecarga de operadores, aunque, en la actualidad, son bastante lentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215009Z" changeid="explorer">
        <seg>Vea L&lt;perlfunc&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use subs     qw(afunc blurfl);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use subs     qw(afunc blurfl);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may or may not save time, depending on the nature and number of
patterns you are searching and the distribution of character
frequencies in the string to be searched; you probably want to compare
run times with and without it to see which is faster.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015231Z" changeid="explorer">
        <seg>Esto puede o no ahorrar tiempo, dependiendo de la naturaleza y el número de patrones que esté buscando y sobre la distribución de frecuencias de caracteres de la cadena a buscar; probablemente querrá comparar los tiempos de funcionamiento con y sin él para ver qué funciona más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A good rule of thumb is that if
your platform has a real C&lt;fork()&gt; (in other words, if your platform is
Unix, including Linux and MacOS X), you can use the list form.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T233834Z" changeid="explorer">
        <seg>Una buena regla general es que si su plataforma tiene una verdadera función C&lt;fork()&gt; (en otras palabras, si su plataforma es Unix, incluyendo Linux y MacOS X), puede utilizar la forma de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you see don't see AUTOCONF or MPEAUTOCONF, make sure you get a new
version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no ve AUTOCONF o MPEAUTOCONF, asegúrese de que obtiene una versión nueva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item splice ARRAY or EXPR,OFFSET,LENGTH,LIST
X&lt;splice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181231Z" changeid="explorer">
        <seg>=item splice ARRAY o DESPLAZAMIENTO,LONGITUD,LISTA
X&lt;splice&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item base</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015207Z" changeid="explorer">
        <seg>=item base</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;chdir&gt;, C&lt;chmod&gt; and C&lt;chown&gt; on filehandles</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015854Z" changeid="explorer">
        <seg>=head2 C&lt;chdir&gt;, C&lt;chmod&gt; y C&lt;chown&gt; en identificadores de archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the number of exponent digits in the scientific notation produced
by C&lt;%e&gt;, C&lt;%E&gt;, C&lt;%g&gt; and C&lt;%G&gt; for numbers with the modulus of the
exponent less than 100 is system-dependent: it may be three or less
(zero-padded as necessary).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el número de dígitos del exponente en notación científica producida por C&lt;%e&gt;, C&lt;%E&gt;, C&lt;%g&gt; y C&lt;%G&gt; para los números con el módulo del exponente menor de 100 es dependiente del sistema: puede ser de tres o menos (con relleno de ceros según sea necesario).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LENGTH is omitted, removes everything from OFFSET onward.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite LONGITUD, se suprime todo desde DESPLAZAMIENTO en adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} elsif (!$result) {
           delete $INC{$filename};
           die &quot;$filename did not return true value&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051227Z" changeid="explorer">
        <seg>} elsif (!$resultado) {
           delete $INC{$archivo};
           die &quot;$archivo no devolvió un valor verdadero&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More detailed information about Perl syntax can be found in L&lt;perlsyn&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224800Z" changeid="explorer">
        <seg>Encontrará información más detallada sobre la sintaxis de Perl en L&lt;perlsyn&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry doesn't really care.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231632Z" changeid="explorer">
        <seg>A Larry le da igual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variables are scoped to the block
(i.e. a bunch of statements surrounded by curly-braces) in which they
are defined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225044Z" changeid="explorer">
        <seg>El ámbito de las variables es el bloque (conjunto de instrucciones entre llaves) en el que se definen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the traditional way</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># la manera tradicional</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item threads-shared</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052659Z" changeid="explorer">
        <seg>=item threads-shared</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;%&quot; is the modulo operator, which computes the division
remainder of its first argument with respect to its second argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;%&quot; es el operador módulo, que calcula el resto de la división de su primer argumento con respecto a su segundo argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlref&gt;, L&lt;perlsub&gt;,
and L&lt;perlmod/&quot;Symbol Tables&quot;&gt; for more discussion on typeglobs and
the C&lt;*foo{THING}&gt; syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlref&gt;, L&lt;perlsub&gt; y L&lt;perlmod/&quot;Tablas de símbolos&quot;&gt; para una mayor discusión sobre typeglobs y la sintaxis &lt;C*foo{COSA}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This permits more
elaborate exception handling using objects that maintain arbitrary state
about the exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto permite un manejo de las excepciones más elaborado que usando objetos que mantengan un estado arbitrario sobre la naturaleza de la excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;~&quot; performs bitwise negation, i.e., 1's complement.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unario &quot;~&quot; realiza la negación bit a bit, es decir, el complemento a uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
I&lt;need&gt; to use literal backslashes within C&lt;\Q...\E&gt;,
consult L&lt;perlop/&quot;Gory details of parsing quoted constructs&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si I&lt;necesita&gt; usar contrabarras literales dentro de C&lt;\Q...\E&gt;,
consulte L&lt;perlop/&quot;Detalles sangrientos del análisis de las construcciones entrecomilladas&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.freebsd - Perl version 5 on FreeBSD systems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.freebsd - Perl versión 5 sobre sistemas FreeBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 64  == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 64  == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use if $] &lt; 5.008, &quot;utf8&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use if $] &lt; 5.008, &quot;utf8&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Module authors should carefully consider whether to rely on other
modules, and which modules to rely on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030111Z" changeid="explorer">
        <seg>Los autores de módulos deben considerar cuidadosamente si se basan en otros módulos, y en qué módulos quieren confiar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/uni/lex_utf8.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010046Z" changeid="explorer">
        <seg>=item t/uni/lex_utf8.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 9.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pax -o to=IBM-1047,from=ISO8859-1 -r &lt; latest.tar</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225058Z" changeid="explorer">
        <seg>pax -o to=IBM-1047,from=ISO8859-1 -r &lt; latest.tar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$sec&gt;, C&lt;$min&gt;, and C&lt;$hour&gt; are the seconds, minutes, and hours
of the specified time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$seg, $min y $hora son los segundos, minutos y horas del tiempo especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -lane 'print $F[0] + $F[-1]' *</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225503Z" changeid="explorer">
        <seg>perl -lane 'print $F[0] + $F[-1]' *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlform&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T015023Z" changeid="explorer">
        <seg>Vea L&lt;perlform&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that parentheses are necessary when you're chomping anything
that is not a simple variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota que los paréntesis son necesarios cuando esté recortando cualquier cosa que no sea una simple variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;   greater than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&gt;   mayor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)/x</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T203520Z" changeid="explorer">
        <seg>)/x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Separate functionality from output.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020705Z" changeid="explorer">
        <seg>=item Separe la funcionalidad de la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The possible values and flag bits of the MODE parameter are
system-dependent; they are available via the standard module C&lt;Fcntl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores posibles y bits de bandera del parámetro MODO son dependientes del sistema; están disponibles en el módulo estándar C&lt;Fcntl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deletes a list of files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elimina una lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 8.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lack of processing of C&lt;\\&gt; creates specific restrictions on
the post-processed text.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La falta de tratamiento de C&lt;\\&gt; crea restricciones específicas en el pos-procesado del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sources of further information</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024043Z" changeid="explorer">
        <seg>Fuentes de información adicional</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operating system, device drivers, C libraries, and Perl run-time
system all conspire to let the programmer treat a single
character (C&lt;\n&gt;) as the line terminator, irrespective of external
representation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022518Z" changeid="explorer">
        <seg>El sistema operativo, gestores de dispositivos, bibliotecas C y Perl en tiempo de ejecución conspiran al unísono para permitirle al programador tratar un simple carácter (C&lt;\n&gt;) como el final de línea, independientemente de su representación externa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># before  ---------------branch-reset----------- after</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T124752Z" changeid="explorer">
        <seg># antes   -------------reinicio de rama--------- después</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = gethostbyaddr($iaddr, AF_INET);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$name  = gethostbyaddr($iaddr, AF_INET);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Ports</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112300Z" changeid="explorer">
        <seg>=head2 Adaptaciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following statement:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103144Z" changeid="explorer">
        <seg>La siguiente instrucción:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A group may
take a repeat count either as postfix, or for unpack(), also via the C&lt;/&gt;
template character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un grupo puede tener un contador de repeticiones, ya sea de forma postfija, o para unpack(), también a través del carácter de plantilla C&lt;/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $ARRAY[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $ARRAY[$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^-D(.*)/) { $debug = $1 }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^-D(.*)/) { $debug = $1 }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item UNIVERSAL</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item UNIVERSAL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item cos EXPR
X&lt;cos&gt; X&lt;cosine&gt; X&lt;acos&gt; X&lt;arccosine&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170356Z" changeid="explorer">
        <seg>=item cos EXPR
X&lt;cos&gt; X&lt;cosine&gt; X&lt;acos&gt; X&lt;arccosine&gt; X&lt;coseno&gt; X&lt;arco coseno&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl_save_bool() has been added.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001240Z" changeid="explorer">
        <seg>Perl_save_bool() ha sido añadido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl ./Porting/podtidy pod/perlsource.pod</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T013212Z" changeid="explorer">
        <seg>perl ./Porting/podtidy pod/perlsource.pod</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most importantly, many bugs were fixed, including several security
problems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Más importante aún, muchos errores han sido solucionados, incluyendo varios problemas de seguridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Term::ReadLine&gt; upgraded to version 1.02</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035744Z" changeid="explorer">
        <seg>C&lt;Term::ReadLine&gt; actualizado a la versión 1.02</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that functions such as C&lt;keys&gt; and C&lt;values&gt; may return huge lists
when used on large objects, like DBM files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que las funciones como C&lt;keys&gt; y C&lt;values&gt; pueden devolver largas listas como cuando se usan con grandes archivos DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All rights reserved.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232605Z" changeid="explorer">
        <seg>Reservados todos los derechos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 2) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 2) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have Perl installed locally, you probably have the documentation
installed as well: type C&lt;man perl&gt; if you're on a system resembling Unix.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230238Z" changeid="explorer">
        <seg>Si ha instalado Perl localmente, es probable que también haya instalado la documentación: si está en un sistema Unix o similar, escriba C&lt;man perl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item MultiEdit</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item MultiEdit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the latest Tru64 releases (e.g. v5.1B or later) gcc cannot be used
to compile a threaded Perl (-Duseithreads) because the system
C&lt;&lt; &lt;pthread.h&gt; &gt;&gt; file doesn't know about gcc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T004446Z" changeid="explorer">
        <seg>En las últimas versiones de Tru64 (por ejemplo, v5.1B o posterior) gcc no se puede utilizar para compilar un Perl con soporte de hilos de ejecución (-Duseithreads) debido a que el fichero del sistema C&lt;&lt; &lt;pthread.h&gt; &gt;&gt; no sabe nada sobre gcc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regex   Hash      hash key grep            grep /$a/, keys %$b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Regex       Hash       grep clave hash                  grep /$a/, keys %$b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@list = (2.18 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@lista = (2.18 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @modules = $inst-&gt;modules();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T005513Z" changeid="explorer">
        <seg>my @modulos = $inst-&gt;modules();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shift ARRAY
X&lt;shift&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200557Z" changeid="explorer">
        <seg>=item shift ARRAY
X&lt;shift&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/&quot;(?:[^&quot;\\]++|\\.)*+&quot;/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/&quot;(?:[^&quot;\\]++|\\.)*+&quot;/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a = $b) or $c;		# really means this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a = $b) or $c;		# en realidad significa esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (keys $hashref) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165258Z" changeid="explorer">
        <seg>for (keys $hashref) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is a general-purpose programming language originally developed for
text manipulation and now used for a wide range of tasks including
system administration, web development, network programming, GUI
development, and more.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224606Z" changeid="explorer">
        <seg>Perl es un lenguaje de programación de propósito general desarrollado originalmente para la manipulación de texto y que, en la actualidad, se usa para una amplia gama de tareas, como administración de sistemas, desarrollo web, programación de red, desarrollo de interfaces gráficas de usuario, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(*MARK:NAME)&gt; C&lt;(*:NAME)&gt;
X&lt;(*MARK)&gt; C&lt;(*MARK:NAME)&gt; C&lt;(*:NAME)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T114615Z" changeid="explorer">
        <seg>=item C&lt;(*MARK:NOMBRA)&gt; C&lt;(*:NOMBRE)&gt;
X&lt;(*MARK)&gt; C&lt;(*MARK:NOMBRE)&gt; C&lt;(*:NOMBRE)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bar = q('This is it.');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bar = q('Así es.');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always use the two-argument
version if a derived class might inherit the function doing the blessing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre usar la versión de dos argumentos si una clase derivada puede heredar la función con un nuevo bautizo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An improved implementation of
C&lt;threads::shared&gt; is available on CPAN - this will be merged into 5.8.9 if
it proves stable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045109Z" changeid="explorer">
        <seg>Una mejor implementación de C&lt;threads::shared&gt; está disponible en CPAN - esto será fusionado en 5.8.9 si se prueba que es estable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@days[3..5]    = qw/Wed Thu Fri/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@dias[3..5]    = qw/Mié Jue Vie/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Determination of whether $BSD_STYLE should be set
is left as an exercise to the reader.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La determinación de cómo poner $BSD_STYLE se deja como ejercicio al lector.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, C&lt;our&gt; has the same scoping rules as C&lt;my&gt; or C&lt;state&gt;, but
does not necessarily create a variable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T002105Z" changeid="explorer">
        <seg>En otras palabras, C&lt;our&gt; tiene las mismas reglas de alcance que C&lt;my&gt; o C&lt;state&gt;, pero no crea, necesariamente, una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that some versions of C&lt;flock&gt; cannot lock things over the
network; you would need to use the more system-specific C&lt;fcntl&gt; for
that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note también que algunas versiones de C&lt;flock&gt; no pueden bloquear cosas sobre la red; necesitará usar un C&lt;fcntl&gt; más específico del sistema para hacer esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Enabling warnings from your shell environment</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010525Z" changeid="explorer">
        <seg>=head2 Activando advertencias desde su entorno del shell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is intentional.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031620Z" changeid="explorer">
        <seg>Esto es intencional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prepends list to the front of the
array and returns the new number of elements in the array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024446Z" changeid="explorer">
        <seg>Antepone LISTA al principio del array, y devuelve el número de elementos en el array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ãvar ArnfjÃ¶rÃ° Bjarmason, Alex Vandiver, Chris Williams, chromatic,
Craig A. Berry, David Golden, David Mitchell, Eric Brine, Father
Chrysostomos, Florian Ragwitz, Frank Wiegand, Gisle Aas, H.Merijn
Brand, Hugo van der Sanden, Jesse Vincent, Josh ben Jore, Karl
Williamson, Leon Brocard, Michael G Schwern, Michael G. Schwern, Nga
Tang Chan, Nicholas Clark, Niko Tyni, Rafael Garcia-Suarez, Ricardo
Signes, Robin Barker, Slaven Rezic, Steffen Mueller, Zefram.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052817Z" changeid="explorer">
        <seg>Ãvar ArnfjÃ¶rÃ° Bjarmason, Alex Vandiver, Chris Williams, chromatic,
Craig A. Berry, David Golden, David Mitchell, Eric Brine, Father
Chrysostomos, Florian Ragwitz, Frank Wiegand, Gisle Aas, H.Merijn
Brand, Hugo van der Sanden, Jesse Vincent, Josh ben Jore, Karl
Williamson, Leon Brocard, Michael G Schwern, Michael G. Schwern, Nga
Tang Chan, Nicholas Clark, Niko Tyni, Rafael Garcia-Suarez, Ricardo
Signes, Robin Barker, Slaven Rezic, Steffen Mueller, Zefram.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Opcode&gt; upgraded to version 1.06</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033941Z" changeid="explorer">
        <seg>C&lt;Opcode&gt; actualizado a la versión 1.06</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array grows or shrinks as necessary.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El array crece o se reduce según sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An OFFSET may be specified to write the data from some part of the
string other than the beginning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DESPLAZAMIENTO puede ser especificado para escribir datos desde algún otro lugar de la cadena distinto del principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words,
names beginning with $ or @, followed by an optional bracketed
expression as a subscript.)  The following code segment prints out &quot;The
price is $Z&lt;&gt;100.&quot;
X&lt;interpolation&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110803T113858Z" changeid="explorer">
        <seg>(En otras palabras, nombres que empiezan con $ o @, seguido de una opcional expresión entre corchetes como si fuera un subíndice). El segmento de código siguiente imprime &quot;El precio es $Z&lt;&gt;100&quot;.
X&lt;interpolation&gt; X&lt;interpolación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that the
similar construct, but with C&lt;eval(&quot;&quot;)&gt; instead, was already forbidden.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192150Z" changeid="explorer">
        <seg>(Note que la construcción similar, pero usando C&lt;eval(&quot;&quot;)&gt;, ya estaba prohibida.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;ne&quot; returns true if the left argument is stringwise not equal
to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;ne&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente distinto que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can replace a numeric repeat count with a template letter enclosed in
brackets to use the packed byte length of the bracketed template for the
repeat count.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede reemplazar un número de repeticiones con una plantilla de letras encerrada entre corchetes para utilizar la longitud en bytes empaquetada de la plantilla entre corchetes para indicar ese número de repeticiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has traditionally been supported by
Larry, scores of software designers and developers, and myriad
programmers, all working for free to create a useful thing to make life
better for everyone.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231038Z" changeid="explorer">
        <seg>Tradicionalmente, el soporte de Perl lo han proporcionado Larry, grupos de diseñadores y desarrolladores de software, y un sinnúmero de programadores, todos dedicados a crear algo útil que nos facilite la vida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;LA LA LA\n&quot; while 1;          # loops forever</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;LA LA LA\n&quot; while 1;          # bucle sin fin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty -echo&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty -echo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Devel::PPPort upgraded to version 3.03</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devel::PPPort actualizado a la versión 3.03</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In those cases where C&lt;HvENAME()&gt; returns null,
C&lt;HvNAME()&gt; should be used instead.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114703Z" changeid="explorer">
        <seg>En los casos donde C&lt;HvENAME()&gt; devuelve un valor nulo, en su lugar se debe usar C&lt;HvNAME()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require Foo::Bar;     # a splendid bareword</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require Foo::Bar;     # algo atractivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The BLOCK construct can be used to emulate case structures.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La construcción BLOQUE puede ser usada para emular estructuras I&lt;switch&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You're a much better advocate if your claims are reasonable and
grounded in reality.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232535Z" changeid="explorer">
        <seg>Si sus afirmaciones son razonables y están basadas en la realidad, sus esfuerzos de evangelización tendrán más éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for my $i (5 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225519Z" changeid="explorer">
        <seg>for my $i (5 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the pattern explicitly mentions a code point that is above 255 (say by
C&lt;\x{100}&gt;); or</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000703Z" changeid="explorer">
        <seg>el patrón menciona explícitamente un punto de código que está por encima de 255 (por ejemplo C&lt;\x{100}&gt;); o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($login,$pass,$uid,$gid) = getpwnam($user)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($login,$pass,$uid,$gid) = getpwnam($usuario)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shutdown(SOCKET, 2);    # I/we have stopped using this socket</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shutdown(SOCKET, 2);    # Hemos dejado de usar el socket</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item printf</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011512Z" changeid="explorer">
        <seg>=item printf</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original culture of the pre-populist Internet and the deeply-held
beliefs of Perl's author, Larry Wall, gave rise to the free and open
distribution policy of perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110403T225138Z" changeid="explorer">
        <seg>La cultura de Internet existente antes de que &quot;la red&quot; se convirtiera en un fenómeno de masas, y las firmes convicciones de Larry Wall, el creador de Perl, dieron lugar a la política de distribución libre y abierta de perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Win32&gt; upgraded to version 0.2601</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041401Z" changeid="explorer">
        <seg>C&lt;Win32&gt; actualizado a la versión 0.2601</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -CS -ne 'printf &quot;%v02X\n&quot;, $_ for unpack(&quot;U0A*&quot;, $_)'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003602Z" changeid="explorer">
        <seg>perl -CS -ne 'printf &quot;%v02X\n&quot;, $_ for unpack(&quot;U0A*&quot;, $_)'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/&quot;The C&lt;overloading&gt; pragma&quot;&gt; above.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152352Z" changeid="explorer">
        <seg>Vea más arriba L&lt;/&quot;El I&lt;pragma&gt; C&lt;overloading&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.perl.org/CGI_MetaFAQ.html</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225506Z" changeid="explorer">
        <seg>http://www.perl.org/CGI_MetaFAQ.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5130delta	Perl changes in version 5.13.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141502Z" changeid="explorer">
        <seg>perl5130delta	Cambios en la versión 5.13.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whereas if you comment out the two lines I said you might wish to,
then it shows it to you this way instead:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032529Z" changeid="explorer">
        <seg>Mientras que si comenta las dos líneas que le he dicho antes, entonces se lo muestra de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item F&lt;h2ph&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003508Z" changeid="explorer">
        <seg>=item F&lt;h2ph&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fcntl($filehandle, F_GETFL, $packed_return_buffer)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010104Z" changeid="explorer">
        <seg>fcntl($identificador, F_GETFL, $búfer_retorno_empaquetado)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make -f Makefile.micro</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make -f Makefile.micro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, because we didn't
C&lt;chdir&gt; there, it would have been testing the wrong file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, porque no hicimos un C&lt;chdir&gt; antes, se estará probando en un archivo incorrecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select(undef, undef, undef, 0.25);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select(undef, undef, undef, 0.25);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What is Perl?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 ¿Qué es Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This works with both Cygwin 1.3.22 and Cygwin 1.5.3.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T182932Z" changeid="explorer">
        <seg>Esto funciona tanto con Cygwin 1.3.22 y Cygwin 1.5.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try &quot;/hurd/pfinet --help&quot; for more
information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020052Z" changeid="explorer">
        <seg>Pruebe &quot;/hurd/pfinet --help&quot; para obtener más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, those are perl5.14.x and perl5.12.x, respectively.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004253Z" changeid="explorer">
        <seg>En la actualidad, éstas son perl5.14.x y perl5.12.x respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
instance, if you're using ftp://ftp.funet.fi/pub/languages/perl/CPAN
as your CPAN site, the file C&lt;CPAN/misc/japh&gt; is downloadable as
ftp://ftp.funet.fi/pub/languages/perl/CPAN/misc/japh .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T112535Z" changeid="explorer">
        <seg>Por ejemplo, si usa ftp://ftp.funet.fi/pub/languages/perl/CPAN como sitio de CPAN, puede descargar el archivo C&lt;CPAN/misc/japh&gt; como ftp://ftp.funet.fi/pub/languages/perl/CPAN/misc/japh .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Win32: non-blocking waitpid(-1,WNOHANG)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Win32: waitpid(-1,WNOHANG) no bloqueante</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&lt; (?PE&lt;lt&gt;NAMEE&lt;gt&gt;pattern) &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003146Z" changeid="explorer">
        <seg>=item C&lt;&lt; (?PE&lt;lt&gt;NOMBRE&lt;gt&gt;patrón) &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl was born in Unix and can therefore access all common Unix
system calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl nació en Unix y por eso puede acceder a todas las llamadas normales del sistema Unix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a DBM Filter that does it:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111003T121628Z" changeid="zipf">
        <seg>El siguiente filtro DBM hace esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%010.6d&gt;', 1;   # prints &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%010.6d&gt;', 1;   # imprime &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your
integer arguments are not literals and have never been interpreted in a
numeric context, you may need to add C&lt;0&gt; to them to force them to look
like numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sus argumentos enteros no son enteros, y nunca han sido interpretados en un contexto numérico, es posible que deba agregarles C&lt;0&gt; para obligarles a que se parezcan a números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;wantarray()&gt;'s result is unspecified in the top level of a file,
in a C&lt;BEGIN&gt;, C&lt;UNITCHECK&gt;, C&lt;CHECK&gt;, C&lt;INIT&gt; or C&lt;END&gt; block, or
in a C&lt;DESTROY&gt; method.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resultado de C&lt;wantarray()&gt; no está especificado en el nivel superior de un archivo, en un C&lt;BEGIN&gt;, C&lt;UNITCHECK&gt;, C&lt;CHECK&gt;, C&lt;INIT&gt; o bloque C&lt;END&gt;, o en un método C&lt;DESTROY&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = [ @tmp ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$i] = [ @tmp ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Debugger and Unicode slowdown</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044828Z" changeid="explorer">
        <seg>=head2 Enlentecimiento del depurador y de Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;foreach&gt; keyword is actually a synonym for the C&lt;for&gt; keyword, so
you can use C&lt;foreach&gt; for readability or C&lt;for&gt; for brevity.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T012507Z" changeid="explorer">
        <seg>La palabra clave C&lt;foreach&gt; es realmente un sinónimo de la palabra clave C&lt;for&gt;, así que puede usar C&lt;foreach&gt; por legibilidad o C&lt;for&gt; por brevedad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Significant updates on the encoding pragma functionality
(tr/// and the DATA filehandle, formats).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T172008Z" changeid="explorer">
        <seg>Actualizaciones significativas en la funcionalidad del pragma de codificación (formatos tr/// y del identificador de archivo de datos DATA).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>comp.lang.perl.misc          High traffic general Perl discussion</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230356Z" changeid="explorer">
        <seg>comp.lang.perl.misc          Discusión general sobre Perl, con mucho tráfico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@@@ }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225544Z" changeid="explorer">
        <seg>@@@ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt; &quot;abc\&quot;def&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt; &quot;abc\&quot;def&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FETCH this, key</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FETCH este, clave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Marcus Holland-Moritz)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112303Z" changeid="explorer">
        <seg>(Marcus Holland-Moritz)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>His UTF-8 rants during the
Amsterdam Perl Mongers meetings got me interested and determined to find out
how to use character encodings in Perl in ways that don't break easily.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235448Z" changeid="explorer">
        <seg>Sus diatribas contra UTF-8 en las reuniones de los Amsterdam Perl Mongers hicieron que me interesara por el tema y me propusiera aprender a utilizar de una manera segura las codificaciones de caracteres en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl will not guarantee what the result of the above statements is.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012118Z" changeid="explorer">
        <seg>Perl no garantizará el resultado de las instrucciones anteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to Damian Conway, you should consider using OO:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015740Z" changeid="explorer">
        <seg>De acuerdo con Damian Conway, debe considerar el uso de POO:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;scalar&gt; is a unary operator, if you accidentally use a
parenthesized list for the EXPR, this behaves as a scalar comma expression,
evaluating all but the last element in void context and returning the final
element evaluated in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T012807Z" changeid="explorer">
        <seg>Dado que C&lt;scalar&gt; es un operador unario, si, accidentalmente, usa para EXPR una lista entre paréntesis, esto se comportará como una expresión escalar con comas, evaluando todos, menos el último elemento, en contexto vacío, y devolviendo el elemento final evaluado en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 (Win32) The /d Switch Of cmd.exe</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142151Z" changeid="explorer">
        <seg>=head2 (Win32) La opción /d de cmd.exe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, a comma terminates the argument of
a unary operator, but merely separates the arguments of a list
operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, una coma determina al argumento de un operador unario, pero sólo sirve de separación entre argumentos en un operador de listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>support for light-weight processes (threads)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001358Z" changeid="explorer">
        <seg>compatibilidad con procesos ligeros (hebras I&lt;threads&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;1,,3&gt; is C&lt;(1,),(3)&gt; is C&lt;1,3&gt; (And
similarly for C&lt;1,,,3&gt; is C&lt;(1,),(,),3&gt; is C&lt;1,3&gt; and so on.)  Not that
we'd advise you to use this obfuscation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;1,,3&gt; es C&lt;(1,),(3)&gt; es C&lt;1,3&gt; (y similarmente para C&lt;1,,,3&gt; es C&lt;(1,),(,),3&gt; es C&lt;1,3&gt; y así sucesivamente). No le aconsejamos usar este tipo de ofuscación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improved error and warnings messages.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mejora en los mensajes de errores y advertencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
the other end can't handle that, be sure to read all the data before
closing the pipe.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si en el otro extremo no puede manejar esto, asegúrese de leer todos los datos antes de cerrar la tubería.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>didn't work correctly but instead corrupted the data.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T011312Z" changeid="explorer">
        <seg>no funciona correctamente, sino que corrompe los datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support fchdir(2),
passing handles raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020147Z" changeid="explorer">
        <seg>En sistemas que no admiten fchdir(2), pasarle un identificador de archivo lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that we have the C&lt;*foo{THING}&gt; notation, typeglobs aren't used as much
for filehandle manipulations, although they're still needed to pass brand
new file and directory handles into or out of functions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003740Z" changeid="explorer">
        <seg>Ahora que tenemos la notación C&lt;*foo{COSA}&gt;, typeglobs no se utilizan tanto para la manipulación de identificadores de archivo, aunque siguen siendo necesarios para pasar identificadores de archivo y de directorio dentro o fuera de funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker,
a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque Perl 5.10 incluía la versión para Mac OS, ExtUtils::MakeMaker, una parte central de la instalación de infraestructura de módulos Perl oficialmente abandonó el soporte para Mac OS en abril de 2004.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New &quot;5.005 threads are deprecated&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T012019Z" changeid="explorer">
        <seg>=head2 Nuevo &quot;5.005 threads are deprecated&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*\D)(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110905T003502Z" changeid="explorer">
        <seg>(.*\D)(\d+)$ &lt;Tengo 2 números: &gt; &lt;53147&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhacktut 	Walk through the creation of a simple C code patch</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141113Z" changeid="explorer">
        <seg>perlhacktut 	Paso a paso por la creación de un sencillo parche en código C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$s = &quot;hi there\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$s = &quot;hola por aquí\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is the same as</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es lo mismo que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/(\d+)/\1000/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050337Z" changeid="explorer">
        <seg>s/(\d+)/\1000/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;~~&quot; does a smart match between its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;~~&quot; hace una coincidencia inteligente entre sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item uc</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item uc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Randal L. Schwartz and brian d foy, with Tom Phoenix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003136Z" changeid="explorer">
        <seg>Randal L. Schwartz y brian d foy, con Tom Phoenix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The existing
VMS-specific ability to access individual elements of a search list
logical name via the $ENV{'foo;N'} syntax (where N is the search list
index) is unimpaired.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000636Z" changeid="explorer">
        <seg>La actual habilidad específica de VMS de acceder a elementos individuales de un nombre lógico de lista de búsqueda a través de la sintaxis $ENV{'foo;N'} (donde N es el índice de la lista de búsqueda) no se ve afectada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @colors = values %fruit_colors;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234512Z" changeid="zipf">
        <seg>my @colores = values %colores_fruta;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is more than one argument in LIST,
or if LIST is an array with more than one value, starts the program
given by the first element of the list with arguments given by the
rest of the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay más de un argumento en LISTA, o si la lista es un array con más de un valor, se inicia el programa indicado en el primer elemento de la lista, con los argumentos indicados por el resto de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>remove Time::Piece</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eliminar Time::Piece</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that on some systems, a return value of C&lt;-1&gt; could mean that child
processes are being automatically reaped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que en algunos sistemas, un valor devuelto de C&lt;-1&gt; podría significar que los procesos hijos se están automáticamente desechando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Note that the exact meaning of these is system dependent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Tenga en cuenta que el significado exacto de éstos depende del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is mainly an issue on 64-bit platforms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es sobre todo un problema en plataformas de 64-bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They check different things so you need both.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224708Z" changeid="explorer">
        <seg>Comprueban cosas distintas, por lo que ambas deben ser incluidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Tests</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014519Z" changeid="explorer">
        <seg>=head2 Pruebas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;%hash ~~ sub {}&gt; and C&lt;@array ~~ sub {}&gt; now test that the subroutine
returns a true value for each key of the hash (or element of the
array), instead of passing the whole hash or array as a reference to
the subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T221749Z" changeid="explorer">
        <seg>C&lt;%hash ~~ sub {}&gt; y C&lt;@array ~~ sub {}&gt; ahora prueban a que la subrutina devuelva un valor verdadero por cada clave del hash (o cada elemento del array), en lugar de pasar todo el hash o el array, como referencias, a la subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^$/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/^$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is only an illusion that the operating system,
device drivers, C libraries, and Perl all conspire to preserve.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es sólo una ilusión que el sistema operativo, controladores de dispositivo, bibliotecas de C, y Perl, conspiran para preservar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both &quot;fetch&quot; filters remove the terminating NULL,
and both &quot;store&quot; filters add a terminating NULL.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T154105Z" changeid="zipf">
        <seg>Los dos filtros &quot;fetch&quot; quitan el carácter NULL de terminación y los dos filtros &quot;store&quot; agregan un carácter NULL de terminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The socket tests may fail if the network is not configured.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020033Z" changeid="explorer">
        <seg>Si la red no está configurada, las pruebas de sockets pueden generar errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shows that number of returned elements can differ from the number of
input elements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171713Z" changeid="explorer">
        <seg>demuestra que el número de elementos devueltos pueden diferir de la cantidad de elementos de la entrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hash{12345} = &quot;something&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T224936Z" changeid="zipf">
        <seg>$hash{12345} = &quot;algo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl officially stands for Practical Extraction and Report Language,
except when it doesn't.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000941Z" changeid="explorer">
        <seg>Oficialmente, Perl significa Practical Extraction and Report Language (I&lt;Lenguaje práctico para la extracción de datos y creación de informes&gt;), excepto cuando no hace eso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTML output will now correctly link
to C&lt;=item&gt;s on the same page, and should be valid XHTML.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034259Z" changeid="explorer">
        <seg>Ahora la salida HTML enlazará correctamente con C&lt;=item&gt; en la misma página, y deberá ser un XHTML válido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some systems, you can avoid this by setting
C&lt;$SIG{CHLD}&gt; to C&lt;&quot;IGNORE&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas, puede evitar esto poniendo C&lt;$SIG{CHLD}&gt; a C&lt;&quot;IGNORE&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(LOG, &quot;&gt;&gt;/usr/spool/news/twitlog&quot;);  # (log is reserved)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003945Z" changeid="explorer">
        <seg>open(LOG, &quot;&gt;&gt;/usr/spool/news/twitlog&quot;);  # (log es palabra reservada)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hint: sometimes appending C&lt;&quot;, stopped&quot;&gt; to your message will cause it
to make better sense when the string C&lt;&quot;at foo line 123&quot;&gt; is appended.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consejo: algunas veces añadir C&lt;&quot;, parado&quot;&gt; a tu mensaje hará aparecerle con un sentido mejor cuando se le añada la cadena C&lt;&quot;at foo line 123&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>STORE this, value</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>STORE este, valor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($cwd = `pwd`);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($cwd = `pwd`);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, if the
PATTERN contains a $ that looks like a variable rather than an
end-of-string test, the variable will be interpolated into the pattern
at run-time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, si el PATRÓN contiene un $ que parece más una variable que una marca de fin de cadena, la variable será interpolada en el patrón, en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Small
changes in the PLAINTEXT or SALT will result in large changes in the
digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pequeños cambios en TEXTPLANO o SALTO resultarán en grandes cambios en el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Alex Davies)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112327Z" changeid="explorer">
        <seg>(Alex Davies)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Over the years, Perl has grown into
a general-purpose programming language.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141635Z" changeid="explorer">
        <seg>Con los años, Perl se ha convertido en un lenguaje de programación de propósito general.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>other array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042953Z" changeid="explorer">
        <seg>del otro array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225929Z" changeid="explorer">
        <seg>=head2 He descargado el código fuente y he intentado compilarlo, pero gdbm/dynamic no puede cargar /malloc/linking/...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @fruits = keys %fruit_colors;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025845Z" changeid="explorer">
        <seg>my @frutas  = keys %colores_fruta;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$field = $query-&gt;radio_group(
               name      =&gt; 'group_name',
               values    =&gt; ['eenie','meenie','minie'],
               default   =&gt; 'meenie',
               linebreak =&gt; 'true',
               labels    =&gt; \%labels</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043005Z" changeid="explorer">
        <seg>$field = $query-&gt;radio_group(
               name      =&gt; 'nombre_grupo',
               values    =&gt; ['eenie','meenie','minie'],
               default   =&gt; 'meenie',
               linebreak =&gt; 'true',
               labels    =&gt; \%etiquetas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;x&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;x&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>==  equality</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120408Z" changeid="zipf">
        <seg>==  igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub aeq {  # compare two list values</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub aeq {  # comparar dos listas de valores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To present something as hex, look into L&lt;/printf&gt;,
L&lt;/sprintf&gt;, and L&lt;/unpack&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T235835Z" changeid="explorer">
        <seg>Para presentar algo en formato hexadecimal, mire en L&lt;/printf&gt;, L&lt;/sprintf&gt; o L&lt;/unpack&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need to cover the following subjects:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023918Z" changeid="explorer">
        <seg>Es necesario que cubra los siguientes temas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@hashes = map +{ lc($_) =&gt; 1 }, @array # EXPR, so needs comma at end</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@hashes = map +{ lc($_) =&gt; 1 }, @array # EXPR, por lo que necesita una coma al final</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlunifaq		Perl Unicode FAQ</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000418Z" changeid="explorer">
        <seg>perlunifaq		Preguntas más frecuentes sobre Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>alarm 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>alarm 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simplified the build process by using the MPEAUTOCONF
functionality in Mark Klein's ld.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Simplificado el proceso de generación mediante la funcionalidad MPEAUTOCONF en el ld de Marcos Klein.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>regular expression enhancements</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001422Z" changeid="explorer">
        <seg>mejoras de las expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;The Perl Review&gt; ( http://www.theperlreview.com ) focuses on Perl
almost completely (although it sometimes sneaks in an article about
another language).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230738Z" changeid="explorer">
        <seg>I&lt;The Perl Review&gt; ( http://www.theperlreview.com ) se centra en Perl casi en exclusiva (aunque a veces incluye algún artículo sobre otro lenguaje).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Bitwise And
X&lt;operator, bitwise, and&gt; X&lt;bitwise and&gt; X&lt;&amp;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235303Z" changeid="explorer">
        <seg>=head2 And binario
X&lt;operator, bitwise, and&gt; X&lt;bitwise and&gt; X&lt;&amp;&gt; X&lt;operador, binario, and&gt; X&lt;binario and&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure &lt;gethostbyname()&gt; is called in SCALAR context and that
its return value is checked for definedness.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cerciorarse de que &lt;gethostbyname()&gt; es llamado en contexto ESCALAR y que se comprueba que su valor de retorno está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shutdown(Rdr, 1);        # no more writing for reader</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shutdown(Rdr, 1);        # no más escrituras para el lector</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Platform-specific fixes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031437Z" changeid="explorer">
        <seg>=head2 Arreglos específicos por plataforma</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exists may also be called on array elements, but its behavior is much less
obvious and is strongly tied to the use of L&lt;/delete&gt; on arrays.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T233812Z" changeid="explorer">
        <seg>exists también pueden ser llamado sobre elementos de array, pero su comportamiento es mucho menos evidente, y está fuertemente ligado a la utilización de L&lt;/delete&gt; en arrays.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In the absence of an explicit C&lt;return&gt;, a subroutine, eval,
or do FILE automatically returns the value of the last expression
evaluated.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En ausencia de un C&lt;return&gt; explícito, una subrutina, eval, o do ARCHIVO, automáticamente devuelve el valor de la última expresión evaluada).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 POD</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023801Z" changeid="explorer">
        <seg>=head2 POD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is a problem, you
can call C&lt;POSIX:_exit($status)&gt; to avoid END and destructor processing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si esto es un problema, puede llamar a C&lt;POSIX:_exit($estado)&gt; para saltar el procesado de END y de los destructores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The (mis)use of C&lt;/tmp&gt; in core modules and documentation has been tidied up.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T104330Z" changeid="explorer">
        <seg>El (mal) uso de C&lt;/tmp&gt; en módulos básicos y documentación han sido recortados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@  Null-fill or truncate to absolute position, counted from the</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@  Relleno con nulos o truncar a una posición absoluta, contado desde el</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may prefer to use the
C&lt;each&gt; function to iterate over such.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede preferir usar la función C&lt;each&gt; para iterar sobre tales listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item if</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232630Z" changeid="explorer">
        <seg>=item if</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Version Strings
X&lt;version string&gt; X&lt;vstring&gt; X&lt;v-string&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035459Z" changeid="explorer">
        <seg>=head3 Cadenas de versión
X&lt;version string&gt; X&lt;vstring&gt; X&lt;v-string&gt; X&lt;cadena versión&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once
compiled, the behavior doesn't change regardless of what rules are in
effect when the regular expression is executed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163740Z" changeid="explorer">
        <seg>Una vez compilado, el comportamiento no cambia, independientemente de las reglas que entren en vigor cuando la expresión regular se ejecute.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endhostent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endhostent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># sort numerically ascending</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ordenación numérica ascendente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are significantly more tests for the C&lt;B&gt; suite of modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212848Z" changeid="explorer">
        <seg>Hay significativamente más pruebas para el conjunto de módulos C&lt;B&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $key, ' = ', unpack('L',$val), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $clave, ' = ', unpack('L',$valor), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq3		Programming Tools</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq3		Herramientas de programación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmodlib		Perl modules: how to write and use</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000433Z" changeid="explorer">
        <seg>perlmodlib		Programación y utilización de módulos Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's widely used for everything
from quick &quot;one-liners&quot; to full-scale application development.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141717Z" changeid="explorer">
        <seg>Es ampliamente utilizado para todo, desde las rápidas &quot;una-línea&quot; hasta el desarrollo de aplicaciones a gran escala.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/ A (*PRUNE) B /</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050632Z" changeid="explorer">
        <seg>/ A (*PRUNE) B /</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, for an C&lt;eval BLOCK&gt; statement,
$subroutine is C&lt;(eval)&gt;, but $evaltext is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012324Z" changeid="explorer">
        <seg>En particular, para una instrucción C&lt;eval BLOQUE&gt;, $subrutina es C&lt;(eval)&gt;, pero $evaltext es indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this command lists any paths that don't exist on your system, then you
may need to move the appropriate libraries to these locations, or create
symbolic links, aliases, or shortcuts appropriately.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225916Z" changeid="explorer">
        <seg>Si este comando muestra rutas de acceso que no existen en el sistema, es posible que tenga que mover las bibliotecas necesarias a estas ubicaciones o crear los vínculos simbólicos, alias o accesos directos correspondientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That method may be best because otherwise you won't treat IEEE
notations like C&lt;NaN&gt; or C&lt;Infinity&gt; properly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este método podría ser mejor porque de otro modo no podría tratar notaciones IEEE como C&lt;Nan&gt; o C&lt;Infinity&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Win32, S&lt;RISC OS&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015000Z" changeid="explorer">
        <seg>(Win32, S&lt;RISC OS&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/(\d+)/ \1 + 1 /eg;            # causes warning under -w</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T225709Z" changeid="explorer">
        <seg>s/(\d+)/ \1 + 1 /eg;            # provoca una advertencia bajo -w</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same as map assignment above</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># la misma asignación que la anterior con map</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Supported Environments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Entornos soportados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;redo&gt; command restarts the loop block without evaluating the
conditional again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;redo&gt; reinicia la iteración sin evaluar de nuevo la condición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides the key feature of C&lt;base&gt; without the feature creep.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110921T145452Z" changeid="explorer">
        <seg>Proporciona la característica clave de C&lt;base&gt; sin la función de fluencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that currently some test scripts may fail when run in parallel (most
notably C&lt;ext/IO/t/io_dir.t&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T002729Z" changeid="explorer">
        <seg>Tenga en cuenta que en la actualidad algunos scripts de prueba pueden fallar cuando se ejecuta en paralelo (sobre todo C&lt;ext/IO/t/io_dir.t&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.pearsonhighered.com/educator/product/Network-Programming-with-Perl/9780201615715.page</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003601Z" changeid="explorer">
        <seg>http://www.pearsonhighered.com/educator/product/Network-Programming-with-Perl/9780201615715.page</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please report any errors, updates, or suggestions to F&lt;perlbug@perl.org&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por favor, informe de cualquier error, actualización o sugerencias a  F&lt;perlbug@perl.org&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This just extends the existing rule that applies
to the regular or operator, as in C&lt;when (expr1 || expr2)&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T221148Z" changeid="explorer">
        <seg>(Esto amplia la regla actual que se aplica al operador or normal, como en C&lt;when (expr1 || expr2)&gt;.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By
default, empty leading fields are preserved, and empty trailing ones are
deleted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto, los campos vacíos precedentes son preservados, y los campos vacíos consecuentes son eliminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IF YOU RUN INTO TROUBLE
=======================</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222209Z" changeid="explorer">
        <seg>SI SE ENCUENTRA CON PROBLEMAS
=============================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = [ split &quot; &quot;, $line ];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030403Z" changeid="explorer">
        <seg>$AoA[$i] = [ split &quot; &quot;, $linea ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lc</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item lc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also put
directly the path to your perl executable, like in C&lt;#!/usr/bin/perl&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224652Z" changeid="explorer">
        <seg>También puede especificar directamente la ruta de acceso a su ejecutable perl: C&lt;#!/usr/bin/perl&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable
in many situations where on the first sight a simple C&lt;()*&gt; looks like
the correct solution.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T220056Z" changeid="explorer">
        <seg>La semántica &quot;agarrar todo lo que puedas, y no dar nada a cambio&quot; es deseable en muchas situaciones en las que, a primera vista, un simple C&lt;()*&gt; parece la solución correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compile-time value of the C&lt;%^H&gt; hint variable can now propagate into
eval(&quot;&quot;)uated code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200408Z" changeid="explorer">
        <seg>El valor en tiempo de compilación de la variable especial C&lt;%^H&gt; ahora se puede propagar en un código eval(&quot;&quot;)uado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^$/);  # skip header lines, short for
                               #   next LINE if ($.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034047Z" changeid="explorer">
        <seg>/^$/); # salta las líneas de cabecera, resumen de
                               #   next LINEA if ($.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print @ary;		# prints 1324</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print @ary;		# imprime 1324</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the C&lt;break&gt; keyword to break out of the enclosing
C&lt;given&gt; block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T012535Z" changeid="explorer">
        <seg>Puede usar la palabra clave C&lt;break&gt; para salir del bloque C&lt;given&gt; actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Illegal division by zero at ../lib/Math/BigInt/Calc.pm line 314.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214810Z" changeid="explorer">
        <seg>Illegal division by zero at ../lib/Math/BigInt/Calc.pm line 314.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (&quot;\020\020&quot; &amp; &quot;\101\101&quot;) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225517Z" changeid="explorer">
        <seg>if (&quot;\020\020&quot; &amp; &quot;\101\101&quot;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(?&lt;char&gt;.)\k&lt;char&gt;/            # ... a different way
         and print &quot;'$+{char}' is the first doubled character\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230234Z" changeid="explorer">
        <seg>/(?&lt;car&gt;.)\k&lt;car&gt;/              # ... de otra forma
         and print &quot;'$+{car}' es el primer carácter repetido\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accelerated Unicode case mappings (C&lt;/i&gt;, C&lt;lc&gt;, C&lt;uc&gt;, etc).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T105029Z" changeid="explorer">
        <seg>Mapeos acelerados en el cambio de tamaño de caja en Unicode (C&lt;/i&gt;, C&lt;lc&gt;, C&lt;uc&gt;, etc).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc/&quot;Safe Pipe Opens&quot;&gt; for more examples of this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc/&quot;Aperturas seguras de tuberías&quot;&gt; para más ejemplos sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since v5.8.0, Perl has built using PerlIO by default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde v5.8.0, Perl ha sido construido para que use PerlIO por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See
C&lt;open&gt;.)  However, an explicit C&lt;close&gt; on an input file resets the line
counter (C&lt;$.&gt;), while the implicit close done by C&lt;open&gt; does not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver C&lt;open&gt;). Sin embargo, un C&lt;close&gt; explícito en un archivo de entrada reinicia el contador de líneas (C&lt;$.&gt;), mientras que un C&lt;close&gt; implícito hecho por C&lt;open&gt;, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>J   A Perl internal unsigned integer value (UV).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>J   Un valor Perl interno entero sin signo (UV).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the left operand is true, the range operator stays true until the
right operand is true, I&lt;AFTER&gt; which the range operator becomes false
again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una vez que el operando izquierdo sea verdadero, el operador rango se mantiene así hasta que el operando de la derecha sea verdadero, I&lt;DESPUÉS&gt; de lo cual, el operador rango se vuelve falso de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please only use this address for
security issues in the Perl core, not for modules independently
distributed on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T232619Z" changeid="explorer">
        <seg>Por favor, utilice sólo esta dirección para problemas de seguridad en el núcleo de Perl, no para los módulos distribuidos de forma independiente en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return (first, &lt;$handle&gt;) if $ALL;  # Or here.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T000400Z" changeid="explorer">
        <seg>return (first, &lt;$handle&gt;) if $TODO; # O aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use File::Find;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225446Z" changeid="explorer">
        <seg>use File::Find;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a cheap and nasty way to break an email address up into parts</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120852Z" changeid="zipf">
        <seg># manera rápida de descomponer una dirección de correo electrónico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C preprocessor including the #include 
statements in the preprocessor output (.i) file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102719Z" changeid="explorer">
        <seg>El preprocesador de C, incluyendo las instrucciones #include en el archivo de salida del preprocesador (.i).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;True\n&quot;      if $hash{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Verdadero\n&quot;   if $hash{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;||&quot; performs a short-circuit logical OR operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;||&quot; realiza una operación lógica OR abreviada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readline
X&lt;readline&gt; X&lt;gets&gt; X&lt;fgets&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194429Z" changeid="explorer">
        <seg>=item readline
X&lt;readline&gt; X&lt;gets&gt; X&lt;fgets&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare L&lt;/values&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compare con L&lt;/values&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A fundamental feature of regular expression matching involves the
notion called I&lt;backtracking&gt;, which is currently used (when needed)
by all regular non-possessive expression quantifiers, namely C&lt;*&gt;, C&lt;*?&gt;, C&lt;+&gt;,
C&lt;+?&gt;, C&lt;{n,m}&gt;, and C&lt;{n,m}?&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T145258Z" changeid="explorer">
        <seg>Una característica fundamental de las expresiones regulares incluye la noción llamada I&lt;backtracking&gt; (vuelta atrás), que se utiliza actualmente (cuando es necesario) por todos los cuantificadores de expresiones regulares no posesivos, es decir, C&lt;*&gt;, C&lt;*?&gt;, C&lt;+&gt;, C&lt;+?&gt;, C&lt;{n,m}&gt;, and C&lt;{n,m}?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could, for example, group binary
digits by threes (as for a Unix-style mode argument such as 0b110_100_100)
or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Podría, por ejemplo, agrupar los dígitos binarios en grupos de tres en tres (como si fuera, al estilo Unix, de un argumento de modo, como en 0b110_100_100) o de cuatro en cuatro (para representar nibbles, como en 0b1010_0110) o en otros grupos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It quickly became a good language
for many system management tasks.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141626Z" changeid="explorer">
        <seg>Rápidamente se convirtió en un magnífico lenguaje para muchas tareas de gestión de sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These modifiers, new in 5.14, affect which character-set semantics
(Unicode, ASCII, etc.) are used, as described below in
L&lt;/Character set modifiers&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163028Z" changeid="explorer">
        <seg>Estos modificadores, nuevos en 5,14, afectan a la semántica del conjunto de caracteres (Unicode, ASCII, etc) que se utiliza, como se describe en L&lt;/Modificadores del conjunto de caracteres&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REF</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>REF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;The LAYER parameter of the binmode() function is described as &quot;DISCIPLINE&quot;
in &quot;Programming Perl, 3rd Edition&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>I&lt;El parámetro CAPA de la función binmode() se describe como &quot;DISCIPLINA&quot; en &quot;Programming Perl, 3rd Edition&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Backwards compatibility</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023029Z" changeid="explorer">
        <seg>=head2 Compatibilidad con versiones anteriores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document varies from difficult to understand to completely
and utterly opaque.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003952Z" changeid="explorer">
        <seg>Este documento varía de &quot;difícil de entender&quot; a &quot;completa y totalmente opaco&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;File::Path&gt; upgraded to version 1.08</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031735Z" changeid="explorer">
        <seg>C&lt;File::Path&gt; actualizado a la versión 1.08</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mac OS Classic</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015345Z" changeid="explorer">
        <seg>Mac OS Classic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub logger {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T233832Z" changeid="zipf">
        <seg>sub registrador {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dbmclose(%HIST);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dbmclose(%HIST);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used after running C&lt;make
install&gt; (or your platform's equivalent procedure) to verify that perl
and its libraries have been installed correctly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234406Z" changeid="explorer">
        <seg>Se puede usar después de ejecutar C&lt;make install&gt; (o el procedimiento equivalente para su plataforma) para comprobar que perl y sus bibliotecas se han instalado correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need more file
descriptors than that, consider rebuilding Perl to use the C&lt;sfio&gt;
library, or perhaps using the POSIX::open() function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si necesita más descriptores de archivo que esa cantidad, contemple la posibilidad de reconstruir Perl para que use la biblioteca C&lt;sfio&gt;, o tal vez usar la función estándar POSIX::open().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$t = @a[0, 1];                  # $t is now 'second'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150309Z" changeid="explorer">
        <seg>$t = @a[0, 1];                  # $t es ahora 'segundo'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example, the smart match operator short-circuits whenever possible, but
C&lt;grep&gt; does not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, el operador de coincidencia inteligente intenta siempre abreviar donde sea posible, mientras que C&lt;grep&gt;, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These conversions are governed by the following general rules:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232653Z" changeid="explorer">
        <seg>Estas conversiones obedecen las siguientes normas generales:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item continuation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item continuation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mysockaddr = getsockname(SOCK);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$mysockaddr = getsockname(SOCK);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example of how your own code can go broken:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231833Z" changeid="explorer">
        <seg>Here is an example of how your own code can go broken:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$re = qr{
             \(
             (?:
                (?&gt; [^()]+ )       # Non-parens without backtracking
              |
                (??{ $re })        # Group with matching parens
             )*
             \)
          }x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050952Z" changeid="explorer">
        <seg>$re = qr{
             \(
             (?:
                (?&gt; [^()]+ )       # No-paréntesis, sin retroceso
              |
                (??{ $re })        # Grupo con coincidencia de paréntesis
             )*
             \)
          }x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first form, the return value of EXPR is parsed and executed as if it
were a little Perl program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la primera forma, el valor devuelto por EXPR es interpretado y ejecutado como si fuera un pequeño programa Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the above usage will create global variables throughout your
program, which is bad programming practice.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225040Z" changeid="explorer">
        <seg>Sin embargo, el uso anterior creará variables globales en todo el programa, algo que no se recomienda en programación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ASCII semantics are used for the case change.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175203Z" changeid="explorer">
        <seg>Semántica ASCII es utilizada para el cambio de tamaño de caja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item c)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item c)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
parallelism means &quot;awk and perl&quot; and &quot;Python and Perl&quot; look good, while
&quot;awk and Perl&quot; and &quot;Python and perl&quot; do not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231600Z" changeid="explorer">
        <seg>Por ejemplo, por paralelismo podemos intuir que &quot;awk y perl&quot; y &quot;Python y Perl&quot; son aceptables, mientras que &quot;awk y Perl&quot; y &quot;Python y perl&quot; no lo son.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?^alupimsx)&gt;
X&lt;(?)&gt; X&lt;(?^)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T051627Z" changeid="explorer">
        <seg>=item C&lt;(?^alupimsx)&gt;
X&lt;(?)&gt; X&lt;(?^)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@lines = (&quot;   - Foo&quot;,
              &quot;01 - Bar&quot;,
              &quot;1  - Baz&quot;,
              &quot;   - Quux&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034303Z" changeid="explorer">
        <seg>@lineas = (&quot;   - Foo&quot;,
               &quot;01 - Bar&quot;,
               &quot;1  - Baz&quot;,
               &quot;   - Quux&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225517Z" changeid="explorer">
        <seg>You need:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should give end users more
flexibility in their choice of upgrade timing, and allow them easier
assessment of the impact of upgrades.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto debería dar a los usuarios finales una mayor flexibilidad en su elección del momento de la actualización, y permitir una evaluación más sencilla de los efectos de las actualizaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several of the core modules have been converted to use this feature for
their system dependent constants - as a result C&lt;use POSIX;&gt; now takes about
200K less memory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T033642Z" changeid="explorer">
        <seg>Varios de los módulos básicos se han convertido para usar esta característica para sus constantes dependientes del sistema - como resultado de esto, C&lt;use POSIX;&gt; ahora ocupa 200K menos de memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Positive assertions match when
their subpattern matches, negative assertions match when their subpattern
fails.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T203236Z" changeid="explorer">
        <seg>Aserciones positivas coinciden cuando los subpatrones coinciden, aserciones negativas coinciden cuando fallan sus subpatrones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dave Mitchell improved the lexer debugging output under C&lt;-DT&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T041034Z" changeid="explorer">
        <seg>Dave Mitchell mejoró la salida de depuración del analizador léxico con C&lt;-DT&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Otherwise, if C&lt;use feature 'unicode_strings'&gt; is in effect:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174935Z" changeid="explorer">
        <seg>=item De lo contrario, si C&lt;use feature 'unicode_strings'&gt; está activo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item b)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolation in patterns has several quirks: C&lt;$|&gt;, C&lt;$(&gt;, C&lt;$)&gt;, C&lt;@+&gt;
and C&lt;@-&gt; are not interpolated, and constructs C&lt;$var[SOMETHING]&gt; are
voted (by several different estimators) to be either an array element
or C&lt;$var&gt; followed by an RE alternative.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La interpolación en los patrones tiene varias peculiaridades: C&lt;$|&gt;, C&lt;$(&gt;, C&lt;$)&gt;, C&lt;@+&gt; y C&lt;@-&gt; no son interpoladas, y construcciones C&lt;$var[ALGO]&gt; son promovidas (por varios estimadores diferentes) a ser un elemento de array o C&lt;$var&gt; seguida de una RE alternativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-  Testing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-  Comprobación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are infinitely more reals than floats,
so some corners must be cut.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay infinitamente más reales que flotantes, por lo que algunos detalles deben ser tenidos en cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators return a count of successful
operations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven una cuenta del número de operaciones exitosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># DOS, etc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225504Z" changeid="explorer">
        <seg># DOS, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ABOUT PERL
==========</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T221716Z" changeid="explorer">
        <seg>ACERCA DE PERL
==============</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Floating-point Arithmetic
X&lt;floating-point&gt; X&lt;floating point&gt; X&lt;float&gt; X&lt;real&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011215Z" changeid="explorer">
        <seg>=head2 Aritmética de punto flotante
X&lt;floating-point&gt; X&lt;floating point&gt; X&lt;float&gt; X&lt;real&gt; X&lt;punto flotante&gt; X&lt;flotante&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class implementing an ordinary array should have the following methods:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una clase implementando un array ordinario común debe tener los siguientes métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 4) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 4) = 1   ==       4096 00000000000010000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, whether
C&lt;&lt; &quot;a $b -&gt; {c}&quot; &gt;&gt; really means:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, si C&lt;&lt; &quot;a $b -&gt; {c}&quot; &gt;&gt; realmente significa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(AmigaOS)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014855Z" changeid="explorer">
        <seg>(AmigaOS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item a)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item a)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># in-memory files</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># archivos en memoria</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programs should rarely if ever make policy decisions better left to
the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los programas rara vez o nunca deben tomar decisiones políticas, que es mejor dejar al usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember that a umask is a number, usually given in octal; it is I&lt;not&gt; a
string of octal digits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recuerde que un umask es un número, generalmente indicado en octal; I&lt;no&gt; es una cadena de dígitos octales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @mpeg = &lt;audio/*/*.mp3&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225556Z" changeid="explorer">
        <seg>my @mpeg = &lt;audio/*/*.mp3&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifiers that alter the way a regular expression
is used by Perl are detailed in L&lt;perlop/&quot;Regexp Quote-Like Operators&quot;&gt; and
L&lt;perlop/&quot;Gory details of parsing quoted constructs&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Modificadores que alteran la forma en que una expresión regular es utilizada por Perl se detallan en L&lt;perlop/&quot;Operadores Regexp Entrecomillados&quot;&gt; y L&lt;perlop/&quot;Detalles sangrientos del análisis de las construcciones entrecomilladas&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlirix		Perl notes for Irix</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlirix		Notas para Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225512Z" changeid="explorer">
        <seg>0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Current Perl's
should handle this problem correctly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El Perl actual debería manejar este problema correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qr/STRING/msixpodual
X&lt;qr&gt; X&lt;/i&gt; X&lt;/m&gt; X&lt;/o&gt; X&lt;/s&gt; X&lt;/x&gt; X&lt;/p&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222719Z" changeid="explorer">
        <seg>=item qr/CADENA/msixpodual
X&lt;qr&gt; X&lt;/i&gt; X&lt;/m&gt; X&lt;/o&gt; X&lt;/s&gt; X&lt;/x&gt; X&lt;/p&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$XS_VERSION = $VERSION; # only needed if you have XS code</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025737Z" changeid="explorer">
        <seg>$XS_VERSION = $VERSION; # solo necesario si tiene código XS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getpwent();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$name  = getpwent();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an indirect object with C&lt;exec&gt; or C&lt;system&gt; is also more
secure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar un objeto indirecto con C&lt;exec&gt; o C&lt;system&gt; es también más seguro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several constructs above specify a character by a number.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232304Z" changeid="explorer">
        <seg>Varias de las construcciones anteriores especifican un carácter a partir de un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $result;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235528Z" changeid="zipf">
        <seg>return $resultado;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, C&lt;when()&gt; will always do an implicit smart match
with its argument, whilst it is convenient in Perl 5 to
suppress this implicit smart match in certain situations,
as documented above.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En Perl 6, C&lt;when()&gt; siempre hará una coincidencia inteligente con sus argumentos, mientras que en Perl 5 es conveniente suprimir esta coincidencia inteligente en ciertas situaciones, como se ha documentado anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;File::Glob&gt; upgraded to version 1.05</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031725Z" changeid="explorer">
        <seg>C&lt;File::Glob&gt; actualizado a la versión 1.05</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perlrepository&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005611Z" changeid="explorer">
        <seg>=item L&lt;perlrepository&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item defined</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item defined</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @new = @old[ sort {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @nuevo = @viejo[ sort {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Cephes           uses external Cephes C library (no big numbers)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035415Z" changeid="explorer">
        <seg>Math::Cephes			usa biblioteca externa en C Cephes (no para grandes números)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression \cI&lt;x&gt;
matches the character control-I&lt;x&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T222926Z" changeid="explorer">
        <seg>La expresión \cI&lt;x&gt; coincide con el carácter control-I&lt;x&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for staying almost, but not entirely similar to
C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para mantenerse casi, pero no del todo, similar a C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#.0o&gt;', 0;        # prints &quot;&lt;0&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#.0o&gt;', 0;        # imprime &quot;&lt;0&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, sprintf() takes the next unused argument as the value to
format for each format specification.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente, sprintf () toma el siguiente argumento utilizado como el valor de formato para cada especificación de formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 14694</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 14694</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting from Perl 5.10, you can say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de Perl 5.10, puede decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Zeus</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>=item Zeus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a real sense, perl already I&lt;is&gt; commercial software: it has a license
that you can grab and carefully read to your manager.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231015Z" changeid="explorer">
        <seg>En realidad, perl I&lt;es&gt; software comercial: tiene una licencia que su jefe puede analizar minuciosamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpriority WHICH,WHO
X&lt;getpriority&gt; X&lt;priority&gt; X&lt;nice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173706Z" changeid="explorer">
        <seg>=item getpriority CUÁL,QUIÉN
X&lt;getpriority&gt; X&lt;priority&gt; X&lt;nice&gt; X&lt;prioridad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)*  # any number of times</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231849Z" changeid="explorer">
        <seg>)*  # cualquier número de veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make -f Makefile.micro regen_uconfig</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make -f Makefile.micro regen_uconfig</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make test  1 hour 45 minutes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make test  1 hora 45 minutos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Opciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filehandle is left open pointing to the
contents after __DATA__.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El gestor de archivo se deja abierto apuntando al contenido que hay después de __DATA__.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($login, $passwd, $uid, $gid,
         $gcos, $home, $shell) = split(/:/);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051547Z" changeid="explorer">
        <seg>($login, $passwd, $uid, $gid,
         $gcos, $home, $shell) = split(/:/);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a tied hash
is evaluated in scalar context, the C&lt;SCALAR&gt; method is called (with a
fallback to C&lt;FIRSTKEY&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T145622Z" changeid="explorer">
        <seg>Si un hash enlazado (tie) es evaluado en contexto escalar, se llama al método C&lt;SCALAR&gt; (con una retrollamada a C&lt;FIRSTKEY&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolating an array or slice interpolates the elements in order,
separated by the value of C&lt;$&quot;&gt;, so is equivalent to interpolating
C&lt;join $&quot;, @array&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Interpolando un array o una parte de él, es interpolar los elementos por orden, separándolos por el valor de C&lt;$&quot;&gt;, que es equivalente a C&lt;join $&quot;, @array&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this feature was 
to be run only right before your program was to exit, this is not
currently so: the C&lt;$SIG{__DIE__}&gt; hook is currently called
even inside eval()ed blocks/strings!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque esta característica está preparada para ser ejecutada sólo antes de que el programa termine, así no es como se hace ahora: el gancho C&lt;$SIG{__DIE__}&gt;, ¡es llamado incluso dentro de cadenas y bloques eval()uados!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>qw!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>qw!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UTS Global LLC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>UTS Global LLC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of C&lt;defined&gt; on aggregates (hashes and arrays) is deprecated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de C&lt;defined&gt; sobre datos agregados (hashes y arrays) está desaconsejado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sysseek() bypasses normal buffered IO, so mixing it with reads other
than C&lt;sysread&gt; (for example C&lt;&lt; &lt;&gt; &gt;&gt; or read()) C&lt;print&gt;, C&lt;write&gt;,
C&lt;seek&gt;, C&lt;tell&gt;, or C&lt;eof&gt; may cause confusion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T022957Z" changeid="explorer">
        <seg>sysseek() omite el búfer normal de E/S, por lo que mezclarlo con lecturas que no sean C&lt;sysread&gt; (por ejemplo C&lt;&lt; &lt;&gt; &gt;&gt; o read()) puede confundir a C&lt;print&gt;, C&lt;write&gt;, C&lt;seek&gt;, C&lt;tell&gt;, o C&lt;eof&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is true of an operation it will be mentioned in
the documentation for that operation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T000510Z" changeid="explorer">
        <seg>Si esto es cierto para una determinada operación, entonces estará mencionado en la documentación de esa operación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, you may need to set
C&lt;$|&gt; ($AUTOFLUSH in English) or call the C&lt;autoflush()&gt; method of
C&lt;IO::Handle&gt; on any open handles.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para estar seguro, es posible que necesite el conjunto C&lt;|&gt; ($AUTOFLUSH en English) o llame al método C&lt;autoflush()&gt; de C&lt;IO::Handle&gt; en cualquier identificador abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2  &quot;bart&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032601Z" changeid="explorer">
        <seg>2  &quot;bart&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;ext/Socket/t/socketpair.t&gt; test fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El test C&lt;ext/Socket/t/socketpair.t&gt; falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Mailing list for Perl on VM/ESA</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T111921Z" changeid="explorer">
        <seg>=head2 Lista de correo de Perl en VM/ESA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a shortcut C&lt;(*MARK:NAME)&gt; can be written C&lt;(*:NAME)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T140844Z" changeid="explorer">
        <seg>Como método abreviado C&lt;(*MARK:NOMBRE)&gt; se puede escribir como C&lt;(*:NOMBRE)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -CS -E 'say &quot;\x{3B1}\x{3C9}&quot;' |</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003533Z" changeid="explorer">
        <seg>$ perl -CS -E 'say &quot;\x{3B1}\x{3C9}&quot;' |</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can reduce some of the looping through slices</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T195019Z" changeid="explorer">
        <seg>Podemos reducir algunos de los bucles usando porciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fix is to re-compile and re-install the modules using 5.8.2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La solución es volver a compilar y volver a instalar los módulos usando 5.8.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\c[      chr(27)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034633Z" changeid="explorer">
        <seg>\c[      chr(27)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Contributed by Salvador FandiÃ±o GarcÃ­a.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200041Z" changeid="explorer">
        <seg>(Escrito por Salvador Fandiño García.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when($_ ~~ $foo)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when($_ ~~ $foo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This improvement was actually in 5.8.7,
but was accidentally omitted from L&lt;perl587delta&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T043505Z" changeid="explorer">
        <seg>(Esta mejora fue hecha en realidad en 5.8.7, pero se omitió accidentalmente a partir de L&lt;perl587delta&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declares the BLOCK or the rest of the compilation unit as being in the
given namespace.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003852Z" changeid="explorer">
        <seg>Declara el BLOQUE o el resto de la unidad de compilación como pertenecientes al espacio de nombres especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As
this could cause problems when C&lt;goto&gt; jumps were involved, this change
was backed out.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035431Z" changeid="explorer">
        <seg>Ya que esto podría causar problemas cuando intervenían saltos C&lt;goto&gt;, este cambio ha sido desechado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;system @args failed: $?&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;system @args falló: $?&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;\@array contains $count copies of 'foo'\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;\@array contiene $cuenta copias de 'foo'\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item d)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item d)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $cycle; # FFFF00</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>print $cycle; # FFFF00</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\d+/$&amp;*2/e;		# yields 'abc246xyz'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213206Z" changeid="explorer">
        <seg>s/\d+/$&amp;*2/e;				# queda como 'abc246xyz'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also exempt from the normal B&lt;-w&gt; warnings
on improper numeric conversions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También es una excepción en el sistema de avisos B&lt;-w&gt; sobre conversiones numéricas impropias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ARGV = grep { -f &amp;&amp; -T } glob('*') unless @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ARGV = grep { -f &amp;&amp; -T } glob('*') unless @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, waiting for a particular
pid with FLAGS of C&lt;0&gt; is implemented everywhere.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, esperar por un particular pid con BANDERAS a C&lt;0&gt; está implementado en todas partes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It fails and
returns false only if the command does not exist I&lt;and&gt; it is executed
directly instead of via your system's command shell (see below).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fallará y devolverá falso sólo si el comando no existe I&lt;y&gt; es ejecutado directamente en lugar de hacerlo con el shell de comandos del sistema (ver abajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A series of characters matches that series of characters in the target
string, so the pattern C&lt;blurfl&gt; would match &quot;blurfl&quot; in the target
string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212453Z" changeid="explorer">
        <seg>Una serie de caracteres coincide con la serie de caracteres en la cadena objetivo, por lo que el patrón C&lt;blurfl&gt; coincidiría con &quot;blurfl&quot; en la cadena objetivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright (c) 2000 Mark Kvale
All rights reserved.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T152751Z" changeid="explorer">
        <seg>Copyright (c) 2000 Mark Kvale. Todos los derechos reservados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because in
PerlThink, the righthand side of an C&lt;s///&gt; is a double-quoted string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T225040Z" changeid="explorer">
        <seg>Eso es porque en el Pensamiento Perliano, el lado derecho de un C&lt;s///&gt; es una cadena entrecomillada doble.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To
enable it, it's necessary to pass the argument C&lt;-Dmad&gt; to Configure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T001952Z" changeid="explorer">
        <seg>Para activarlo, es necesario pasar el argumento C&lt;-Dmad&gt; a Configure.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Switch</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014839Z" changeid="explorer">
        <seg>=item Switch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.riscos - Perl version 5 for RISC OS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.riscos - Perl versión 5 para sistemas operativos RISC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|  x   |  7   |</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225610Z" changeid="explorer">
        <seg>|  x   |  7   |</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's run from a terminal, F&lt;perldoc&gt; will usually call F&lt;pod2man&gt; to
translate POD (Plain Old Documentation - see L&lt;perlpod&gt; for an
explanation) into a manpage, and then run F&lt;man&gt; to display it; if
F&lt;man&gt; isn't available, F&lt;pod2text&gt; will be used instead and the output
piped through your favourite pager.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233407Z" changeid="explorer">
        <seg>Cuando se ejecuta desde un terminal, normalmente F&lt;perldoc&gt; llama a F&lt;pod2man&gt; para convertir el formato POD (Plain Old Documentation; consulte L&lt;perlpod&gt; para ver una descripción) en una página de manual, y después ejecuta F&lt;man&gt; para mostrarla; si F&lt;man&gt; no está disponible, se usa F&lt;pod2text&gt; y el resultado se canaliza a través de su paginador favorito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\x1b         [2,8]  restricted range hex char (example: ESC)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034517Z" changeid="explorer">
        <seg>\x1b	[2,8]	rango restringido car. hex	(example: ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures
crypt() will hash the new string with the same salt as the digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto asegura que crypt() hará el hash de la nueva cadena con el mismo salto que el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use
diagnostics&gt; pragma automatically turns Perl's normally terse warnings
and errors into these longer forms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001626Z" changeid="explorer">
        <seg>El pragma C&lt;use diagnostics&gt; convierte automáticamente las advertencias y errores de Perl, normalmente escuetos, en estos mensajes más desarrollados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operands to a binary bitwise op are strings of different
sizes, B&lt;|&gt; and B&lt;^&gt; ops act as though the shorter operand had
additional zero bits on the right, while the B&lt;&amp;&gt; op acts as though
the longer operand were truncated to the length of the shorter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los operandos a una operación bit a bit binaria son cadenas de diferentes tamaños, los operadores B&lt;|&gt; y B&lt;^&gt; actúan como si el operando más corto tuviera más bit cero a la derecha, mientras que el operador B&lt;&amp;&gt; actúa como si el operando más largo fuera truncado a la longitud de la menor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item state EXPR
X&lt;state&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201631Z" changeid="explorer">
        <seg>=item state EXPR
X&lt;state&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=back</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If CLASSNAME is omitted, the current package
is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite NOMBRECLASE, se usa el paquete actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or because
the Bourne shell is more familiar to you than I&lt;csh&gt;, so writing C&lt;for&gt;
comes more naturally.)  If VAR is omitted, C&lt;$_&gt; is set to each value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(O si le es más familiar el shell Bourne que el I&lt;csh&gt;, escribir C&lt;for&gt; le será más natural). Si VAR se omite, C&lt;$_&gt; se inicializa con cada valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can't be used to get out of a block or
subroutine given to C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se puede utilizar para salir de un bloque o una subrutina pasada a C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Wx</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225454Z" changeid="explorer">
        <seg>=item Wx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string =~ s/ (</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225536Z" changeid="explorer">
        <seg>$string =~ s/ (</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>r	Return the modified string and leave the original string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T214357Z" changeid="explorer">
        <seg>r	Devuelve la cadena modificada dejando la cadena original</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What is Perl 6?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230017Z" changeid="explorer">
        <seg>=head2 ¿Qué es Perl 6?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item format</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item format</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, the arguments to a subroutine are available
to us as a special array called C&lt;@_&gt; (see L&lt;perlvar&gt; for more on that).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225524Z" changeid="explorer">
        <seg>Los argumentos pasados a una subrutina están disponibles en un array especial denominado C&lt;@_&gt; (consulte L&lt;perlvar&gt; para obtener más información).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exceptions to this rule are when the file or directory should be
kept private (mail files, for instance).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las excepciones a esta regla son cuando el archivo o directorio debe mantenerse privados (archivos de correo, por ejemplo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within search patterns (which also undergo double-quotish substitution)
there is an unfortunate ambiguity:  Is C&lt;/$foo[bar]/&gt; to be interpreted as
C&lt;/${foo}[bar]/&gt; (where C&lt;[bar]&gt; is a character class for the regular
expression) or as C&lt;/${foo[bar]}/&gt; (where C&lt;[bar]&gt; is the subscript to array
@foo)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dentro de los patrones de búsqueda (que también están bajo la sustitución del entrecomillado doble) existe una desafortunada ambigüedad: ¿Debe C&lt;/$foo[bar]/&gt; ser interpretado como C&lt;/${foo}[bar]/&gt; (donde C&lt;[bar]&gt; es una clase carácter para la expresión regular) o como C&lt;/${foo[bar]}/&gt; (donde C&lt;[bar]&gt; es el subíndice del array @foo)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sort { $a-&gt;[1] cmp $b-&gt;[1] }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>sort { $a-&gt;[1] cmp $b-&gt;[1] }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 1) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 1) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-1-56592-716-2 [1st edition January 2002]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003634Z" changeid="explorer">
        <seg>ISBN 978-1-56592-716-2 [1ª edición - Enero de 2002]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose a sensible and consistent version numbering scheme (X.YY is the common Perl module numbering scheme)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014244Z" changeid="explorer">
        <seg>Elija una sensata y coherente esquema de numeración de versiones (X.YY es el esquema de numeración normal para los módulos Perl)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ActivePerl is a pre-compiled version of Perl
ready-to-use.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225832Z" changeid="explorer">
        <seg>ActivePerl es una versión precompilada de Perl, lista para usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if $!;              # errno</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171121Z" changeid="explorer">
        <seg>if $!;              # errno</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Bit::Vector;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225513Z" changeid="explorer">
        <seg>use Bit::Vector;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014851Z" changeid="explorer">
        <seg>=item open</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($@) {
           $INC{$filename} = undef;
           die $@;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051144Z" changeid="explorer">
        <seg>if ($@) {
           $INC{$archivo} = undef;
           die $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &amp;&amp;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234248Z" changeid="explorer">
        <seg>(($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &amp;&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = ()[1,0];           # @a has no elements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@a = ()[1,0];           # @a no tiene elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual random
order is subject to change in future versions of Perl, but it is
guaranteed to be in the same order as either the C&lt;keys&gt; or C&lt;values&gt;
function would produce on the same (unmodified) hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El actual orden aleatorio está sujeto a cambio en futuras versiones de Perl, pero se garantiza que sea el mismo orden que las funciones C&lt;keys&gt; o C&lt;values&gt; producirían (mientras que el hash no haya sido modificado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the file will not be included twice under the same specified
name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el archivo no será incluido dos veces con el mismo nombre especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq5		Files and Formats</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003917Z" changeid="explorer">
        <seg>perlfaq5		Archivos y formatos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ make</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ make</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Yves
Orton)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112231Z" changeid="explorer">
        <seg>(Yves Orton)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns true on success,
false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tuvo éxito, sino, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item given BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T234700Z" changeid="explorer">
        <seg>=item given BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do note that the examples have been written by many different authors over
a period of several decades.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004522Z" changeid="explorer">
        <seg>Tenga en cuenta que los ejemplos han sido escritos por muchos autores distintos a lo largo de varias décadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first version of this document appeared on Perl Monks, where several
people had useful suggestions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224404Z" changeid="explorer">
        <seg>La primera versión de este documento se publicó en Perl Monks, donde muchas personas realizaron útiles sugerencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Binary\n&quot; if -B _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Binario\n&quot; if -B _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $variable;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225441Z" changeid="explorer">
        <seg>my $variable;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item split</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item split</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Extending and Embedding Perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003641Z" changeid="explorer">
        <seg>=item I&lt;Extending and Embedding Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item semop KEY,OPSTRING
X&lt;semop&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200443Z" changeid="explorer">
        <seg>=item semop KEY,OPSTRING
X&lt;semop&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and this all reduces to one string internally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y todo esto se reduce a una sola cadena, internamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item split /PATTERN/,EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item split /PATRÓN/,EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a platform independent C&lt;move&gt; function look at the L&lt;File::Copy&gt;
module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una función independiente de la plataforma vea C&lt;move&gt; en el módulo L&lt;File::Copy&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(':', split(/(?=\w)/, 'hi there!'));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(':', split(/(?=\w)/, 'hola por aqui!'));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, evaluates C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, se evalúa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(C&lt;\v&gt;
does have meaning in regular expression patterns in Perl, see L&lt;perlre&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220127Z" changeid="explorer">
        <seg>(C&lt;\v&gt; tiene significado en los patrones de las expresiones regulares en Perl, vea L&lt;perlre&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some people may wish to outlaw barewords entirely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas personas tal vez deseen prohibir palabras sueltas por completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://space.mit.edu/~davis/jed/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://space.mit.edu/~davis/jed/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$obj-&gt;do_something(undef, undef, undef, undef, undef, undef, 1024);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022235Z" changeid="explorer">
        <seg>$obj-&gt;hacer_algo(undef, undef, undef, undef, undef, undef, 1024);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;libnetcfg|libnetcfg&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234318Z" changeid="explorer">
        <seg>=item L&lt;libnetcfg|libnetcfg&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @files = File::Find::Rule-&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T005527Z" changeid="explorer">
        <seg>my @archivos = File::Find::Rule-&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5131delta	Perl changes in version 5.13.1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141453Z" changeid="explorer">
        <seg>perl5131delta	Cambios en la versión 5.13.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, it's just the list argument separator, and inserts
both its arguments into the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, es solo el separador de la lista de argumentos, e inserta sus argumentos en la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlrecharclass/Negation&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220333Z" changeid="explorer">
        <seg>Vea L&lt;perlrecharclass/Negación&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @parameters = @$arrayref[1..$#$arrayref];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @parametros = @$arrayref[1..$#$arrayref];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In particular, calling values() in void context resets
the iterator with no other overhead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(De forma particular, llamando a values() en contexto nulo (void) resetea el iterador sin otro efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Other regexp features</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Otras características de las expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>length pack(&quot;l&quot;), length pack(&quot;l!&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>length pack(&quot;l&quot;), length pack(&quot;l!&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It usually works out better for flow control than in assignments:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230709Z" changeid="explorer">
        <seg>Por lo general, funciona mejor para el control flujo que en las asignaciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we have F&lt;lib/strict.pm&gt; and F&lt;lib/strict.t&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014542Z" changeid="explorer">
        <seg>Por ejemplo, tenemos F&lt;lib/strict.pm&gt; y F&lt;lib/strict.t&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negative values give the Unicode replacement character (chr(0xfffd)),
except under the L&lt;bytes&gt; pragma, where the low eight bits of the value
(truncated to an integer) are used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Valores negativos dan el carácter de reemplazo Unicode (chr(0xfffd)), salvo bajo el pragma L&lt;bytes&gt;, donde se utilizan los ocho bits más bajos del valor (truncado a un entero).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the POSIX module's C&lt;pause&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215808Z" changeid="explorer">
        <seg>Vea también la función C&lt;pause&gt; del módulo POSIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string enclosed by backticks (grave accents) first undergoes
double-quote interpolation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una cadena delimitada por comillas simples invertidas (acentos graves) se somete a una primera interpolación de entrecomillado doble.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; &lt;=&gt; &gt;&gt; X&lt;spaceship&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; &lt;=&gt; &gt;&gt; X&lt;spaceship&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;   sSiIlLqQ   Force big-endian byte-order on the type.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&gt;   sSiIlLqQ   Fuerza un orden de bytes en big-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, functions in Perl that serve as wrappers for system calls (&quot;syscalls&quot;)
of the same name (like chown(2), fork(2), closedir(2), etc.) return
true when they succeed and C&lt;undef&gt; otherwise, as is usually mentioned
in the descriptions below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152042Z" changeid="explorer">
        <seg>En general, funciones en Perl que sirven como envoltorios para llamadas al sistema (&quot;syscalls&quot;) del mismo nombre (como  chown(2), fork(2), closedir(2), etc.) devuelven verdadero cuando tienen éxito y C&lt;undef&gt; en otro caso, como se menciona en las descripciones de más abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Software Foundation; either version 1, or (at your option) any</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Software Foundation; ya sea la versión 1, o (en su opinión) cualquier</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\c[          [5]    control char      (example: chr(27))</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T185818Z" changeid="explorer">
        <seg>\c[		[5]	car. control			(ejemplo: chr(27))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rex = qr/my.STRING/is;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$rex = qr/mi.CADENA/is;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just a personal note:  I want you to know that I create nice things like this
because it pleases the Author of my story.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222712Z" changeid="explorer">
        <seg>Sólo un apunte personal: quiero que sepa que puedo crear cosas bonitas como ésta, ya que agrada al Autor de mi historia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that here C&lt;$1&gt; etc. are
also set, and that this differs from Perl 4's behavior.)  When there are
no parentheses in the pattern, the return value is the list C&lt;(1)&gt; for
success.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tenga en cuenta que aquí C&lt;$1&gt;, etc, también son establecidas, y que esto difiere del comportamiento de Perl 4). Cuando no hay paréntesis en el patrón, el valor de retorno es la lista C&lt;(1)&gt; en caso de éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document gives instructions for building Perl for RISC OS.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento proporciona instrucciones para la construcción de Perl para sistemas operativos RISC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $index (0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $indice (0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moving a file between file systems now preserves the access and
modification time stamps</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031703Z" changeid="explorer">
        <seg>Ahora, mover un archivo entre sistemas de archivos, conserva las fechas de acceso y modificación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The POSIX module (part of the standard perl distribution) implements
ceil(), floor(), and other mathematical and trigonometric functions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo POSIX (parte de la distribución estándar de Perl) implementa ceil(), floor(), y otras funciones matemáticas y trigonométricas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note
that simply using</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el simple uso de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Has the same
effect as</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T010813Z" changeid="explorer">
        <seg>Tiene el mismo efecto que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the value of the
last C&lt;chop&gt; is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo se devuelve el valor del último recorte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my($a, $b, %rest) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my($a, $b, %resto) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the variable was previously declared with C&lt;my&gt;, it uses
that variable instead of the global one, but it's still localized to
the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la variable fue previamente declarada con C&lt;my&gt;, usará esta variable en vez de la global, pero sigue siendo local en el bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { $answer = }; # WRONG</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { $respuesta = }; # MAL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-&gt;                      +          .        search.cpan.org</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224201Z" changeid="explorer">
        <seg>-&gt;                        +          .           search.cpan.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
scalar context, it comes back as a single (potentially multi-line)
string, or undef if the command failed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, se devuelve como una sola cadena de caracteres (con, posiblemente, múltiples líneas dentro), o undef si el comando ha fallado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But if they do not, all
characters will be in either 32- or 64-bit complements, depending on your
architecture.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224145Z" changeid="explorer">
        <seg>Pero si no lo son, todos los caracteres será complemento a 32- o 64-bit, dependiendo de su arquitectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;make test&quot; step runs a Perl Verification Procedure, usually before
installation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225044Z" changeid="explorer">
        <seg>El paso &quot;make test&quot; ejecuta un I&lt;Perl Verification Procedure&gt;, normalmente antes de la instalación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the socket option requested.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Establece la opción de socket solicitada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlrecharclass	Perl regular expression character classes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000327Z" changeid="explorer">
        <seg>perlrecharclass	Clases de caracteres en expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more sophisticated test suites there are Test::More and Test::MockObject.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030718Z" changeid="explorer">
        <seg>Para obtener más bancos de pruebas sofisticadas use Test::More y Test::MockObject.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sentences++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$sentencias++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Test::Harness</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Test::Harness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is due to Haiku
not implementing C&lt;/dev/log&gt; support yet.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se debe a que Haiku aún no implementa soporte para C&lt;/dev/log&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>package main;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>package main;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;\t&quot; x ($tab/8), ' ' x ($tab%8);	# tab over</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;\t&quot; x ($tab/8), ' ' x ($tab%8);	# relleno con tabuladores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191357Z" changeid="explorer">
        <seg>bien</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first version, the one without the indirect object, ran the I&lt;echo&gt;
program, passing it C&lt;&quot;surprise&quot;&gt; an argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La primera versión, sin el objeto indirecto, ejecuta el programa I&lt;echo&gt;, pasándole C&lt;&quot;sorpresa&quot;&gt; como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($@ eq &quot;Unimplemented&quot; ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225302Z" changeid="explorer">
        <seg>if ($@ eq &quot;Unimplemented&quot; ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl 5.7.2, if the first two elements of the list are C&lt;undef&gt;, 
the utime(2) syscall from your C library is called with a null second
argument.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011928Z" changeid="explorer">
        <seg>Desde Perl 5.7.2, si los dos primeros elementos de la lista son C&lt;undef&gt;, se llama a la biblioteca del sistema C utime(2) con un segundo argumento nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;|-&quot;, &quot;tr&quot;, '[a-z]', '[A-Z]');</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T233626Z" changeid="explorer">
        <seg>open(FOO, &quot;|-&quot;, &quot;tr&quot;, '[a-z]', '[A-Z]');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function msgget(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC msgget(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De otra forma</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A BLOCK by itself (labeled or not) is semantically equivalent to a
loop that executes once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un BLOQUE por sí mismo (etiquetado o no) es semánticamente equivalente a un bucle que se ejecuta una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getprotoent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getprotoent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then again, you could always use parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por otra parte, siempre se puede utilizar paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arbitrary URL schemes now allowed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034510Z" changeid="explorer">
        <seg>Ahora se permiten nuevos esquemas URL arbitrarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's C-style C&lt;for&gt; loop works like the corresponding C&lt;while&gt; loop;
that means that this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El estilo de los bucles C&lt;for&gt; del C funcionan igual que el correspondiente bucle C&lt;while&gt;. Es decir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 format</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T015014Z" changeid="explorer">
        <seg>=head2 format</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>V  An unsigned long (32-bit) in &quot;VAX&quot; (little-endian) order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>V  Un largo sin signo (32 bit) en orden &quot;VAX&quot; (little-endian).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that packed floating-point data written on one machine
may not be readable on another, even if both use IEEE floating-point
arithmetic (because the endianness of the memory representation is not part
of the IEEE spec).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que datos empaquetados de punto flotante escritos en una máquina quizás no puedan ser leídos en otra, aunque ambas utilizan aritmética IEEE de punto flotante (porque la ordenación de bytes de la representación en memoria no es parte de la especificación IEEE).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, C&lt;IPC::Semaphore&gt;
documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215602Z" changeid="explorer">
        <seg>Vea también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, y C&lt;IPC::Semaphore&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;perldoc&gt; program gives you access to all the documentation that comes
with Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000109Z" changeid="explorer">
        <seg>El programa F&lt;perldoc&gt; proporciona acceso a toda la documentación incluida en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlartistic	Perl Artistic License</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000819Z" changeid="explorer">
        <seg>perlartistic	Licencia Artistic de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/foo/)       { ... }  # true if $_ contains &quot;foo&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T212748Z" changeid="zipf">
        <seg>if (/foo/)       { ... }  # verdadero si $_ contiene &quot;foo&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Special Topics</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003512Z" changeid="explorer">
        <seg>=head2 Temas especiales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do what you meant properly, you must write:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para hacer correctamente lo que quería decir, debe escribir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($realfilename,$result);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($realnombrearchivo,$resultado);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is intended to mark placeholder code, that is not yet implemented.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T002940Z" changeid="explorer">
        <seg>Su objetivo es marcar una posición de código, que aún no está implementado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8.3 23:59:59 GMT, Wednesday December 31st 2003</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5.8.3 23:59:59 GMT miércoles, 31 de diciembre 2003</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $x;   my $x;	# warns</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040521Z" changeid="explorer">
        <seg>my $x;   my $x;	# avisa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,12, 2) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,12, 2) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section describes the
notion of better/worse for combining operators.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T234632Z" changeid="explorer">
        <seg>Esta sección describe el concepto de mejor/peor para los operadores de combinación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item accept NEWSOCKET,GENERICSOCKET
X&lt;accept&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165436Z" changeid="explorer">
        <seg>=item accept NUEVOSOCKET,SOCKETGENÉRICO
X&lt;accept&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try to document your code and use Pod formatting in a consistent way.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intente documentar su código y usar formateo Pod de una forma consistente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If OFFSET is
past the end of the array, Perl issues a warning, and splices at the
end of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el DESPLAZAMIENTO es más allá del final del array, Perl lanza una advertencia, y extrae al final del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;dbmclose&gt;, C&lt;dbmopen&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;dbmclose&gt;, C&lt;dbmopen&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (TYPE)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item (TYPE)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(C&lt;and&gt;, C&lt;or&gt; and C&lt;not&gt; aren't just in the above table as descriptions
of the operators.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225243Z" changeid="explorer">
        <seg>(En la tabla anterior C&lt;and&gt;, C&lt;or&gt; y C&lt;not&gt; no son solo descripciones de los operadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*)\b(\d+)$</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233813Z" changeid="explorer">
        <seg>(.*)\b(\d+)$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($nfound,$timeleft) = select($rout=$rin, undef, undef, $timeout);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051053Z" changeid="explorer">
        <seg>($nfound,$timeleft) = select($rout=$rin, undef, undef, $timeout);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your module should have a clearly defined scope which is no longer than
a single sentence.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014927Z" changeid="explorer">
        <seg>Su módulo debe tener un ámbito claramente definido que no es más que una sola instrucción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
SEARCHLIST is delimited by bracketing quotes, the REPLACEMENTLIST has
its own pair of quotes, which may or may not be bracketing quotes;
for example, C&lt;tr[aeiouy][yuoiea]&gt; or C&lt;tr(+\-*/)/ABCD/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031846Z" changeid="explorer">
        <seg>Si la LISTA_BÚSQUEDA está delimitada por sus propios delimitadores, la LISTA_REEMPLAZO tiene su propio par de delimitadores, que pueden o no ser los mismos delimitadores que los primeros. Por ejemplo, C&lt;tr[aeiouy][yuoiea]&gt; o C&lt;tr(+\-*/)/ABCD/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = &quot;dlrow ,olleH&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = &quot;odnum ,aloH&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;Quote and Quote-like Operators&quot;&gt; for a list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030501Z" changeid="explorer">
        <seg>Vea L&lt;perlop/&quot;Comillas y Operadores de comillas&quot;&gt; para una lista de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, C&lt;$AoA[2]&gt; is not an
array, but an array ref.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, C&lt;$AoA[2]&gt; no es un array, si no una referencia a un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good example:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015036Z" changeid="explorer">
        <seg>Buen ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{3,}                matches 3 or more of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230631Z" changeid="zipf">
        <seg>{3,}                detecta 3 o más coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Although on older perls,
which don't have support for lexical pragmas, it keeps its global
behaviour.) (Audrey Tang)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005305Z" changeid="explorer">
        <seg>(Aunque en versiones anteriores de perl, que no cuentan con el apoyo de pragmas léxicos, mantiene su comportamiento global.) (Audrey Tang)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;${^CHILD_ERROR_NATIVE}&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T195338Z" changeid="explorer">
        <seg>=head2 C&lt;${^CHILD_ERROR_NATIVE}&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 EBCDIC Platforms</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015125Z" changeid="explorer">
        <seg>=head2 EBCDIC Platforms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n = @$aref - 1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052941Z" changeid="explorer">
        <seg>$n = @$aref - 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;XS::Typemap&gt; upgraded to version 0.02</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041610Z" changeid="explorer">
        <seg>C&lt;XS::Typemap&gt; actualizado a la versión 0.02</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-u  File has setuid bit set.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004748Z" changeid="explorer">
        <seg>-u  Archivo tiene puesto el bit setuid.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl remains fundamentally a dynamically typed language, not
a statically typed one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231219Z" changeid="explorer">
        <seg>En esencia, Perl es un lenguaje de tipos dinámicos, no de tipos estáticos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you actually want the key to be stored in the DBM database
as a C int, you will have to use C&lt;pack&gt; when writing, and C&lt;unpack&gt;
when reading.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T160157Z" changeid="zipf">
        <seg>Si desea almacenarla como un entero de C, debe usar C&lt;pack&gt; al escribir y C&lt;unpack&gt; al leer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are the statistics for Perl 5.005_62 on my system:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020107Z" changeid="explorer">
        <seg>Estas son las estadísticas correspondientes a Perl 5.005_62 en mi sistema:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;PerlIO::scalar&gt; understands C&lt;&lt; $/ = &quot;&quot; &gt;&gt; now</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034100Z" changeid="explorer">
        <seg>C&lt;PerlIO::scalar&gt; ahora entiende C&lt;&lt; $/ = &quot;&quot; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This would be a
problem with autovivified filehandles, but it may be dynamically set to the
format of your choice by assigning the name to the C&lt;$^&gt; variable while
that filehandle is selected.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T025935Z" changeid="explorer">
        <seg>Esto podría ser un problema con identificadores de archivo autovivificados, pero puede ser configurado de forma dinámico con el formato de su elección mediante la asignación del nombre a la variable C&lt;$^&gt; mientras esté seleccionado el identificador de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, there will always be small, focused, special-purpose
languages dedicated to a specific problem domain that are simply more
convenient for certain kinds of problems.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231038Z" changeid="explorer">
        <seg>Sin embargo, siempre habrá lenguajes reducidos de propósito específico orientados a un dominio de un problema concreto, más cómodos para afrontar determinados tipos de problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation tweaks and typo fixes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ajustes y correcciones de errata en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A word boundary (C&lt;\b&gt;) is a spot between two characters
that has a C&lt;\w&gt; on one side of it and a C&lt;\W&gt; on the other side
of it (in either order), counting the imaginary characters off the
beginning and end of the string as matching a C&lt;\W&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un límite de palabra (C&lt;\b&gt;) es un punto que hay entre dos caracteres que tienen un C&lt;\w&gt; a un lado y un C&lt;\W&gt; al otro lado de él (en cualquier orden), contando con los caracteres imaginarios del principio y final de la cadena coincidentes con un C&lt;\W&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#B&gt;',  12;   # prints &quot;&lt;0B1100&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#B&gt;',  12;   # imprime &quot;&lt;0B1100&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preserve the string matched such that ${^PREMATCH}, ${^MATCH}, and
${^POSTMATCH} are available for use after matching.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Preserva la cadena coincidente, de tal manero que ${^PREMATCH}, ${^MATCH} y ${^POSTMATCH} están disponibles para su uso después de la comprobación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Here There Be Pods!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 ¡Aquí estarán los Pods!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl Mongers?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231237Z" changeid="explorer">
        <seg>¿Y Perl Mongers?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C style for loop is rarely needed in Perl since Perl provides
the more friendly list scanning C&lt;foreach&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225152Z" changeid="explorer">
        <seg>El bucle for de C no se suele usar, ya que Perl proporciona una alternativa más sencilla para recorrer listas, el bucle C&lt;foreach&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is portable only when all platforms sharing packed data use the
same binary representation for signed integers; for example, when all
platforms use two's-complement representation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es portátil solo cuando todas las plataformas compartiendo datos empaquetados usa la misma representación binaria de enteros con signo; por ejemplo, cuando todas las plataformas utilizan la representación de complemento a dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Release considerations</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014042Z" changeid="explorer">
        <seg>=head2 Consideraciones del lanzamiento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;Neither POD nor CODE!?&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;Ni POD ni CÓDIGO!?&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Put the opening
parentheses before the operator to separate it from code that follows (this
applies only to operators with higher precedence than unary operators, of
course):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152643Z" changeid="explorer">
        <seg>Poner el paréntesis de apertura antes del operador para separarlo del código que le sigue (esto se aplica únicamente a los operadores con mayor precedencia que los operadores unarios, por supuesto):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($dev,$ino,$mode,$nlink,$uid,$gid);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234245Z" changeid="explorer">
        <seg>my ($dev,$ino,$mode,$nlink,$uid,$gid);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The difference is largely because Perl 5
does not, even internally, have a boolean type.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(La diferencia es incluso mayor, porque Perl 5 no tiene, incluso internamente, un tipo booleano)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chr</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a &quot;postponed&quot; regular subexpression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T181858Z" changeid="explorer">
        <seg>Esta es una subexpresión regular &quot;pospuesta&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At The Second O'Reilly Open Source Software Convention, Larry Wall
announced Perl 6 development would begin in earnest.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110403T225431Z" changeid="explorer">
        <seg>En la Segunda Convención de Software Open Source de O'Reilly, Larry Wall anunció que el desarrollo de Perl 6 iba a empezar en serio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Steve Lidie and Nancy Walsh</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003633Z" changeid="explorer">
        <seg>Steve Lidie y Nancy Walsh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { $answer = $a / $b; }; warn $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { $respuesta = $a / $b; }; warn $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;perlivp&gt; enhancements</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041847Z" changeid="explorer">
        <seg>=head2 Mejoras en C&lt;perlivp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For various reasons, Perl is probably not well-suited for real-time
embedded systems, low-level operating systems development work like
device drivers or context-switching code, complex multi-threaded
shared-memory applications, or extremely large applications.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231209Z" changeid="explorer">
        <seg>Por diversos motivos, es probable que Perl no sea adecuado para sistemas incrustados en tiempo real, trabajo de desarrollo de sistemas operativos a bajo nivel, como controladores de dispositivos o código de cambio de contexto de subprocesos, aplicaciones complejas de memoria compartida y múltiples subprocesos, o aplicaciones extremadamente grandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLASSNAME is the name of a class implementing objects
of correct type.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CLASE es el nombre de la clase que implementa objetos del tipo correcto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getsockname SOCKET
X&lt;getsockname&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173716Z" changeid="explorer">
        <seg>=item getsockname SOCKET
X&lt;getsockname&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T010950Z" changeid="explorer">
        <seg>Sí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless ($return = do $file) {
            warn &quot;couldn't parse $file: $@&quot; if $@;
            warn &quot;couldn't do $file: $!&quot;    unless defined $return;
            warn &quot;couldn't run $file&quot;       unless $return;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044023Z" changeid="explorer">
        <seg>unless ($return = do $file) {
            warn &quot;no puedo analizar $file: $@&quot; if $@;
            warn &quot;no puedo hacer $file: $!&quot;    unless defined $return;
            warn &quot;no puedo ejecutar $file&quot;     unless $return;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/(\d+)/1 + $1/eg;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/(\d+)/1 + $1/eg;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ARGV = map { /\.(gz|Z)$/ ? &quot;gzip -dc &lt; $_ |&quot; : $_ } @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054421Z" changeid="explorer">
        <seg>@ARGV = map { /\.(gz|Z)$/ ? &quot;gzip -dc &lt; $_ |&quot; : $_ } @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Metacharacters</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Metacaracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it is reached, matching
continues in B, which may also backtrack as necessary; however, should B
not match, then no further backtracking will take place, and the pattern
will fail outright at the current starting position.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T011651Z" changeid="explorer">
        <seg>Una vez que se alcanza, la coincidencia continúa en B, que también puede hacer una vuelta atrás cuando sea necesario; sin embargo, si no hubiera coincidencia con B, entonces ya no se llevará a cabo la vuelta atrás, y el patrón fallará de forma absoluta en la actual posición de inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Unsafe signals again available</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T155410Z" changeid="explorer">
        <seg>=head2 Acceso a señales de forma insegura de nuevo disponibles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To help you convert legacy programs to Perl, we've included three
conversion filters:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234142Z" changeid="explorer">
        <seg>Los tres filtros de conversión siguientes generan código Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a handful of remaining test failures on VMS, mostly due to
test fixes and minor module tweaks with too many dependencies to
integrate into this release from the development stream, where they have
all been corrected.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T053415Z" changeid="explorer">
        <seg>Hay un puñado de pruebas fallidas que quedan en VMS, sobre todo debido a la corrección de pruebas y ajustes menores con demasiadas dependencias como para poder integrarse en esta versión de la secuencia de desarrollo, donde todos ellas han sido corregidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>03B1.03C9</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003551Z" changeid="explorer">
        <seg>03B1.03C9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 For Loops
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042052Z" changeid="explorer">
        <seg>=head2 Bucles for
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;''&gt;, C&lt;q//&gt;, C&lt;tr'''&gt;, C&lt;y'''&gt;, the replacement of C&lt;s'''&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item C&lt;''&gt;, C&lt;q//&gt;, C&lt;tr'''&gt;, C&lt;y'''&gt;, y el reemplazo de C&lt;s'''&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Changes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Cambios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq1 - General Questions About Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T195539Z" changeid="explorer">
        <seg>perlfaq1 - Preguntas generales sobre Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior may disappear in future versions of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comportamiento puede desaparecer en futuras versiones de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The L&lt;perlglossary&gt; manpage is a glossary of terms used in the Perl
documentation, technical and otherwise, kindly provided by O'Reilly Media,
Inc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013725Z" changeid="explorer">
        <seg>La página de manual L&lt;perlglossary&gt; es un glosario de términos utilizados en la documentación de Perl, técnicos y otros, amablemente proporcionado por O'Reilly Media, Inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Testing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030342Z" changeid="explorer">
        <seg>=head2 Pruebas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IBM z/OS and other EBCDIC platforms continue to be problematic
regarding Unicode support.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003211Z" changeid="explorer">
        <seg>IBM z/OS y otras plataformas EBCDIC siguen siendo problemáticas en relación con la compatibilidad con Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsource - A guide to the Perl source tree</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T013217Z" changeid="explorer">
        <seg>perlsource - Guía del árbol de código fuente de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operand is
an identifier, a string consisting of a minus sign concatenated
with the identifier is returned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T184238Z" changeid="explorer">
        <seg>Si el operando es un identificador, es devuelta un string formado por un signo menos concatenado con el identificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Fraction         big, unlimited fractions like 9973 / 12967</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035333Z" changeid="explorer">
        <seg>Math::Fraction		grandes e ilimitadas fracciones, como 9973 / 12967</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although these are grouped by family, they all have the precedence
of assignment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque estos están agrupados por familia, todos ellos tienen la precedencia de la asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is the string C&lt;&quot;\0X\0\0YZ&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es la cadena C&lt;&quot;\0X\0\0YZ&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;accept&gt;, C&lt;bind&gt;, C&lt;connect&gt;, C&lt;getpeername&gt;, C&lt;getsockname&gt;,
C&lt;getsockopt&gt;, C&lt;listen&gt;, C&lt;recv&gt;, C&lt;send&gt;, C&lt;setsockopt&gt;, C&lt;shutdown&gt;,
C&lt;socket&gt;, C&lt;socketpair&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202131Z" changeid="explorer">
        <seg>C&lt;accept&gt;, C&lt;bind&gt;, C&lt;connect&gt;, C&lt;getpeername&gt;, C&lt;getsockname&gt;,
C&lt;getsockopt&gt;, C&lt;listen&gt;, C&lt;recv&gt;, C&lt;send&gt;, C&lt;setsockopt&gt;, C&lt;shutdown&gt;,
C&lt;socket&gt;, C&lt;socketpair&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use warnings qw(all);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use warnings qw(all);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to get a month name from a list:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto hace que sea fácil obtener un nombre de mes desde una lista:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also call C&lt;die&gt; with a reference argument, and if this is trapped
within an C&lt;eval&gt;, C&lt;$@&gt; contains that reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede llamar a C&lt;die&gt; con una referencia como argumento, y si éste queda atrapado en un C&lt;eval&gt;, C&lt;$@&gt; contiene esa referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considering that, as of 2006, there are over ten thousand existing
modules in the archive, one probably exists to do nearly anything you
can think of.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230143Z" changeid="explorer">
        <seg>En 2006 ya había más de diez mil módulos en el repositorio, por lo que no es de extrañar que pueda encontrar módulos para casi cualquier tarea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Formats likely
to be of most use are integer-packing ones like C&lt;n&gt; for Java strings,
C&lt;w&gt; for ASN.1 or SNMP, and C&lt;N&gt; for Sun XDR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Formatos de mayor uso son los empaquetados de enteros como C&lt;n&gt; para las cadenas de Java, C&lt;w&gt; de ASN.1 o SNMP, y C&lt;N&gt; de XDR de Sun</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub require {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub require {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Smart matching
is described in L&lt;perlsyn/&quot;Smart matching in detail&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincidencia inteligente se describe en L&lt;perlsyn/&quot;Coincidencia inteligente en detalle&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you have used the Data::Dumper module to
dump data into different files, and then compared the files to see
whether the data has changed, now you will have false positives since
the order in which hashes are dumped will vary.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135459Z" changeid="explorer">
        <seg>Por ejemplo, si ha utilizado el módulo Data::Dumper para volcar los datos en diferentes archivos, y luego comparó los archivos para ver si los datos han cambiado, ahora tendrá falsos positivos ya que el orden en que los hashes se vuelcan pueden variar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;each&gt;, C&lt;values&gt;, and C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T235945Z" changeid="explorer">
        <seg>Vea también C&lt;each&gt;, C&lt;values&gt; y C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;|-&quot;, &quot;tr '[a-z]' '[A-Z]'&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T233604Z" changeid="explorer">
        <seg>open(FOO, &quot;|-&quot;, &quot;tr '[a-z]' '[A-Z]'&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;unpack()&gt; now defaults to unpacking the C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170805Z" changeid="explorer">
        <seg>C&lt;unpack()&gt; ahora, por defecto, desempaqueta C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the second C&lt;\&gt; in C&lt;qq/\c\/&gt; is interpreted as a part
of C&lt;\/&gt;, and the following C&lt;/&gt; is not recognized as a delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, el segundo C&lt;\&gt; en C&lt;qq/\c\/&gt; es interpretado como una parte de C&lt;\/&gt;, y el siguiente C&lt;/&gt; no es reconocido como un delimitador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for basic issues of how Perl parses and compiles itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014622Z" changeid="explorer">
        <seg>Pruebas de problemas básicos relacionados con la manera en que Perl se analiza y compila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For historical reasons, some values work on almost every system
supported by Perl: 0 means read-only, 1 means write-only, and 2
means read/write.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por razones históricas, algunos valores funcionan en casi todos los sistemas soportados por Perl: 0 significa solo lectura, 1 significa sólo escritura y 2 significa lectura y escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus you can use any of the loop control
statements in it to leave or restart the block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013459Z" changeid="explorer">
        <seg>Así que puede usar cualquiera de las instrucciones de control de bucle dentro de él para salir o reiniciarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpod		Perl plain old documentation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000304Z" changeid="explorer">
        <seg>perlpod		Documentación en texto simple (POD)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a side-effect of this, the overloaded-ness of constants now propagates
into eval(&quot;&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200512Z" changeid="explorer">
        <seg>Como un efecto secundario de esto, la sobrecarga de las constantes ahora se propaga en eval(&quot;&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/foo/bar/ le 5;  # &quot;le&quot; infix operator</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213651Z" changeid="explorer">
        <seg>s/foo/bar/ le 5;  # &quot;le&quot; operador infijo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>form that you can possibly imagine, not even excepting</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>forma que pueda posiblemente imaginar, incluyendo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of C&lt;ref&gt; as a C&lt;typeof&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede pensar en C&lt;ref&gt; como un operador C&lt;typeof&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@_) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225550Z" changeid="explorer">
        <seg>foreach (@_) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally the R may be
followed by a number, (which will be true when evaluated when recursing
inside of the appropriate group), or by C&lt;&amp;NAME&gt;, in which case it will
be true only when evaluated during recursion in the named group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T194452Z" changeid="explorer">
        <seg>Además, el R puede ser seguido de un número (que será cierto cuando es evaluado cuando se procesa recursivamente dentro del grupo correspondiente), o por C&lt;&amp;NOMBRE&gt;, en cuyo caso sólo será verdadera cuando sea evaluada durante la recursión en el grupo con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key distinction between systems that need
C&lt;binmode&gt; and those that don't is their text file formats.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La distinción clave entre los sistemas que requieren C&lt;binmode&gt; y los que no, es en sus formatos de archivo de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%4d %s\n&quot;, $hash{$key}, $key;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%4d %s\n&quot;, $hash{$clave}, $clave;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have to re-read this entire section a few times...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234254Z" changeid="explorer">
        <seg>Es posible que tenga que leer esta sección varias veces...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the C&lt;%a&gt; and C&lt;%b&gt;, the short forms of the day of the week
and the month of the year, may not necessarily be three characters wide.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;%a&gt; y C&lt;%b&gt;, las formas cortas del día de la semana y el mes del año, pueden no ser necesariamente de tres caracteres de ancho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Systems
like Unix, Mac OS, and Plan 9, that end lines with a single
character and encode that character in C as C&lt;&quot;\n&quot;&gt; do not
need C&lt;binmode&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los sistemas como Unix, Mac OS, y Plan 9, cuyos finales de línea terminan con un único carácter y codifican ese carácter en C como C&lt;&quot;\n&quot;&gt; no necesitan C&lt;binmode&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator will have the same precedence and associativity as C&lt;||&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014426Z" changeid="explorer">
        <seg>El operador tendrá la misma precedencia y asociatividad que C&lt;||&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the current position for the C&lt;readdir&gt; routine on DIRHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T021013Z" changeid="explorer">
        <seg>Establece la posición actual de la rutina C&lt;readdir&gt; en IDENTIFICADOR_DIR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals are usually delimited by either single or double
quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los literales de cadena se suelen delimitar con comillas simples o dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>r   Return substitution and leave the original string untouched.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T212825Z" changeid="explorer">
        <seg>r	Devuelve la sustitución y deja la cadena original intacta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar
context, returns the number of times the expression was true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el número de veces que la expresión fue verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL for (EXPR; EXPR; EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA for (EXPR; EXPR; EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005643Z" changeid="explorer">
        <seg>=item Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is made equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231623Z" changeid="explorer">
        <seg>es equivalente a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BEGIN failed--compilation aborted at /tmp/a line 1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031740Z" changeid="explorer">
        <seg>BEGIN failed--compilation aborted at /tmp/a line 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The defined test avoids problems where line has a string
value that would be treated as false by Perl, for example a &quot;&quot; or
a &quot;0&quot; with no trailing newline.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La prueba de definición evita problemas donde la línea contiene un valor de cadena que sería tratado como falso por Perl, como por ejemplo, un &quot;&quot; o un &quot;0&quot; sin salto de línea final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>join() could return garbage when the same join() statement was used to
process 8 bit data having earlier processed UTF8 data, due to the flags
on that statement's temporary workspace not being reset correctly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012236Z" changeid="explorer">
        <seg>join() podría devolver basura cuando la misma instrucción join() fue anteriormente usada para procesar datos de 8 bits habiendo procesado anteriormente datos UTF8, debido a que las banderas en ese área de trabajo temporal no eran correctamente reinicializadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new operator, C&lt;...&gt;, nicknamed the Yada Yada operator, has been added.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T002852Z" changeid="explorer">
        <seg>Un nuevo operador, C&lt;...&gt;, apodado el operador Blablablá, ha sido añadido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;default&gt; behaves exactly like C&lt;when(1 == 1)&gt;, which is
to say that it always matches.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;default&gt; se comporta exactamente igual que C&lt;when(1 == 1)&gt;, que es lo mismo que decir que siempre coincide.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/sort&gt; for examples
of how to arrange for an output ordering.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlfunc/sort&gt; para ejemplos de cómo organizar una salida ordenada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-cw&gt; ] [ B&lt;-d&gt;[B&lt;t&gt;][:I&lt;debugger&gt;] ] [ B&lt;-D&gt;[I&lt;number/list&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-cw&gt; ] [ B&lt;-d&gt;[B&lt;t&gt;][:I&lt;debugger&gt;] ] [ B&lt;-D&gt;[I&lt;número/lista&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 ctime  just use                    @INC  include paths</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224352Z" changeid="explorer">
        <seg>10 ctime  ¡use                           @INC  rutas de inclusión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If either operand of scalar &quot;..&quot; is a constant expression,
that operand is considered true if it is equal (C&lt;==&gt;) to the current
input line number (the C&lt;$.&gt; variable).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si alguno de los operandos del escalar &quot;..&quot; es una expresión constante, este operando es considerado cierto si es igual (C&lt;==&gt;) al número de línea actual de la entrada (la variable C&lt;$.&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're confused about why you use an '@' there on a hash slice
instead of a '%', think of it like this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T235138Z" changeid="explorer">
        <seg>Si se siente confuso sobre el porqué usa un '@' en una porción de hash en lugar de un '%', piénselo así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when ('foo' or 'bar') { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215702Z" changeid="explorer">
        <seg>when ('foo' or 'bar') { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On failure, it returns false and sets C&lt;$!&gt;
(errno):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001930Z" changeid="explorer">
        <seg>En caso de error, se devuelve falso y establece C&lt;$!&gt; (errno):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(These used to live in
t/op).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014647Z" changeid="explorer">
        <seg>(antes estaban en t/op).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is subroutine definition, not a real function I&lt;per se&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la definición de subrutina, no una función real I&lt;per se&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -MDateTime -le'print DateTime-&gt;today-&gt;mjd'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>$ perl -MDateTime -le'print DateTime-&gt;today-&gt;mjd'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.1g&gt;', 100;    # prints &quot;&lt;1e+02&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.1g&gt;', 100;    # imprime &quot;&lt;1e+02&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># prints AbelAxedCainPunishedcatchaseddoggonetoxyz</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># prints AbelAxedCainPunishedcatchaseddoggonetoxyz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Obituary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Obituario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See C&lt;sprintf&gt; for an
explanation of the format argument.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T010446Z" changeid="explorer">
        <seg>Vea C&lt;sprintf&gt; para una explicación del argumento de formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if( @array1 ~~ @array2 )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225552Z" changeid="explorer">
        <seg>if( @array1 ~~ @array2 )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef   Any       undefined                !defined($b)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef       Cualquiera indefinido                       !defined($b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some concerns to keep in mind when using an endianness modifier:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175203Z" changeid="explorer">
        <seg>Éstas son algunas de las preocupaciones a tener en cuenta cuando se usa un modificador de ordenación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, a lot of the
quite clunky routines like fsqrt() and flog() are now much much faster.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T174011Z" changeid="explorer">
        <seg>Además, muchas de las rutinas bastante torpes como fsqrt() y flog() son ahora mucho más rápidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If a curly bracket occurs in any other context and does not form part of
a backslashed sequence like C&lt;\x{...}&gt;, it is treated
as a regular character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042830Z" changeid="explorer">
        <seg>(Si aparece una llave en cualquier otro contexto y no forma parte de una secuencia escapada como en C&lt;\x{...}&gt;, es tratada como un carácter normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When complementing strings, if all characters have ordinal values under
256, then their complements will, also.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224100Z" changeid="explorer">
        <seg>Al complementar las cadenas, si todos los caracteres tienen valores ordinales menores de 256, sus complementarios, también lo serán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;splice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;splice&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (%tied_hash) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (%hash_enlazado) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
final match did indeed match C&lt;p&gt;, it's a good bet that you're running a
very old (pre-5.6.0) version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025956Z" changeid="explorer">
        <seg>Si la última coincidencia, es, en su lugar, C&lt;p&gt;, es una buena apuesta de que está ejecutando una versión anterior de Perl (pre-5.6.0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$a ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$a ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, this isn't important because you automatically
get them all anyway.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, esto no es importante, ya que, de todos modos, los obtiene automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%06s&gt;', 12;   # prints &quot;&lt;000012&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%06s&gt;', 12;   # imprime &quot;&lt;000012&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are still some bits and pieces hanging around in here that
need to be moved.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014728Z" changeid="explorer">
        <seg>Aún quedan cosas que deben moverse a otra parte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN: 1-55860-701-3 [1st edition March 2005]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003545Z" changeid="explorer">
        <seg>ISBN: 1-55860-701-3 [1ª edición - Marzo de 2005]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make perl fork() safe even on platforms that don't have pthread_atfork()</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hacer que el fork() de perl sea seguro incluso en plataformas que no tienen pthread_atfork()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item File::Find</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014818Z" changeid="explorer">
        <seg>=item File::Find</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These news matter to you only if you either write XS code or like to
know about or hack Perl internals (using Devel::Peek or any of the
C&lt;B::&gt; modules counts), or like to run Perl with the C&lt;-D&gt; option.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003615Z" changeid="explorer">
        <seg>Estas noticias solamente son importantes para usted si, o escribe código XS o le gustaría saber acerca de o quiere I&lt;hackear&gt; las partes internas Perl (usando Devel::Peek o cualquiera de los módulos C&lt;B::&gt;), o como para ejecutar Perl con la opción C&lt;-D&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...			# code for each line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>...			# código por cada línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tied hashes do not currently return anything useful in scalar context,
for example when used as boolean tests:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T002505Z" changeid="explorer">
        <seg>Actualmente, los hashes enlazados no devuelven nada útil en contexto escalar, por ejemplo cuando se utilizan como pruebas booleanas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to test whether you can write,
either use file tests or try setting a dummy hash entry inside an C&lt;eval&gt; 
to trap the error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere comprobar si puede escribir o no, use test de archivo o intente asignar una entrada hash ficticia dentro de un C&lt;eval&gt;, para atrapar el error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has been added to the core (version 2.020).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152253Z" changeid="explorer">
        <seg>Fue añadido al núcleo principal (versión 2.020).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># These evaluate exit before doing the print:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Evalúan exit antes de hacer el print:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And still another case is that you may want to call C&lt;srand()&gt;
after a C&lt;fork()&gt; to avoid child processes sharing the same seed value as the
parent (and consequently each other).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183412Z" changeid="explorer">
        <seg>Y otro caso es que puede llamar a C&lt;srand()&gt; después de un C&lt;fork()&gt; para evitar que los procesos hijos compartan el mismo valor de inicialización como el padre (y por lo tanto entre sí).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $byte = chr(192);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235737Z" changeid="explorer">
        <seg>my $byte = chr(192);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to generate a suitable uconfig.h</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223530Z" changeid="explorer">
        <seg>para generar un uconfig.h adecuado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eof;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eof;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, once the C&lt;(*COMMIT)&gt; has been entered, and if the pattern
does not match, the regex engine will not try any further matching on the
rest of the string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T143602Z" changeid="explorer">
        <seg>En otras palabras, una vez que encontramos C&lt;(*COMMIT)&gt;, y si el patrón no coincide, el motor de expresiones regulares no tratará de encontrar nada más en el resto de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation improved</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mejor documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225532Z" changeid="explorer">
        <seg>while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is what happens at the end of execution: Perl destroys all data
structures, including user data.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135750Z" changeid="explorer">
        <seg>Eso es lo que ocurre al final de la ejecución: Perl destruye todas las estructuras de datos, incluyendo los datos del usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@files = glob(&quot;$dir/*.[ch]&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@archivos = glob(&quot;$dir/*.[ch]&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Where can I buy a commercial version of perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231008Z" changeid="explorer">
        <seg>=head2 ¿Dónde puedo adquirir una versión comercial de perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates EXPR and exits immediately with that value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa EXPR y sale inmediatamente con este valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should also always run under C&lt;use strict&gt; or know the
reason why not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debería siempre también correr con C&lt;use strict&gt; o conocer la razón de porqué no hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it isn't a goto in the normal sense at all, and
doesn't have the stigma associated with other gotos.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De hecho, no es un goto en el sentido normal y no tiene el estigma asociado con los otros gotos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item length</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item length</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you get complaints about so_locations then search in the file
hints/irix_6.sh for &quot;lddflags&quot; and do the suggested adjustments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003930Z" changeid="explorer">
        <seg>Si recibe problemas sobre so_locations entonces busque en el archivo hints/irix_6.sh por &quot;lddflags&quot; y haga los ajustes sugeridos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$semop = pack(&quot;s!3&quot;, $semnum, -1, 0);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$semop = pack(&quot;s!3&quot;, $semnum, -1, 0);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 2) = 2   ==         32 00000100000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 2) = 2   ==         32 00000100000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, as in perl 5.10.0, C&lt;when (1..10)&gt; will not work to test
whether a given value is an integer between 1 and 10; you should use
C&lt;when ([1..10])&gt; instead (note the array reference).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233327Z" changeid="explorer">
        <seg>Tenga en cuenta que, como en Perl 5.10.0, C&lt;when (1..10)&gt; no va servirá para probar si un valor es un número entero entre 1 y 10, así que en su lugar debería usar C&lt;when ([1..10])&gt; (nótese la referencia al array).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># This is the UTF-8 encoding of the string in the previous example</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Esta es la codificación UTF-8 de la cadena del ejemplo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 4</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000706Z" changeid="explorer">
        <seg>=item 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 5</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000728Z" changeid="explorer">
        <seg>=item 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general rule is
that the identifier must be a string literal.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La regla general es que el identificador debe ser una cadena literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item B</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014812Z" changeid="explorer">
        <seg>=item B</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[xyz];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[xyz];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlref		Perl references, the rest of the story</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000333Z" changeid="explorer">
        <seg>perlref		Referencias: el resto de la historia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We recommend that you use void context C&lt;keys @array&gt; for this, but reasoned
that it taking C&lt;values @array&gt; out would require more documentation than
leaving it in.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Le recomendamos que utilice el contexto vacío C&lt;keys @array&gt; para esto, pero razonando que hacer C&lt;values @array&gt; exigirá más comentarios que dejarlo tal cual)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On Windows Borland's C compiler can now compile perl with PerlIO and/or
USE_LARGE_FILES enabled.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T105531Z" changeid="explorer">
        <seg>El compilador de Borland C en Windows ahora puede compilar perl con PerlIO y/o tener activado USE_LARGE_FILES.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New &quot;Tied variable freed while still in use&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002822Z" changeid="explorer">
        <seg>=head2 Nuevo &quot;I&lt;Tied variable freed while still in use&gt;&quot; (Variable enlazada liberada mientras todavía está en uso)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does not automatically flush output handles on some platforms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015534Z" changeid="explorer">
        <seg>En algunas plataformas no se realiza un vaciado de los identificadores de archivo de salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of a camel with
the topic of Perl is a trademark of O'Reilly and Associates Inc., and is used
with their permission (ie distribution of the source, compiling a Windows
executable from it, and using that executable locally).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T105823Z" changeid="explorer">
        <seg>El uso de un camello con el motivo de Perl es una marca registrada de O'Reilly and Associates Inc., y es utilizado con su permiso (es decir, la distribución del código fuente, la compilación de un ejecutable en Windows a partir de él, y ​​el uso de ese ejecutable a nivel local).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if you aren't in doubt, consider the mental welfare of the person
who has to maintain the code after you, and who will probably put
parentheses in the wrong place.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso si usted no tiene dudas, considerar el bienestar mental de la persona que tenga que mantener el código después de usted, y quien seguramente pondrá los paréntesis en el lugar equivocado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For new projects the core perl team would strongly recommend that you use
dedicated, single purpose security tools such as C&lt;sudo&gt; in preference to
C&lt;suidperl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T104234Z" changeid="explorer">
        <seg>Para nuevos proyectos el equipo básico de desarrollo perl recomienda, encarecidamente, que utilice herramientas específicas para el propósito de seguridad, tales como C&lt;sudo&gt;, en lugar de C&lt;suidperl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;\Y|$re\Y|&gt; the variable
part of this regular expression needs to be converted explicitly
(but only if the special meaning of C&lt;\Y|&gt; should be enabled inside $re):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002830Z" changeid="explorer">
        <seg>Para C&lt;\Y|$re\Y|&gt; la parte variable de esta expresión regular es necesario convertirla de forma explícita (pero sólo si el significado especial de C&lt;\Y|&gt; debe estar habilitado en el interior de $re):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item *</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are traditionally valued 1, 2, 8 and 4, but
you can use the symbolic names if you import them from the L&lt;Fcntl&gt; module,
either individually, or as a group using the C&lt;:flock&gt; tag.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T234112Z" changeid="explorer">
        <seg>Estas constantes tienen, tradicionalmente, los valores 1, 2, 8 y 4, pero puede usar los nombres simbólicos si los importa con el módulo L&lt;Fcntl&gt;, tanto de forma individual o como un grupo usando la marca C&lt;:flock&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;scalar&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;scalar&gt; X&lt;escalar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you want the pattern to use the initial values of the variables
regardless of whether they change or not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T204649Z" changeid="explorer">
        <seg>desea que el patrón use los valores iniciales de las variables, independientemente de si van a cambiar o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime(time);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050252Z" changeid="explorer">
        <seg>($seg,$min,$hora,$mdia,$mes,$anno,$sdia,$ydia,$esdst) =
					    localtime(time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>% perl5.12 -E 'say scalar gmtime( 0x9FFF_FFFFFFFF )'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225528Z" changeid="explorer">
        <seg>% perl5.12 -E 'say scalar gmtime( 0x9FFF_FFFFFFFF )'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} map { [$_, /=(\d+)/, uc($_)] } @old;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} map { [$_, /=(\d+)/, uc($_)] } @viejo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-I&gt;I&lt;dir&gt; ] [ B&lt;-m&gt;[B&lt;-&gt;]I&lt;module&gt; ] [ B&lt;-M&gt;[B&lt;-&gt;]I&lt;'module...'&gt; ] [ B&lt;-f&gt; ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-I&gt;I&lt;dir&gt; ] [ B&lt;-m&gt;[B&lt;-&gt;]I&lt;módulo&gt; ] [ B&lt;-M&gt;[B&lt;-&gt;]I&lt;'módulo...'&gt; ] [ B&lt;-f&gt; ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is you, if you're thinking about copying or distributing this Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es usted, si usted está pensando en copiar o distribuir este paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user types in a password that is
crypt()'d with the same salt as the stored digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El usuario escribe la contraseña que es en-crypt()-tada con el mismo salto con el que fue almacenado el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;Oh look, an exception--whatever.&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225349Z" changeid="explorer">
        <seg>say &quot;¡Oh, mira!, una excepción lo-que-sea.&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item substr EXPR,OFFSET</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item substr EXPR,DESPLAZAMIENTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Absolute numbered
groups were referred to using C&lt;\1&gt;,
C&lt;\2&gt;, etc., and this notation is still
accepted (and likely always will be).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T185353Z" changeid="explorer">
        <seg>Los grupos numerados de forma absoluta eran de la forma C&lt;\1&gt;, C&lt;\2&gt;, etc., y esta notación todavía está aceptada (y probablemente siempre lo será).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the string
describing the equivalent prototype is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, se devuelve la cadena que describe el prototipo equivalente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Lincoln Stein</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003557Z" changeid="explorer">
        <seg>Lincoln Stein</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $&quot; = &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225457Z" changeid="explorer">
        <seg>local $&quot; = &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak reference deletion remains I&lt;O(n)&gt;, but if deletion only
happens at program exit, it may be skipped completely.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T042254Z" changeid="explorer">
        <seg>El borrado de referencias débiles sigue siendo I&lt;O(n)&gt;, pero si el borrado solo sucede en la salida del programa, puede ser omitido por completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo,  8,  8) = 0x50;   # 'PerlPerlP'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($foo,  8,  8) = 0x50;   # 'PerlPerlP'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL
X&lt;setsockopt&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200553Z" changeid="explorer">
        <seg>=item setsockopt SOCKET,NIVEL,OPCIÓN_NOMBRE,OPCIÓN_VALOR
X&lt;setsockopt&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Capture groups
contained by the pattern will have the value as determined by the
outermost recursion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T202407Z" changeid="explorer">
        <seg>Los grupos de captura que contengan el patrón tendrán el valor determinado por la recursividad más externa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %hash   = map { $_, 1 } @array;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225547Z" changeid="explorer">
        <seg>my %hash   = map { $_, 1 } @array;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any list operator (print(), etc.) or any unary operator (chdir(), etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si cualquier operador de lista (print(), etc) o cualquier otro operador unario (chdir(), etc) es seguido por un paréntesis de apertura como el siguiente token, el operador y los argumentos entre paréntesis se considera que son de mayor prioridad, como en una llamada a una función normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VERSION may be either a numeric argument such as 5.006, which will be
compared to C&lt;$]&gt;, or a literal of the form v5.6.1, which will be compared
to C&lt;$^V&gt; (aka $PERL_VERSION).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VERSIÓN puede ser un argumento numérico, como 5.006, que será comparado con C&lt;$]&gt;, o un literal de la forma v5.6.1, que será comparado con C&lt;$^V&gt; (alias de $PERL_VERSION).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is not
the case; supposing it is, say telcoUTS, create a script, uts/uname
(i.e. uname, in the subdirectory &quot;uts&quot; of the main Perl source dir):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214109Z" changeid="explorer">
        <seg>Si este no es el caso, suponiendo que fuera, digamos telcoUTS, cree un script, uts/uname (es decir, uname en el subdirectorio &quot;uts&quot; del directorio principal de Perl):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because we don't
have special variable types, and Perl needs to know whether to sort
numerically (where 99 is less than 100) or alphabetically (where 100 comes
before 99).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225239Z" changeid="explorer">
        <seg>Porque Perl no distingue el tipo del contenido de las variables y tiene que determinar si debe ordenar numéricamente (99 menor que 100) o alfabéticamente (100 es anterior a 99).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For WHENCE, you may also use the constants C&lt;SEEK_SET&gt;, C&lt;SEEK_CUR&gt;,
and C&lt;SEEK_END&gt; (start of the file, current position, end of the file)
from the Fcntl module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T023057Z" changeid="explorer">
        <seg>Para DÓNDE puede usar las constantes C&lt;SEEK_SET&gt;, C&lt;SEEK_CUR&gt;, y C&lt;SEEK_END&gt; (inicio de archivo, posición actual, y fin de archivo) del módulo L&lt;Fcntl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = '1234';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$x = '1234';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;&lt; &lt;=&gt; &gt;&gt; returns C&lt;undef&gt; when either operand is C&lt;NaN&gt;
(not-a-number), and laso because C&lt;sort&gt; raises an exception unless the
result of a comparison is defined, be careful when sorting with a
comparison function like C&lt;&lt; $a &lt;=&gt; $b &gt;&gt; any lists that might contain a
C&lt;NaN&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014531Z" changeid="explorer">
        <seg>Dado que C&lt;&lt; &lt;=&gt; &gt;&gt; devuelve C&lt;undef&gt; cuando alguno de los operandos es C&lt;NaN&gt; (I&lt;not-a-number&gt;, no es un número), y porque también C&lt;sort&gt; lanza una excepción a menos que el resultado de la comparación esté definido, tenga cuidado al ordenar con una función de comparación como C&lt;&lt; $a &lt;=&gt; $b &gt;&gt; cualquier lista que pueda contener un C&lt;NaN&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No knowledge of XS is necessary.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234609Z" changeid="explorer">
        <seg>Para ello no tiene que saber cómo funciona XS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Password: &quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Contraseña: &quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An
exception is raised if VERSION is greater than the version of the
current Perl interpreter; Perl will not attempt to parse the rest of the
file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se genera una excepción si la VERSIÓN es mayor que la versión del intérprete actual de Perl; Perl no tratará de analizar el resto del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All documentation
of this version of Perl therefore refers to &quot;layers&quot; rather than to
&quot;disciplines&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toda documentación desde esta versión de Perl se refiere a &quot;capas&quot; en vez de a &quot;disciplinas&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On Cygwin we now strip the last number from the DLL.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153108Z" changeid="explorer">
        <seg>En Cygwin ahora quitamos el último número de la DLL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's psychology....</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T051833Z" changeid="explorer">
        <seg>Esa es la psicología...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}gx;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225537Z" changeid="explorer">
        <seg>}gx;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time only two filters have been used; we only need to manipulate
the contents of the key, so it wasn't necessary to install any value
filters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111003T121709Z" changeid="zipf">
        <seg>En este caso no se han utilizado más que dos filtros; solo hay que manipular el contenido de la clave, por lo que no es necesario instalar ningún filtro de valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, each converted value looks
like its machine-level representation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente, cada valor convertido se parece a su representación a nivel de máquina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @ints;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>my @ints;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item B&lt;filter_fetch_key&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190456Z" changeid="zipf">
        <seg>=item B&lt;filter_fetch_key&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With certain HP C compiler releases (e.g. B.11.11.02) you will
get many warnings like this (lines wrapped for easier reading):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003659Z" changeid="explorer">
        <seg>Con ciertas versiones del compilador de C de HP (por ejemplo, B.11.11.02) obtendrá muchas advertencias como esta (líneas ajustadas para facilitar la lectura):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match 0 or more times, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide con 0 o más veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$/ = &quot;\n&quot;;        # put back to normal input delimiter</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$/ = &quot;\n&quot;;           # volvemos al delimitador de entrada normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such use shall not be
construed as a distribution of this Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal uso no debe interpretarse como una distribución de este Paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsec&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001658Z" changeid="explorer">
        <seg>Vea L&lt;perlsec&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@part = @{ $AoA[4] } [ 7..12 ];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194737Z" changeid="explorer">
        <seg>@part = @{ $AoA[4] } [ 7..12 ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3 nlink    number of (hard) links to the file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3 nlink    número de enlaces (duros) al archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Same as C&lt;y///&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Igual que el C&lt;y///&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This file contains instructions how to build Perl for Haiku and lists
known problems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este archivo contiene instrucciones de cómo construir Perl para Haiku y listas de problemas conocidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$success = 1, last if /$pat/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$exito = 1, last if /$pat/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cygwin</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015358Z" changeid="explorer">
        <seg>Cygwin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;Devel::DProf&gt;
for more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231935Z" changeid="explorer">
        <seg>Consulte L&lt;Devel::DProf&gt; para obtener más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or maybe even this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193925Z" changeid="explorer">
        <seg>o tal vez incluso así.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This subroutine is called as above, but the first parameter is
the array reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta subrutina se llama como antes, pero el primer parámetro es la referencia al array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several memory leaks associated with variables shared between threads
have been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Varias agotamientos de memoria, asociados con variables compartidas entre hilos han sido corregidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x &amp; $y == 0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015503Z" changeid="explorer">
        <seg>$x &amp; $y == 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Sun systems, SunFreeware.com provides binaries of most popular
applications, including compilers and Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225835Z" changeid="explorer">
        <seg>Para sistemas Sun, SunFreeware.com proporciona binarios de las aplicaciones más populares, incluidos compiladores y los binarios de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$c = $d unless defined $c;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015148Z" changeid="explorer">
        <seg>$c = $d unless defined $c;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last LINE if $foo;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last LINEA if $foo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add -Wall in cflags when compiling with gcc to weed out dubious
C practices</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadir -Wall en cflags cuando se compila con gcc para eliminar prácticas dudosas de C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Do one thing and do it well</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014803Z" changeid="explorer">
        <seg>=head2 Haga una cosa y hágala bien</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function should have been named wantlist() instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función debería haber sido nombrada wantlist().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes C&lt;if&gt;, basic
file reads and writes, simple regexes, etc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014558Z" changeid="explorer">
        <seg>Incluyen pruebas de C&lt;if&gt;, operaciones básicas de lectura y escritura, expresiones regulares sencillas, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the time, C&lt;when(EXPR)&gt; is treated as an implicit smart match of
C&lt;$_&gt;, i.e. C&lt;$_ ~~ EXPR&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayor parte de los casos, C&lt;when(EXPR)&gt; es tratado como una coincidencia inteligente implícita de C&lt;$_&gt;, es decir, C&lt;$_ ~~ EXPR&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://open-perl-ide.sourceforge.net/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>http://open-perl-ide.sourceforge.net/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing, but less efficient</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, pero menos eficiente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll assume an @AoA
variable as before.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194658Z" changeid="explorer">
        <seg>Vamos a suponer una variable @AoA, como antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from sort&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>desde sort&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item g and c
X&lt;/g&gt; X&lt;/c&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222841Z" changeid="explorer">
        <seg>=item g y c
X&lt;/g&gt; X&lt;/c&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The C&lt;...&gt; operator</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T002819Z" changeid="explorer">
        <seg>=head2 El operador C&lt;...&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mac OS X now installs with Perl version number embedded in
installation directory names for easier upgrading of user-compiled
Perl, and the installation directories in general are more standard.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T183352Z" changeid="explorer">
        <seg>Mac OS X ahora se instala con el número de versión de Perl incrustado en los nombres de directorio de la instalación para facilitar la actualización por parte del usuario que compiló Perl, y los directorios de instalación, en general, son más estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many minor bugs have been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T102457Z" changeid="explorer">
        <seg>Muchos pequeños errores han sido corregidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously, the C code implementing $^E
did not preserve C&lt;errno&gt;, so reading $^E could cause C&lt;errno&gt; and therefore
C&lt;$!&gt; to change unexpectedly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Anteriormente, el código en C que implementaba $^E no preservaba C&lt;errno&gt;, por lo que la lectura de $^E podría causar que C&lt;errno&gt; y, por lo tanto, C&lt;$!&gt; cambiaran de forma inesperada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run Configure with -Duseithreads which will configure Perl with
the Perl 5.8.0 &quot;interpreter threads&quot;, see L&lt;threads&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220639Z" changeid="explorer">
        <seg>Ejecute Configure con -Duseithreads que configurará Perl con hilos de ejecución Perl 5.8.0 a nivel de intérprete; vea L&lt;threads&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item goto EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item goto EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most likely cause
of this was identified and fixed by Nicholas Clark.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044938Z" changeid="explorer">
        <seg>La causa más probable de ello fue identificado y solucionado por Nicholas Clark.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt; on a C&lt;()&gt; group, this affects
all types inside the group that accept byte-order modifiers,
including all subgroups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt; en un grupo C&lt;()&gt;, afecta a todos los tipos dentro del grupo que acepten a los modificadores de ordenación de bytes, incluyendo a todos los subgrupos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is irrelevant:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T001249Z" changeid="zipf">
        <seg>El espacio en blanco no es significativo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>got &lt;d is under the bar in the &gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T155217Z" changeid="explorer">
        <seg>obtiene &lt;, al mediodía, se come, y en el &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and call it with C&lt;perl dangerous.pl 'rm -rfv *|'&gt;, it actually opens a
pipe, executes the C&lt;rm&gt; command and reads C&lt;rm&gt;'s output from that pipe.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y lo llama con C&lt;perl peligroso.pl 'rm -rfv *|'&gt;, realmente abre una tubería, ejecuta el comando C&lt;rm&gt; y lee la salida de C&lt;rm&gt; desde esa tubería.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A major release is one in which most of
the functionality has changed, or in which major new functionality is
added.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025234Z" changeid="explorer">
        <seg>Una versión principal es aquella en la que la mayor parte de la funcionalidad ha cambiado, o en los que se ha añadido una nueva funcionalidad importante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} else {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that, for the superuser on the local filesystems, the C&lt;-r&gt;,
C&lt;-R&gt;, C&lt;-w&gt;, and C&lt;-W&gt; tests always return 1, and C&lt;-x&gt; and C&lt;-X&gt; return 1
if any execute bit is set in the mode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También note que, para el superusuario en el sistema de archivos local, los test C&lt;-r&gt;, C&lt;-R&gt;, C&lt;-w&gt; y C&lt;-W&gt; siempre devuelven 1, y C&lt;-x&gt; y C&lt;-X&gt; devuelven 1 si cualquier bit de ejecución está puesto en el modo del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE:&gt; The behaviour of a C&lt;my&gt; statement modified with a statement
modifier conditional or loop construct (e.g. C&lt;my $x if ...&gt;) is
B&lt;undefined&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013221Z" changeid="explorer">
        <seg>B&lt;NOTA:&gt; El comportamiento de una instrucción C&lt;my&gt; modificada con una instrucción de modificador condicional o construcción de bucle (p.e. C&lt;my $x if ...&gt;) es B&lt;indefinido&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;overload&gt;, L&lt;perlop&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234148Z" changeid="explorer">
        <seg>L&lt;overload&gt;, L&lt;perlop&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlintro		Perl introduction for beginners</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000148Z" changeid="explorer">
        <seg>perlintro		Introducción a Perl para principiantes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.8.5 release and
the 5.8.6 release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe las diferencias entre la versión 5.8.5 y la versión 5.8.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may be more
by the time you read this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230333Z" changeid="explorer">
        <seg>Es posible que cuando lea este documento ya existan otros nuevos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, some Perl
programmers prefer to avoid them altogether.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231924Z" changeid="explorer">
        <seg>Como consecuencia, algunos programadores de Perl prefieren evitarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$temp = join($&quot;, @ARGV);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$temporal = join($&quot;, @ARGV);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=for cynics And how many perl 5.8.x versions can I release ahead of Vista?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041515Z" changeid="explorer">
        <seg>=for cínicos ¿Cuántas versiones de perl 5.8.x puedo lanzar antes de Vista?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perl581delta/&quot;Future Directions&quot;&gt; for more soothsaying.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perl581delta/&quot;Direcciones futuras&quot;&gt; para tener una mayor perspectiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*d&gt;', -1, 0;   # prints &quot;&lt;0&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*d&gt;', -1, 0;   # imprime &quot;&lt;0&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If ARRAY is omitted, shifts the
C&lt;@_&gt; array within the lexical scope of subroutines and formats, and the
C&lt;@ARGV&gt; array outside a subroutine and also within the lexical scopes
established by the C&lt;eval STRING&gt;, C&lt;BEGIN {}&gt;, C&lt;INIT {}&gt;, C&lt;CHECK {}&gt;,
C&lt;UNITCHECK {}&gt;, and C&lt;END {}&gt; constructs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013858Z" changeid="explorer">
        <seg>Si se omite ARRAY, se desplaza el array C&lt;@_&gt; dentro del ámbito léxico de subrutinas y formatos, y el array C&lt;@ARGV&gt; si está fuera de una subrutina y también dentro de los ámbitos léxicos establecidos por construcciones como C&lt;eval CADENA&gt;, C&lt;BEGIN {}&gt;, C&lt;INIT {}&gt;, C&lt;CHECK {}&gt;, C&lt;UNITCHECK {}&gt; y C&lt;END {}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlmod&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215211Z" changeid="explorer">
        <seg>Vea L&lt;perlmod&gt; para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
ARG part of the pattern was omitted, then C&lt;$REGERROR&gt; will be set to the
name of the last C&lt;(*MARK:NAME)&gt; pattern executed, or to TRUE if there was
none.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T012853Z" changeid="explorer">
        <seg>Si la parte ARG del patrón es omitida, entonces C&lt;$REGERROR&gt; se establecerá al nombre del último patrón C&lt;(*MARK:NOMBRE)&gt; ejecutado, o a TRUE si no había ninguno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly 5.8.5's freeze will be at
the end of June, with release by mid July.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, la congelación de 5.8.5 será a finales de junio, con el lanzamiento a mediados de julio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use wait in your handler for $SIG{CHLD} it may accidentally for the
child created by qx() or system().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183902Z" changeid="explorer">
        <seg>Si utiliza wait en su controlador de $SIG{CHLD} puede, accidentalmente, hacer esperar por el hijo creado por qx() o system().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this automatically
filters compressed arguments through B&lt;gzip&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, esto filtrará automáticamente los argumentos comprimidos a través de B&lt;gzip&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For WHENCE you may use the constants C&lt;SEEK_SET&gt;,
C&lt;SEEK_CUR&gt;, and C&lt;SEEK_END&gt; (start of the file, current position, end
of the file) from the L&lt;Fcntl&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013145Z" changeid="explorer">
        <seg>Para DÓNDE puede usar las constantes C&lt;SEEK_SET&gt;, C&lt;SEEK_CUR&gt; y C&lt;SEEK_END&gt; (inicio del archivo, posición actual y fin de archivo) desde el módulo L&lt;Fcntl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may prefer to use the C&lt;each&gt;
function to iterate over large DBM files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede preferir usar la función C&lt;each&gt; para iterar sobre archivos DBM grandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get at hash elements:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234422Z" changeid="zipf">
        <seg>Para obtener los elementos de un hash:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Is Perl difficult to learn?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230253Z" changeid="explorer">
        <seg>=head2 ¿Es difícil aprender a programar en Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See the precedence table in L&lt;perlop&gt;.)  List
operators take more than one argument, while unary operators can never
take more than one argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver la tabla de precedencia en L&lt;perlop&gt;.)  Los operadores de listas toman más de un argumento, mientras que los operadores unarios nunca toman más de un argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Regular Expressions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Expresiones Regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To read both a command's STDOUT and its STDERR separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004254Z" changeid="explorer">
        <seg>Leer tanto el STDOUT como el STDERR de un comando, pero separadamente, es más fácil hacerlos redireccionar separadamente a archivos, y luego leer esos archivos cuando el programa termine:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;kill&gt; is now fatal when called on non-numeric process identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153328Z" changeid="explorer">
        <seg>C&lt;kill&gt; ahora es fatal cuando es llamado en identificadores de proceso que no son numéricos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Reinventing the wheel</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031136Z" changeid="explorer">
        <seg>=head2 Reinventando la rueda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/cmd/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014605Z" changeid="explorer">
        <seg>=item * F&lt;t/cmd/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directory is for dual-life modules where the blead source is
canonical.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014432Z" changeid="explorer">
        <seg>Este directorio contiene módulos de evolución dual en los que la versión canónica es la del código fuente de la rama B&lt;blead&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^\s+|\s+$//g;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225537Z" changeid="explorer">
        <seg>s/^\s+|\s+$//g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the final match matched C&lt;q&gt; instead of C&lt;p&gt;, which a match
without the C&lt;\G&gt; anchor would have done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Observe que el último emparejamiento es C&lt;q&gt; en vez de C&lt;p&gt;, que una coincidencia sin el anclaje C&lt;\G&gt; habría hecho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two additional lines request from perl to catch various common
problems in your code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224706Z" changeid="explorer">
        <seg>Estas dos líneas adicionales ordenan a perl que detecte diversos problemas comunes en el código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Information still relevant has been moved to L&lt;perlrepository&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152623Z" changeid="explorer">
        <seg>La información que sigue siendo relevante ha sido movida a L&lt;perlrepository&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(':', split(/ */, 'hi there')), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(':', split(/ */, 'hola por aqui')), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Otherwise, If EXPR has the UTF8 flag set</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174629Z" changeid="explorer">
        <seg>=item De lo contrario, si EXPR tiene la bandera UTF8 puesta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;unless&gt; is the opposite, it executes the statement I&lt;unless&gt;
the condition is true (i.e., if the condition is false).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013035Z" changeid="explorer">
        <seg>C&lt;unless&gt; es el opuesto, ejecuta la instrucción si la condición I&lt;no es&gt; verdadera (e.d., si la condición es falsa).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item cos</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item cos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect of C&lt;splice&gt; is considered highly experimental.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181352Z" changeid="explorer">
        <seg>Este aspecto de C&lt;splice&gt; es considerado altamente experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A later C&lt;(*SKIP)&gt; pattern will then skip
forward to that point if backtracked into on failure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T114846Z" changeid="explorer">
        <seg>Un patrón C&lt;(*SKIP)&gt; consiguiente saltará entonces a este punto, si hace una vuelta atrás a causa de un fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\w        [3]  Match a &quot;word&quot; character (alphanumeric plus &quot;_&quot;, plus
                   other connector punctuation chars plus Unicode
                   marks)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T044439Z" changeid="explorer">
        <seg>\w        [3]  Coincide con un carácter &quot;palabra&quot; (alfanumérico más &quot;_&quot;, más
                   otros caract. de puntuación de continuación, más marcas
                   Unicode)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item length EXPR
X&lt;length&gt; X&lt;size&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175353Z" changeid="explorer">
        <seg>=item length EXPR
X&lt;length&gt; X&lt;size&gt; X&lt;longitud&gt; X&lt;tamaño&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chris Nandor E&lt;lt&gt;pudge@pobox.comE&lt;gt&gt;
continued development and maintenance for the duration of the port's life.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Chris Nandor E&lt;lt&gt;pudge@pobox.comE&lt;gt&gt; continuó el desarrollo y mantenimiento durante la vida útil de esta versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is
now fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto ha sido arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be sure to default all these options
to the commonest use.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023744Z" changeid="explorer">
        <seg>Asegúrese de que todas estas opciones estén puestas, por defecto, para el uso más común.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note: If your rand function consistently returns numbers that are too
large or too small, then your version of Perl was probably compiled
with the wrong number of RANDBITS.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Nota: si su función rand devuelve constantemente números demasiado grandes o demasiado pequeños, entonces su versión de Perl fue, probablemente, compilada con un número incorrecto de RANDBITS).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;Reasonable copying fee&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Cuota razonable por las copias&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading $^E now preserves $!.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Leyendo $^E ahora preserva $!.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot;Hello, world\n&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233857Z" changeid="zipf">
        <seg>print(&quot;Hola a todos\n&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item p</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item p</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item s</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item s</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item x</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is just like C's comma operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es igual que el operador coma del C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;The Third Element is&quot;, $myarray[2], &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El tercer elemento es&quot;, $miarray[2], &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perl589delta&gt;
for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014003Z" changeid="explorer">
        <seg>Vea L&lt;perl589delta&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What is a JAPH?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231928Z" changeid="explorer">
        <seg>=head2 ¿Qué es un JAPH?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item m</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item m</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item do SUBROUTINE(LIST)
X&lt;do&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171435Z" changeid="explorer">
        <seg>=item do SUBRUTINA(LISTA)
X&lt;do&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%s    a string</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%s    una cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is still possible to backtrack past the construct, but not
into it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213732Z" changeid="explorer">
        <seg>Todavía es posible dar marcha atrás más allá de la construcción, pero no dentro de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item i</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optimiser on HP-UX 11.23 (Itanium 2) is currently partly disabled (scaled
down to +O1) when using HP C-ANSI-C; the cause of problems at higher
optimisation levels is still unclear.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T053131Z" changeid="explorer">
        <seg>El optimizador en HP-UX 11.23 (Itanium 2) está ahora, en parte, desactivado (reducido a +O1) cuando se usa en HP C-ANSI-C; la causa de los problemas en los niveles más altos de optimización aún no está clara.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fields</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015226Z" changeid="explorer">
        <seg>=item fields</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$u = @h{'first', 'second'};     # $u is now 'B'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150348Z" changeid="explorer">
        <seg>$u = @h{'primero', 'segundo'};  # $u es ahora 'B'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is now fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T201345Z" changeid="explorer">
        <seg>Esto ha sido arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, the
C&lt;use warnings&gt; pragma and the B&lt;-w&gt; switch (that is, the C&lt;$^W&gt; variable)
produces warnings if the STRING contains the &quot;,&quot; or the &quot;#&quot; character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por esta razón, el pragma C&lt;use warnings&gt; y la opción B&lt;-w&gt; (es decir, la variable C&lt;$^W&gt;) produce advertencias de si la cadena contiene la &quot;,&quot; o el carácter &quot;#&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perlbug|perlbug&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234415Z" changeid="explorer">
        <seg>=item L&lt;perlbug|perlbug&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item glob</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item glob</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of 5.14, none of these raises an exception if they are not supported on
your platform.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182218Z" changeid="explorer">
        <seg>A partir de 5.14, ninguno de estos produce una excepción si no están suportados en su plataforma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;/&quot; divides two numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;/&quot; divide dos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And, C&lt;\d+&gt;, may match strings of digits
that are a mixture from different writing systems, creating a security
issue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T173003Z" changeid="explorer">
        <seg>Y, C&lt;\d+&gt;, puede coincidir con cadenas de dígitos que son una mezcla de diferentes sistemas de escritura, creando un problema de seguridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treat string as multiple lines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Trata a la cadena como un conjunto de varias líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Older threaded Perls (5.8.6 or earlier)
will run into this problem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Anteriores Perls con threads (5.8.6 o anteriores) tendrán este problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
subroutine should return either nothing or else a list of up to three 
values in the following order:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La subrutina debe devolver, o nada, o bien una lista de hasta tres valores en el orden siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You get this from taking the reference of function calls like
C&lt;pos()&gt; or C&lt;substr()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Obtiene esto de la referencia a las llamadas a funciones como C&lt;pos()&gt; o C&lt;substr()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are not local to a scope, nor
readonly, but instead are volatile package variables similar to C&lt;$AUTOLOAD&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T010625Z" changeid="explorer">
        <seg>No son locales en el ámbito en donde se encuentren, ni de solo lectura, sino que son variables de paquete volátiles, similares a C&lt;$AUTOLOAD&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,11, 2) = 1   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,11, 2) = 1   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s|^|$front\{|;
                    redo LINE;
                }
            }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050858Z" changeid="explorer">
        <seg>s|^|$frente\{|;
                    redo LINEA;
                }
            }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of November 2005, only an alpha version has been released.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En noviembre de 2005, sólo ha sido lanzada una versión alfa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ( prompt(); defined( $_ = &lt;STDIN&gt; ); prompt() ) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ( prompt(); defined( $_ = &lt;STDIN&gt; ); prompt() ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Extracting matches</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113504Z" changeid="explorer">
        <seg>=head2 Extrayendo coincidencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not a general way to portably store floating-point values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No es una forma general de almacenar de forma portátil los valores de punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Something modified the values being iterated over.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003233Z" changeid="explorer">
        <seg>Algo modificó los valores que se utilizaron en la iteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful for dynamic patterns, such as those read in from a
configuration file, taken from an argument, or specified in a table
somewhere.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T192224Z" changeid="explorer">
        <seg>Esto es particularmente útil para los patrones dinámicos, como los que se leen desde un archivo de configuración, tomados desde un argumento, o especificados en alguna otra tabla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%%    a percent sign</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%%    un signo de por ciento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;dprofpp|dprofpp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231919Z" changeid="explorer">
        <seg>=item L&lt;dprofpp|dprofpp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The author of Perl has never felt the need to use this form of C&lt;goto&gt;
(in Perl, that is; C is another matter).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El autor de Perl nunca ha sentido la necesidad de usar esta forma de C&lt;goto&gt; (en Perl, desde luego. C es otra historia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Reference Manual</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Manual de referencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;The Perl Cookbook&gt; (the &quot;Ram Book&quot;):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003022Z" changeid="explorer">
        <seg>=item I&lt;The Perl Cookbook&gt; (el &quot;Libro del Carnero&quot;):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pragma has precedence over the other pragmas
listed below that change the defaults.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001840Z" changeid="explorer">
        <seg>Este pragma tiene prioridad sobre otros pragmas listados a continuación que cambian los valores predeterminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use \p{Prop} for longer names</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T044449Z" changeid="explorer">
        <seg>Use \p{Prop} para los nombres largos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;abs&gt;, C&lt;bless&gt;, C&lt;break&gt;, C&lt;chomp&gt;, C&lt;chr&gt;, C&lt;continue&gt;, C&lt;default&gt;, 
C&lt;exists&gt;, C&lt;formline&gt;, C&lt;given&gt;, C&lt;glob&gt;, C&lt;import&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;,
C&lt;lock&gt;, C&lt;map&gt;, C&lt;my&gt;, C&lt;no&gt;, C&lt;our&gt;, C&lt;prototype&gt;, C&lt;qr//&gt;, C&lt;qw//&gt;, C&lt;qx//&gt;,
C&lt;readline&gt;, C&lt;readpipe&gt;, C&lt;ref&gt;, C&lt;sub&gt;*, C&lt;sysopen&gt;, C&lt;tie&gt;, C&lt;tied&gt;, C&lt;uc&gt;,
C&lt;ucfirst&gt;, C&lt;untie&gt;, C&lt;use&gt;, C&lt;when&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165259Z" changeid="explorer">
        <seg>C&lt;abs&gt;, C&lt;bless&gt;, C&lt;break&gt;, C&lt;chomp&gt;, C&lt;chr&gt;, C&lt;continue&gt;, C&lt;default&gt;, 
C&lt;exists&gt;, C&lt;formline&gt;, C&lt;given&gt;, C&lt;glob&gt;, C&lt;import&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;,
C&lt;lock&gt;, C&lt;map&gt;, C&lt;my&gt;, C&lt;no&gt;, C&lt;our&gt;, C&lt;prototype&gt;, C&lt;qr//&gt;, C&lt;qw//&gt;, C&lt;qx//&gt;,
C&lt;readline&gt;, C&lt;readpipe&gt;, C&lt;ref&gt;, C&lt;sub&gt;*, C&lt;sysopen&gt;, C&lt;tie&gt;, C&lt;tied&gt;, C&lt;uc&gt;,
C&lt;ucfirst&gt;, C&lt;untie&gt;, C&lt;use&gt;, C&lt;when&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match 1 or more times, not greedily</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincide con 1 o más veces, sin avaricia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlopenbsd 	Perl notes for OpenBSD</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlopenbsd 	Notas para OpenBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For measuring time in better granularity than one second, use the
L&lt;Time::HiRes&gt; module from Perl 5.8 onwards (or from CPAN before then), or,
if you have gettimeofday(2), you may be able to use the C&lt;syscall&gt;
interface of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T023841Z" changeid="explorer">
        <seg>Para medir el tiempo con una granularidad mayor de un segundo, use el módulo L&lt;Time::HiRes&gt; de Perl 5.8 (o desde CPAN antes de él), o si tiene gettimeofday(2), puede utilizar el interfaz C&lt;syscall&gt; de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Why do we have separate numeric and string comparisons?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225235Z" changeid="explorer">
        <seg>¿Por qué se usa un operador de comparación para números y otro para cadenas?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C3 method resolution order added in 5.10.0 has been re-implemented as
a plugin, without changing its Perl-space interface.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T113918Z" changeid="explorer">
        <seg>El método de resolución de orden C3 añadido en 5.10.0 se ha re-implementado como un complemento, sin cambiar su interfaz del espacio Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you can get gcc for 5.3,
you could try that, too, since gcc in IRIX 6 is a known workaround for
at least the shuffle.t and sort.t failures.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T002223Z" changeid="explorer">
        <seg>Si puede conseguir gcc para 5.3, podría también intentarlo con él, ya que desde el gcc en IRIX 6 es al menos una solución conocida para los errores de shuffle.t y sort.t.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING:&gt; The previous example has a bug because the automatic
close that happens when the refcount on C&lt;handle&gt; does not
properly detect and report failures.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T000901Z" changeid="explorer">
        <seg>B&lt;AVISO:&gt; El anterior ejemplo tiene un error porque el cierre automático que sucede cuando el recuento de referencias de C&lt;handle&gt; no lo detecta apropiadamente y da mensajes de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a fatal error if there are
no octal digits at all.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T205811Z" changeid="explorer">
        <seg>Es un error fatal si no hay dígitos octales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;s///le&gt; is treated as a substitution followed by the C&lt;le&gt; operator, not
the C&lt;/le&gt; flags.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213530Z" changeid="explorer">
        <seg>C&lt;s///le&gt; es tratada como una sustitución seguida por el operador C&lt;le&gt;, no las opciones C&lt;/le&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Time::HiRes&gt; upgraded to version 1.86 (was 1.66)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040732Z" changeid="explorer">
        <seg>C&lt;Time::HiRes&gt; actualizado a la versión 1.86 (era 1.66)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, if the specified Perl version is greater than or equal to 5.9.5,
C&lt;use VERSION&gt; will also load the C&lt;feature&gt; pragma and enable all
features available in the requested version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, si la versión especificada de Perl es mayor o igual a 5.9.5, C&lt;use VERSIÓN&gt; cargará el pragma C&lt;feature&gt; y activará todas las características disponibles en la versión solicitada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The copy of the Unicode Character Database included in Perl 5.8 has
been updated to 4.0.1 from 4.0.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T103540Z" changeid="explorer">
        <seg>La copia de la base de datos de caracteres Unicode incluidos en Perl 5.8 ha sido actualizado desde la 4.0.0 a la 4.0.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'Now is the time for all' . &quot;\n&quot; .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054505Z" changeid="explorer">
        <seg>'Ahora es el momento de todos' . &quot;\n&quot; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The repeat count gobbles that many values from
the LIST when used with all format types other than C&lt;a&gt;, C&lt;A&gt;, C&lt;Z&gt;, C&lt;b&gt;,
C&lt;B&gt;, C&lt;h&gt;, C&lt;H&gt;, C&lt;@&gt;, C&lt;.&gt;, C&lt;x&gt;, C&lt;X&gt;, and C&lt;P&gt;, where it means
something else, dscribed below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de repeticiones engulle a tantos valores de la LISTA cuando es usada con todos los tipos de formato que no sean C&lt;a&gt;, C&lt;A&gt;, C&lt;Z&gt;, C&lt;b&gt;,
C&lt;B&gt;, C&lt;h&gt;, C&lt;H&gt;, C&lt;@&gt;, C&lt;.&gt;, C&lt;x&gt;, C&lt;X&gt; y C&lt;P&gt;, donde significa otra cosa, descrita abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(3,8,3);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>set_vec(3,8,3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>once</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224254Z" changeid="explorer">
        <seg>1 vez</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VERSION is provided, C&lt;package&gt; sets the C&lt;$VERSION&gt; variable in the given
namespace to a L&lt;version&gt; object with the VERSION provided.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se indica VERSIÓN, C&lt;package&gt; inicializa la variable C&lt;$VERSION&gt; en el espacio de nombres indicado a un objeto L&lt;version&gt; con la VERSIÓN indicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your Perl success stories and testimonials may be of help to others 
who wish to advocate the use of Perl in their applications, 
or if you wish to simply express your gratitude to Larry and the 
Perl developers, please write to perl-thanks@perl.org .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001536Z" changeid="explorer">
        <seg>Si considera que sus éxitos con Perl y sus testimonios pueden ayudar a otros programadores que desean utilizar Perl en sus proyectos, o si simplemente quiere expresar su gratitud a Larry y a los demás programadores de Perl, escriba un mensaje a la dirección perl-thanks@perl.org .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This prints the whole structure,
using the shell-style for() construct to loop across the outer
set of subscripts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193757Z" changeid="explorer">
        <seg>Esto muestra toda la estructura, utilizando la construcción de un bucle al estilo del for() de la shell para ciclar por el conjunto externo de subíndices.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even then, it may not be used to
go into any construct that requires initialization, such as a
subroutine or a C&lt;foreach&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso entonces, no se puede usar para ir a cualquier construcción que requiere inicialización, como una subrutina o un bucle C&lt;foreach&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item srand EXPR
X&lt;srand&gt; X&lt;seed&gt; X&lt;randseed&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201259Z" changeid="explorer">
        <seg>=item srand EXPR
X&lt;srand&gt; X&lt;seed&gt; X&lt;randseed&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-hv&gt; ] [ B&lt;-V&gt;[:I&lt;configvar&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-hv&gt; ] [ B&lt;-V&gt;[:I&lt;configvar&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pattern matching the empty string (not to be confused with
an empty pattern C&lt;//&gt;, which is just one member of the set of patterns
matching the epmty string), splits EXPR into individual
characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un patrón de coincidencia con la cadena vacía (que no debe confundirse con un patrón vacío C&lt;//&gt;, que es sólo un miembro del conjunto de patrones coincidentes con la cadena vacía), divide EXPR en caracteres individuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(I&lt;Loss of information&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232708Z" changeid="explorer">
        <seg>(I&lt;Pérdida de información&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>utime(undef, undef, $file)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>utime(undef, undef, $archivo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;find2perl&gt; now assumes C&lt;-print&gt; as a default action.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;find2perl&gt; ahora asume C&lt;-print&gt; como una acción por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>don't panic and just set the sticky bit in your /tmp
directory by doing the following as root:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no entre en pánico y establezca el bit sticky en el directorio /tmp haciendo lo siguiente como root:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will print the sorted contents of the file named F&lt;&quot;stuff&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T214140Z" changeid="explorer">
        <seg>imprimirá los contenidos ordenados del fichero nombrado como F&lt;&quot;stuff&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else {
           return $result;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051235Z" changeid="explorer">
        <seg>} else {
           return $resultado;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item untie VARIABLE
X&lt;untie&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210338Z" changeid="explorer">
        <seg>=item untie VARIABLE
X&lt;untie&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the best match for C&lt;S&gt; is considered.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235951Z" changeid="explorer">
        <seg>Sólo es considerada la mejor coincidencia para C&lt;S&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/(foo)bar/$1/g;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212542Z" changeid="explorer">
        <seg>s/(foo)bar/$1/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it is a rite of passage to
write your own version of these things, please consider carefully
whether the Perl world really needs you to publish it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031400Z" changeid="explorer">
        <seg>Si bien es un rito de paso escribir su propia versión de estas cosas, por favor, considere cuidadosamente si el mundo de Perl realmente lo necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It looks
like most programming languages you're likely to have experience
with, so if you've ever written a C program, an awk script, a shell
script, or even a BASIC program, you're already partway there.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230309Z" changeid="explorer">
        <seg>Perl se parece a la mayoría de los lenguajes de programación con los que es probable que tenga experiencia, por lo que si ya ha escrito programas en C, scripts en awk o de shell, o incluso un programa en BASIC, no le costará adaptarse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rin = fileno(STDIN);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051030Z" changeid="explorer">
        <seg>$rin = fileno(STDIN);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's C&lt;sprintf&gt; permits the following universally-known conversions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl C&lt;sprintf&gt; permite las siguientes conversiones universalmente conocidas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To set the default output handle
to something other than STDOUT, use the select operation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T005654Z" changeid="explorer">
        <seg>Para configurar el controlador de salida predeterminado a otro valor distinto que STDOUT, use el operador C&lt;select&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Mac Classic</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225504Z" changeid="explorer">
        <seg># Mac Classic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both forms are equivalent.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T215007Z" changeid="explorer">
        <seg>Ambas formas son equivalentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be aware,
however, that, when this construct is followed by a
quantifier, it currently triggers a warning message under
the C&lt;use warnings&gt; pragma or B&lt;-w&gt; switch saying it
C&lt;&quot;matches null string many times in regex&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T215053Z" changeid="explorer">
        <seg>Tenga en cuenta, sin embargo, que, cuando esta construcción es seguida por un cuantificador, actualmente lanza un mensaje de advertencia bajo el pragma C&lt;use warnings&gt; o la opción B&lt;-w&gt;, diciendo C&lt;&quot;matches null string many times in regex&quot;&gt; (I&lt;la cadena nula coincide muchas veces en la exp. reg.&gt;)).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^$/);
                               # (typically in a loop labeled LINE)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053634Z" changeid="explorer">
        <seg>/^$/);
                               # (típicamente en un bucle etiquetado como LINEA)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a reference to the object underlying VARIABLE (the same value
that was originally returned by the C&lt;tie&gt; call that bound the variable
to a package.)  Returns the undefined value if VARIABLE isn't tied to a
package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una referencia al objeto subyacente en VARIABLE (el mismo valor que fue devuelto originalmente por la llamada C&lt;tie&gt; que unía a la variable a un paquete). Devuelve el valor indefinido si la VARIABLE no está vinculada a un paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike C&lt;my&gt; or C&lt;state&gt;, which allocates storage for a variable and
associates a simple name with that storage for use within the current
scope, C&lt;our&gt; associates a simple name with a package (read: global)
variable in the current package, for use within the current lexical scope.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T001948Z" changeid="explorer">
        <seg>A diferencia de C&lt;my&gt; o C&lt;state&gt;, que asignan almacenamiento para una variable y asocian un nombre sencillo con este almacenamiento para su uso dentro del ámbito actual, C&lt;our&gt; asocia un nombre sencillo con una variable de paquete (es decir: global) en el paquete actual, para su uso dentro del ámbito léxico actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will use smart matching because only I&lt;one&gt; of the operands is a boolean; the
other uses smart matching, and that wins.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215145Z" changeid="explorer">
        <seg>usará coincidencia inteligente, porque sólo I&lt;uno&gt; de los operandos es un valor booleano; los otros utilizan coincidencia inteligente, y el resultado será verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dec = 0xDEADBEEF;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225513Z" changeid="explorer">
        <seg>$dec = 0xDEADBEEF;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$output = `cmd 2&gt;&amp;1 1&gt;/dev/null`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$salida = `comando 2&gt;&amp;1 1&gt;/dev/null`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without the braces, Perl would have looked for a $whospeak, a
C&lt;$who::0&gt;, and a C&lt;$who's&gt; variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin las llaves, Perl buscaría por $quien_altavoz, y el paquete C&lt;$quien::0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a problem with C&lt;syscall(&amp;SYS_pipe)&gt;: it returns the file
number of the read end of the pipe it creates, but there is no way
to retrieve the file number of the other end.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T020147Z" changeid="explorer">
        <seg>Hay un problema con C&lt;syscall(&amp;SYS_pipe)&gt;: devuelve el número de archivo de la lectura final de la tubería que crea, pero no hay manera de recuperar el número de archivo del otro extremo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some things to watch out for are:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101821Z" changeid="explorer">
        <seg>Algunas cosas a tener en cuenta son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\g1       [5]  Backreference to a specific or previous group,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224409Z" changeid="explorer">
        <seg>\g1       [5]  Contrareferencia a un grupo específico o anterior,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to the people who reviewed this document for me, before it went public.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235545Z" changeid="explorer">
        <seg>Las personas que han revisado este documento antes de su publicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare with L&lt;/use&gt;, which can do a similar check at compile time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compare con L&lt;/use&gt;, que puede hacer un control similar en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each chunk
is converted separately to a value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada fragmento se convierte en un valor por separado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$seconds = $3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$segundos = $3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Unicode Character Database 4.1.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200056Z" changeid="explorer">
        <seg>=head2 Unicode Character Database 4.1.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rename lib/unicode to lib/unicore to avoid case-insensitivity problems
with lib/Unicode</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>cambiar el nombre de lib/unicode a lib/unicore para evitar problemas de mayúsculas y minúsculas, con lib/Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, lines after the here-doc syntax
are compared with the terminating string line by line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, las líneas que siguen a la sintaxis del documento incrustado son comparados con la línea de terminación de cadena, una a una.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that
no whitespace may precede the C&lt;&lt; # &gt;&gt;, unlike modern C preprocessors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223748Z" changeid="explorer">
        <seg>Tenga en cuenta que no puede haber espacios en blanco delante de  C&lt;&lt; # &gt;&gt;, a diferencia de preprocesadores C modernos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting from a hash tied to
a DBM file deletes the entry from the DBM file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Borrando de un hash enlazado a un archivo DBM, borra esa entrada del archivo DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl doesn't match multiple characters in an inverted bracketed
character class, which otherwise could be highly confusing.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162543Z" changeid="explorer">
        <seg>Perl no coincide con caracteres múltiples en una clase invertida de caracteres entre corchetes, lo cual podría ser muy confuso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$vector-&gt;Index_List_Store(@ints);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>$vector-&gt;Index_List_Store(@ints);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This however (probably) raised the false expectation that the strict
refs, vars and subs were being enforced (and that @ISA was somehow
&quot;declared&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T175026Z" changeid="explorer">
        <seg>Sin embargo, esto planteó (probablemente) la falsa expectativa de que los strict refs, vars y subs estaban siendo forzados (y que @ISA era, de alguna manera &quot;declarada&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596102067</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003350Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596102067</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, these internal optimizations are not
always applicable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T211213Z" changeid="explorer">
        <seg>Por otra parte, estas optimizaciones internas no siempre son aplicables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDOUT `sort`;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213754Z" changeid="explorer">
        <seg>print STDOUT `sort`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you get tired of remembering which element of the return list
contains which return value, by-name interfaces are provided
in standard modules: C&lt;File::stat&gt;, C&lt;Net::hostent&gt;, C&lt;Net::netent&gt;,
C&lt;Net::protoent&gt;, C&lt;Net::servent&gt;, C&lt;Time::gmtime&gt;, C&lt;Time::localtime&gt;,
and C&lt;User::grent&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está cansado de recordar qué elemento de la lista devuelta contiene qué valor, existen interfaces por nombre, en módulos estándar: C&lt;File::stat&gt;, C&lt;Net::hostent&gt;, C&lt;Net::netent&gt;, C&lt;Net::protoent&gt;, C&lt;Net::servent&gt;, C&lt;Time::gmtime&gt;, C&lt;Time::localtime&gt; y C&lt;User::grent&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 1-59059-018-X [1st edition August 2002]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003434Z" changeid="explorer">
        <seg>ISBN 1-59059-018-X [1ª edición - Agosto de 2002]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to add
a new parameter you will have to add it to the end of the list for
backward compatibility, and this will probably make your list order
unintuitive.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022023Z" changeid="explorer">
        <seg>Si desea agregar un nuevo parámetro lo tendrá que añadir al final de la lista, para mantener la compatibilidad con versiones anteriores, y esto probablemente hará que su orden de lista sea poco intuitivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>until ( condition ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T003005Z" changeid="zipf">
        <seg>until ( condición ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This bug
has now been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este error ya se ha solucionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello world\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225504Z" changeid="explorer">
        <seg>print &quot;Hello world\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only implication of the term &quot;native&quot; on integers is that the limits for
the maximal and the minimal supported true integral quantities are close to
powers of 2.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232452Z" changeid="explorer">
        <seg>La única implicación del término &quot;nativo&quot; para los enteros es que los límites máximo y mínimo de las cantidades verdaderamente enteras admitidas son cercanos a potencias de 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Building 32-bit Perl in Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002329Z" changeid="explorer">
        <seg>=head2 Compilando Perl de 32 bit en Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltoot		Perl OO tutorial, part 1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000212Z" changeid="explorer">
        <seg>perltoot		Programación orientada a objetos, parte 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The -C switch has changed in an incompatible way.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T141707Z" changeid="explorer">
        <seg>La opción -C ha cambiado de una forma incompatible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say '$foo is an odd digit';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>say '$foo es un dígito impar';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;if&gt; statement is straightforward.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013324Z" changeid="explorer">
        <seg>La instrucción C&lt;if&gt; es sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(':', split(//,   'hi there!', -1)), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(':', split(//,   'hola aqui!', -1)), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that characters from 128 to 255 (inclusive) are by default
internally not encoded as UTF-8 for backward compatibility reasons.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que los caracteres de 128 a 255 (inclusive) son, por defecto, internamente no codificados como UTF-8, por razones de compatibilidad hacia atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the list of arguments might work fine for one, two or even three
arguments, any more arguments become hard for the module user to
remember, and hard for the module author to manage.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021857Z" changeid="explorer">
        <seg>Si bien la lista de argumentos puede funcionar bien para uno, dos o incluso tres argumentos, los siguientes argumentos le serán más difícil de recordar para el usuario del módulo, y difícil de mantener para el autor del módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the delimiters are
bracketing, nested pairs are also skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los delimitadores están entre emparejados, las parejas anidadas también se omiten.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On
unconnected sockets, you must specify a destination to I&lt;send to&gt;, in which
case it does a sendto(2) syscall.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sockets desconectados, debe especificar un destino I&lt;adonde&gt; enviarlo, en cuyo caso hace una llamada del sistema sendto(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this new feature was not planned, it fell
naturally out of PerlIO changes, and is to be considered an accidental
feature.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171154Z" changeid="explorer">
        <seg>Aunque esta nueva característica no fue planeada, apareció de forma natural de los cambios que se hicieron a PerlIO, y se considera una característica accidental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no shell metacharacters in the argument, it is split into
words and passed directly to C&lt;execvp&gt;, which is more efficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay metacaracteres shell en el argumento, es dividido en palabras y pasadas directamente a C&lt;execvp&gt;, que es más eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item s
X&lt;/s&gt; X&lt;regex, single-line&gt; X&lt;regexp, single-line&gt;
X&lt;regular expression, single-line&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222730Z" changeid="explorer">
        <seg>=item s
X&lt;/s&gt; X&lt;regex, single-line&gt; X&lt;regexp, single-line&gt; X&lt;regular expression, single-line&gt; X&lt;regex, una línea&gt; X&lt;expresión regular, una línea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, the leading symbol ('$' or '@') on the array or
hash indicates whether you are getting back a singular value (a
scalar) or a plural one (a list).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por otra parte, el símbolo principal ('$' o '@') en el array o hash indica si va a obtener un valor singular (un escalar) o uno plural (una lista).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
scalar context, glob iterates through such filename expansions, returning
undef when the list is exhausted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, glob itera a través de la expansión de nombres de archivo, devolviendo undef cuando se agote la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack('nN', 42, 4711);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack('nN', 42, 4711);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and here's another.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y aquí otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treats ARRAY as a stack by appending the values of LIST to the end of
ARRAY.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T010729Z" changeid="explorer">
        <seg>Considera a ARRAY como una pila añadiendo los valores de LISTA al final de ARRAY.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Within
character classes C&lt;\b&gt; represents backspace rather than a word
boundary, just as it normally does in any double-quoted string.)
The C&lt;\A&gt; and C&lt;\Z&gt; are just like &quot;^&quot; and &quot;$&quot;, except that they
won't match multiple times when the C&lt;/m&gt; modifier is used, while
&quot;^&quot; and &quot;$&quot; will match at every internal line boundary.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Dentro de las clases carácter, C&lt;\b&gt; representa el retroceso -I&lt;backspace&gt;- en lugar del límite de palabra, tal como lo hace normalmente en cualquier cadena doblemente entrecomillada). Los C&lt;\A&gt; y C&lt;\Z&gt; son como los &quot;^&quot; y &quot;$&quot;, excepto que no coincidirán múltiples veces cuando se use el modificador C&lt;/m&gt;, mientras que &quot;^&quot; y &quot;$&quot; coincidirán en cada límite de línea que contenga la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl588delta - what is new for perl v5.8.8</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T023744Z" changeid="explorer">
        <seg>perl588delta - qué hay de nuevo en perl v5.8.8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;address is %*vX\n&quot;, &quot;:&quot;, $addr;   # IPv6 address</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;dirección es %*vX\n&quot;, &quot;:&quot;, $addr;   # dirección IPv6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The focus is on elements of style which are visible to the users of a 
module, rather than those parts which are only seen by the module's 
developers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T012927Z" changeid="explorer">
        <seg>La atención se centra en los elementos de estilo que son visibles para los usuarios de un módulo, en lugar de aquellas partes que sólo son vistos por los desarrolladores del módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8.4 23:59:59 GMT, Wednesday March 31st 2004</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5.8.4 23:59:59 GMT miércoles, 31 de marzo 2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FH, $filename) or die &quot;Can't open $filename: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FH, $archivo) or die &quot;No puedo abrir $archivo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\s+$//;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/\s+$//;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular,
characters C&lt;&quot;0&quot;&gt; and C&lt;&quot;1&quot;&gt; generate nybbles 0 and 1, as do bytes
C&lt;&quot;\000&quot;&gt; and C&lt;&quot;\001&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T174920Z" changeid="explorer">
        <seg>En particular, los caracteres C&lt;&quot;0&quot;&gt; y C&lt;&quot;1&quot;&gt; generan los nibles 0 y 1, así como los bytes C&lt;&quot;\000&quot;&gt; y C&lt;&quot;\001&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following lines are equivalent:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las siguientes líneas son equivalentes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Patterns are subject to an additional level of interpretation as a
regular expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los patrones están sujetos a un nivel adicional de interpretación como una expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each letter may optionally be followed by a number indicating the repeat
count.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada letra puede ser seguida opcionalmente por un número que indica el número de repeticiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now it's barely a skeleton
as its whitewashed bones have fractured or eroded.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200906Z" changeid="explorer">
        <seg>Ahora, sus huesos pelados, rotos o erosionados, solo se asemejan vagamente a un esqueleto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, an identifier within such curlies is forced to be a string,
as is any simple identifier within a hash subscript.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De hecho, un identificador dentro de estos signos, se le fuerza a ser una cadena, como a cualquier identificador dentro del subíndice de un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;File::Copy&gt; upgraded to version 2.09</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031513Z" changeid="explorer">
        <seg>C&lt;File::Copy&gt; actualizado a la versión 2.09</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This doesn't work with C&lt;-t&gt;, and you need to remember
that lstat() and C&lt;-l&gt; leave values in the stat structure for the
symbolic link, not the real file.)  (Also, if the stat buffer was filled by
an C&lt;lstat&gt; call, C&lt;-T&gt; and C&lt;-B&gt; will reset it with the results of C&lt;stat _&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto no funciona con  C&lt;-t&gt;, y necesita recordar que lstat() y C&lt;-l&gt; dejarán valores en la estructura stat para el enlace simbólico, no el archivo real).  (También, si la memoria intermedia de stat se rellenó con una llamada C&lt;lstat&gt;, C&lt;-T&gt; y C&lt;-B&gt; serán reinicializados con los resultados de C&lt;stat _&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n = &quot;-12.34e56&quot;;	    # number specified as a string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232307Z" changeid="explorer">
        <seg>$n = &quot;-12.34e56&quot;;       # número especificado como una cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default { say &quot;I don't like anything&quot; }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234739Z" changeid="explorer">
        <seg>default { say &quot;No me gusta nada&quot; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid starting a new top-level hierarchy, especially if a suitable
hierarchy already exists under which you could place your module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015358Z" changeid="explorer">
        <seg>Evite comenzar una nueva jerarquía de nivel superior, sobre todo si una jerarquía adecuada ya existe en virtud del cual se puede colocar su módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is roughly equivalent to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es casi equivalente a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opens a pair of connected pipes like the corresponding system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Abre un par de tuberías conectadas como lo hace correspondiente llamada al sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Document C&lt;make&gt;/C&lt;emake&gt; more visibly</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033428Z" changeid="explorer">
        <seg>C&lt;make&gt;/C&lt;emake&gt; mejor documentado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;-&quot; returns the difference of two numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;-&quot; devuelve la diferencia de dos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chop</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $, = &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225457Z" changeid="explorer">
        <seg>local $, = &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default answers for the rest of the
questions are usually sufficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Suele ser suficiente tomar el valor por defecto para las respuestas del resto de las preguntas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exit 255;                   # last resort</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171215Z" changeid="explorer">
        <seg>exit 255;                   # último recurso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(David Billinghurst &lt;David.Billinghurst@riotinto.com.au&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003932Z" changeid="explorer">
        <seg>(David Billinghurst &lt;David.Billinghurst@riotinto.com.au&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Jeffrey E. F. Friedl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003551Z" changeid="explorer">
        <seg>Jeffrey E. F. Friedl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unary &amp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item unario &amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,14, 2) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,14, 2) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unary *</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item unario *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U32 hash;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114005Z" changeid="explorer">
        <seg>U32 hash;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(.)(.)(.)(.)(.)(.)(.)(.)(.)\g10/   # \g10 is a backreference</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191451Z" changeid="explorer">
        <seg>/(.)(.)(.)(.)(.)(.)(.)(.)(.)\g10/   # \g10 es una contrareferencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $re = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002108Z" changeid="explorer">
        <seg>my $re = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlmodlib&gt; lists the
modules which came with your Perl installation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225619Z" changeid="explorer">
        <seg>L&lt;perlmodlib&gt; enumera los módulos incluidos en la instalación de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># add new columns to an existing row</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T010033Z" changeid="explorer">
        <seg># añadir nuevas columnas a una fila existente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each character is just that: the
character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234520Z" changeid="explorer">
        <seg>Cada carácter no es más que eso: un carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has a side effect when
opening unnamed pipes in a shell script: there is no child process
generated under.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102320Z" changeid="explorer">
        <seg>Esto tiene un efecto secundario al abrir las tuberías anónimas en un script de shell: no se ha generado ningún proceso hijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	list operators (rightward)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	operadores de lista (por la derecha)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=for comment</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=for comment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now returns extra information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031231Z" changeid="explorer">
        <seg>Ahora devuelve información adicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reflect the functionality of the module, not the implementation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015322Z" changeid="explorer">
        <seg>Refleje la funcionalidad del módulo, no la implementación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next if /^$/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232650Z" changeid="explorer">
        <seg>next if /^$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Yves Orton)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112222Z" changeid="explorer">
        <seg>(Yves Orton)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They may be used only as separate tokens; they
will not be interpolated into strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo podrán ser utilizados como símbolos aislados; no se interpolarán dentro de cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code freeze for the next maintenance release (5.8.5) will be on 30th June
2004, with release by mid July.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T111227Z" changeid="explorer">
        <seg>La congelación de código para la versión de mantenimiento siguiente (5.8.5) será el 30 de junio de 2004, con la publicación a mediados de julio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Builtin operators and functions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002812Z" changeid="zipf">
        <seg>=head2 Funciones y operadores integrados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return &quot;\Q$str&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return &quot;\Q$str&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For rounding to a certain number
of digits, sprintf() or printf() is usually the easiest route.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para redondear a un determinado número de dígitos, sprintf() o printf() suele ser el camino más fácil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions in this section can serve as terms in an expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las funciones de esta sección pueden servir como términos en una expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other core committers contributed most of the changes, and applied most
of the patches sent in by the hundreds of contributors listed in F&lt;AUTHORS&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235404Z" changeid="explorer">
        <seg>El otro grupo principal de colaboradores contribuyó con la mayor parte de los cambios, y aplicaron la mayoría de los parches enviados por cientos de colaboradores que figuran en F&lt;AUTORES&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;Changes&gt; file for exhaustive details on what changed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004041Z" changeid="explorer">
        <seg>El archivo de F&lt;Changes&gt; (Cambios) para obtener más información exhaustiva sobre lo que ha cambiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does the same thing that the listen(2) system call does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace lo mismo que la llamada del sistema listen(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This feature
is slightly different from the previous C&lt;Configure -Dinstallprefix=...&gt;.)
See F&lt;INSTALL&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T181703Z" changeid="explorer">
        <seg>(Esta característica es ligeramente diferente de la anterior C&lt;Configure -Dinstallprefix=...&gt;.) Vea F&lt;INSTALL&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(??{ code })&gt;
X&lt;(??{})&gt;
X&lt;regex, postponed&gt; X&lt;regexp, postponed&gt; X&lt;regular expression, postponed&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T181824Z" changeid="explorer">
        <seg>=item C&lt;(??{ código })&gt;
X&lt;(??{})&gt; X&lt;regex, pospuesto&gt; X&lt;regexp, pospuesto&gt; X&lt;expresión regular, pospuesto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235028Z" changeid="explorer">
        <seg>Procesar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you do this, the following idiom is recommended:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025707Z" changeid="explorer">
        <seg>Si hace esto, se recomienda usar el siguiente modismo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item connect SOCKET,NAME
X&lt;connect&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170328Z" changeid="explorer">
        <seg>=item connect SOCKET,NOMBRE
X&lt;connect&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first to get the correct constant definitions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>primero para obtener las definiciones de las constantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 no warnings 'category' works correctly with -w</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T043532Z" changeid="explorer">
        <seg>=head2 no warnings 'category' ahora funciona correctamente con -w</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also uses filehandle I&lt;ARGV&gt;
internally.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014146Z" changeid="explorer">
        <seg>Internamente, también utiliza el identificador de archivo &lt;ARGV&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0xff                # hex</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0xff                # hex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As
explained below in L&lt;/Extended Patterns&gt; it is possible to explicitly
specify modifiers that apply only to portions of a regular expression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001524Z" changeid="explorer">
        <seg>Como se ha explicado en L&lt;/Patrones extendidos&gt;, es posible especificar explícitamente los modificadores que se aplican sólo a unas partes de una expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.10g&gt;', 1;     # prints &quot;&lt;1&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.10g&gt;', 1;     # imprime &quot;&lt;1&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050207Z" changeid="explorer">
        <seg>/x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to
interpolate regexes into larger regexes and not have to worry about the
capture groups being renumbered.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002319Z" changeid="explorer">
        <seg>Esto le permite interpolar expresiones regulares en grandes expresiones regulares y no tener que preocuparse por el cambio en la numeración de los grupos de captura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for( $i = 0; $i &lt; @array; $i++ ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225554Z" changeid="explorer">
        <seg>for( $i = 0; $i &lt; @array; $i++ ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*                   zero or more of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230532Z" changeid="zipf">
        <seg>*                   cero o más coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;$input&gt;) {    # note use of indirection
            if (/^#include &quot;(.*)&quot;/) {
                process($1, $input);
                next;
            }
            #...          # whatever</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050412Z" changeid="explorer">
        <seg>while (&lt;$entrada&gt;) {    # note el uso de la indirección
            if (/^#include &quot;(.*)&quot;/) {
                procesa($1, $input);
                next;
            }
            #...          # cualquier otra cosa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lowercase of any character
outside the ASCII range is the character itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175226Z" changeid="explorer">
        <seg>La minúscula de cualquier carácter fuera del rango ASCII es el propio carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$result = sprintf(&quot;%08d&quot;, $number);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$resultado = sprintf(&quot;%08d&quot;, $numero);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item print LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item print LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When modified by the C&lt;while&gt; or
C&lt;until&gt; loop modifier, executes the BLOCK once before testing the loop
condition.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se encuentra acompañado por los modificadores de bucle C&lt;while&gt; o C&lt;until&gt;, ejecuta el BLOQUE una vez antes de comprobar la condición del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for list data
X&lt;list&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201200Z" changeid="explorer">
        <seg>=item Funciones para lista de datos
X&lt;list&gt; X&lt;lista&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dprofpp -p program.pl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T005751Z" changeid="explorer">
        <seg>dprofpp -p programa.pl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reads from the filehandle whose typeglob is contained in EXPR (or from
C&lt;*ARGV&gt; if EXPR is not provided).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011205Z" changeid="explorer">
        <seg>Lee del identificador de archivo cuyo I&lt;typeglob&gt; esté contenido en EXPR (o desde C&lt;*ARGV&gt; si se omite EXPR).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>b  A bit string (ascending bit order inside each byte, like vec()).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>b  Una cadena de bit (en orden de bit ascendente dentro de cada byte, como vec()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This assertion may be used as a C&lt;(?(condition)yes-pattern|no-pattern)&gt;
switch.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T221833Z" changeid="explorer">
        <seg>Esta aserción puede ser usada con un interruptor C&lt;(?(condición)patrón-sí|patrón-no)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 64  ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 64  ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;.IX bar\n&quot;    if /\bbar\b/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;.IX bar\n&quot;    if /\bbar\b/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;UNIVERSAL&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005507Z" changeid="explorer">
        <seg>=item C&lt;UNIVERSAL&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 32  ==       8192 00000000000001000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 32  ==       8192 00000000000001000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the C&lt;&lt; =&gt; &gt;&gt; operator behaves exactly as the comma operator
or list argument separator, according to context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, el operador C&lt;&lt; =&gt; &gt;&gt; se comporta exactamente como el operador coma o separador de lista de argumentos, según el contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests the state of the source tree for various common errors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014709Z" changeid="explorer">
        <seg>Pruebas que detectan diversos errores comunes en el árbol de código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local %{$x}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015205Z" changeid="explorer">
        <seg>local %{$x}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Setup Perl and utilities on VM/ESA</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101557Z" changeid="explorer">
        <seg>=head2 Instalación de Perl y de las utilerías en VM/ESA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, there are a number of
&quot;README&quot; files with hints and tips about building and using Perl on a wide
variety of platforms, some more common than others.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222056Z" changeid="explorer">
        <seg>Además, hay una serie de archivos &quot;README&quot; con consejos y sugerencias sobre la construcción y el uso de Perl en una amplia variedad de plataformas, algunas más comunes que otras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls flock(2), or an emulation of it, on FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010509Z" changeid="explorer">
        <seg>Llama a flock(2), o una emulación de ella, sobre IDENTIFICADOR_ARCHIVO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Nice quads!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;¡quads divertidos!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlhist&gt; (new as of 5.005)
for Perl's milestone releases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200120Z" changeid="explorer">
        <seg>En L&lt;perlhist&gt; (nuevo desde la versión 5.005) está registrado el historial de lanzamiento de versiones de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort(find_records (@key));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort(busca_registros (@claves));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended that for this usage you put the DEFINE block at the
end of the pattern, and that you name any subpatterns defined within it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T203317Z" changeid="explorer">
        <seg>Se recomienda que para este uso ponga el bloque DEFINE al final del patrón, y que dé nombre a cualquier sub-patrón definido dentro de él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\033         [7,8]  restricted range octal char  (example: ESC)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034556Z" changeid="explorer">
        <seg>\033	[7,8]	rango restringido car. octal	(ejemplo: ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;endprotoent&gt;, C&lt;endservent&gt;, C&lt;gethostbyaddr&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getprotobyname&gt;, C&lt;getprotobynumber&gt;, C&lt;getprotoent&gt;,
C&lt;getservbyname&gt;, C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;sethostent&gt;,
C&lt;setnetent&gt;, C&lt;setprotoent&gt;, C&lt;setservent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T204408Z" changeid="explorer">
        <seg>C&lt;endprotoent&gt;, C&lt;endservent&gt;, C&lt;gethostbyaddr&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getprotobyname&gt;, C&lt;getprotobynumber&gt;, C&lt;getprotoent&gt;,
C&lt;getservbyname&gt;, C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;sethostent&gt;,
C&lt;setnetent&gt;, C&lt;setprotoent&gt;, C&lt;setservent&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;^&quot; returns its operands XORed together bit by bit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;^&quot; devuelve la operación XOR, bit a bit, de sus operandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither need
quoting.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ninguno necesita ser entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is handy when you want to do a list assignment in a Boolean
context, because most list functions return a null list when finished,
which when assigned produces a 0, which is interpreted as FALSE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil cuando se quiere hacer una lista de asignación en un contexto booleano, porque la mayoría de funciones que devuelve una lista, devuelven una nula cuando han terminado, que cuando se asignan producen un 0, lo que se interpreta como FALSO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596003746/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003240Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596003746/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($port, $myaddr) = sockaddr_in($mysockaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($port, $myaddr) = sockaddr_in($mysockaddr);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sub NAME BLOCK
X&lt;sub&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201701Z" changeid="explorer">
        <seg>=item sub NOMBRE BLOQUE
X&lt;sub&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On insecure systems, these
restrictions may be relaxed, but this is not a portable assumption.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas inseguros, estas restricciones pueden estar más relajadas, pero no es una suposición normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be careful with parentheses:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado con los paréntesis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = 'bar';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050108Z" changeid="explorer">
        <seg>$_ = 'bar';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;diagnostics&gt; upgraded to version 1.15</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030407Z" changeid="explorer">
        <seg>C&lt;diagnostics&gt; actualizado a la versión 1.15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;&lt; decimal string --&gt; native integer &gt;&gt; conversion cannot be done
without loss of information, the result is compatible with the conversion
sequence C&lt;&lt; decimal_string --&gt; native_floating_point --&gt; native_integer &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232834Z" changeid="explorer">
        <seg>Si no se puede aplicar la conversión C&lt;&lt; cadena decimal --&gt; entero nativo &gt;&gt; sin pérdida de información, el resultado es compatible con la secuencia de conversiones C&lt;&lt; cadena decimal --&gt; punto flotante nativo --&gt; entero nativo &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future versions of perl might do something different from the
version of perl you try it out on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Futuras versiones de perl pueden hacer algo diferente de la versión de perl que esté probando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Regex     pattern match            $a =~ /$b/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  Regex      coincidencia de patrones         $a =~ /$b/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a declaration
of the array:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay una declaración del array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlretut/&quot;Using regular expressions in Perl&quot;&gt; for further explanation
of the g and c modifiers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220338Z" changeid="explorer">
        <seg>Vea L&lt;perlretut/&quot;Usando expresiones regulares en Perl&quot;&gt; para una explicación más detallada de los modificadores g y c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Steve Peters &lt;steve@fisharerojo.org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Steve Peters &lt;steve@fisharerojo.org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PAT?+               (?&gt;PAT?)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232345Z" changeid="explorer">
        <seg>PAT?+               (?&gt;PAT?)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item warn LIST
X&lt;warn&gt; X&lt;warning&gt; X&lt;STDERR&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211021Z" changeid="explorer">
        <seg>=item warn LISTA
X&lt;warn&gt; X&lt;warning&gt; X&lt;STDERR&gt; X&lt;avisos&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;sprintf &quot;%u&quot;, -1&gt; therefore provides the same result as
C&lt;sprintf &quot;%u&quot;, ~0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T233208Z" changeid="explorer">
        <seg>Así, C&lt;sprintf &quot;%u&quot;, -1&gt; produce el mismo resultado que C&lt;sprintf &quot;%u&quot;, ~0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These examples of
the whatever operator are still syntax errors:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225638Z" changeid="explorer">
        <seg>Estos ejemplos del operador lo-que-sea siguen siendo errores de sintaxis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is often useful if you need to check the current Perl version before
C&lt;use&gt;ing library modules that won't work with older versions of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Suele ser útil si necesita comprobar la versión actual de Perl antes de que C&lt;use&gt; módulos que no funcionarán con versiones anteriores de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No Configure is needed to build microperl,
on the other hand this means that interfaces between Perl and your
operating system are left very -- minimal.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se necesita Configure para construir microperl, por otra parte esto significa que las interfaces entre Perl y su sistema operativo se quedan en muy, muy, muy mínimas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a bug in FreeBSD's
C&lt;readdir_r&gt; function in versions 4.5 and earlier that can cause a SEGV when
reading large directories.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay un bug en la función C&lt;readdir_r&gt; de FreeBSD en la versión 4.5 y anteriores que pueden provocar un SEGV al leer grandes directorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Files and I/O</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T232159Z" changeid="zipf">
        <seg>=head2 Archivos y E/S</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item flock</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015015Z" changeid="explorer">
        <seg>=item flock</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5122delta	Perl changes in version 5.12.2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000716Z" changeid="explorer">
        <seg>perl5122delta	Cambios en la versión 5.12.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more details and discussion on the latter, see:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215021Z" changeid="explorer">
        <seg>Para obtener más detalles y discusión sobre esto último, vea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;err&gt; low-precedence defined-or operator used to be enabled by
default (although as a weak keyword, meaning that any function would
override it).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T193549Z" changeid="explorer">
        <seg>Tenga en cuenta que, por defecto, C&lt;err&gt; activa un nivel bajo de precedencia con el operador defined-or (aunque, como palabra clave débil, lo que significa que cualquier función puede sobreescribirla).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict qw(@ISA);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015259Z" changeid="explorer">
        <seg>use strict qw(@ISA);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Free (as in beer) books</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003700Z" changeid="explorer">
        <seg>=head2 Libros gratuitos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;string, concatenation&gt; X&lt;concatenation&gt;
X&lt;cat&gt; X&lt;concat&gt; X&lt;concatenate&gt; X&lt;.&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234455Z" changeid="explorer">
        <seg>X&lt;string, concatenation&gt; X&lt;concatenation&gt;
X&lt;cat&gt; X&lt;concat&gt; X&lt;concatenate&gt; X&lt;.&gt; X&lt;cadena&gt; X&lt;concatenación&gt; X&lt;concatenar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://bookmarks.cpan.org/search.cgi?cat=Training%2FTutorials</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225438Z" changeid="explorer">
        <seg>http://bookmarks.cpan.org/search.cgi?cat=Training%2FTutorials</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%u    an unsigned integer, in decimal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%u    un entero sin signo, en decimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '%2$d %1$d', 12, 34;      # prints &quot;34 12&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '%2$d %1$d', 12, 34;      # imprime &quot;34 12&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, OO Perl is largely beyond the scope of this document.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T234942Z" changeid="explorer">
        <seg>Sin embargo, este tema queda fuera del ámbito de este documento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 1-930110-82-0 [1st edition August 2002]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003644Z" changeid="explorer">
        <seg>ISBN 1-930110-82-0 [1ª edición - Agosto de 2002]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># no compile-time or run-time warnings before here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># no advertencias en compilación o ejecución antes de aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.7/8.x for DG/UX ix86 R4.20MU0x</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl 5.7/8.x para DG/UX ix86 R4.20MU0x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the opposite way, to resolve a hostname to the IP address
you can write this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sentido contrario, para resolver un nombre de host a la dirección IP puede escribir lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The null list is represented by ().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La lista nula se representa por ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Z&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224402Z" changeid="explorer">
        <seg>&quot;Z&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;tr///&gt;, C&lt;y///&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item C&lt;tr///&gt;, C&lt;y///&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such discretionary locks are more flexible, but
offer fewer guarantees.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T161806Z" changeid="explorer">
        <seg>Tales bloqueos, discrecionalmente, son más flexibles, pero ofrecen pocas garantías.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it nice for initializing hashes:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto hace que sea algo agradable para inicializar los hashes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 102.111.111;        # same</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print 102.111.111;        # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Task-Oriented</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003426Z" changeid="explorer">
        <seg>=head2 Libros orientados a tareas específicas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef %hash;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef %hash;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 'p N$' ^ &quot; E&lt;H\n&quot;;		# prints &quot;Perl\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print 'p N$' ^ &quot; E&lt;H\n&quot;;		# imprime &quot;Perl\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the sprintf() function with some formats could lead to a buffer
overflow in some specific cases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044450Z" changeid="explorer">
        <seg>Usando la función sprintf() con algunos formatos podría dar lugar a un desbordamiento de búfer, en algunos casos específicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item bless REF</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item bless REF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;$/&gt; is set to C&lt;undef&gt;, when C&lt;readline&gt; is in scalar
context (i.e., file slurp mode), and when an empty file is read, it
returns C&lt;''&gt; the first time, followed by C&lt;undef&gt; subsequently.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando C&lt;$/&gt; tenga un valor de C&lt;undef&gt;, cuando C&lt;readline&gt; esté en contexto escalar (es decir, modo de absorción completa de archivo), y cuando se esté leyendo un archivo vacío, devuelve C&lt;''&gt; la primera vez, seguido a continuación de C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception to this is when writing files that should be
kept private: mail files, web browser cookies, I&lt;.rhosts&gt; files, and
so on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La excepción a esto es cuando se escriben archivos que deben mantenerse de forma privada: archivos de correo, los cookies del navegador web, archivos I&lt;rhosts&gt;, y así sucesivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If they happen
to be in the same package, Perl will emit warnings if you have asked
for them, just like multiple C&lt;my&gt; declarations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si están en el mismo paquete, Perl emitirá mensajes de advertencia si los tiene activados, al igual que múltiples declaraciones de C&lt;my&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;..&quot; is the range operator, which is really two different
operators depending on the context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;..&quot; es el operador rango, que en realidad son dos operadores diferentes en función del contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (1..15) { print &quot;Merry Christmas\n&quot;; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (1..15) { print &quot;Feliz Navidad\n&quot;; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># We must also take care of not escaping the legitimate \\Y|</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001934Z" changeid="explorer">
        <seg># También hay que tener cuidado de no escapar la legítima</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The four-argument form of select() did not preserve $!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001234Z" changeid="explorer">
        <seg>La forma de cuatro argumentos de select() no preservaba $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence this change will not have any affect once perl is
installed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153010Z" changeid="explorer">
        <seg>Por lo tanto, este cambio no tendrá ningún efecto una vez se haya instalado perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir ($foo)  || die;	# (chdir $foo) || die</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir ($foo)  || die;	# (chdir $foo) || die</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes the C&lt;STORABLE_attach&gt; hook functionality added by
Adam Kennedy, and more frugal memory requirements when storing under C&lt;ithreads&gt;, by
using the C&lt;ithreads&gt; cloning tracking code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035021Z" changeid="explorer">
        <seg>Se incluye la funcionalidad C&lt;STORABLE_attach&gt; añadida por Adam Kennedy, y menores requisitos de memoria estando bajo C&lt;ithreads&gt;, usando el código de seguimiento de clonación de C&lt;ithreads&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?(condition)yes-pattern)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T193453Z" changeid="explorer">
        <seg>=item C&lt;(?(condición)patrón-sí)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Perl supports passing of up to only 14 arguments to your syscall,
which in practice should (usually) suffice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que Perl soporta pasar sólo hasta 14 argumentos a su syscall, que en la práctica debería (generalmente) ser suficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may charge any fee you choose for support of this
Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede reclamar un canon decidido por usted para el soporte de este Paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, on 32-bit machines
an integer may be represented by a sequence of 4 bytes, which  will in
Perl be presented as a string that's 4 characters long.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192025Z" changeid="explorer">
        <seg>Por ejemplo, en máquinas de 32 bits, un entero puede ser representado por una secuencia de 4 bytes, que en Perl se presentará como una cadena de cuatro caracteres de longitud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have cached your return value, then
return a pointer to it without changing the reference count.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114934Z" changeid="explorer">
        <seg>Si tiene cacheado su valor de retorno, entonces devuelva un puntero a él sin tener que cambiar el contador de referencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;boolean&gt; X&lt;bool&gt; X&lt;true&gt; X&lt;false&gt; X&lt;truth&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;boolean&gt; X&lt;bool&gt; X&lt;true&gt; X&lt;false&gt; X&lt;truth&gt; X&lt;booleano&gt; X&lt;verdadero&gt; X&lt;falso&gt; X&lt;verdad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that using the v-strings for IPv4
addresses is not portable unless you also use the
inet_aton()/inet_ntoa() routines of the Socket package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el uso de v-strings para las direcciones IPv4 no es portable a menos que también utilice las rutinas del paquete Socket inet_aton()/inet_ntoa().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Format number with up to 8 leading zeroes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Formatea número con un máximo de 8 ceros iniciales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $bar;    # prints 30</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $bar;    # pinta 30</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @ints, 0 if $bits =~ s/^(\d)// &amp;&amp; $1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225602Z" changeid="explorer">
        <seg>push @ints, 0 if $bits =~ s/^(\d)// &amp;&amp; $1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item B&lt;filter_store_key&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190454Z" changeid="zipf">
        <seg>=item B&lt;filter_store_key&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact,
the line marked &quot;implicit deref&quot; above works just fine--in this
instance--to do what the one that says explicit deref did.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030837Z" changeid="explorer">
        <seg>De hecho, la anterior línea marcada &quot;desreferencia implícita&quot; funciona muy bien -en este caso- para hacer lo mismo que hacía el de desreferencia explícita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;given&gt;
and C&lt;when&gt; are used in Perl to implement C&lt;switch&gt;/C&lt;case&gt; like statements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103549Z" changeid="explorer">
        <seg>C&lt;given&gt; y C&lt;when&gt; se utilizan en Perl para implementar instrucciones parecidas a C&lt;switch&gt;/C&lt;case&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unshift EXPR,LIST</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183721Z" changeid="explorer">
        <seg>=item unshift EXPR,LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now there's indeed something following &quot;AB&quot; that is not
&quot;123&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171209Z" changeid="explorer">
        <seg>Ahora hay realmente algo después de &quot;AB&quot; que no es &quot;123&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { unimplemented() };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { no_implementado() };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On ASCII platforms, the resulting characters from the list above are the
complete set of ASCII controls.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204934Z" changeid="explorer">
        <seg>En las plataformas ASCII, los caracteres resultantes de la lista anterior son el conjunto completo de los caracteres de control ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Cygwin 1.5 the F&lt;io/tell&gt; and F&lt;op/sysio&gt; tests have failures for
some yet unknown reason.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003259Z" changeid="explorer">
        <seg>En Cygwin 1.5 las pruebas F&lt;io/tell&gt; y F&lt;op/sysio&gt; tienen fallas por alguna razón aún desconocida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With that trick MakeMaker will only read the first line and thus read
the underscore, while the perl interpreter will evaluate the $VERSION
and convert the string into a number.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025847Z" changeid="explorer">
        <seg>Con este truco MakeMaker sólo leerá la primera línea y, por tanto, leerá el guión bajo, mientras que el intérprete de perl evaluará la $VERSION y convertirá la cadena en un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlink &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlink &quot;alfa&quot;, &quot;beta&quot;, &quot;gamma&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect of C&lt;push&gt; is considered highly experimental.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T180451Z" changeid="explorer">
        <seg>Este aspecto de C&lt;push&gt; es considerado altamente experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;~~&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;~~&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select STDERR; $| = 1;  # make unbuffered</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110307T000411Z" changeid="explorer">
        <seg>select STDERR; $| = 1;  # hacerlo sin búfer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the &quot;^&quot; character is guaranteed to match only the
beginning of the string, the &quot;$&quot; character only the end (or before the
newline at the end), and Perl does certain optimizations with the
assumption that the string contains only one line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto, el carácter &quot;^&quot; garantiza que coincidirá solo con el principio de la cadena, el carácter &quot;$&quot; solo con el final (o antes del nueva línea del final) y Perl hará ciertas optimizaciones asumiendo que la cadena solo contiene una línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To sort a hash by value, you'll need to use a C&lt;sort&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ordenar un hash por valor, necesitará usar la función C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array   =&gt;  {
                     description =&gt; &quot;ordered list of items&quot;,
                     sigil =&gt; '@',
                    },</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T214345Z" changeid="explorer">
        <seg>array   =&gt;  {
                     descripcion =&gt; &quot;lista ordenada de elementos&quot;,
                     sigilo =&gt; '@',
                    },</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\p{}&gt; did not imply
Unicode rules, and neither did all occurrences of C&lt;\N{}&gt;, until 5.12.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T000638Z" changeid="explorer">
        <seg>C&lt;\p{}&gt; no implica reglas Unicode, y tampoco todas las apariciones de C&lt;\N{}&gt;, hasta 5.12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>v-strings as they currently exist are scheduled to be deprecated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T005527Z" changeid="explorer">
        <seg>Los v-strings, tal como existen en la actualidad, está previsto que sean descartados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a bit exotic, that last one</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Un poco exótico, este último</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;regex, capture buffer&gt; X&lt;regexp, capture buffer&gt;
X&lt;regex, capture group&gt; X&lt;regexp, capture group&gt;
X&lt;regular expression, capture buffer&gt; X&lt;backreference&gt;
X&lt;regular expression, capture group&gt; X&lt;backreference&gt;
X&lt;\g{1}&gt; X&lt;\g{-1}&gt; X&lt;\g{name}&gt; X&lt;relative backreference&gt; X&lt;named backreference&gt;
X&lt;named capture buffer&gt; X&lt;regular expression, named capture buffer&gt;
X&lt;named capture group&gt; X&lt;regular expression, named capture group&gt;
X&lt;%+&gt; X&lt;$+{name}&gt; X&lt;&lt; \k&lt;name&gt; &gt;&gt;
There is no limit to the number of captured substrings that you may use.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T001443Z" changeid="explorer">
        <seg>X&lt;regex, búfer captura&gt; X&lt;regexp, búfer captura&gt;
X&lt;regex, grupo captura&gt; X&lt;regexp, grupo captura&gt;
X&lt;expresión regular, búfer captura&gt; X&lt;contrareferencia&gt;
X&lt;expresión regular, grupo captura&gt;
X&lt;\g{1}&gt; X&lt;\g{-1}&gt; X&lt;\g{nombre}&gt; X&lt;contrareferencia relativa&gt; X&lt;contrareferencia nombre&gt;
X&lt;búfer captura nombre&gt; X&lt;expresión regular, búfer captura nombre&gt;
X&lt;grupo captura nombre&gt; X&lt;expresión regular, grupo captura nombre&gt;
X&lt;%+&gt; X&lt;$+{nombre}&gt; X&lt;&lt; \k&lt;nombre&gt; &gt;&gt;
No hay límite al número de subcadenas capturadas que puede usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function semctl(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC semctl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no need to do an interactive configure, just type</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214349Z" changeid="explorer">
        <seg>No hay necesidad de hacer un sistema interactivo para hacer la configuración, sólo tiene que escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Date::Calc qw( Today_and_Now Add_Delta_DHMS );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225526Z" changeid="explorer">
        <seg>use Date::Calc qw( Today_and_Now Add_Delta_DHMS );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A little interface to ExtUtils::Installed to examine installed modules,
validate your packlists and even create a tarball from an installed module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235338Z" changeid="explorer">
        <seg>Esta utilidad ofrece una interfaz sencilla de ExtUtils::Installed, que permite examinar módulos instalados, validar las listas de paquetes e incluso crear un archivo de almacenamiento tar a partir de un módulo instalado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't be
tempted to write</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215650Z" changeid="explorer">
        <seg>No caiga en la tentación de escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be descriptive (i.e. accurately describes the purpose of the module).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015259Z" changeid="explorer">
        <seg>Sea descriptivo (es decir, describa con precisión el propósito del módulo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End_Lines</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fin_Lineas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0  &quot;george&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032550Z" changeid="explorer">
        <seg>0  &quot;george&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %hash;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225618Z" changeid="explorer">
        <seg>my %hash;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose is to help you build Perl for UTS, which, if you
follow these instructions, should be easy, and result in
a solidly working installation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T213702Z" changeid="explorer">
        <seg>El propósito es ayudar a construir Perl para UTS, que, si se siguen estas instrucciones, debería ser fácil, y el resultado ser una instalación sólida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Bigger Numbers
X&lt;number, arbitrary precision&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T011326Z" changeid="explorer">
        <seg>=head2 Grandes números
X&lt;number, arbitrary precision&gt; X&lt;número, precisión arbitraria&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;5: got $1\n&quot; if $x =~ /^(\D*)(?=\d)(?!123)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171616Z" changeid="explorer">
        <seg>print &quot;5: tenemos $1\n&quot; if $x =~ /^(\D*)(?=\d)(?!123)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The private data cache will take ownership of a reference to private_sv,
much the same way that C&lt;hv_store()&gt; takes ownership of a reference to the
value that you pass it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115334Z" changeid="explorer">
        <seg>El caché privado de datos se apropiará de una referencia a private_sv, de la misma manera que C&lt;hv_store()&gt; toma la propiedad de una referencia al valor que usted le pasa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The full dispatch table for the smart match operator is given in
L&lt;perlsyn/&quot;Smart matching in detail&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T161305Z" changeid="explorer">
        <seg>La tabla de combinaciones para el operador de coincidencia inteligente está en L&lt;perlsyn/&quot;Coincidencia inteligente en detalle&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For
example, see L&lt;perlrebackslash/Octal escapes&gt;.)  Starting in Perl 5.14, you may
use C&lt;\o{}&gt; instead, which avoids all these problems.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232240Z" changeid="explorer">
        <seg>(Por ejemplo, vea L&lt;perlrebackslash/Secuencias de escape octales&gt;.) A partir de Perl v5.14, puede utilizar en su lugar C&lt;\o{}&gt;, toda vez que evita todos estos problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item  C&lt;m''&gt;, the pattern of C&lt;s'''&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item  C&lt;m''&gt;, y el patrón de C&lt;s'''&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/Math/BigInt/t/bigfltpm.........Use of uninitialized value ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214800Z" changeid="explorer">
        <seg>lib/Math/BigInt/t/bigfltpm.........Use of uninitialized value ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value C&lt;LVALUE&gt; indicates a reference to an lvalue that is not
a variable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T202415Z" changeid="explorer">
        <seg>El valor de retorno C&lt;LVALUE&gt; indica una referencia a un I&lt;ivalor&gt; (valor que se pone a la izquierda) que no es una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that none of the above are supposed to write your code for you:
asking questions about particular problems or general advice is fine,
but asking someone to write your code for free is not very cool.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230630Z" changeid="explorer">
        <seg>Tenga en cuenta que en ninguno de estos sitios van a hacer su trabajo; puede pedir consejo o hacer preguntas sobre problemas concretos, pero no espere que le escriban el código gratis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parent directory (/tmp/) is not safe (sticky bit not set</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Parent directory (/tmp/) is not safe (sticky bit not set</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rand 10 * 20;	# rand (10 * 20)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>rand 10 * 20;	# rand (10 * 20)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[]    anon.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224142Z" changeid="explorer">
        <seg>[]    ref. array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember the following important rule: There is B&lt;no rule&gt; that relates
the behavior of an expression in list context to its behavior in scalar
context, or vice versa.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recuerde la siguiente regla importante: B&lt;No hay regla&gt; que relacione el comportamiento de una expresión en contexto lista a su comportamiento en contexto escalar, o viceversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hh          interpret integer as C type &quot;char&quot; or &quot;unsigned char&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181432Z" changeid="explorer">
        <seg>hh          interpreta un entero como un &quot;char&quot; o &quot;unsigned char&quot; del C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array is given scalar context,
and instead of using the 0th element of the array as the format, Perl will
use the count of elements in the array as the format, which is almost never
useful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El array se le da en contexto escalar, y en lugar de utilizar el elemento 0 del array como el formato, Perl usará el número de elementos del array como el formato, que casi nunca es útil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What you need to do is get a binary version of C&lt;gcc&gt; for your system
first.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225817Z" changeid="explorer">
        <seg>Lo primero que debe hacer es obtener una versión binaria de C&lt;gcc&gt; para su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the mostly deeply nested array or hash will not spring into
existence just because its existence was tested, any intervening ones will.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015116Z" changeid="explorer">
        <seg>Aunque el array o hash más profundamente anidado no se autovivifique sólo por que su existencia sea comprobada, cualquiera de los niveles intermedios sí que lo hará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is supported it usually encodes some
administrative comment about the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está soportado usualmente codifica algún comentario administrativo sobre el usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @ints, grep vec($vec, $_, 1), $-[0] * 8 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>push @ints, grep vec($vec, $_, 1), $-[0] * 8 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You certainly won't be chastised if you don't
trust nuclear-plant or brain-surgery monitoring code to it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231301Z" changeid="explorer">
        <seg>Nadie le reprochará que no lo utilice para desarrollar código de control de centrales nucleares o neurocirugía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lowercase line-noise MiXeD line-noise.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205754Z" changeid="explorer">
        <seg>minúsculas línea-ruido MeZcLaDoS línea-ruido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or the loop implied by split().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230802Z" changeid="explorer">
        <seg>o el bucle implícito de split().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>was misleading because the &quot;other&quot; included also the thread giving
the warning.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001536Z" changeid="explorer">
        <seg>era engañoso, porque los &quot;otros&quot; incluían también al hilo que daba la advertencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Will raise an exception if used on a machine that
doesn't implement getpgrp(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elevará una excepción si se usa en una máquina que no implemente getpgrp(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sb = stat($filename);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$sb = stat($archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tr///</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item tr///</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># sort using explicit subroutine name</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ordena usando un nombre de una subrutina explícita</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sequence   Note    Description</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110220T230159Z" changeid="explorer">
        <seg>Secuencia  Nota    Descripción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that since Perl 5.8.1 the single-number v-strings (like C&lt;v65&gt;)
are not v-strings before the C&lt;&lt; =&gt; &gt;&gt; operator (which is usually used
to separate a hash key from a hash value); instead they are interpreted
as literal strings ('v65').</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T145703Z" changeid="explorer">
        <seg>Tenga en cuenta que desde Perl 5.8.1 los v-string de un solo número (como C&lt;v65&gt;) no son v-strings delante del operador C&lt;&lt; =&gt; &gt;&gt; (que se utiliza normalmente para separar una clave hash de un valor hash), sino que se interpretan como cadenas literales ('v65').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item alarm</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item alarm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of EXPR indicates how many call frames
to go back before the current one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de EXPR indica cuántos marcos de llamada se ha de retroceder antes del actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yet another cross-compilation option has been added: now Perl builds
on OpenZaurus, an Linux distribution based on Mandrake + Embedix for
the Sharp Zaurus PDA.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010017Z" changeid="explorer">
        <seg>Se ha agregado otra opción de compilación cruzada: ahora Perl se compila en OpenZaurus, una distribución Linux basada en Mandrake + Embedix para la PDA Sharp Zaurus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pain was intensified by the Unicode implementation of Perl 5.8.0
(still) having nasty bugs, especially related to the use of s/// and
tr///.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T144311Z" changeid="explorer">
        <seg>El dolor se intensificó por que la implementación de Unicode de Perl 5.8.0 (todavía) tenía errores desagradables, especialmente en relación con el uso de s// y tr///.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;lt&quot; returns true if the left argument is stringwise less than
the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;lt&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente menor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the length in I&lt;characters&gt; of the value of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la longitud en I&lt;caracteres&gt; del valor de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>no warnings 'deprecated';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T010825Z" changeid="explorer">
        <seg>no warnings 'deprecated';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use if WANT_WARNINGS, warnings =&gt; qw(all);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use if WANT_WARNINGS, warnings =&gt; qw(all);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(EXPR should be positive.)  If EXPR is
omitted, the value C&lt;1&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(EXPR debe ser positiva). Si EXPR se omite, se usa el valor C&lt;1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/Capture groups&gt; below for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045047Z" changeid="explorer">
        <seg>Vea más abajo L&lt;/Búfer de captura&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2  &quot;elroy&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032552Z" changeid="explorer">
        <seg>2  &quot;elroy&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tolkien quotes at the head of C source file have been checked and
proper citations added, thanks to a patch from Tom Christiansen.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005934Z" changeid="explorer">
        <seg>Tolkien al principio del archivo fuente en C han sido verificadas y añadido referencias apropiadas, gracias a un parche de Tom Christiansen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/$rex/foo/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/$rex/foo/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backslashed metacharacters in Perl are alphanumeric, such as C&lt;\b&gt;,
C&lt;\w&gt;, C&lt;\n&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Metacaracteres escapados en Perl son alfanuméricos, como C&lt;\b&gt;, C&lt;\w&gt;, C&lt;\n&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.005-style threads (activated by C&lt;use Thread;&gt;) were deprecated in
Perl 5.8.0 and will be removed after Perl 5.8, see L&lt;perl58delta&gt; for
details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011154Z" changeid="explorer">
        <seg>Los I&lt;threads&gt; estilo 5.005 (activados con C&lt;use Thread;&gt;) fueron desaprobados en Perl 5.8.0 y serán eliminados después de Perl 5.8, vea L&lt;perl58delta&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %h = ( FOO =&gt; 23 );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my %h = ( FOO =&gt; 23 );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Probably the best thing to do is try to write equivalent code to do a
set of tasks.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230741Z" changeid="explorer">
        <seg>Probablemente lo mejor sea escribir código equivalente para realizar una serie de tareas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughout the previous section all the examples have used the syntax:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T231620Z" changeid="zipf">
        <seg>En todos los ejemplos de la sección anterior se utilizó esta sintaxis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to minor cleanup
of questionable expressions in F&lt;vms.c&gt;, file permissions should no longer be
garbled by the PerlIO layer, and spurious record boundaries should no longer be
introduced by the PerlIO layer during output.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230828Z" changeid="explorer">
        <seg>Además de una limpieza de menor importancia de cuestionables expresiones en F&lt;vms.c&gt;, los permisos de archivo ya no deberían ser distorsionados por la capa PerlIO, y los espurios límites de registro ya no deberían ser introducidos por la capa PerlIO durante la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In IRIX 5.3 and with Perl 5.8.1 (Perl 5.8.0 didn't compile in IRIX 5.3)
the following failures are known.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T002135Z" changeid="explorer">
        <seg>En IRIX 5.3 y con Perl 5.8.1 (Perl 5.8.0 no compila en IRIX 5.3) se conocen los siguientes errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values are returned in an apparently random order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores son devueltos en un aparente orden aleatorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A few of these are
good, some are OK, but many aren't worth your money.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T002843Z" changeid="explorer">
        <seg>Algunos son buenos y otros aceptables, pero muchos no merecen la pena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C&lt;exec&gt;, C&lt;system&gt; allows you to lie to a program about its name if
you use the C&lt;system PROGRAM LIST&gt; syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que C&lt;exec&gt;, C&lt;system&gt; permite reposar a un programa bajo un nombre, si se utiliza la sintaxis C&lt;system PROGRAMA LISTA&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment to a
scalar evaluates the right-hand side in scalar context, while
assignment to an array or hash evaluates the righthand side in list
context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La asignación a un escalar evalúa lo que hay en el lado derecho en contexto escalar, mientras que la asignación a un array o a un hash evalúa el lado derecho en contexto de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use IPC::SysV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use IPC::SysV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -le '$i++ while getpwuid($i); print $i'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225503Z" changeid="explorer">
        <seg>perl -le '$i++ while getpwuid($i); print $i'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
$quota is unsupported, it is an empty scalar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la $cuota no está soportada, es un escalar vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;enc2xs&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234547Z" changeid="explorer">
        <seg>=item L&lt;enc2xs&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -le '$a = &quot;NaN&quot;; print &quot;NaN support here&quot; if $a != $a'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl -le '$a = &quot;NaN&quot;; print &quot;tiene soporte NaN&quot; if $a != $a'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DELETE this, key</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DELETE este, clave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other escape sequences such as C&lt;\200&gt; and C&lt;\t&gt; and backslashed
characters such as C&lt;\\&gt; and C&lt;\-&gt; are converted to appropriate literals.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las otras secuencias de escape, como C&lt;\200&gt; y C&lt;\t&gt; y caracteres escapados con contrabarras, como C&lt;\\&gt; y C&lt;\-&gt;, son convertidas a literales apropiados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pattern matches nothing and always fails.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T143626Z" changeid="explorer">
        <seg>Este patrón no coincide con nada y fallará siempre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If necessary run just the failing scripts
again sequentially and see if the failures go away.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T002804Z" changeid="explorer">
        <seg>Si es necesario ejecute los scripts una vez más de forma secuencial y mire a ver si los errores desaparecen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The oct() function is commonly used when a string such as C&lt;644&gt; needs
to be converted into a file mode, for example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función oct() es de uso común cuando una cadena como C&lt;644&gt; tiene que ser convertida en un modo de archivo, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Craig A. Berry, David Golden, David Leadbeater, Father Chrysostomos, Florian
Ragwitz, Jesse Vincent, Karl Williamson, Nick Johnston, Nicolas Kaiser, Paul
Green, Rafael Garcia-Suarez, Rainer Tammer, Ricardo Signes, Steffen Mueller,
ZsbÃ¡n Ambrus, Ãvar ArnfjÃ¶rÃ° Bjarmason</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T231235Z" changeid="explorer">
        <seg>Craig A. Berry, David Golden, David Leadbeater, Father Chrysostomos, Florian
Ragwitz, Jesse Vincent, Karl Williamson, Nick Johnston, Nicolas Kaiser, Paul
Green, Rafael Garcia-Suarez, Rainer Tammer, Ricardo Signes, Steffen Mueller,
ZsbÃ¡n Ambrus, Ãvar ArnfjÃ¶rÃ° Bjarmason</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead it is
primarily used to check if two pieces of text are the same without
having to transmit or store the text itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En cambio se usa principalmente para comprobar si dos trozos de textos son el mismo sin tener que transmitirlo o almacenarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not doing so may lead to surprises:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T125347Z" changeid="explorer">
        <seg>El no hacerlo puede dar lugar a sorpresas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the peculiar C&lt;use VERSION&gt; form, VERSION may be either a positive
decimal fraction such as 5.006, which will be compared to C&lt;$]&gt;, or a v-string
of the form v5.6.1, which will be compared to C&lt;$^V&gt; (aka $PERL_VERSION).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la forma peculiar C&lt;use VERSION&gt;, VERSION puede ser tanto un número fraccionario decimal positivo, como 5.006, que será comparado con C&lt;$]&gt;, o como una v-cadena de la forma v5.6.1, que será comparado con C&lt;$^V&gt; (también conocido como $PERL_VERSION).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Despite the funny
names, precedence is the same as any other named unary operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A pesar de los nombres graciosos, la precedencia es la misma que cualquier otro operador unario con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Fall-through</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Atravesar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.pm.org/         the Perl Mongers</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001559Z" changeid="explorer">
        <seg>http://www.pm.org/         el sitio de Perl Mongers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you were into Schwartzian Transforms, you would probably
have selected map for that</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T195313Z" changeid="explorer">
        <seg>Si está en una transformada Schwartziana, es probable que haya elegido map para esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not worry, you've apparently got the
ASCII-&gt;EBCDIC translation worked out correctly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se preocupe, parecer que le funcionó correctamente la traducción EBCDIC-&gt;ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wait $child_pid;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005950Z" changeid="explorer">
        <seg>wait $child_pid;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     undef     undefined                !defined $a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  undef      indefinido                       !defined $a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die q(I don't know what to do with $foo);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die q(No sé qué hacer con $foo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;RE&gt; in C&lt;?RE?&gt;, C&lt;/RE/&gt;, C&lt;m/RE/&gt;, C&lt;s/RE/foo/&gt;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item C&lt;RE&gt; en C&lt;?RE?&gt;, C&lt;/RE/&gt;, C&lt;m/RE/&gt;, C&lt;s/RE/foo/&gt;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;defined&gt; X&lt;undefined&gt; X&lt;undef&gt; X&lt;null&gt; X&lt;string, null&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;defined&gt; X&lt;definido&gt; X&lt;undefined&gt; X&lt;indefinido&gt; X&lt;undef&gt; X&lt;null&gt; X&lt;nulo&gt; X&lt;string, null&gt; X&lt;cadena, nulo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;charnames&gt; upgraded to version 1.05</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025609Z" changeid="explorer">
        <seg>C&lt;charnames&gt; actualizado a la versión 1.05</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T225446Z" changeid="explorer">
        <seg>único</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\z  Match only at end of string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225912Z" changeid="explorer">
        <seg>\z  Coincide solo con el final de la cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef   Hash      always false (undef can't be a key)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef       Hash       siempre falso (undef no puede ser una clave)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should seldom if ever use C&lt;0644&gt; as argument to C&lt;sysopen&gt;, because
that takes away the user's option to have a more permissive umask.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Rara vez o nunca debe utilizar C&lt;0644&gt; como argumento a C&lt;sysopen&gt;, porque eso le quita al usuario la opción de tener un umask más permisivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl 5 smart match and C&lt;given&gt;/C&lt;when&gt; constructs are not
absolutely identical to their Perl 6 analogues.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La coincidencia inteligente de Perl 5 y las construcciones C&lt;given&gt;/C&lt;when&gt; no son completamente idénticas a sus análogas en Perl 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At other times, a simple comparison to C&lt;0&gt; or C&lt;&quot;&quot;&gt; is
what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras ocasiones, una simple comparación con C&lt;0&gt; o C&lt;&quot;&quot;&gt; es lo que necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$VERSION = eval $VERSION;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025739Z" changeid="explorer">
        <seg>$VERSION = eval $VERSION;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically these are arguments such as might be passed
to the C&lt;dbm_open()&gt; function of C.  The object returned by the C&lt;new&gt;
method is also returned by the C&lt;tie&gt; function, which would be useful
if you want to access other methods in CLASSNAME.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo general estos son argumentos que pudieran ser transmitidos a la función del C C&lt;dbm_open()&gt;. El objeto devuelto por el método C&lt;new&gt; también es devuelto por la función C&lt;tie&gt;, que será útil si desea tener acceso a otros métodos en CLASE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gethostbyname NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gethostbyname NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has two
effects: first, a C&lt;write&gt; or a C&lt;print&gt; without a filehandle 
default to this FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013327Z" changeid="explorer">
        <seg>Esto tiene dos efectos: primero, un C&lt;write&gt; o un C&lt;print&gt; sin un identificador de archivo será por defecto este IDENTIFICADOR_ARCHIVO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmodinstall	Perl modules: how to install from CPAN</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000440Z" changeid="explorer">
        <seg>perlmodinstall	Instalación de módulos de CPAN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything else is unsafe.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier otro caso no es seguro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The right operand is not evaluated while the operator is in the
&quot;false&quot; state, and the left operand is not evaluated while the
operator is in the &quot;true&quot; state.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operando de la derecha no es evaluado, mientras que el operador esté en el estado &quot;falso&quot;, y el operando de la izquierda no es evaluado mientras que el operador se encuentre en el estado &quot;verdadero&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5137delta	Perl changes in version 5.13.7</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141343Z" changeid="explorer">
        <seg>perl5137delta	Cambios en la versión 5.13.7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$^ = 'report1_top';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$^ = 'informe1_top';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning to C&lt;$#days&gt; actually changes the length of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Asignar un valor a C&lt;$#días&gt; cambia realmente la longitud del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But never write &quot;PERL&quot;,
because perl is not an acronym, apocryphal folklore and post-facto
expansions notwithstanding.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231619Z" changeid="explorer">
        <seg>Pero nunca escriba &quot;PERL&quot;, ya que perl no es un acrónimo (pese al folclore apócrifo y los desarrollos inventados posteriormente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?&lt;!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025530Z" changeid="explorer">
        <seg>(?&lt;!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item index STR,SUBSTR,POSITION
X&lt;index&gt; X&lt;indexOf&gt; X&lt;InStr&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173951Z" changeid="explorer">
        <seg>=item index STRING,SUBSTR,POSICIÓN
X&lt;index&gt; X&lt;indexOf&gt; X&lt;InStr&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;3: got $1\n&quot; if $x =~ /^(\D*)(?!123)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170229Z" changeid="explorer">
        <seg>print &quot;3: tenemos $1\n&quot; if $x =~ /^(\D*)(?!123)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are documented at great length in L&lt;perlre&gt;, but for
the meantime, here's a quick cheat sheet:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225424Z" changeid="explorer">
        <seg>Estas se describen de forma detallada en L&lt;perlre&gt;. A continuación se incluye una guía rápida:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $j = int rand ($i+1);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225556Z" changeid="explorer">
        <seg>my $j = int rand ($i+1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The caching of conversions (as described above) means that the integer
conversion does not throw away fractional parts on floating point numbers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T233927Z" changeid="explorer">
        <seg>El almacenamiento en caché de las conversiones descritas arriba significa que la conversión a enteros no desecha las partes fraccionarias en los números de punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while($vec =~ /[^\0]/g ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>while($vec =~ /[^\0]/g ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX qw/mktime strftime/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225522Z" changeid="explorer">
        <seg>use POSIX qw/mktime strftime/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt; (possibly paired with C&lt;\E&gt;) are
converted to corresponding Perl constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt; (posiblemente emparejado con C&lt;\E&gt;) son convertidas a las correspondientes construcciones Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(whichever was last seen)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232630Z" changeid="explorer">
        <seg>(lo que se haya visto por última vez)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The smart match operator C&lt;~~&gt; is no longer commutative.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233555Z" changeid="explorer">
        <seg>El operador de coincidencia inteligente C&lt;~~&gt; ya no es conmutativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the new C&lt;and&gt; and C&lt;or&gt; operators to avoid having to parenthesize
list operators so much, and to reduce the incidence of punctuation
operators like C&lt;&amp;&amp;&gt; and C&lt;||&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use los nuevos operadores C&lt;and&gt; y C&lt;or&gt; para evitar poner demasiados paréntesis en listas de operadores y para reducir la incidencia de puntuación de operadores como C&lt;&amp;&amp;&gt; y C&lt;||&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say $AoA[2][1];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T025911Z" changeid="explorer">
        <seg>say $AoA[2][1];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are
I&lt;strongly&gt; advised to follow this introduction with more information
from the full Perl manual, the table of contents to which can be found
in L&lt;perltoc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224548Z" changeid="explorer">
        <seg>Es I&lt;muy&gt; recomendable complementar esta introducción con información del manual de Perl completo, cuya tabla de contenido se encuentra en L&lt;perltoc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 0-596-10206-2 [1st edition March 2006]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003346Z" changeid="explorer">
        <seg>ISBN 0-596-10206-2 [1ª edición - Marzo de 2006]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>no strict 'refs';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no strict 'refs';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The joke is that it's scheduled for Christmas, but that we
just don't know which one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004302Z" changeid="explorer">
        <seg>Decimos en broma que saldrá en Navidad, pero no confirmamos el año de lanzamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Elvis</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item Elvis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/binmode&gt;, L&lt;/open&gt;, and the C&lt;open&gt; pragma, L&lt;open&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/binmode&gt;, L&lt;/open&gt;, y el pragma C&lt;open&gt;, L&lt;open&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only
universally recognized values for EXPR are C&lt;0&gt; for success and C&lt;1&gt;
for error; other values are subject to interpretation depending on the
environment in which the Perl program is running.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los únicos valores universalmente reconocidos para EXPR son C&lt;0&gt; para éxito y C&lt;1&gt; para error; otros valores están sujetos a interpretación dependiendo del entorno en que el programa Perl está corriendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use v5.14;   # needed for implicit deref of array refs by array ops</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031519Z" changeid="explorer">
        <seg>use v5.14;   # necesario para una desref. implícita de ref. de array para oper. de array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item when EXPR BLOCK
X&lt;when&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T025058Z" changeid="explorer">
        <seg>=item when EXPR BLOQUE
X&lt;when&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decoding can't happen reliably if you don't know how the data was encoded.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235056Z" changeid="explorer">
        <seg>No es posible descodificar de manera fiable si no se sabe cómo se codificaron los datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Devel::PPPort</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Devel::PPPort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No further attempts
to find a valid match by advancing the start pointer will occur again.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T142054Z" changeid="explorer">
        <seg>No habrá nuevos intentos para encontrar una coincidencia válida avanzando el puntero de arranque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[\000-\177];		# wickedly delete 8th bit</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T032606Z" changeid="explorer">
        <seg>[\000-\177];		# borra onerosamente el octavo bit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Unicode Character Database 4.0.1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T103501Z" changeid="explorer">
        <seg>=head2 Unicode Character Database 4.0.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Unicode Character Database 4.0.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170656Z" changeid="explorer">
        <seg>=head2 Unicode Character Database 4.0.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;   sSiIlLqQ   Force little-endian byte-order on the type.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;   sSiIlLqQ   Fuerza un orden de bytes en little-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item abs</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item abs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, C&lt;stat&gt; returns a boolean value indicating success
or failure, and, if successful, sets the information associated with
the special filehandle C&lt;_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012732Z" changeid="explorer">
        <seg>En contexto escalar, C&lt;stat&gt; devuelve un valor booleano que indica el éxito o el fracaso y, si tiene éxito, establece la información asociada con el identificador de archivo especial C&lt;_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true for
success, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero en caso de éxito, o falso en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;not&gt; for a lower
precedence version of this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220015Z" changeid="explorer">
        <seg>Vea también C&lt;not&gt; para una versión de menor prioridad que ésta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Change to &quot;Can't locate Foo.pm in @INC&quot; error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Cambiado el error &quot;Can't locate Foo.pm in @INC&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Text strings (character strings)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234511Z" changeid="explorer">
        <seg>=head3 Cadenas de texto (cadenas de caracteres)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A semicolon is still encouraged if the
block takes up more than one line, because you may eventually add
another line.)  Note that there are some operators like C&lt;eval {}&gt; and
C&lt;do {}&gt; that look like compound statements, but aren't (they're just
TERMs in an expression), and thus need an explicit termination if used
as the last item in a statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012953Z" changeid="explorer">
        <seg>(Un punto y coma es aún así recomendable si el bloque tiene más de una línea, porque, eventualmente, puede añadir alguna línea más). Note que algunos operadores como C&lt;eval {}&gt; y C&lt;do {}&gt; parecen instrucciones compuestas, pero no lo son (son sólo TÉRMINOS en una expresión) y es necesario una terminación explícita si se usa como el último punto de una instrucción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the filehandle came from a piped open, C&lt;close&gt; returns false if one of
the other syscalls involved fails or if its program exits with non-zero
status.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005647Z" changeid="explorer">
        <seg>Si el identificador de archivo proviene de una tubería abierta, C&lt;close&gt; adicionalmente devolverá falso si alguna de las otras llamadas del sistema implicadas falla, o si el programa termina con un valor de estado distinto de cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.*?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>.*?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also a simple rule that works
consistently with C&lt;VAR_NAMES_LIKE_THIS&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es una regla que funciona también con C&lt;VAR_NOMBRES_COMO_ESTE&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Win32, S&lt;Plan 9&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014905Z" changeid="explorer">
        <seg>(Win32, S&lt;Plan 9&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Deprecation Warnings</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T010056Z" changeid="explorer">
        <seg>=head2 Advertencias de desaprobación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/     \# [ \t]*   ( [^ \t] .* ) /x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002938Z" changeid="explorer">
        <seg>/     \# [ \t]*   ( [^ \t] .* ) /x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not form legal quoted expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no forman expresiones legales de entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bart</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>bart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#        produces 123456789123456784</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#        produce 123456789123456784</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example, the third line above produces:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, la tercera línea de arriba produce:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>% perl -V</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225436Z" changeid="explorer">
        <seg>% perl -V</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way to describe which substring is
actually matched is the concept of backtracking (see L&lt;&quot;Backtracking&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T233939Z" changeid="explorer">
        <seg>Una forma de describir qué subcadena coincidente realmente, es con el concepto de dar marcha atrás (vea L&lt;&quot;Marcha atrás&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 mode     file mode  (type and permissions)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2 mode     modo de archivo (tipo y permisos)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instead of</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014356Z" changeid="explorer">
        <seg>en lugar de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support fchown(2), passing filehandles raises
an exception.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005415Z" changeid="explorer">
        <seg>En sistemas que no admiten fchown(2), pasarle un identificador de archivo lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Include tests with your module</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014141Z" changeid="explorer">
        <seg>Incluya test con su módulo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item perl Build</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025001Z" changeid="explorer">
        <seg>=item perl Build</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item truncate FILEHANDLE,LENGTH
X&lt;truncate&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013247Z" changeid="explorer">
        <seg>=item truncate IDENTIFICADOR_ARCHIVO,LONGITUD
X&lt;truncate&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So instead of</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que en lugar de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $/ = &quot;&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025139Z" changeid="explorer">
        <seg>local $/ = &quot;&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only available after Perl 5.10, and only if the
C&lt;switch&gt; feature has been requested.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T232523Z" changeid="explorer">
        <seg>Sólo está disponible después de Perl 5.10, y sólo si la característica C&lt;switch&gt; ha sido solicitada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Irrespective of its distribution, all code examples here are in the public
domain.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232613Z" changeid="explorer">
        <seg>Independientemente de su distribución, todos los ejemplos de código incluidos son de dominio público.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your module should also include a README file describing the module and
giving pointers to further information (website, author email).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024829Z" changeid="explorer">
        <seg>El módulo también debe incluir un archivo README que describa el módulo y dé consejos para obtener más información (página web, correo electrónico del autor).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ld:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004644Z" changeid="explorer">
        <seg>ld:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if it succeeded, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tiene éxito; de lo contrario, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document differs from L&lt;perlnewmod&gt; in that it is a style guide
rather than a tutorial on creating CPAN modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013022Z" changeid="explorer">
        <seg>Este documento se diferencia de L&lt;perlnewmod&gt; en que se trata de una guía de estilo en lugar de un manual sobre la creación de módulos de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$path =~ s|/usr/bin|/usr/local/bin|;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ruta =~ s|/usr/bin|/usr/local/bin|;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only one timer may be counting at once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo un temporizador puede estar contando cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function should return a reference to an array containing the parent
classes in order.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114540Z" changeid="explorer">
        <seg>La función debe devolver una referencia a una array que contiene las clases padres en orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has now
been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015426Z" changeid="explorer">
        <seg>Este error ya se ha solucionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stay tuned, but don't worry that you'll
have to change major versions of Perl; no one is going to take Perl 5
away from you.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004307Z" changeid="explorer">
        <seg>Puede seguir su desarrollo, pero no debe preocuparse por tener que actualizar Perl; nadie va a quitarle Perl 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HASH is the name of the hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>HASH es el nombre del hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $nodelay = unpack(&quot;I&quot;, $packed);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $nodelay = unpack(&quot;I&quot;, $empaquetado);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considerations for module design and coding:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015618Z" changeid="explorer">
        <seg>Consideraciones para el diseño y codificación del módulo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;Maintainers&gt;, F&lt;Maintainers.pl&gt;, and F&lt;Maintainers.pm&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014819Z" changeid="explorer">
        <seg>=item * F&lt;Maintainers&gt;, F&lt;Maintainers.pl&gt; y F&lt;Maintainers.pm&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might even try the &quot;I feel lucky&quot; button.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232113Z" changeid="explorer">
        <seg>Incluso puede probar el botón &quot;Voy a tener suerte&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tie my $cycle, 'Tie::Cycle', [ qw( FFFFFF 000000 FFFF00 ) ];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>tie my $cycle, 'Tie::Cycle', [ qw( FFFFFF 000000 FFFF00 ) ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UNTIE this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>UNTIE este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C-generating compiler backend B::C (the frontend being
C&lt;perlcc -c&gt;) is even more broken than it used to be because of
the extensive lexical variable changes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003120Z" changeid="explorer">
        <seg>El soporte de compilador generador de C, B::C (la interfaz que hay por detrás de C&lt;perlcc -c&gt;) sigue estando aún más roto de lo que solía ser a causa de extensos cambios en las variables léxicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are intending to manipulate bitstrings, be certain that
you're supplying bitstrings: If an operand is a number, that will imply
a B&lt;numeric&gt; bitwise operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si tiene la intención de manipular cadenas de bits, asegúrese de que está suministrando cadenas de bits: si un operando es un número, esto implicará una operación binaria B&lt;numérica&gt; bit a bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows the constructs
such as C&lt;open(my $fh, ...)&gt; and C&lt;open(local $fh,...)&gt; to be used to
create filehandles that will conveniently be closed automatically when
the scope ends, provided there are no other references to them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003839Z" changeid="explorer">
        <seg>Esto permite que instrucciones como C&lt;open(my $fh, ...)&gt; y C&lt;open(local $fh,...)&gt; se utilicen para crear identificadores de archivo que convenientemente se cerrarán automáticamente cuando termine el ámbito de aplicación, siempre que no haya otras referencias a ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internal cleanup</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Limpieza interior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Mastering Perl/Tk&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003630Z" changeid="explorer">
        <seg>=item I&lt;Mastering Perl/Tk&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enhanced documentation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mejora en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmodlib&gt; for a list of standard modules and pragmas.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmodlib&gt; para una lista de módulos y pragmas estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note for Linux users: on Linux, the C functions C&lt;getpid()&gt; and
C&lt;getppid()&gt; return different values from different threads.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota para usuarios Linux: en Linux, las funciones C C&lt;getpid()&gt; y C&lt;getppid()&gt; devuelven valores diferentes para hilos (threads) diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s {foo}  # Replace foo</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s {foo}  # Reemplaza foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;Copyright Holder&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Titular del Copyright&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlreapi		Perl regular expression plugin interface</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlreapi		Interfaz de complementos: expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example
where side-effects of look-ahead I&lt;might&gt; have influenced the
following match, see L&lt;/C&lt;&lt; (?&gt;pattern) &gt;&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212026Z" changeid="explorer">
        <seg>Para ver un ejemplo de los efectos secundarios de las aserciones antecedentes que I&lt;pueden&gt; influir en la siguiente coincidencia, vea L&lt;/C&lt;&lt; (?&gt;patrón) &gt;&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're looking for the information on how to use here-documents,
which used to be here, that's been moved to
L&lt;perlop/Quote and Quote-like Operators&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T184803Z" changeid="explorer">
        <seg>Si está buscando por información de cómo usar documentos embebidos, que solía estar aquí, ha sido trasladada a L&lt;perlop/Comillas y Operadores de comillas&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can double the braces to make them such, though.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque puede doblar las llaves para crearlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Knuth, volume II, for a more robust treatment of
this topic.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver Knuth, volumen II, para un tratamiento más fuerte de este tema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no changes intentionally incompatible with 5.8.7.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T023818Z" changeid="explorer">
        <seg>No hay cambios intencionadamente incompatibles con 5.8.7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/&quot;$/&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/&quot;$/&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005150Z" changeid="explorer">
        <seg>=item chdir IDENTIFICADOR_ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for built-in IO functions, including command line arguments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014627Z" changeid="explorer">
        <seg>Pruebas de funciones de E/S predefinidas, incluidos los argumentos de línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;prove&gt; is part of Test::Harness, which users of earlier
Perl versions can install from CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;prove&gt; es parte de Test::Harness, que los usuarios de versiones anteriores de Perl pueden instalar desde CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @squares = map { $_ * $_ } @numbers;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171543Z" changeid="explorer">
        <seg>my @cuadrados = map { $_ * $_ } @numeros;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;\t [ @$aref ],&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031800Z" changeid="explorer">
        <seg>say &quot;\t [ @$aref ],&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LFS (large file support) tests (C&lt;t/op/lfs&gt; and C&lt;xt/Fcntl/t/syslfs&gt;) are
disabled as seeking beyond 2 GB is broken according to jhi@iki.fi who was the
last one checking the BeOS port and updating this file before me.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los test para LFS (I&lt;large file support&gt;, soporte para archivos grandes) (C&lt;t/op/lfs&gt; y C&lt;xt/Fcntl/t/syslfs&gt;) están deshabilitados, debido a que el posicionamiento a más de 2 GB falla, según jhi@iki.fi, que fue el último que controló la adaptación de BeOS y la actualización de este archivo antes de mí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In scalar context, it returns merely the first value produced.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En contexto escalar, devuelve sólo el primer valor producido).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub backwards ($$) { $_[1] cmp $_[0]; }  # $a and $b are not set here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub al_reves ($$) { $_[1] cmp $_[0]; }  # $a y $b no se usan aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically this is used like the normal
piped open when you want to exercise more control over just how the
pipe command gets executed, such as when running setuid and
you don't want to have to scan shell commands for metacharacters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Habitualmente esto se usa como el open entubado cuando quiere ejercer más control sobre cómo el comando entubado es ejecutado, como cuando se ejecuta con setuid y no quiero tener que escanear comandos del shell buscando metacaracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your module should run successfully under the strict pragma and should
run without generating any warnings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022948Z" changeid="explorer">
        <seg>Su módulo debe funcionar con éxito bajo el I&lt;pragma strict&gt; y debe funcionar sin generar ninguna advertencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future versions of Perl are likely
to eliminate these arbitrary limitations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las futuras versiones de Perl probablemente eliminarán estas limitaciones arbitrarias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Better yet, use the carefully constrained evaluation within a Safe
compartment.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T223233Z" changeid="explorer">
        <seg>Mejor aún, utilice la evaluación cuidadosamente limitada dentro de un compartimento de seguridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, this
does not mean that Perl can do operations only over integers in this range:
it is possible to store many more integers in floating point format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232611Z" changeid="explorer">
        <seg>Insistimos: esto no significa que Perl sólo puede realizar operaciones con enteros de este intervalo; es posible almacenar muchos más enteros en formato de punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$vec-&gt;Chunk_List_Store(3, split(//, reverse &quot;33653337357&quot;));</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225514Z" changeid="explorer">
        <seg>$vec-&gt;Chunk_List_Store(3, split(//, reverse &quot;33653337357&quot;));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; &lt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; &lt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($shift=0; $shift &lt; $width; ++$shift) {
            for ($off=0; $off &lt; 32/$width; ++$off) {
                $str = pack(&quot;B*&quot;, &quot;0&quot;x32);
                $bits = (1&lt;&lt;$shift);
                vec($str, $off, $width) = $bits;
                $res = unpack(&quot;b*&quot;,$str);
                $val = unpack(&quot;V&quot;, $str);
                write;
            }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052524Z" changeid="explorer">
        <seg>for ($shift=0; $shift &lt; $width; ++$shift) {
            for ($off=0; $off &lt; 32/$width; ++$off) {
                $str = pack(&quot;B*&quot;, &quot;0&quot;x32);
                $bits = (1&lt;&lt;$shift);
                vec($str, $off, $width) = $bits;
                $res = unpack(&quot;b*&quot;,$str);
                $val = unpack(&quot;V&quot;, $str);
                write;
            }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;We use ${who}speak when ${who}'s here.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Usamos un ${quien}_altavoz cuando $quien está aquí.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;h&gt; and C&lt;H&gt; formats pack a string that many nybbles (4-bit groups,
representable as hexadecimal digits, C&lt;&quot;0&quot;..&quot;9&quot;&gt; C&lt;&quot;a&quot;..&quot;f&quot;&gt;) long.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El formato C&lt;h&gt; y C&lt;H&gt; empaqueta una cadena con tantos nibles (grupos de 4 bits, representables como dígitos hexadecimales, C&lt;&quot;0&quot; .. &quot;9&quot;&gt; C&lt;&quot;a&quot; .. &quot;f&quot;&gt;) contenga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following guidelines may help you judge whether your API is
sufficiently straightforward:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020540Z" changeid="explorer">
        <seg>Las siguientes pautas pueden ayudar a juzgar si su API es suficientemente clara:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this means that its contents will be interpolated twice, so</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que esto significa que su contenido será interpolado dos veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Remove over-optimisation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044018Z" changeid="explorer">
        <seg>=head2 Eliminar el exceso de optimización</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsec		Perl security</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsec		Seguridad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;~0&gt; usually evaluates to a large
integral value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;~0&gt; por lo general se evalúa como un valor entero de gran tamaño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ld --help</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ld --help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$^V will also be a &quot;version object&quot; so the
printf(&quot;%vd&quot;,...) construct will no longer be needed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T005713Z" changeid="explorer">
        <seg>$^V también será un &quot;objeto de versión&quot;, por lo que la construcción printf(&quot;%vd&quot;,...) ya no será necesaria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dave Mitchell improved the lexer debugging output under C&lt;-DT&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051956Z" changeid="explorer">
        <seg>Dave Mitchell mejoró la salida de depura del analizador léxico con C&lt;-DT&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the packed sockaddr address of the other end of the SOCKET
connection.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T162125Z" changeid="explorer">
        <seg>Devuelve la dirección socket empaquetada del otro extremo de la conexión SOCKET.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators such as C&lt;**&gt;, C&lt;sin&gt; and C&lt;exp&gt; force arguments to floating point
format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234037Z" changeid="explorer">
        <seg>Algunos operadores, como C&lt;**&gt;, C&lt;sin&gt; y C&lt;exp&gt;, fuerzan la conversión de los argumentos al formato de punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may use C&lt;&amp;&gt; after C&lt;&lt; &gt; &gt;&gt;,
C&lt;&lt;&lt; &gt;&gt; &gt;&gt;&gt;, C&lt;&lt; &lt; &gt;&gt;, C&lt;&lt; +&gt; &gt;&gt;, C&lt;&lt;&lt; +&gt;&gt; &gt;&gt;&gt;, and C&lt;&lt; +&lt; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191851Z" changeid="explorer">
        <seg>Puede usar C&lt;&amp;&gt; después de C&lt;&lt; &gt; &gt;&gt;, C&lt;&lt;&lt; &gt;&gt; &gt;&gt;&gt;, C&lt;&lt; &lt; &gt;&gt;, C&lt;&lt; +&gt; &gt;&gt;, C&lt;&lt;&lt; +&gt;&gt; &gt;&gt;&gt;, y C&lt;&lt; +&lt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then there's</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y luego está</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;English&gt; upgraded to version 1.02</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031026Z" changeid="explorer">
        <seg>C&lt;English&gt; actualizado a la versión 1.02</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is the next major version of Perl, although it's not intended to
replace Perl 5.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004330Z" changeid="explorer">
        <seg>Perl 6 es la siguiente versión principal de Perl, pero no es un sustituto de Perl 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($BSD_STYLE) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($BSD_STYLE) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-51427-3 [July 2007]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003321Z" changeid="explorer">
        <seg>ISBN 978-0-596-51427-3 [Julio de 2007]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x_hi;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200434Z" changeid="explorer">
        <seg>$x_hi;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you put C&lt;{0,5}&gt; instead of C&lt;*&gt;
on the external group, no current optimization is applicable, and the
match takes a long time to finish.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T211319Z" changeid="explorer">
        <seg>Por ejemplo, si pone C&lt;{0,5}&gt; en lugar de C&lt;*&gt; en el grupo externo, no se aplica ninguna optimización, y la coincidencia tarda mucho tiempo en terminar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>: # use perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015118Z" changeid="explorer">
        <seg>: # use perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Write simple routines to do simple things.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020603Z" changeid="explorer">
        <seg>=item Escriba rutinas sencillas para hacer cosas simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your Perl book isn't listed and you think it should be, let us know.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003841Z" changeid="explorer">
        <seg>Si su libro sobre Perl no está en la lista y cree que deberíamos incluirlo, póngase en contacto con nosotros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NOTES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 NOTAS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you're done with your filehandles, you should C&lt;close()&gt; them
(though to be honest, Perl will clean up after you if you forget):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225358Z" changeid="explorer">
        <seg>Cuando termine de trabajar con los identificadores de archivo, debe cerrarlos con C&lt;close()&gt; (de todos modos, Perl se encargará de ello si se le olvida):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (&quot;foo&quot;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (&quot;foo&quot;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next if m#^/usr/spool/uucp#;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next if m#^/usr/spool/uucp#;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;use locale&gt; is in effect,
and POSIX::setlocale() has been called, the character used for the
decimal separator is affected by the LC_NUMERIC locale.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;use locale&gt; está activo, y POSIX::setlocale() ha sido llamada, el carácter utilizado para el separador decimal se ve afectado por la configuración regional de LC_NUMERIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getgrgid($num);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$name  = getgrgid($num);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\1&gt; in
the usual double-quoted string means a control-A.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T225136Z" changeid="explorer">
        <seg>C&lt;\1&gt; en una cadena normal entrecomillada doble es un control-A.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful
for modifying a copy of something, like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para modificar una copia de algo, como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*+     Match 0 or more times and give nothing back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>*+     Coincide 0 o más veces y no devuelve nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print vec($foo, 0, 8);  # prints 80 == 0x50 == ord('P')</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print vec($foo, 0, 8);  # imprime 80 == 0x50 == ord('P')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 9, 2) = 1   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 9, 2) = 1   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(S&lt;RISC OS&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014839Z" changeid="explorer">
        <seg>(S&lt;RISC OS&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($paragraph = &lt;&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025217Z" changeid="explorer">
        <seg>while ($parrafo = &lt;&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes the file or pipe associated with the filehandle, flushes the IO
buffers, and closes the system file descriptor.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005537Z" changeid="explorer">
        <seg>Cierra el archivo o tubería asociada con el identificador de archivo, limpiando los búfer de E/S, y cierra el descriptor del archivo en el sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(P) The substitution was looping infinitely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(P) The substitution was looping infinitely.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-standard extensions in your local sprintf(3) are 
therefore unavailable from Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Extensiones no estándares en su sprintf(3) regional, por lo tanto, no estará disponible desde Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prior to Perl 5.14, this wouldn't even compile:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030515Z" changeid="explorer">
        <seg>Antes de Perl 5.14, esto ni siquiera hubiera compilado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the source number is between two numbers representable in the target form,
a representation of one of these numbers is used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232716Z" changeid="explorer">
        <seg>Si el número de origen está entre dos números representables en la forma de destino, se usa una representación de uno de estos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;File::Find&gt; upgraded to version 1.10</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031714Z" changeid="explorer">
        <seg>C&lt;File::Find&gt; actualizado a la versión 1.10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;ptardiff&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234926Z" changeid="explorer">
        <seg>=item L&lt;ptardiff&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You really probably want to be using C&lt;my&gt; instead, because C&lt;local&gt; isn't
what most people think of as &quot;local&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo que realmente querrá usar es C&lt;my&gt;, debido a que C&lt;local&gt; no es lo que la mayoría de la gente piensa en algo &quot;local&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $xyzzy = decode('Windows-1251', $cgi-&gt;param('foo'));</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235153Z" changeid="explorer">
        <seg>my $xyzzy = decode('Windows-1251', $cgi-&gt;param('foo'));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no
Daylight Saving Time in GMT.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay horario de verano en el horario GMT.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is grandfathered (for \1 to \9) for the RHS of a substitute to avoid
shocking the
B&lt;sed&gt; addicts, but it's a dirty habit to get into.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T224943Z" changeid="explorer">
        <seg>Se trata de vicios adquiridos (por \1 a \9) para el lado derecho de una sustitución para evitar escandalizar a los adictos del B&lt;sed&gt;, pero es un hábito sucio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it does both, scalar arguments 
come first and list argument follow, and there can only ever
be one such list argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si aparecen ambos, los argumentos escalares van antes que el argumento de lista, y solo puede existir un argumento de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, always pass
C&lt;srand&gt; an integer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para estar seguros, siempre pase un entero a C&lt;srand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @squares = map { $_ * $_ } grep { $_ &gt; 5 } @numbers;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171758Z" changeid="explorer">
        <seg>my @cuadrados = map { $_ * $_ } grep { $_ &gt; 5 } @numeros;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This warning should have been already in 5.8.0, since they are.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T012008Z" changeid="explorer">
        <seg>Esta advertencia debería haber salido ya desde 5.8.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C Operators Missing From Perl
X&lt;operator, missing from perl&gt; X&lt;&amp;&gt; X&lt;*&gt;
X&lt;typecasting&gt; X&lt;(TYPE)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002318Z" changeid="explorer">
        <seg>=head2 Operadores de C que faltan en Perl
X&lt;operator, missing from perl&gt; X&lt;&amp;&gt; X&lt;*&gt;
X&lt;typecasting&gt; X&lt;(TYPE)&gt; X&lt;operador, faltan en Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Shell</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014833Z" changeid="explorer">
        <seg>=item Shell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T141348Z" changeid="explorer">
        <seg>( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;shift&gt; and C&lt;unshift&gt; do the
same thing to the left end of an array that C&lt;pop&gt; and C&lt;push&gt; do to the
right end.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;shift&gt; y C&lt;unshift&gt; hacen lo mismo con el extremo izquierdo de un array que C&lt;pop&gt; y C&lt;push&gt; hacen para el extremo derecho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Reporting Bugs</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Informar de errores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mentioning the ternary operator in
this error message makes syntax diagnostic easier.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040323Z" changeid="explorer">
        <seg>Mencionando el operador ternario en este mensaje de error hace más fácil la diagnosis de la sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING:&gt; Calling delete on array values is deprecated and likely to
be removed in a future version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T232915Z" changeid="explorer">
        <seg>B&lt;AVISO:&gt; Usar delete en elementos de un array es una funcionalidad obsoleta y es probable que sea eliminada en una futura versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is exactly equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es exactamente equivalente a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Void context just means the value has been discarded, such as a
statement containing only C&lt;&quot;fred&quot;;&gt; or C&lt;getpwuid(0);&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El contexto vacío significa simplemente que el valor ha sido descartado, como en una instrucción que contenga solamente C&lt;&quot;fred&quot;;&gt; o C&lt;getpwuid(0);&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DynaLoader::dl_unload_file() now works on Windows.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014138Z" changeid="explorer">
        <seg>DynaLoader::dl_unload_file() ahora funciona en Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print int(0.6/0.2-2), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225510Z" changeid="explorer">
        <seg>print int(0.6/0.2-2), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has most of the usual conditional and looping constructs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234722Z" changeid="zipf">
        <seg>Perl ofrece las estructuras condiciones y de bucle habituales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the braces are required in Perl, even if you've only got one
line in the block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225132Z" changeid="explorer">
        <seg>Tenga en cuenta que en Perl es obligatorio usar las llaves, aunque sólo haya una línea en el bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're particularly concerned with this, search the CPAN for
random number generator modules instead of rolling out your own.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201600Z" changeid="explorer">
        <seg>Si está especialmente preocupado por esto, busque en CPAN por módulos generadores de números aleatorios en lugar de desarrollar el suyo propio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Unicode F&lt;NameAliases.txt&gt; database file has been added.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110921T152055Z" changeid="explorer">
        <seg>El fichero base de datos Unicode F&lt;NameAliases.txt&gt; ha sido añadido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl586delta - what is new for perl v5.8.6</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl586delta - qué hay de nuevo para perl v5.8.6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item syscall NUMBER, LIST
X&lt;syscall&gt; X&lt;system call&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204106Z" changeid="explorer">
        <seg>=item syscall NÚMERO, LISTA
X&lt;syscall&gt; X&lt;system call&gt; X&lt;llamada del sistema&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@newAoA = ();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194942Z" changeid="explorer">
        <seg>@newAoA = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pattern really, I&lt;really&gt; wants to succeed, so it uses the
standard pattern back-off-and-retry and lets C&lt;\D*&gt; expand to just &quot;AB&quot; this
time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171158Z" changeid="explorer">
        <seg>El patrón, I&lt;de verdad&gt;, quiere tener éxito, por lo que utiliza el modelo estándar de marcha-atrás-e-inténtalo y permite que C&lt;\D*&gt; se expanda esta vez a solo &quot;AB&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not good.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015518Z" changeid="explorer">
        <seg>Esto no es bueno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$some_unicode .= &lt;FH&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031420Z" changeid="explorer">
        <seg>$some_unicode .= &lt;FH&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converts a time as returned by the time function to a 9-element list
with the time analyzed for the local time zone.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Convierte un tiempo devuelto por la función time() en una lista de 9 elementos según la zona horaria local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Mac OS X see README.macosx</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220645Z" changeid="explorer">
        <seg>Para Mac OS X vea README.macosx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;/[8]&gt; below for details on which character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220115Z" changeid="explorer">
        <seg>Vea L&lt;/[8]&gt; más abajo, para detalles sobre este carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no builtin C&lt;import&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe la función C&lt;import&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
mark may be given a name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T114717Z" changeid="explorer">
        <seg>A esta marca se le puede dar un nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that some modules in this directory may not yet have been
released separately on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014446Z" changeid="explorer">
        <seg>Tenga en cuenta que es posible que algunos de los módulos de este directorio aún no se hayan publicado por separado en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The comments show the string after each step.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los comentarios ponen de manifiesto la cadena después de cada etapa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pop EXPR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175740Z" changeid="explorer">
        <seg>=item pop EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remedy to this problem is to replace this code with the correct idiom:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T175630Z" changeid="explorer">
        <seg>El remedio para este problema es reemplazar este código con la expresión correcta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(*ACCEPT)&gt;
X&lt;(*ACCEPT)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050539Z" changeid="explorer">
        <seg>=item C&lt;(*ACCEPT)&gt;
X&lt;(*ACCEPT)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.6.0                             2000-Mar-22
                               5.7.0        2000-Sep-02
                  5.6.1                     2001-Apr-08
                               5.7.1        2001-Apr-09
                               5.7.2        2001-Jul-13
                               5.7.3        2002-Mar-05
          5.8.0                             2002-Jul-18
                  5.8.1                     2003-Sep-25</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005903Z" changeid="explorer">
        <seg>5.6.0				2000-Mar-22
			5.7.0		2000-Sep-02
	5.6.1				2001-Apr-08
			5.7.1		2001-Apr-09
			5.7.2		2001-Jul-13
			5.7.3		2002-Mar-05
	5.8.0				2002-Jul-18
		5.8.1			2003-Sep-25</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@c = (0,1)[2,3];        # @c has no elements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@c = (0,1)[2,3];        # @c no tiene elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produce, respectively</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce, respectivamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be sure to specify Perl version requirements both in Makefile.PL or
Build.PL and with C&lt;require 5.6.1&gt; or similar.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030320Z" changeid="explorer">
        <seg>Asegúrese de especificar los requisitos de la versión de Perl, tanto en Makefile.PL o Build.PL y con C&lt;require 5.6.1&gt; o similar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-X  File is executable by real uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004558Z" changeid="explorer">
        <seg>-X  Archivo es ejecutable por el uid/gid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-o  File is owned by effective uid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004528Z" changeid="explorer">
        <seg>-o  Archivo es propiedad del uid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># or going the other way</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># o de otra manera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These modules generally have their F&lt;Makefile.PL&gt; and are laid out
more like a typical CPAN module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014422Z" changeid="explorer">
        <seg>Estos módulos suelen tener un archivo F&lt;Makefile.PL&gt; y su estructura es similar a la del típico módulo de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;split&gt; on C&lt;/\s+/&gt; is like a S&lt;C&lt;split(' ')&gt;&gt; except that any leading
whitespace produces a null first field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;split&gt; con C&lt;/\s+/&gt; es como un S&lt;C&lt;split(' ')&gt;&gt; excepto que cualquier espacio en blanco inicial produce un primer campo nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you needed to know the length of the string in bytes, now's the perfect time
for that.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235250Z" changeid="explorer">
        <seg>Si necesita averiguar la longitud de la cadena en bytes, ahora es el momento de hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (s|{.*| |) {
            $front = $_;
            while (&lt;STDIN&gt;) {
                if (/}/) {  # end of comment?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050838Z" changeid="explorer">
        <seg>if (s|{.*| |) {
            $frente = $_;
            while (&lt;STDIN&gt;) {
                if (/}/) {  # ¿fin de comentario?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl modules provide a range of features to help you avoid reinventing
the wheel, and can be downloaded from CPAN ( http://www.cpan.org/ ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T230050Z" changeid="explorer">
        <seg>No pierda tiempo reinventando la rueda. Los módulos de Perl disponibles en CPAN (http://www.cpan.org/) proporcionan funcionalidad que puede utilizar en sus programas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($port, $iaddr) = sockaddr_in($hersockaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($port, $iaddr) = sockaddr_in($hersockaddr);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember,
people often respond better to what they get out of it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232341Z" changeid="explorer">
        <seg>Recuerde que las personas suelen ser más receptivas cuando reciben algo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit
the PERMS argument to C&lt;sysopen&gt;, Perl uses the octal value C&lt;0666&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite el argumento PERMISOS a C&lt;sysopen&gt;, Perl utiliza el valor octal C&lt;0666&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x	Use extended regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>x	Usa expresiones regulares extendidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 AUTHOR AND COPYRIGHT</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232558Z" changeid="explorer">
        <seg>=head1 AUTOR Y COPYRIGHT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though it looks as though they're the same method calls (uid),
they aren't, because a C&lt;File::stat&gt; object is different from
a C&lt;User::pwent&gt; object.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T164629Z" changeid="explorer">
        <seg>Incluso aunque parezcan los mismos métodos (uid), no lo son, porque un objeto C&lt;File::stat&gt; es diferente de un objeto C&lt;User::pwent&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that
one can have code called assertions sprinkled in the code: usually
they are optimised away, but they can be enabled with the C&lt;-A&gt; option.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014324Z" changeid="explorer">
        <seg>Esto significa que uno puede tener código llamado assertions salpicado en el código: suele ser optimizado, pero se puede activar con la opción C&lt;-A&gt; opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item MiNT</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005654Z" changeid="explorer">
        <seg>=item MiNT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(1+2) + 4;   # Prints 3.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(1+2) + 4;	# Imprime 3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;1: got $1\n&quot; if $x =~ /^(ABC)(?!123)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170202Z" changeid="explorer">
        <seg>print &quot;1: tenemos $1\n&quot; if $x =~ /^(ABC)(?!123)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;cpanp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235038Z" changeid="explorer">
        <seg>=item L&lt;cpanp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlapio		Perl internal IO abstraction interface</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000532Z" changeid="explorer">
        <seg>perlapio		Interfaz de abstracción de E/S interna</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: In perl 5.12.x and earlier, the regex engine
was not re-entrant, so interpolated code could not
safely invoke the regex engine either directly with
C&lt;m//&gt; or C&lt;s///&gt;), or indirectly with functions such as
C&lt;split&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T201917Z" changeid="explorer">
        <seg>B&lt;AVISO&gt;: En perl 5.12.x y anteriores, el motor regex es, actualmente, no re-entrante, por lo que el código interpolado no podrá invocar de forma segura el motor regex, tanto directamente con C&lt;m//&gt; o C&lt;s///&gt;, o indirectamente con funciones, como C&lt;split&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readpipe EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item readpipe EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use&gt; function calls the C&lt;import&gt; method
for the package used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función C&lt;use&gt; llama al método C&lt;import&gt; del paquete a usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Arrays</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232609Z" changeid="explorer">
        <seg>=item Arrays</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (substr($x,1,2)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (substr($x,1,2)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this to find out whether two handles refer to the
same underlying descriptor:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020537Z" changeid="explorer">
        <seg>Puede usar esto para encontrar cuándo dos identificadores de archivos se refieren al mismo descriptor subyacente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,14, 1) = 1   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,14, 1) = 1   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!/usr/bin/perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#!/usr/bin/perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># VMS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225505Z" changeid="explorer">
        <seg># VMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string =~ s/^\s+|\s+$//gm;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225538Z" changeid="explorer">
        <seg>$string =~ s/^\s+|\s+$//gm;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[2][2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[2][2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the three-argument form to open a file with arbitrary weird characters in it,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235336Z" changeid="explorer">
        <seg>Use la forma de tres argumentos para abrir un archivo con una cantidad arbitraria de caracteres extraños, en su nombre,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primarily this is so that you can use the B&lt;undump&gt; program (not
supplied) to turn your core dump into an executable binary after
having initialized all your variables at the beginning of the
program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Principalmente esto se utiliza en conjunción con el programa B&lt;undump&gt; (no suministrado) para convertir tu volcado del núcleo en un binario ejecutable después de haber inicializado todas las variables al comienzo del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you want your program to be readable, consider supplying the argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted quiere que su programa sea legible, considere suplir el argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Object Oriented Perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003610Z" changeid="explorer">
        <seg>=item I&lt;Object Oriented Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The restriction lasts to the
end of the enclosing block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La restricción dura hasta el final del bloque que lo alberga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I can't say anything with regard to PPC.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puedo decir nada con respecto a PPC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># symbolic dereferencing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># desreferencia simbólica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open HANDLE, &quot;&lt; $file&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230143Z" changeid="explorer">
        <seg>open HANDLE, &quot;&lt; $archivo&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl590delta - what is new for perl v5.9.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030520Z" changeid="explorer">
        <seg>perl590delta - qué hay de nuevo en perl v5.9.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;*&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;*&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ [B&lt;-e&gt;|B&lt;-E&gt;] I&lt;'command'&gt; ] [ B&lt;--&gt; ] [ I&lt;programfile&gt; ] [ I&lt;argument&gt; ]...&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ [B&lt;-e&gt;|B&lt;-E&gt;] I&lt;'comando'&gt; ] [ B&lt;--&gt; ] [ I&lt;programa&gt; ] [ I&lt;argumento&gt; ]...&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the explanation for the
C&lt;(*MARK:NAME)&gt; verb below for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T012831Z" changeid="explorer">
        <seg>Vea la explicación del verbo C&lt;(*MARK:NOMBRE)&gt; abajo para obtener más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\v        [3]  Vertical whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224928Z" changeid="explorer">
        <seg>\v        [3]  Espacio en blanco vertical</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Steve Peters)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112308Z" changeid="explorer">
        <seg>(Steve Peters)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This usage (which also works fine with system()) forces
interpretation of the arguments as a multivalued list, even if the
list had just one argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este uso (que también funciona bien con system()) fuerza la interpretación de los argumentos como una lista multievaluada, incluso si la lista sólo tiene un argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are now.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora lo son.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some C macros have been tidied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas macros C se han arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How
are you going to do that?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193203Z" changeid="explorer">
        <seg>¿Cómo va a hacer eso?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Byteorders C&lt;&quot;1234&quot;&gt; and C&lt;&quot;12345678&quot;&gt; are little-endian; C&lt;&quot;4321&quot;&gt;
and C&lt;&quot;87654321&quot;&gt; are big-endian.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las ordenaciones C&lt;&quot;1234&quot;&gt; y C&lt;&quot;12345678&quot;&gt; son little-endian; C&lt;&quot;4321&quot;&gt; y C&lt;&quot;87654321&quot;&gt; son big-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class::Struct: allow recursive classes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Class::Struct: permite clases recursivas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;+&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;+&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The
fact that a Perl interpreter and your code are in the same binary file
is, in this case, a form of mere aggregation.)  This is my interpretation
of the GPL.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T224452Z" changeid="explorer">
        <seg>(El hecho de que un intérprete de Perl y su código estén en el mismo archivo binario es, en este caso, una forma de agregación simple.) Esta es mi interpretación de la GPL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, C&lt;localtime()&gt; returns the ctime(3) value:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, C&lt;localtime()&gt; devuelve el valor de ctime(3):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of them
was found to be of more nuisance than benefit: the automagic
(and silent) &quot;UTF-8-ification&quot; of filehandles, including the
standard filehandles, if the user's locale settings indicated
use of UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143719Z" changeid="explorer">
        <seg>Una de ellas resultó ser de más molestia que beneficio: la automágica (y silenciosa) &quot;UTF-8-fijación&quot; de los identificadores de archivo, incluyendo los identificadores de archivo estándar, si la configuración regional del usuario indica el uso de UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, http://mirror.cpan.org/ has a nice
interface to the http://www.cpan.org/MIRRORED.BY mirror directory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230106Z" changeid="explorer">
        <seg>Además, http://mirror.cpan.org/ ofrece una cómoda interfaz del directorio reflejado http://www.cpan.org/MIRRORED.BY .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;S?&gt;, C&lt;S*&gt;, C&lt;S+&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050002Z" changeid="explorer">
        <seg>=item C&lt;S?&gt;, C&lt;S*&gt;, C&lt;S+&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For GMT
instead of local time use the L&lt;/gmtime&gt; builtin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para GMT, en lugar de la hora local, use la primitiva L&lt;/gmtime&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that the C&lt;p&gt; modifier is special in that its presence
anywhere in a pattern has a global effect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T194107Z" changeid="explorer">
        <seg>Tenga en cuenta que el modificador C&lt;p&gt; es especial, en que su presencia en cualquier lugar del patrón tiene un efecto global.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlop/Terms and List Operators (Leftward)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215319Z" changeid="explorer">
        <seg>Vea L&lt;perlop/Términos y Operadores de listas (por la izquierda)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Arithmetic</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120350Z" changeid="zipf">
        <seg>=item Aritmética</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $key (keys %HASH) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $clave (keys %HASH) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, on POSIX-conforming systems, zero will
signal the current process group and -1 will signal all processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, en los sistemas conformes a POSIX, un cero señalará al grupo del proceso actual y -1 señalará todos los procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlreftut		Perl references short introduction</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000157Z" changeid="explorer">
        <seg>perlreftut		Breve introducción a las referencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># prints AbelCaincatdogx</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># prints AbelCaincatdogx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pack(&quot;@1A((@2A)@3A)&quot;, qw[X Y Z])</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pack(&quot;@1A((@2A)@3A)&quot;, qw[X Y Z])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failed Test  Status Wstat Total Fail  Failed  List of failed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Failed Test  Status Wstat Total Fail  Failed  List of failed</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;charnames&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215035Z" changeid="explorer">
        <seg>Vea L&lt;charnames&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The shared object /usr/lib/libm.so did not resolve any symbols.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004715Z" changeid="explorer">
        <seg>El objeto compartido /usr/lib/libm.so no resuelve a ningún símbolo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Irix 6.2 Posix 1003.1b man pages</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004239Z" changeid="explorer">
        <seg>Irix 6.2 Posix 1003.1b páginas man</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>size =&gt; 1024,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021614Z" changeid="explorer">
        <seg>tamaño =&gt; 1024,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwuid</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014954Z" changeid="explorer">
        <seg>=item getpwuid</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$input++;    # this is a string increment</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$entrada++;    # esto es un incremento de cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;-&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;-&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlebcdic		Considerations for running Perl on EBCDIC platforms</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000427Z" changeid="explorer">
        <seg>perlebcdic		Ejecución de Perl en plataformas EBCDIC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># This will expand any embedded scalar variable</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Esto expandirá cualquier variables escalar incrustada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, you can match
on just about anything you could dream of by using more complex regular
expressions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225422Z" changeid="explorer">
        <seg>De hecho, puede detectar coincidencias donde quiera con expresiones regulares más complejas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$age{$a} &lt;=&gt; $age{$b};  # presuming numeric</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$edad{$a} &lt;=&gt; $edad{$b};  # presumimos numéricos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.activestate.com/Products/Visual_Perl/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>http://www.activestate.com/Products/Visual_Perl/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to map strings between lower/upper cases, see
L&lt;perlfunc/lc&gt; and L&lt;perlfunc/uc&gt;, and in general consider using the C&lt;s&gt;
operator if you need regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T032049Z" changeid="explorer">
        <seg>Si desea mapear cadenas entre minúsculas/mayúsculas, vea L&lt;perlfunc/lc&gt; y L&lt;perlfunc/uc&gt;; y, en general, considere usar el operador C&lt;s&gt; si necesita usar expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/map&gt; for a list composed of the results of the BLOCK or EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/map&gt; para una lista compuesta de los resultados del BLOQUE o EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlreftut&gt;
and L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlreftut&gt; y L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a fully ported perl for VM/ESA 2.3.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T064833Z" changeid="explorer">
        <seg>Esta es una versión de perl completamente portado para VM/ESA 2.3.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE:&gt; In order to make things easier for programmers with experience
with the Python or PCRE regex engines, the pattern C&lt;&lt; (?P=NAME) &gt;&gt;
may be used instead of C&lt;&lt; \k&lt;NAME&gt; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T215150Z" changeid="explorer">
        <seg>B&lt;NOTA:&gt; Con el fin de facilitar las cosas a los programadores con experiencia en Python o motores regex PCRE, el patrón C&lt;&lt; (?P=NOMBRE) &gt;&gt;
puede ser usado en lugar de C&lt;&lt; \k&lt;NOMBRE&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the 25 traditional lowercase Greek letters, including both sigmas,
you could use this instead:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224612Z" changeid="explorer">
        <seg>Para obtener las 25 letras minúsculas griegas, incluyendo ambos sigmas, puede usar esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nNvV       Treat integers as signed instead of unsigned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>nNvV       Trata a enteros como con signo, en lugar de sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\l          lowercase next char (think vi)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043820Z" changeid="explorer">
        <seg>\l		pasar a minúscula el siguiente carácter (como en vi)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>list      %hash     element: $array[0]     $hash{'a'}
            &amp;sub
            *glob    SCALAR VALUES
                     number, string, reference, glob, undef</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224128Z" changeid="explorer">
        <seg>lista      %hash     elemento: $array[0]     $hash{'a'}
             &amp;sub
             *glob    VALORES ESCALARES
                      número, cadena, referencia, glob, undef</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As one example, the C&lt;type&gt; command under
the POSIX shell is very different from the C&lt;type&gt; command under DOS.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como ejemplo, el comando C&lt;type&gt; en el shell POSIX es muy diferente del comando C&lt;type&gt; en DOS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir($tmpdir)      or die &quot;can't chdir $tmpdir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir($tmpdir)      or die &quot;no puede chdir $tmpdir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is probably useful only when combined with C&lt;(?{})&gt; or C&lt;(??{})&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T143950Z" changeid="explorer">
        <seg>Es probable que sea útil cuando sólo se combine con C&lt;(?{})&gt; o C&lt;(??{})&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.005</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014642Z" changeid="explorer">
        <seg>5.005</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both forms, the value returned is the value of the last expression
evaluated inside the mini-program; a return statement may be also used, just
as with subroutines.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012428Z" changeid="explorer">
        <seg>En ambas formas, el valor devuelto es el valor de la última expresión evaluada dentro del mini-programa; una instrucción return se puede usar también, como si fuera una subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is an expression, its value is used as the real
filehandle wanted; an undefined scalar will be suitably autovivified.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T020500Z" changeid="explorer">
        <seg>Si IDENTIFICADOR_ARCHIVO es una expresión, el valor es tomado como el nombre real del identificador de archivo buscado; un escalar indefinido será autovivificado adecuadamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @a = ( 1 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225458Z" changeid="explorer">
        <seg>my @a = ( 1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### last always comes here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>### last siempre viene aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many books on Perl and Perl-related.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T002806Z" changeid="explorer">
        <seg>Hay muchos libros sobre Perl o relacionados con Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Unicode::Collate-&gt;new&gt; method no longer overwrites user's C&lt;$_&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041100Z" changeid="explorer">
        <seg>El método C&lt;Unicode::Collate-&gt;new&gt; ya no sobreescribe el C&lt;$_&gt; del usuario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(ARTICLE, &quot;caesar &lt;$article |&quot;)      # ditto</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(ARTICLE, &quot;caesar &lt;$article |&quot;)      # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensure your module works under C&lt;use strict&gt; and C&lt;-w&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013737Z" changeid="explorer">
        <seg>Asegúrese de que su módulo funciona bajo C&lt;use strict&gt; y C&lt;-w&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entire hashes are denoted by '%':
X&lt;hash&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los hashes enteros se designan por '%': X&lt;hash&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VARIABLE is the name of the variable
to be enchanted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VARIABLE es el nombre de la variable que será enlazada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is a unary operator, not a list operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que se trata de un operador unario, no un operador de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($rin,fileno(STDIN),1) = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($rin,fileno(STDIN),1) = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the independent subexpression
L&lt;/C&lt;&lt; (?&gt;pattern) &gt;&gt;&gt; for more details;
possessive quantifiers are just syntactic sugar for that construct.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043239Z" changeid="explorer">
        <seg>Vea la subexpresión independiente L&lt;/C&lt;&lt; (?&gt;patrón) &gt;&gt;&gt; para obtener más detalles; los cuantificadores posesivos son el edulcorante sintáctico para esta construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For delays of finer granularity than one second, the Time::HiRes module
(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides usleep().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para lapsos de tiempo inferiores a un segundo, el módulo Time::HiRes (en CPAN, y desde Perl 5.8 parte de la distribución estándar) ofrece usleep().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to indicate that an option is to be
interpreted by the TCP protocol, LEVEL should be set to the protocol
number of TCP, which you can get using C&lt;getprotobyname&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, para indicar que una opción a de ser interpretada por el protocolo TCP, NIVEL debe ser puesto al número de protocolo del TCP, que puede obtener usando C&lt;getprotobyname&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlos400		Perl notes for OS/400</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlos400		Notas para OS/400</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What's that C&lt;shift&gt;?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T233431Z" changeid="zipf">
        <seg>¿Qué hace C&lt;shift&gt;?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parentheses in Perl 6
are always optional in a control construct such as C&lt;if()&gt;,
C&lt;while()&gt;, or C&lt;when()&gt;; they can't be made optional in Perl
5 without a great deal of potential confusion, because Perl 5
would parse the expression</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los paréntesis en Perl 6 son siempre opcionales en construcciones de control, como en C&lt;if()&gt;, C&lt;while()&gt;, o C&lt;when()&gt;; no pueden ser opcionales en Perl 5, sin ganar una gran confusión, porque Perl 5 interpretaría la expresión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item redo LABEL
X&lt;redo&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194511Z" changeid="explorer">
        <seg>=item redo ETIQUETA
X&lt;redo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While running Configure and when building, you are likely to get
quite a few of these warnings:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004643Z" changeid="explorer">
        <seg>Mientras ejecuta Configure y cuando compile, es probable que obtenga un buen número de estas advertencias:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;redo&gt; cannot be used to retry a block that returns a value such as
C&lt;eval {}&gt;, C&lt;sub {}&gt;, or C&lt;do {}&gt;, and should not be used to exit
a grep() or map() operation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011321Z" changeid="explorer">
        <seg>C&lt;redo&gt; no puede usarse para reiniciar un bloque que devuelve un valor, como C&lt;eval {}&gt;, C&lt;sub {}&gt; o C&lt;do {}&gt;, y no debe ser usado para salir de una operación grep() o map().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>file()-&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225446Z" changeid="explorer">
        <seg>file()-&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the multiplicity of floating-point formats and the lack of a
standard &quot;network&quot; representation for them, no facility for interchange has been
made.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a la multiplicidad de formatos de punto flotante y la falta de una norma de representación en la &quot;red&quot; para ellos, no hay ninguna facilidad para el intercambio de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;I don't like oranges.&quot; when /oranges?;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234727Z" changeid="explorer">
        <seg>say &quot;No me gustan las naranjas.&quot;	when /naranjas?/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Switch&gt; upgraded to version 2.10_01</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035035Z" changeid="explorer">
        <seg>C&lt;Switch&gt; actualizado a la versión 2.10_01</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wanted there I&lt;not&gt; to be an @AoA,
but rather just a reference to it, you could do something more like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si I&lt;no&gt; quiere que sea un @AoA, sino una referencia a él, puede hacer algo más parecido a esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is similar to the command line mode of the L&lt;CPAN&gt; module,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235035Z" changeid="explorer">
        <seg>Es similar al modo de línea de comandos del módulo L&lt;CPAN&gt;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Assertions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T195819Z" changeid="explorer">
        <seg>=head2 Aserciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will have exactly the opposite restrictions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tendrá exactamente las restricciones contrarias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the most important
part of this tutorial.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234243Z" changeid="explorer">
        <seg>Ésta es la parte más importante del tutorial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In scalar context, returns the number of values.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024849Z" changeid="explorer">
        <seg>(En contexto escalar, devuelve el número de valores.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir +($foo) * 20;	# chdir ($foo * 20)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir +($foo) * 20;	# chdir ($foo * 20)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@array) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@array) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item study SCALAR
X&lt;study&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201643Z" changeid="explorer">
        <seg>=item study ESCALAR
X&lt;study&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;s///&gt; substitution operator is documented in L&lt;perlop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233345Z" changeid="zipf">
        <seg>El operador de sustitución, C&lt;s///&gt;, se describe en L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All filter methods return the existing filter, if present, or C&lt;undef&gt;
if not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111003T120110Z" changeid="zipf">
        <seg>Todos los métodos de filtro devuelven el filtro, si existe; de lo contrario, devuelven C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\cK         control char          (example: VT)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043429Z" changeid="explorer">
        <seg>\cK		carácter de control	(ejemplo: VT)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line numbers
displayed by diagnostics are internally stored as short integers,
so they are limited to a maximum of 65535 (higher numbers usually being
affected by wraparound).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001805Z" changeid="explorer">
        <seg>Por otra parte, los números de línea especificados por los diagnósticos se almacenan internamente como enteros cortos, por lo que están limitados a un máximo de 65535 (cifras más altas quedarán afectadas por el desbordamiento).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tutorials, end-user documentation, research papers, FAQs etc are not 
appropriate in a module's main documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031728Z" changeid="explorer">
        <seg>Manuales, documentación de usuario final, documentos de investigación, P+F (I&lt;FAQ&gt;), etc, no son apropiadas en la documentación principal de un módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's regular expression support is both broad and deep, and is the
subject of lengthy documentation in L&lt;perlrequick&gt;, L&lt;perlretut&gt;, and
elsewhere.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225403Z" changeid="explorer">
        <seg>El soporte de Perl para las expresiones regulares es amplio y profundo, y se describe en gran detalle en los documentos L&lt;perlrequick&gt; y L&lt;perlretut&gt;, entre otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't fall into the trap of using a C&lt;printf&gt; when a simple
C&lt;print&gt; would do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No caiga en la trampa de utilizar un C&lt;printf&gt; cuando un simple C&lt;print&gt; valdría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;and&quot; returns the logical conjunction of the two surrounding
expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;and&quot; devuelve la conjunción lógica de las dos expresiones que la rodean.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be careful if you put double quotes around the picture, because an C&lt;@&gt;
character may be taken to mean the beginning of an array name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado si pone dobles comillas alrededor del cuadro, porque un carácter C&lt;@&gt; puede ser tomado como el comienzo del nombre de un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TEMPLATE is a sequence of characters that give the order and type
of values, as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La PLANTILLA es una secuencia de caracteres que dan el orden y el tipo de los valores, de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$aref = $AoA[$i];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052933Z" changeid="explorer">
        <seg>$aref = $AoA[$i];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following
computes the same number as the System V sum program:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, lo siguiente calcula el mismo número que el programa sum de System V:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($@) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($@) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;use locale&gt; is in effect and POSIX::setlocale() has been called,
the character used for the decimal separator in formatted floating-point
numbers is affected by the LC_NUMERIC locale.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;use locale&gt; está en vigor y POSIX::setlocale() ha sido llamado, el carácter utilizado para el separador decimal en formato de punto flotante de los números se ve afectada por la configuración regional LC_NUMERIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fixes a bug in C&lt;colored&gt; when C&lt;$EACHLINE&gt; is set that caused it to not color
lines consisting solely of 0 (literal zero).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T065334Z" changeid="explorer">
        <seg>Corrige un error en C&lt;colored&gt; cuando C&lt;$EACHLINE&gt; está activado, que provocaba que las líneas compuestas únicamente de ceros (cero literal) no se colorearán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Naming conventions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021309Z" changeid="explorer">
        <seg>=item Convenciones de nombres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the natural logarithm (base I&lt;e&gt;) of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el logaritmo natural (base I&lt;e&gt;) de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = ( $key =&gt; $value );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = ( $clave =&gt; $valor );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 8, 2) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 8, 2) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (&quot;foo&quot;) { ++$count }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (&quot;foo&quot;) { ++$cuenta }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpolicy		Perl development policies</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000535Z" changeid="explorer">
        <seg>perlpolicy		Directivas de desarrollo de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;!&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;!&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the pattern uses a Unicode property (C&lt;\p{...}&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000825Z" changeid="explorer">
        <seg>el patrón utiliza una propiedad Unicode (C&lt;\p{...}&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like
C&lt;(*PRUNE)&gt;, this verb always matches, and when backtracked into on
failure, it causes the regex engine to try the next alternation in the
innermost enclosing group (capturing or otherwise).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T141217Z" changeid="explorer">
        <seg>Al igual que C&lt;(*PRUNE)&gt;, este verbo siempre coincide, y cuando se hace vuelta atrás a causa de un fallo, hace que el motor de expresiones regulares trate la alternativa siguiente en el grupo más interno (de captura o de otra manera).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format of the intervening
text is described in L&lt;perlpod&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El formato del texto intermedio está descrito en L&lt;perlpod&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#{$AoA[$i]} ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052915Z" changeid="explorer">
        <seg>$#{$AoA[$i]} ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*d&gt;',  0, 0;   # prints &quot;&lt;&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*d&gt;',  0, 0;   # imprime &quot;&lt;&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;unpack()&gt; will default to unpacking the C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014530Z" changeid="explorer">
        <seg>C&lt;unpack()&gt; desempaquetará, por defecto, C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GLOB</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>GLOB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl builtin functions that may behave
differently under EBCDIC are mentioned in the perlport.pod document.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T111711Z" changeid="explorer">
        <seg>Las funciones Perl integradas que pueden comportarse de manera diferente en EBCDIC se mencionan en el documento perlport.pod.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = (</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = (</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually,
the C&lt;sprintf&gt;, C&lt;printf&gt;, or the C&lt;POSIX::floor&gt; and C&lt;POSIX::ceil&gt;
functions will serve you better than will int().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usualmente, las funciones C&lt;sprintf&gt;, C&lt;printf&gt;, o C&lt;POSIX::floor&gt; y C&lt;POSIX::ceil&gt; le servirán mejor que int().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary distributions for some proprietary platforms can be found
http://www.cpan.org/ports/ directory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225406Z" changeid="explorer">
        <seg>En el directorio http://www.cpan.org/ports/ encontrará distribuciones binarias para algunas plataformas comerciales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With format C&lt;b&gt;,
the first character of the 8-tuple determines the least-significant bit of a
character; with format C&lt;B&gt;, it determines the most-significant bit of
a character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con el formato C&lt;b&gt;, el primer carácter de la 8-tupla determina el bit menos significativo de un carácter; con el formato C&lt;B&gt;, se determina el bit más significativo de un carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it's a common mistake to use C&lt;exec&gt; instead of C&lt;system&gt;, Perl
warns you if there is a following statement that isn't C&lt;die&gt;, C&lt;warn&gt;,
or C&lt;exit&gt; (if C&lt;-w&gt; is set--but you always do that, right?).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012449Z" changeid="explorer">
        <seg>Como es un error normal usar C&lt;exec&gt; en lugar de C&lt;system&gt;, Perl le avisará si hay alguna instrucción a continuación que no sea C&lt;die&gt;, C&lt;warn&gt; o C&lt;exit&gt; (si C&lt;-w&gt; está puesto -pero usted, siempre lo tiene así, ¿verdad?-).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 4) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 4) = 1   ==        256 00000000100000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;FindBin&gt; upgraded to version 1.47</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032210Z" changeid="explorer">
        <seg>C&lt;FindBin&gt; actualizado a la versión 1.47</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If MODE is C&lt;&lt;&lt; &gt;&gt; &gt;&gt;&gt;, the file is opened for appending, again being
created if necessary.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T002243Z" changeid="explorer">
        <seg>Si MODO es C&lt;&lt;&lt; &gt;&gt; &gt;&gt;&gt;, el archivo es abierto en modo añadir, y de nuevo, será creado si es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can, without fear
of conflict, use the same name for a scalar variable, an array, or
a hash--or, for that matter, for a filehandle, a directory handle, a
subroutine name, a format name, or a label.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T001042Z" changeid="explorer">
        <seg>Esto significa que usted puede, sin temor a conflictos, utilizar el mismo nombre para una variable escalar, un array o un hash; o, por la misma razón, para un identificador de archivo, un identificador de directorio, el nombre de una subrutina, un nombre de formato o una etiqueta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;perlivp&gt; program is set up at Perl source code build time to test
the Perl version it was built under.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234339Z" changeid="explorer">
        <seg>El programa F&lt;perlivp&gt; se configura en tiempo de compilación del código fuente de Perl para comprobar la versión de Perl con la que se generó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting from the beginning of the input string, each 8-tuple
of characters is converted to 1 character of output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir del comienzo de la cadena de entrada, cada 8-tupla de caracteres se convierte en un carácter de la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's easiest to make a local copy of the reference
before any manipulations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más fácil hacer una copia local de la referencia antes de cualquier manipulación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently,
the rules to determine where the C&lt;code&gt; ends are somewhat convoluted.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T215735Z" changeid="explorer">
        <seg>En la actualidad, las reglas para determinar el lugar donde C&lt;código&gt; termina son algo enrevesadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-line BLOCK may be put on one line, including curlies.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un BLOQUE de una sola línea puede ser puesto en una sola línea, incluyendo sus llaves.o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/((.)(.)(.)(.)(.)(.)(.)(.)(.))\010/ # \010 is octal</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191519Z" changeid="explorer">
        <seg>/((.)(.)(.)(.)(.)(.)(.)(.)(.))\010/ # \010 es octal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub snazzle($) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub snazzle($) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;PASSWD&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;PASSWD&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or maybe they need very serious hand-holding and contractual obligations.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231050Z" changeid="explorer">
        <seg>O puede ser que tengan obligaciones contractuales o por acuerdos que limiten su libertad de elección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want your here-docs to be indented with the rest of the code,
you'll need to remove leading whitespace from each line manually:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere que su documento incrustado esté indentado con el resto del código, tendrá que quitar los espacios en blanco sobrantes de cada línea manualmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}ige;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225535Z" changeid="explorer">
        <seg>}ige;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See C&lt;tie&gt;.)
Has no effect if the variable is not tied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver C&lt;tie&gt;). No tiene efecto si la variable no está enlazada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README files and changelogs for CPAN modules bundled with perl are no
longer installed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T034722Z" changeid="explorer">
        <seg>Los archivos README y registros de cambios de los módulos de CPAN incluidos con perl ya no son  instalados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exit status of C&lt;pod2usage&gt; fixed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034429Z" changeid="explorer">
        <seg>Arreglado el estado de la salida de C&lt;pod2usage&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if there are
multiple ways it might succeed, you need to understand backtracking to
know which variety of success you will achieve.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T165835Z" changeid="explorer">
        <seg>Y si hay múltiples maneras en las que podría tener éxito, necesita entender la marcha atrás para saber qué variedad de éxitos va a lograr.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $HASH{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $HASH{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A kill() method is available for thread signalling.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005432Z" changeid="explorer">
        <seg>Un método kill() está disponible para la señalización en hilos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your routine iterates through some kind of list (such as a list of
files, or records in a database) you may consider providing a callback
so that users can manipulate each element of the list in turn.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020841Z" changeid="explorer">
        <seg>Si la rutina se repite a través de algún tipo de lista (por ejemplo, una lista de archivos o registros en una base de datos), puede considerar la posibilidad de una retrollamada (I&lt;callback&gt;) para que los usuarios puedan manipular cada elemento de la lista cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 @- and @+ in patterns</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T111941Z" changeid="explorer">
        <seg>=head2 @- y @+ en patrones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEE ALSO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VER TAMBIÉN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest two-level data structure to build in Perl is an array of
arrays, sometimes casually called a list of lists.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T025817Z" changeid="explorer">
        <seg>La estructura de datos a dos niveles más simple que se puede construir en Perl es un array de array, llamada en algunas ocasiones lista de listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's some advice: supply a creation mode of C&lt;0666&gt; for regular
files (in C&lt;sysopen&gt;) and one of C&lt;0777&gt; for directories (in
C&lt;mkdir&gt;) and executable files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He aquí algunos consejos: suministre un modo de creación de C&lt;0666&gt; para archivos regulares (en C&lt;sysopen&gt;) y uno de C&lt;0777&gt; para directorios (en C&lt;mkdir&gt;) y los archivos ejecutables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Any       string equality          $a eq $b</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  Cualquiera igualdad de cadenas              $a eq $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $answer = 42;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230806Z" changeid="zipf">
        <seg>my $respuesta = 42;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open $file: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230203Z" changeid="explorer">
        <seg>or die &quot;No puedo abrir $archivo: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Who supports Perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T195933Z" changeid="explorer">
        <seg>=head2 ¿Quién respalda a Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;IPC::Open2&gt;, L&lt;IPC::Open3&gt;, and
L&lt;perlipc/&quot;Bidirectional Communication with Another Process&quot;&gt;
for examples of such things.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175737Z" changeid="explorer">
        <seg>Ver L&lt;IPC::Open2&gt;, L&lt;IPC::Open3&gt;, y L&lt;perlipc/&quot;Comunicación Bidireccional con otro proceso&quot;&gt; para ejemplos de estas cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1..3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1..3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### next always comes here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>### next siempre viene aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with Perl 5.14, C&lt;pop&gt; can take a scalar EXPR, which must hold a
reference to an unblessed array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175755Z" changeid="explorer">
        <seg>A partir de Perl 5.14, C&lt;pop&gt; puede tomar una EXPR escalar, que debe contener la referencia a un hash o un array no bendecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last; # can't go to outer :-(</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last; # no puedo volver al bucle más externo :-(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with Foreword by Larry Wall</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003025Z" changeid="explorer">
        <seg>con prólogo de Larry Wall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die @_ if $^S;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die @_ if $^S;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When of the form C&lt;\N{NAME}&gt;, it matches the
character or character sequence whose name is C&lt;NAME&gt;; and similarly
when of the form C&lt;\N{U+I&lt;hex&gt;}&gt;, it matches the character whose Unicode
code point is I&lt;hex&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045215Z" changeid="explorer">
        <seg>Cuando es de la forma C&lt;\N{NOMBRE}&gt;, coincide con el carácter o secuencia de caracteres cuyo nombre es C&lt;NOMBRE&gt;; y de manera similar cuando es de la forma C&lt;\N{U+I&lt;hex&gt;}&gt;, coincide con el carácter cuyo punto de código Unicode es I&lt;hex&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;aa\x08&quot; =~ /${a}0/;  # True!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191739Z" changeid="explorer">
        <seg>&quot;aa\x08&quot; =~ /${a}0/;  # ¡Verdadero!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m?(homer)?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T212207Z" changeid="explorer">
        <seg>m?(homer)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,29, 1) = 1   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,29, 1) = 1   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;File::Copy&gt; now detects Unix compatibility mode on VMS.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153244Z" changeid="explorer">
        <seg>C&lt;File::Copy&gt; ahora detecta el modo de compatibilidad Unix, en VMS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($paragraph =~ /($sentence_rx)/g) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025732Z" changeid="explorer">
        <seg>while ($parrafo =~ /($sentencia_rx)/g) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::BigInteger       uses an external C library</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035405Z" changeid="explorer">
        <seg>Math::BigInteger		usa una biblioteca C externa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receives a message on a socket.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recibe un mensaje de un socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is whatever you can justify on the basis
of media cost, duplication charges, time of people involved, and so on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es lo que puede justificar en función de los costes medios de comunicación, gastos de duplicación, tiempo de las personas involucradas, y así sucesivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a reciprocal fashion, an operation provides either a scalar or a
list context to each of its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma recíproca, cualquier operación establece un contexto escalar o un contexto de lista para cada uno de sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>q{foo{bar}baz}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>q{foo{bar}baz}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1645 Irix 6.2 &amp; 6.3 POSIX header file updates</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004256Z" changeid="explorer">
        <seg>1645 Irix 6.2 &amp; 6.3 POSIX actualizaciones de los ficheros cabecera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$addrtype,$length,@addrs) = gethost*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($name,$aliases,$addrtype,$length,@addrs) = gethost*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 4) = 2   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 4) = 2   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 5.8.0 there were about 69000 separate tests in about 700 test files,
in Perl 5.9.0 there are about 77000 separate tests in about 780 test files.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T002203Z" changeid="explorer">
        <seg>En Perl 5.8.0 había alrededor de 69.000 pruebas distintas en alrededor de 700 archivos de prueba, en Perl 5.9.0 hay cerca de 77.000 pruebas distintas en alrededor de 780 archivos de prueba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;[$ix])   { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;[$i])      { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a) the GNU General Public License as published by the Free</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a) la Licencia General Pública GNU, publicada por la Free</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(3,8,7);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>set_vec(3,8,7);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%g&gt;', 1;        # prints &quot;&lt;1&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%g&gt;', 1;        # imprime &quot;&lt;1&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only kind of simple statement is an expression evaluated for its
side effects.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012918Z" changeid="explorer">
        <seg>La única clase de instrucción simple que existe es una expresión evaluada para obtener unos efectos colaterales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset 'X';      # reset all X variables</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>reset 'X';      # reinicia todas las variables X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar values can be used in various ways:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230948Z" changeid="zipf">
        <seg>Los valores escalares se pueden usar de varias maneras:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 sprintf() fixes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044359Z" changeid="explorer">
        <seg>=head2 Arreglos en sprintf()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$obj-&gt;do_something(</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021545Z" changeid="explorer">
        <seg>$obj-&gt;hacer_algo(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/ExtUtils/t/PL_FILES.t      #26813</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T053453Z" changeid="explorer">
        <seg>lib/ExtUtils/t/PL_FILES.t      #26813</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldoc		Look up Perl documentation in Pod format</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000627Z" changeid="explorer">
        <seg>perldoc		Consulta de la documentación de Perl en formato Pod</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Haiku</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005650Z" changeid="explorer">
        <seg>=item Haiku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perlmroapi&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005521Z" changeid="explorer">
        <seg>=item L&lt;perlmroapi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because this wouldn't work:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030023Z" changeid="explorer">
        <seg>Porque si no, lo siguiente no funcionará:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But both are slower than assigning the empty list
or undefining %HASH or @ARRAY, which is the customary 
way to empty out an aggregate:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero estos dos son más lentos que simplemente asignar una lista vacía o indefiniendo %HASH o @ARRAY, que es la forma normal de vaciar un agregado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A slice of an empty list is still an empty list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una porción de una lista vacía es también una lista vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value can be used as an indirect
filehandle, usually the real filehandle name or an autovivified handle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023543Z" changeid="explorer">
        <seg>IDENTIFICADOR_ARCHIVO puede ser una expresión cuyo valor puede ser usado como un identificador de archivo indirecto, normalmente el nombre real del identificador de archivo o un identificador autovivificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $animal;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232606Z" changeid="explorer">
        <seg>print $animal;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-52011-3 [5th edition June 2008]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003112Z" changeid="explorer">
        <seg>ISBN 978-0-596-52011-3 [5ª edición - Junio de 2008]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open FILEHANDLE,MODE,EXPR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011036Z" changeid="explorer">
        <seg>=item open IDENTIFICADOR_ARCHIVO,MODO,EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>format Something =</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>format Algo =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rmdir FILENAME
X&lt;rmdir&gt; X&lt;rd&gt; X&lt;directory, remove&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T195950Z" changeid="explorer">
        <seg>=item rmdir NOMBRE_DIRECTORIO
X&lt;rmdir&gt; X&lt;rd&gt; X&lt;directory, remove&gt; X&lt;directorio, eliminar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember that the look-aheads
are zero-width expressions--they only look, but don't consume any
of the string in their match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171449Z" changeid="explorer">
        <seg>Recuerde que las aserciones consecuentes son expresiones de ancho cero: ellas solo miran, pero no utilizan ninguna parte de la cadena de caracteres en su coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takes the
same flags as the system call of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toma las mismas banderas que la llamada al sistema del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX qw/strftime/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225522Z" changeid="explorer">
        <seg>use POSIX qw/strftime/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For double-quoted strings, the quoting from C&lt;\Q&gt; is applied after
interpolation and escapes are processed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222210Z" changeid="explorer">
        <seg>Para las cadenas con comillas dobles, el efecto de C&lt;\Q&gt; es aplicado después del procesado de la interpolación y el escapado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar(@whatever) == $#whatever + 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>scalar(@loquesea) == $#loquesea + 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./Configure -Dusethreads -Duseithreads</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>./Configure -Dusethreads -Duseithreads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 8   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 8   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless (EXPR) BLOQUE elsif (EXPR) BLOQUE ... else BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since the publishing of this
book, by many known as &quot;Camel III&quot;, the consensus of the naming of this
functionality has moved from &quot;discipline&quot; to &quot;layer&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, desde la publicación de este libro, conocido por muchos como &quot;Camel III&quot;, el consenso sobre el nombre de esta funcionalidad se ha movido desde &quot;disciplina&quot; a &quot;capa&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hash{&quot;$key\0&quot;} = &quot;$value\0&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110812T145040Z" changeid="zipf">
        <seg>$hash{&quot;$clave\0&quot;} = &quot;$valor\0&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596520694</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003524Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596520694</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, C&lt;a*ab&gt; will match the same as C&lt;a+b&gt;,
since the match of the subgroup C&lt;a*&gt; is influenced by the following
group C&lt;ab&gt; (see L&lt;&quot;Backtracking&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220555Z" changeid="explorer">
        <seg>Por el contrario, C&lt;a*ab&gt; coincidirá igual que con C&lt;a+b&gt;, ya que la coincidencia del subgrupo C&lt;a*&gt; está influenciada por el texto del grupo siguiente C&lt;ab&gt; (vea L&lt;&quot;backtracking&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't normally need to worry about this unless
you are writing a Perl debugger.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No necesita preocuparse de esto a menos que esté escribiendo un depurador Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item syswrite FILEHANDLE,SCALAR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013042Z" changeid="explorer">
        <seg>=item syswrite IDENTIFICADOR_ARCHIVO,ESCALAR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item telldir DIRHANDLE
X&lt;telldir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T021109Z" changeid="explorer">
        <seg>=item telldir IDENTIFICADOR_DIR
X&lt;telldir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Support for
specific formats are available from CPAN as C&lt;CPANPLUS::Dist::*&gt; modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235329Z" changeid="explorer">
        <seg>El código de compatibilidad con los distintos formatos específicos se encuentra en los módulos C&lt;CPANPLUS::Dist::*&gt; de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(.)(.)(.)(.)(.)(.)(.)(.)(.)\10/    # \10 is octal</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191455Z" changeid="explorer">
        <seg>/(.)(.)(.)(.)(.)(.)(.)(.)(.)\10/    # \10 es octal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hashes have no particular internal order, though you can sort the keys
and loop through them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224935Z" changeid="explorer">
        <seg>En los hashes no hay un orden interno específico, aunque puede ordenar las claves antes de recorrerlas en un bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When reading, VAR must be a variable that will
hold the data read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al leer, VAR debe ser una variable que contendrá los datos leídos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpodspec 	Perl plain old documentation format specification</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000306Z" changeid="explorer">
        <seg>perlpodspec 	Especificación del formato POD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or you might have had a temporary variable sitting around with the
array in it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>O podría haber usado una variable temporal con el array en ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that
one will be able to say</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014347Z" changeid="explorer">
        <seg>Esto significa que uno podrá decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 1) = 1   ==          4 00100000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 1) = 1   ==          4 00100000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The level of detail in Perl module documentation generally goes from
less detailed to more detailed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024133Z" changeid="explorer">
        <seg>El nivel de detalle en la documentación general del módulo Perl, va de menos a más detallada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::BigIntFast       Bit::Vector wrapper for big numbers</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035357Z" changeid="explorer">
        <seg>Math::BigIntFast		envoltorio de Bit::Vector para grandes números</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The conditional is true if any variables were assigned; that is,
if the pattern matched.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025133Z" changeid="explorer">
        <seg>La condición es verdadera si cualquiera de las variables fueron asignadas; es decir, si el patrón emparejó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In I&lt;getpw*()&gt; the fields $quota, $comment, and $expire are special
in that they are unsupported on many systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En I&lt;getpw*()&gt; los campos $cuota, $comentario y $expiracion son casos especiales en el sentido que en muchos sistemas no están soportados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with Perl 5.14, C&lt;splice&gt; can take scalar EXPR, which must hold a
reference to an unblessed array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181340Z" changeid="explorer">
        <seg>A partir de Perl 5.14, C&lt;splice&gt; puede tomar una EXPR escalar, que debe contener la referencia a un hash o un array no bendecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmpeix		Perl notes for MPE/iX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmpeix		Notas para MPE/iX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;SVf_UTF8&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005937Z" changeid="explorer">
        <seg>=item C&lt;SVf_UTF8&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$oct = sprintf(&quot;%o&quot;, 3735928559);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225514Z" changeid="explorer">
        <seg>$oct = sprintf(&quot;%o&quot;, 3735928559);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, many Perl books include a distribution of perl,
as do the O'Reilly Perl Resource Kits (in both the Unix flavor
and in the proprietary Microsoft flavor); the free Unix distributions
also all come with perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231102Z" changeid="explorer">
        <seg>Por ejemplo, muchos libros sobre Perl incluyen una distribución de perl, como los kits de recursos Perl publicados por O'Reilly (incluyen una versión para Unix y una versión comercial para sistemas Microsoft); las distribuciones gratuitas de Unix también incluyen perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl should now build on MirOS BSD.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003844Z" changeid="explorer">
        <seg>Perl ahora debe compilarse en MirOS BSD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to trap errors when loading an XS module, some problems with
the binary interface (such as Perl version skew) may be fatal even with
C&lt;eval&gt; unless C&lt;$ENV{PERL_DL_NONLAZY}&gt; is set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea capturar los errores cuando se carga un módulo XS, algunos problemas con la interfaz binaria (como el sesgo de versión de Perl) puede ser fatal, incluso con C&lt;eval&gt; a menos que C&lt;$ENV{PERL_DL_NONLAZY}&gt; esté puesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hex = unpack(&quot;H*&quot;, pack(&quot;N&quot;, 3735928559));</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225514Z" changeid="explorer">
        <seg>$hex = unpack(&quot;H*&quot;, pack(&quot;N&quot;, 3735928559));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or from the command line:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o desde la línea de comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $y (1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $y (1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To keep the string the same
length, you may need to pad or chop your value using C&lt;sprintf&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para mantener la cadena de la misma longitud, puede ser necesario rellenar o recortar su valor con C&lt;sprintf&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A contact email address for the author/maintainer</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024054Z" changeid="explorer">
        <seg>Una dirección de correo electrónico de contacto del autor/mantenedor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>we prevent backtracking and find the count of the longest matching string
at each matching starting point like so:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T012756Z" changeid="explorer">
        <seg>evitamos la vuelta atrás y hacemos el recuento de la cadena más larga coincidente en cada punto inicial de la coincidencia, como se ve:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary compatibility with 5.8.0 has been restored in 5.8.2, which
necessitates breaking compatibility with 5.8.1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La compatibilidad binaria con 5.8.0 ha sido restaurada en 5.8.2, que requiere romper la compatibilidad con 5.8.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omit redundant punctuation as long as clarity doesn't suffer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Omitir la puntuación redundante mientras no se reduzca la claridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The snazzle() function will behave in the most spectacular</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función snazzle() se convertirá en la más espectacular</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matching operations can have various modifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las operaciones de coincidencia pueden tener varios modificadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The null list contains no elements, so when the password file is
exhausted, the result is 0, not 2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La lista vacía no contiene elementos, así que cuando el archivo de contraseñas se acaba, el resultado es 0, no 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Categories of modules range from text manipulation to network protocols
to database integration to graphics.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225600Z" changeid="explorer">
        <seg>Las categorías de módulos abarcan desde la manipulación de texto hasta protocolos de red, integración de bases de datos o gráficos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ($foo &amp; 255) + 1, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ($foo &amp; 255) + 1, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@data = &lt;FILE&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T010549Z" changeid="explorer">
        <seg>@data = &lt;ARCHIVO&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ideally, someone who's slightly familiar with your module should be able
to refresh their memory without hitting &quot;page down&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024424Z" changeid="explorer">
        <seg>Lo ideal sería que alguien que está un poco familiarizado con el módulo debería ser capaz de refrescar su memoria sin tener que pulsar el &quot;avance de página&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provide sensible defaults for parameters which have them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022314Z" changeid="explorer">
        <seg>Proporcione parámetros por defecto para los parámetros que los tengan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you change them, Perl won't
even notice.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T204610Z" changeid="explorer">
        <seg>Si las cambia, Perl ni siquiera se dará cuenta.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 OS groups</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200701Z" changeid="explorer">
        <seg>=head2 Agrupación de SO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item stat</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item stat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>i  A signed integer value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>i  Un valor entero con signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Searches a string for a pattern match, and in scalar context returns
true if it succeeds, false if it fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Busca una cadena para una coincidencia de patrones, y en un contexto escalar devuelve verdadero si tiene éxito, falso si falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If what the angle brackets contain is a simple scalar variable (e.g.,
&lt;$foo&gt;), then that variable contains the name of the
filehandle to input from, or its typeglob, or a reference to the
same.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014316Z" changeid="explorer">
        <seg>Si lo que los ángulos contienen es una variable escalar simple (por ejemplo, &lt;$foo&gt;), entonces esa variable contiene el nombre del identificador de archivo desde el qué recibir la entrada, o su I&lt;typeglob&gt;, o una referencia al mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport&gt;, 
your port's specific documentation, and your system-specific local manpages
for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T234018Z" changeid="explorer">
        <seg>Vea L&lt;perlport&gt;, la documentación específica de su adaptación Perl, y sus páginas de manual locales, para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the yes-pattern is never directly executed, and no
no-pattern is allowed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195828Z" changeid="explorer">
        <seg>En este caso, el patrón-sí no se ejecuta nunca directamente, y no se permite un patrón-no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operations return C&lt;undef&gt; to indicate failure, end of file,
system error, uninitialized variable, and other exceptional
conditions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001717Z" changeid="explorer">
        <seg>Muchas operaciones devuelven C&lt;undef&gt; para indicar un error, fin de archivo, error del sistema, variable no inicializada u otras condiciones excepcionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item substr EXPR,OFFSET,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item substr EXPR,DESPLAZAMIENTO,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlnumber		Perl number semantics</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000405Z" changeid="explorer">
        <seg>perlnumber		Semántica de números</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;tr&gt; operator is not equivalent to the tr(1)
utility.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T032000Z" changeid="explorer">
        <seg>El operador C&lt;tr&gt; no es equivalente a la utilidad tr(1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item package NAMESPACE BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175410Z" changeid="explorer">
        <seg>=item package ESPACIO_NOMBRES BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect of C&lt;values&gt; is considered highly
experimental.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183818Z" changeid="explorer">
        <seg>Este aspecto de C&lt;values&gt; es considerado altamente experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to read LENGTH I&lt;characters&gt; of data into variable SCALAR
from the specified FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011641Z" changeid="explorer">
        <seg>Intento de leer LONGITUD I&lt;caracteres&gt; de datos en la variable ESCALAR del IDENTIFICADOR_ARCHIVO especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$2 = (bar(baz)+baz(bop))</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185702Z" changeid="explorer">
        <seg>$2 = (bar(baz)+baz(bop))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the test lib/ftmp-security gives you as a result
something like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la prueba lib/ftmp-security da como resultado algo como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is now fixed; now C&lt;no warnings 'io';&gt; will only turn off warnings in the
C&lt;io&gt; class.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T043832Z" changeid="explorer">
        <seg>Esto ha sido corregido; ahora C&lt;no warnings 'io';&gt; sólo desactivará las advertencias en la clase C&lt;io&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default {
            say &quot;I don't like anything&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234548Z" changeid="explorer">
        <seg>default {
            say &quot;No me gusta nada&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, despite what may be implied in I&lt;&quot;Programming Perl&quot;&gt; (the
Camel, 3rd edition) or elsewhere, C&lt;:raw&gt; is I&lt;not&gt; simply the inverse of C&lt;:crlf&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que, a pesar de estar implícito en I&lt;&quot;Programming Perl&quot;&gt; (el dromedario, 3ª edición) o en otro lugar, C&lt;:raw&gt; I&lt;no&gt; es el simplemente el inverso de C&lt;:crlf&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, ensure you've
found an actual bug.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231115Z" changeid="explorer">
        <seg>Cuando esté seguro, confírmelo otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
C&lt;int(-6.725/0.025)&gt; produces -268 rather than the correct -269; that's
because it's really more like -268.99999999999994315658 instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;int(-6.725/0.025)&gt; produce -268 en vez del valor correcto -269; esto es porque el valor realmente es -268.99999999999994315658.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This set of
characters is just a recommendation; the characters allowed in
the salt depend solely on your system's crypt library, and Perl can't
restrict what salts C&lt;crypt()&gt; accepts.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este conjunto de caracteres es sólo una recomendación; los caracteres permitidos en el salto dependen solamente de la función crypt del sistema y Perl no puede restringir el salto que C&lt;crypt()&gt; acepte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(PASSWD, &quot;&gt;&quot;, &quot;/dev/passwd&quot;) or ...;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225644Z" changeid="explorer">
        <seg>open(PASSWD, &quot;&gt;&quot;, &quot;/dev/passwd&quot;) or ...;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar may contain one single value in any of three
different flavors: a number, a string, or a reference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T001241Z" changeid="explorer">
        <seg>Un escalar puede contener un único valor perteneciente a un tipo de entre tres distintos: un número, una cadena o una referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with Perl 5.14, C&lt;values&gt; can take a scalar EXPR, which must hold
a reference to an unblessed hash or array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183809Z" changeid="explorer">
        <seg>A partir de Perl 5.14, C&lt;values&gt; puede tomar una EXPR escalar, que debe contener la referencia a un hash o un array no bendecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a description
of this, see L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215244Z" changeid="explorer">
        <seg>Para una descripción de ésto, vea L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;a2p&gt; converts F&lt;awk&gt; scripts to Perl programs; for example, C&lt;a2p -F:&gt;
on the simple F&lt;awk&gt; script C&lt;{print $2}&gt; will produce a Perl program
based around this code:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234154Z" changeid="explorer">
        <seg>F&lt;a2p&gt; convierte scripts F&lt;awk&gt; en programas Perl; por ejemplo, si ejecuta C&lt;a2p -F:&gt; sobre el sencillo script F&lt;awk&gt; C&lt;{print $2}&gt;, generará un programa Perl basado en el código siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;\N&gt; has two meanings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que C&lt;\N&gt; tiene dos significados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;the sort pragma|sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;el pragma sort|sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($some_condition) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181650Z" changeid="zipf">
        <seg>if ($una_condicion) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takes a LIST of values and converts it into a string using the rules
given by the TEMPLATE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toma una LISTA de valores y la convierte en una cadena usando las reglas dadas por la PLANTILLA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike i, m, s and x, these two flags affect the way the regex is used
rather than the regex itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de i, m, s y x, estos dos indicadores afectan a la forma en que se utiliza la expresión regular en lugar de la propia expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates an unnamed pair of sockets in the specified domain, of the
specified type.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea un par de sockets anónimos en el dominio especificado, del tipo especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/io/perlio_leaks.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010003Z" changeid="explorer">
        <seg>=item t/io/perlio_leaks.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>translates a list of numbers to their squared values.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171552Z" changeid="explorer">
        <seg>traduce una lista de números a sus valores al cuadrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;eval&gt;/C&lt;die&gt; always works,
modulo the caveats given in L&lt;perlipc/&quot;Signals&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando C&lt;eval&gt;/C&lt;die&gt; siempre funciona, teniendo en cuenta las advertencias dadas en L&lt;perlipc/&quot;Señales&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns like ioctl: C&lt;undef&gt; for error; &quot;C&lt;0&gt; but
true&quot; for zero; and the actual return value otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014046Z" changeid="explorer">
        <seg>Devuelve lo mismo que ioctl: C&lt;undef&gt; para error; &quot;C&lt;0&gt; but true&quot; para cero; o el valor de retorno real, en cualquier otro caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be aware that setting C&lt;@DB::args&gt; is I&lt;best effort&gt;, intended for
debugging or generating backtraces, and should not be relied upon.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023055Z" changeid="explorer">
        <seg>Tenga en cuenta que fijar C&lt;@DB::args&gt; es I&lt;el mejor esfuerzo&gt;, destinado a la depuración o la generación de seguimientos, y no debería ser invocado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/io/perlio.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010008Z" changeid="explorer">
        <seg>=item t/io/perlio.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first element of the
list must be the numeric mode, which should probably be an octal
number, and which definitely should I&lt;not&gt; be a string of octal digits:
C&lt;0644&gt; is okay, but C&lt;&quot;0644&quot;&gt; is not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023258Z" changeid="explorer">
        <seg>El primer elemento de la lista debe ser un modo numérico, que normalmente estará en octal, y que, definitivamente, I&lt;no&gt; debe ser una cadena de dígitos en octal: C&lt;0644&gt; es correcto, C&lt;&quot;0644&quot;&gt; no lo es.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;splain&gt; is an interface to L&lt;perldiag&gt; - paste in your error message
to it, and it'll explain it for you.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234101Z" changeid="explorer">
        <seg>F&lt;splain&gt; es una interfaz de L&lt;perldiag&gt;; si pega un mensaje de error, mostrará una descripción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/[8]&gt; below for details on which character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T202421Z" changeid="explorer">
        <seg>Ver L&lt;/[8]&gt; más abajo para detalles sobre el carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %hash  = ();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225615Z" changeid="explorer">
        <seg>my %hash  = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LENGTH is
not specified, writes whole SCALAR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LONGITUD no se especifica, escribe todo el ESCALAR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>======  =====     =====================    =============</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>==========  =========  ===============================  =============</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bundled version is 2.06_01.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T020025Z" changeid="explorer">
        <seg>La versión incluida es la 2.06_01.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and I&lt;not&gt;
Mac OS X.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando decimos bajo &quot;Mac OS&quot;, queremos decir Mac OS 7, 8 y 9, y I&lt;no&gt; Mac OS X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider two possible matches, C&lt;AB&gt; and C&lt;A'B'&gt;, C&lt;A&gt; and C&lt;A'&gt; are
substrings which can be matched by C&lt;S&gt;, C&lt;B&gt; and C&lt;B'&gt; are substrings
which can be matched by C&lt;T&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235024Z" changeid="explorer">
        <seg>Consideremos dos posibles coincidencias, C&lt;AB&gt; y C&lt;A'B'&gt;, C&lt;A&gt; y C&lt;A'&gt; son subcadenas que pueden coincidir con C&lt;S&gt;; C&lt;B&gt; y C&lt;B'&gt; son subcadenas que pueden coincidir con C&lt;T&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(IN, $ARGV[0]) || die &quot;can't open $ARGV[0]: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235533Z" changeid="explorer">
        <seg>open(IN, $ARGV[0]) || die &quot;no puedo abrir $ARGV[0]: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chr(127)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204558Z" changeid="explorer">
        <seg>chr(127)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the current position to the beginning of the directory for the
C&lt;readdir&gt; routine on DIRHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020813Z" changeid="explorer">
        <seg>Establece la posición actual al comienzo del directorio para la rutina C&lt;readdir&gt; en IDENTIFICADOR_DIR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete() may also be used on arrays and array slices, but its behavior is less
straightforward.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete() puede usarse también en lo arrays y porciones de array, pero su comportamiento es menos claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every CPAN module has a bug tracker set up in RT, http://rt.cpan.org .
You can submit bugs to RT either through its web interface or by
email.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231216Z" changeid="explorer">
        <seg>Todo módulo de CPAN tiene un sistema de seguimiento de errores configurado en RT, http://rt.cpan.org . Puede enviar informes de error a RT por correo electrónico o a través de su interfaz web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, ithreads were made
less memory-intensive.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014245Z" changeid="explorer">
        <seg>Además, ithreads se ha hecho menos intenso con el consumo de memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In almost all cases like this, it's usually a far, far better idea to use the
structured control flow mechanisms of C&lt;next&gt;, C&lt;last&gt;, or C&lt;redo&gt; instead of
resorting to a C&lt;goto&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En casi todos los casos como este, es usualmente una mejor, mucho mejor idea, usar los mecanismos de control de flujo de C&lt;next&gt;, C&lt;last&gt; o C&lt;redo&gt; en vez de recurrir a C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may not be a space between the C&lt;&lt; &lt;&lt; &gt;&gt; and the identifier,
unless the identifier is explicitly quoted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No es necesario un espacio entre el C&lt;&lt; &lt;&lt; &gt;&gt; y el identificador, a menos que el identificador esté explícitamente entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as B&lt;Do What I
Mean&gt;, abbreviated B&lt;DWIM&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es conocido como B&lt;Do What I Mean&gt; (haz lo que te digo), abreviado como B&lt;DWIM&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the entry doesn't exist you get the undefined value.)  For example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si la entrada no existe obtendrá el valor indefinido). Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I said bar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He dicho bar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we usually think of quotes as literal values, in Perl they
function as operators, providing various kinds of interpolating and
pattern matching capabilities.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras solemos solemos pensar de lo entrecomillado como si fueran valores literales, en Perl funcionan como operadores, ofreciendo diversos tipos de interpolación y capacidades de coincidencia de patrones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;A&gt; and C&lt;A'&gt; coincide: C&lt;AB&gt; is a better match than C&lt;AB'&gt; if
C&lt;B&gt; is a better match for C&lt;T&gt; than C&lt;B'&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235412Z" changeid="explorer">
        <seg>Si C&lt;A&gt; y C&lt;A'&gt; coinciden: C&lt;AB&gt; es una mejor coincidencia que C&lt;AB'&gt; si C&lt;B&gt; es un mejor coincidencia para C&lt;T&gt; que C&lt;B'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See README.os400.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T190824Z" changeid="explorer">
        <seg>Vea README.os400.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 New Tests</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Nuevas pruebas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Provide sensible shortcuts and defaults.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021044Z" changeid="explorer">
        <seg>=item Proporcione atajos y valores por defecto razonables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The perl interpreter is now more tolerant of UTF-16-encoded scripts.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El intérprete perl es ahora más tolerante con los script codificados en UTF-16.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has been the
behaviour in the cygwin.com build for years.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T020139Z" changeid="explorer">
        <seg>Este ha sido el comportamiento en la compilación de cygwin.com desde hace años.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = &quot;The brown fox jumps over the lazy dog&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T220447Z" changeid="explorer">
        <seg>$_ = &quot;El zorro marrón saltó sobre el perezoso perro&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an input filehandle is marked C&lt;:utf8&gt; and Perl sees illegal UTF-8
coming in when doing C&lt;&lt; &lt;FH&gt; &gt;&gt;, if warnings are enabled a warning is
immediately given - instead of being silent about it and Perl being
unhappy about the broken data later.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010835Z" changeid="explorer">
        <seg>Si un identificador de archivo de entrada es marcado como C&lt;:utf8&gt; y Perl ve UTF-8 ilegal cuando hace C&lt;&lt; &lt;FH&gt; &gt;&gt;, si las advertencias están activadas, se levanta inmediatamente una advertencia - en lugar de callar y dejar Perl descontento con el resto de datos estropeados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = q!I said, &quot;You said, 'She said it.'&quot;!;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = q!Yo dije, &quot;Tu dijiste, 'Ella dijo.'&quot;!;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most platforms, you will have to protect
shell metacharacters if you want them treated literally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de plataformas, tendrá que proteger los metacaracteres de shell, si quiere que ellos sean tratados literalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a more rigorous (and complicated) view of
the rules involved in selecting a match among possible alternatives,
see L&lt;Combining RE Pieces&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T145135Z" changeid="explorer">
        <seg>Para un análisis más riguroso (y complicado punto de vista) de las normas involucradas en la selección de una coincidencia entre las alternativas posibles, vea L&lt;Combinando piezas RE&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># code</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># código</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>% perl -lne 'print if /^[^\/]+\.[ch]\s+/' MANIFEST</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T015012Z" changeid="explorer">
        <seg>% perl -lne 'print if /^[^\/]+\.[ch]\s+/' MANIFEST</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/mro/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014628Z" changeid="explorer">
        <seg>=item * F&lt;t/mro/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say 'a complicated check for $foo is true';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>say 'una confirmación complicada para $foo es cierta';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keys(%users) = 1000;		# allocate 1024 buckets</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>keys(%usuarios) = 1000;		# reserva 1024 cajones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} };</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223514Z" changeid="explorer">
        <seg>} };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of lines remaining on the current
page is in variable C&lt;$-&gt;, which can be set to C&lt;0&gt; to force a new page.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030009Z" changeid="explorer">
        <seg>El número de líneas restantes de la página actual está en la variable C&lt;$-&gt;, que se puede fijar a C&lt;0&gt; para forzar una nueva página.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What about adding new columns?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Qué pasa con la adición de nuevas columnas?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m{ \(
          (
            (?&gt; [^()]+ )        # change x+ above to (?&gt; x+ )
          |
            \( [^()]* \)
          )+</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T214529Z" changeid="explorer">
        <seg>m{ \(
          (
            (?&gt; [^()]+ )        # cambiar x+ anterior a (?&gt; x+ )
          |
            \( [^()]* \)
          )+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Jerry Hedden).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005956Z" changeid="explorer">
        <seg>(Jerry Hedden).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># for speed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># para aumentar la velocidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression
C&lt;glob(&quot;.* *&quot;)&gt; matches all files in the current working directory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T164708Z" changeid="explorer">
        <seg>La expresión C&lt;glob(&quot;.* *&quot;)&gt; coincide con todos los archivos en el directorio de trabajo actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most implementations of C&lt;srand&gt; take an integer and will silently
truncate decimal numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de las implementaciones de C&lt;srand&gt; toman un número entero y silenciosamente truncará los números decimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now C&lt;use customre&gt; enables the new escape in constant regular
expressions, i.e., those without any runtime variable interpolations.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002513Z" changeid="explorer">
        <seg>Ahora C&lt;use customre&gt; permite usar el nuevo escape en expresiones regulares constantes, es decir, aquellas que no tienen ninguna interpolación de variables en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 OO Perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Perl orientado a objetos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the packed address if it succeeded, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la dirección empaquetada si ha tenido éxito, de lo contrario, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join(':', split(//, 'hi there')), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print join(':', split(//, 'hola por aqui')), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl
bug database at http://bugs.perl.org/ .  There may also be
information at http://www.perl.org/ , the Perl Home Page.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T041651Z" changeid="explorer">
        <seg>Si encuentra algo que piensa que es un error, podría verificar los artículos publicados recientemente en el grupo de noticias comp.lang.perl.misc y la base de datos de errores de perl en http://bugs.perl.org/ . Hay también información en la página principal de Perl, http://www.perl.org/ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@new = sort other::backwards @old;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@nuevo = sort otro::al_reves @viejo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Constant Folding
X&lt;constant folding&gt; X&lt;folding&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010957Z" changeid="explorer">
        <seg>=head2 Plegado de constantes
X&lt;constant folding&gt; X&lt;folding&gt; X&lt;plegado de constantes&gt; X&lt;plegado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POSITION and the return value are based at C&lt;0&gt; (or whatever
you've set the C&lt;$[&gt; variable to--but don't do that).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>POSICIÓN y el valor devuelto están basados en C&lt;0&gt; (o al valor indicado por la variable C&lt;$[&gt;, pero no lo haga, por favor).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument will be
dereferenced automatically.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165234Z" changeid="explorer">
        <seg>El argumento es desreferenciado automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, Perl attempts to flush all files opened for
output before forking the child process, but this may not be supported
on some platforms (see L&lt;perlport&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de la versión v5.6.0, Perl intentará vaciar todos los archivos abiertos para salida antes de crear un proceso hijo, pero esto puede no estar soportado en algunas plataformas (ver L&lt;perlport&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because
this promotes strange action at a distance, this counterintuitive
behavior may be fixed in a future release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que provoca una acción extraña a gran distancia, este comportamiento no intuitivo puede ser arreglado en una distribución futura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does the same thing as the C&lt;stat&gt; function (including setting the
special C&lt;_&gt; filehandle) but stats a symbolic link instead of the file
the symbolic link points to.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010831Z" changeid="explorer">
        <seg>hace lo mismo que la función C&lt;stat&gt; (incluyendo el establecimiento del identificador de archivo especial C&lt;_&gt;) pero de un enlace simbólico en lugar del archivo apuntado por el enlace simbólico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last if $x = $y**2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last if $x = $y**2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp $re;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T222805Z" changeid="explorer">
        <seg>chomp $re;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlport&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215543Z" changeid="explorer">
        <seg>Vea también L&lt;perlport&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, keep in mind that Perl might not be the right tool for every
job.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232530Z" changeid="explorer">
        <seg>Por último, tenga en cuenta que Perl puede no ser la herramienta adecuada para algunas tareas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ((1+2)+4);  # Prints 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ((1+2)+4);	# Imprime 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The days of just flinging strings around are over.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T060221Z" changeid="explorer">
        <seg>Actualmente ya no es posible trabajar con cadenas de texto de manera irreflexiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'aaab' =~ /a+b?(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T011931Z" changeid="explorer">
        <seg>'aaab' =~ /a+b?(?{print &quot;$&amp;\n&quot;; $contador++})(*FAIL)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may substantially slow your program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto puede ralentizar sustancialmente el programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl591delta	Perl changes in version 5.9.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl591delta	Cambios en la versión 5.9.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @{$ref-&gt;[$x][$y]}[$index1, $index2, @moreindices];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @{$ref-&gt;[$x][$y]}[$indice1, $indice2, @masindices];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;r is not a reference at all.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;r no es una referencia.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0x56 0x78 0x12 0x34</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0x56 0x78 0x12 0x34</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -Dcc='cc -64' -Duse64bitall</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002623Z" changeid="explorer">
        <seg>sh Configure -Dcc='cc -64' -Duse64bitall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the value of the last evaluated expression of the successful
C&lt;when&gt;/C&lt;default&gt; clause, if there's one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223120Z" changeid="explorer">
        <seg>el valor de la última expresión evaluada de la exitosa cláusula C&lt;when&gt;/C&lt;default&gt;, si hay alguna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's equivalent to C&lt;&amp;&amp;&gt; except for the very low
precedence.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230223Z" changeid="explorer">
        <seg>Es equivalente a &quot;&amp;&amp;&quot; excepto por tener una precedencia muy baja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that unlike C&lt;split&gt;, C&lt;join&gt; doesn't take a pattern as its
first argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuidado que, a diferencia de C&lt;split&gt;, C&lt;join&gt; no toma un patrón como su primer argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next call following that one restarts iteration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La siguiente llamada reinicia la iteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, see L&lt;/exec&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215829Z" changeid="explorer">
        <seg>Una vez más, vea L&lt;/exec&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now it works both ways.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031356Z" changeid="explorer">
        <seg>Ahora funciona de las dos maneras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 RELEASE CONSIDERATIONS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025103Z" changeid="explorer">
        <seg>=head1 CONSIDERACIONES DEL LANZAMIENTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section needs a rewrite.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230204Z" changeid="explorer">
        <seg>En esta sección necesita una nueva revisión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While that group may still
be found on some news servers, it is unwise to use it, because
postings there will not appear on news servers which honour the
official list of group names.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230414Z" changeid="explorer">
        <seg>Aún lo encontrará en algunos servidores de noticias, pero no debe usarlo, ya que lo que publique allí no aparecerá en los servidores de noticias que respetan la lista oficial de nombres de grupos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 I don't have a C compiler.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225801Z" changeid="explorer">
        <seg>=head2 No dispongo de un compilador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless
otherwise stated the ARG argument is optional; in some cases, it is
forbidden.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T004756Z" changeid="explorer">
        <seg>A menos que se indique lo contrario el argumento ARG es opcional; y en algunos casos, está prohibido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;given(EXPR)&gt; will assign the value of EXPR to C&lt;$_&gt;
within the lexical scope of the block, so it's similar to</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042711Z" changeid="explorer">
        <seg>C&lt;given(EXPR)&gt; asignará el valor de EXPR a C&lt;$_&gt; dentro del ámbito léxico del bloque, algo similar a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = ('cc', '-E', $bar);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = ('cc', '-E', $bar);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the hook is an object, it must provide an INC method that will be
called as above, the first parameter being the object itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el enganche es un objeto, debe proporcionar un método INC que será llamado como antes, el primer parámetro siendo el objeto mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Send omissions or corrections to &lt;F&lt;perlbug@perl.org&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Envíe omisiones o correcciones a &lt;F&lt;perlbug@perl.org&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Bitwise Or and Exclusive Or
X&lt;operator, bitwise, or&gt; X&lt;bitwise or&gt; X&lt;|&gt; X&lt;operator, bitwise, xor&gt;
X&lt;bitwise xor&gt; X&lt;^&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235427Z" changeid="explorer">
        <seg>=head2 Or y exclusivo or binarios
X&lt;operator, bitwise, or&gt; X&lt;bitwise or&gt; X&lt;|&gt; X&lt;operator, bitwise, xor&gt; X&lt;operador, binario, or&gt; X&lt;binario or&gt; X&lt;operador, binario, xor&gt; X&lt;binario xor&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12345.67</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>12345.67</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function places an advisory lock on a shared variable or referenced
object contained in I&lt;THING&gt; until the lock goes out of scope.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171417Z" changeid="explorer">
        <seg>Esta función coloca un bloqueo sobre una variable compartida, o un objeto referenciado contenido en I&lt;COSA&gt; hasta que el bloqueo salga del ámbito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New B&lt;-E&gt; command-line switch</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200535Z" changeid="explorer">
        <seg>=head2 Nueva opción en línea de comandos B&lt;-E&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chown $uid, $gid, @ary;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chown $uid, $gid, @ary;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every simple statement must be terminated with a
semicolon, unless it is the final statement in a block, in which case
the semicolon is optional.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012933Z" changeid="explorer">
        <seg>Cada instrucción simple debe terminarse en un punto y coma excepto si es la última instrucción de un bloque, en cuyo caso el punto y coma es opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The names of the classes should be the result of calling
C&lt;HvENAME()&gt; on the stash.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114616Z" changeid="explorer">
        <seg>Los nombres de las clases deben ser el resultado de la llamada C&lt;HvENAME()&gt; en el esquema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$obj ~~ X</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$obj ~~ X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $character_count = length $text;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234538Z" changeid="explorer">
        <seg>my $numero_caracteres = length $texto;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To extract an ASCII tar archive on VM/ESA, try this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101428Z" changeid="explorer">
        <seg>Para extraer un archivo tar ASCII en VM/ESA, haga lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the entry doesn't exist you get an empty list.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si la entrada no existe, obtendrá una lista vacía).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improved tests.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035729Z" changeid="explorer">
        <seg>Mejora de las pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sort() returns aliases into the original list, much as a for loop's index
variable aliases the list elements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sort() devuelve alias en la lista original, como lo hace la variable de índice de los bucles for(), que hace un alias de los elementos de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What's in a name?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015154Z" changeid="explorer">
        <seg>=head2 ¿Qué hay en un nombre?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@result = sort { $a &lt;=&gt; $b } grep { $_ == $_ } @input;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@resultado = sort { $a &lt;=&gt; $b } grep { $_ == $_ } @entrada;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LAYER is present it is a single string, but may contain multiple
directives.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si CAPA está presente es un único string, pero puede contener múltiples directivas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ **= $_ , / {$_} / for 2 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ **= $_ , / {$_} / for 2 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,m}+ Match at least n but not more than m times and give nothing back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n,m}+ Coincide al menos n pero no más de m veces y no devuelve nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each such format generates 1 bit of the result.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada uno de estos formatos genera un bit del resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, documentation intended for core Perl developers lives in the
F&lt;Porting/&gt; directory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014755Z" changeid="explorer">
        <seg>Por último, la documentación para programadores del núcleo de Perl se encuentra en el directorio F&lt;Porting/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an expression that specifies an element of a hash, returns true if the
specified element in the hash has ever been initialized, even if the
corresponding value is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dada una expresión que especifica un elemento de un hash, devuelve verdadero si el elemento especificado en el hash ha sido inicializado, incluso si el correspondiente valor está indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has been
expanded in many ways.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112129Z" changeid="explorer">
        <seg>Ha sido expandido de muchas maneras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pack(&quot;n/a* w/a&quot;,&quot;hello,&quot;,&quot;world&quot;)       gives &quot;\000\006hello,\005world&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pack(&quot;n/a* w/a&quot;,&quot;hello,&quot;,&quot;world&quot;)       da &quot;\000\006hello,\005world&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might also have loaded that from a function:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es posible que también lo haya cargado a partir de una función:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opendir(my $dh, $some_dir) || die;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>opendir(my $dh, $algun_dir) || die;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, &quot;&lt;&quot;, &quot;foo&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $fh, &quot;&lt;&quot;, &quot;foo&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is experimental support for Linux abstract Unix domain sockets.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T104705Z" changeid="explorer">
        <seg>Hay un soporte experimental para los sockets abstractos del dominio Unix en Linux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without flock() support:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin soporte de flock():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $filename = &quot;filt&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T131901Z" changeid="zipf">
        <seg>my $archivo = &quot;filt&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;\000\001\000\002&quot; on big-endian</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175253Z" changeid="explorer">
        <seg># &quot;\000\001\000\002&quot; en big-endian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric labels now work</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las etiquetas numéricas ahora funcionan</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\E		end either case modification or quoted section</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T221800Z" changeid="explorer">
        <seg>\E		fin de modificación de tamaño de caja o sección entrecomillada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 'Hello, world';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233623Z" changeid="zipf">
        <seg>print 'Hola a todos';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature can be used together with the special variable C&lt;$^N&gt; to
capture the results of submatches in variables without having to keep
track of the number of nested parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T215908Z" changeid="explorer">
        <seg>Esta característica se puede utilizar con la variable especial C&lt;$^N&gt; para capturar los resultados de las coincidencias parciales en variables sin tener que seguir la pista del número de paréntesis anidados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, if you wish to run Configure non-interactively (see the INSTALL
document for details), to have it select the correct hint file, you'll
need to provide the argument -Dhintfile=riscos on the Configure
command-line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que, si desea ejecutar Configure de forma no interactiva (ver el documento INSTALL para más detalles), a su sugerencia de seleccionar el archivo correcto, tendrá que proporcionar el argumento -Dhintfile=riscos en la línea de comando para Configure.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;&quot;switch&quot;&gt; feature is enabled, C&lt;continue&gt; is also a function that
falls through the current C&lt;when&gt; or C&lt;default&gt; block instead of iterating
a dynamically enclosing C&lt;foreach&gt; or exiting a lexically enclosing C&lt;given&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023939Z" changeid="explorer">
        <seg>Si la característica C&lt;&quot;switch&quot;&gt; está habilitada, C&lt;continue&gt; es también una función que termina el actual bloque C&lt;when&gt; o C&lt;default&gt; en lugar de realizar una iteración de un C&lt;foreach&gt; dinámicamente colocado o saliendo de un C&lt;given&gt; encerrado léxicamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These languages have their own newsgroups in which you
can learn about (but hopefully not argue about) them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230752Z" changeid="explorer">
        <seg>Estos lenguajes tienen sus propios grupos de noticias, en los que puede obtener más información sobre ellos (preferiblemente sin herir sensibilidades).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ld --help 2&gt;&amp;1 | grep AUTOCONF</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ld --help 2&gt;&amp;1 | grep AUTOCONF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 1.3, 14th Apr 1997</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Version 1.3, 14th Apr 1997</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do { print &quot;@list\n&quot; } while NextPermuteNum @list;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>do { print &quot;@list\n&quot; } while NextPermuteNum @list;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apple  =&gt; &quot;red&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025826Z" changeid="explorer">
        <seg>manzana =&gt; &quot;rojo&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item close</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item close</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you like you can force Perl to ignore your system's flock(2)
function, and so provide its own fcntl(2)-based emulation, by passing
the switch C&lt;-Ud_flock&gt; to the F&lt;Configure&gt; program when you configure
and build a new Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T234455Z" changeid="explorer">
        <seg>Si le gusta, puede forzar a Perl a que ignore la función de su sistema flock(2) y proveer de su propia emulación basada en fcntl(2), pasando la opción C&lt;-Ud_flock&gt; al programa F&lt;Configure&gt; cuando configure y compile un nuevo Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hexadecimal, octal, or binary, representations in string literals
(e.g. '0xff') are not automatically converted to their integer
representation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hexadecimal, octal o binario, representaciones en cadenas literales (por ejemplo, '0xff') no se convierten automáticamente en su representación en entero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rounds up the allocated buckets to the next power of two:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto redondea el número de cajones reservados a la siguiente potencia de dos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For -t and -T,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212335Z" changeid="explorer">
        <seg>Por -t y -T,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Switch;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Switch;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/(.)\g1/$1/g;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225529Z" changeid="explorer">
        <seg>s/(.)\g1/$1/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please keep in mind that many
of them are code fragments rather than complete programs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004501Z" changeid="explorer">
        <seg>Tenga en cuenta que muchos de estos ejemplos son fragmentos de código, no programas completos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use IO::Handle;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use IO::Handle;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlre&gt; for additional information on valid syntax for STRING, and
for a detailed look at the semantics of regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlre&gt; para obtener información adicional sobre la sintaxis válida para CADENA, y para una vista detallada de la semántica de las expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/re/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014640Z" changeid="explorer">
        <seg>=item * F&lt;t/re/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -d:NYTProf some_perl.pl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T005803Z" changeid="explorer">
        <seg>perl -d:NYTProf algun_perl.pl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, ensure that you've found an actual bug.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231111Z" changeid="explorer">
        <seg>En primer lugar, debe asegurarse de que se trata realmente de un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the C&lt;(?{...})&gt; block, C&lt;$_&gt; refers to the string the regular
expression is matching against.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T220639Z" changeid="explorer">
        <seg>Dentro del bloque C&lt;(?{...})&gt;, C&lt;$_&gt; se refiere a la cadena contra que la expresión regular se está evaluando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's also I&lt;$foo Magazin&gt;, a German magazine
dedicated to Perl, at ( http://www.foo-magazin.de ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230743Z" changeid="explorer">
        <seg>I&lt;$foo Magazin&gt; ( http://www.foo-magazin.de ) es una revista escrita en alemán dedicada a Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't shrink the number of buckets allocated for the hash using
C&lt;keys&gt; in this way (but you needn't worry about doing this by accident,
as trying has no effect).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede reducir el número de alojamientos reservados para el hash usando C&lt;keys&gt; de esta manera (pero no necesita preocuparse si hace esto por accidente; intentarlo no tiene ningún efecto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 4) = 8   ==        128 00000001000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 4) = 8   ==        128 00000001000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hex = $vec-&gt;to_Hex();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225514Z" changeid="explorer">
        <seg>$hex = $vec-&gt;to_Hex();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, it returns a
list of values counting (up by ones) from the left value to the right
value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, devuelve una lista de valores contando (de uno en uno) desde el valor de la izquierda al valor de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines declarations can also be loaded up with the C&lt;require&gt; statement
or both loaded and imported into your namespace with a C&lt;use&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012812Z" changeid="explorer">
        <seg>Las declaraciones de subrutinas pueden cargarse también con la instrucción C&lt;require&gt; o cargadas e importadas en su espacio de nombres con la instrucción C&lt;use&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using
this, one can control Perl's idea of filenames and line numbers in
error or warning messages (especially for strings that are processed
with C&lt;eval()&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando esto, uno puede controlar la idea que tiene Perl de los nombres de archivos y número de líneas en los mensajes de avisos y errores (especialmente para las cadenas procesadas con C&lt;eval()&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3 nlink  3 day        3 subroutine   $\    output separator</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224340Z" changeid="explorer">
        <seg>3 nlink  3 día        3 subrutina       $\    separador entrada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Can I do [task] in Perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230817Z" changeid="explorer">
        <seg>=head2 ¿Puedo hacer [tarea] en Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VMS: fix perl -P</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VMS: arreglado perl -P</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># These examples are subject to system-specific variation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Estos ejemplos están sujetos a variaciones específicas del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar in spirit to, but not the same as, grep(1) and its
relatives.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es similar en espíritu, pero no lo mismo, que con grep(1) y sus hermanos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>testing...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>comprobando...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
returns sine of C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, devuelve el seno de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($win,fileno(STDOUT),1) = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($win,fileno(STDOUT),1) = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Google search engine now carries archived and searchable newsgroup
content.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230946Z" changeid="explorer">
        <seg>El motor de búsqueda de Google permite realizar búsquedas en contenido archivado de grupos de noticias:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;newline&gt; X&lt;line terminator&gt; X&lt;eol&gt; X&lt;end of line&gt;
X&lt;\n&gt; X&lt;\r&gt; X&lt;\r\n&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003258Z" changeid="explorer">
        <seg>X&lt;newline&gt; X&lt;line terminator&gt; X&lt;eol&gt; X&lt;end of line&gt;
X&lt;\n&gt; X&lt;\r&gt; X&lt;\r\n&gt; X&lt;nueva línea&gt; X&lt;fin de línea&gt; X&lt;terminador de línea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;2: '&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;2: '&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given this code:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, dado este código:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most visible
difference is that, in Perl 5, parentheses are required around
the argument to C&lt;given()&gt; and C&lt;when()&gt; (except when this last
one is used as a statement modifier).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013525Z" changeid="explorer">
        <seg>La diferencia más visible es que, en Perl 5, los paréntesis son requeridos alrededor del argumento en C&lt;given()&gt; y C&lt;when()&gt; (excepto cuando éste último se usa como modificador de instrucciones)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	+ - .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	+ - .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This wasn't previously the case.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200855Z" changeid="explorer">
        <seg>Esto no es lo que ocurría anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Along the same lines, just because you I&lt;CAN&gt; omit parentheses in many
places doesn't mean that you ought to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De la misma forma, sólo porque usted I&lt;PUEDA&gt; omitir paréntesis en muchos lugares no significa que deba hacerlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[^()] )&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003010Z" changeid="explorer">
        <seg>[^()] )&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any enums with negative values are now skipped.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041840Z" changeid="explorer">
        <seg>Cualquier enum con valores negativos es ahora omitido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perllocale		Perl locale support</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000411Z" changeid="explorer">
        <seg>perllocale		Compatibilidad con la configuración regional</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this
case, only the C&lt;g&gt; and C&lt;c&gt; flags on the empty pattern are honored;
the other flags are taken from the original pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T024816Z" changeid="explorer">
        <seg>En este caso, sólo las opciones C&lt;g&gt; y C&lt;c&gt; en el patrón vacío son tomadas en cuenta; las otras opciones son tomadas del patrón original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Exponentiation
X&lt;**&gt; X&lt;exponentiation&gt; X&lt;power&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234201Z" changeid="explorer">
        <seg>=head2 Exponenciación
X&lt;**&gt; X&lt;exponentiation&gt; X&lt;power&gt; X&lt;exponenciación&gt; X&lt;elevado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^=(\w+)/pod($1)/ge;	# use function call</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213240Z" changeid="explorer">
        <seg>s/^=(\w+)/pod($1)/ge;			# usa una función de llamada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (1) (2) ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T194512Z" changeid="explorer">
        <seg>=item (1) (2) ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this code:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, este código:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another example switched the first &quot;latin1&quot; encoding it finds
to &quot;utf8&quot; in a pod file:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030339Z" changeid="explorer">
        <seg>En este otro ejemplo se cambia la primera ocurrencia de la codificación &quot;latin1&quot; que se encuentra a &quot;utf8&quot;, en un archivo pod:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Binary strings (byte strings)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234549Z" changeid="explorer">
        <seg>=head3 Cadenas binarias (cadenas de bytes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the pattern of regex operators (C&lt;qr//&gt;, C&lt;m//&gt; and C&lt;s///&gt;),
the quoting from C&lt;\Q&gt; is applied after interpolation is processed,
but before escapes are processed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222357Z" changeid="explorer">
        <seg>Para el patrón de los operadores regex (C&lt;qr//&gt;, C&lt;m//&gt; y C&lt;s///&gt;), el efecto de C&lt;\Q&gt; es aplicado después de que se haya procesado la interpolación, pero antes de que sean procesados los escapados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item mkdir FILENAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item mkdir ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4 - either a real number, or a string that looks like a number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>4 - o un número real, o una cadena que se parezca a un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When searching for the terminating line of a here-doc, nothing
is skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Durante la búsqueda de la línea de terminación de un documento incrustado, nada se omite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deeper underlying truth is that juxtaposition in
regular expressions always means AND, except when you write an explicit OR
using the vertical bar.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T172040Z" changeid="explorer">
        <seg>La verdad más profunda que subyace es que la yuxtaposición de las expresiones regulares siempre significa Y, excepto cuando se escribe un explícito O, mediante la barra vertical.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 What's New in Perl for MPE/iX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Qué hay de nuevo en Perl para MPE/iX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%2\$*3\$d %d\n&quot;, 12, 34, 3;    # will print &quot; 34 12\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%2\$*3\$d %d\n&quot;, 12, 34, 3;    # imprimirá &quot; 34 12\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = scalar(@b) || @c;	# really meant this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@a = scalar(@b) || @c;	# quiere realmente decir esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The full list of these is in
L&lt;perlop/Quote and Quote-like Operators&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T184816Z" changeid="explorer">
        <seg>The full list of these is in
L&lt;perlop/Quote and Quote-like Operators&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlboot - Beginner's Object-Oriented Tutorial</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlboot - Beginner's Object-Oriented Tutorial</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is another step where the presence of the C&lt;//x&gt; modifier is
relevant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este es otro paso donde la presencia del modificador C&lt;//x&gt; es relevante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can deal with this by using both an assertion and a negation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171240Z" changeid="explorer">
        <seg>Podemos lidiar con este problema utilizando una afirmación y una negación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item split /PATTERN/,EXPR,LIMIT
X&lt;split&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201131Z" changeid="explorer">
        <seg>=item split /PATRÓN/,EXPR,LÍMITE
X&lt;split&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the target string is encoded in UTF-8; or</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000621Z" changeid="explorer">
        <seg>la cadena destino está codificado en UTF-8; o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>u  A uuencoded string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>u  Una cadena codificada con uuencode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators will assume a bit
vector operation is desired when both operands are strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos operadores asumirán una operación de vector de bits cuando ambos operandos sean cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Randal L. Schwartz, Tom Phoenix, and brian d foy</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003107Z" changeid="explorer">
        <seg>Randal L. Schwartz, Tom Phoenix y brian d foy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of the rarer platforms that worked 100% or pretty close to it
with perl 5.8.0 have been left a little bit untended since their
maintainers have been otherwise busy lately, and therefore there will
be more failures on those platforms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T002209Z" changeid="explorer">
        <seg>Muchas de las plataformas más raras en las que funcionaba al 100% o muy cerca de ello con perl 5.8.0 se han quedado un poco descuidadas debido a que sus responsables se han ocupado últimamente de otras cosas, y por lo tanto habrá más fallos en esas plataformas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns
the number of characters replaced or deleted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de caracteres sustituidos o eliminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my(@a) = splice(@_,0,shift);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my(@a) = splice(@_,0,shift);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>on Perl 5.14 or later</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181441Z" changeid="explorer">
        <seg>en Perl 5.14 o superior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax following the keyword
is defined entirely by the extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La sintasix que sigue al identificador se define enteramente por la expansión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 How stable is Perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230202Z" changeid="explorer">
        <seg>=head2 ¿Es Perl estable?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a scalar operator:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como operador escalar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; =&gt; &gt;&gt; operator is mostly just a more visually distinctive
synonym for a comma, but it also arranges for its left-hand operand to be
interpreted as a string if it's a bareword that would be a legal simple
identifier.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005302Z" changeid="explorer">
        <seg>El operador C&lt;&lt; =&gt; &gt;&gt; es más que nada un distintivo visual sinónimo de una coma, además de que también se encarga de que su operando de la izquierda sea interpretado como una cadena, si es un palabra suelta que pudiera ser un simple identificador legal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latest versions are probably the least deployed and widely tested, so
you may want to wait a few months after their release and see what
problems others have if you are risk averse.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200806Z" changeid="explorer">
        <seg>Las versiones más recientes suelen estar menos implementadas y probadas. Si no le gusta arriesgar, es posible que prefiera esperar unos meses para ver qué problemas detectan los usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;POSIX/POSIX::SigAction&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170032Z" changeid="explorer">
        <seg>Vea L&lt;POSIX/POSIX::SigAction&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substr($str, -30) =~ s/\b(\p{Alpha}+)\b/\u\L$1/g;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031231Z" changeid="explorer">
        <seg>substr($str, -30) =~ s/\b(\p{Alpha}+)\b/\u\L$1/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$var = &quot;value&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$var = &quot;valor&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ cpan -l</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225445Z" changeid="explorer">
        <seg>$ cpan -l</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,22, 1) = 1   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,22, 1) = 1   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document can be read I&lt;as is&gt;: as F&lt;README.uts&gt;, or you
can read it after you build your package using &quot;man perluts&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T213606Z" changeid="explorer">
        <seg>Este documento se puede leer I&lt;tal cual&gt;: como F&lt;README.uts&gt;, o puede leerlo después de construir el paquete usando &quot;man perluts&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, their results are interpreted as unsigned integers, but
if C&lt;use integer&gt; is in effect, their results are interpreted
as signed integers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma predeterminada, los resultados se interpretan como enteros sin signo, pero si C&lt;use integer&gt; está en efecto, sus resultados se interpretan como enteros con signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right	! ~ \ and unary + and -</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053224Z" changeid="explorer">
        <seg>right	! ~ \ unarios + y -</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\a          alarm (bell)          (BEL)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043348Z" changeid="explorer">
        <seg>\a		alarma (campana)	(BEL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ cpan -a</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225446Z" changeid="explorer">
        <seg>$ cpan -a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Darren Chamberlain, Dave Cross, and Andy Wardley</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003605Z" changeid="explorer">
        <seg>Darren Chamberlain, Dave Cross y Andy Wardley</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item send SOCKET,MSG,FLAGS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item send SOCKET,MSG,FLAGS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item send SOCKET,MSG,FLAGS,TO
X&lt;send&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200448Z" changeid="explorer">
        <seg>=item send SOCKET,MSG,FLAGS,TO
X&lt;send&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shutdown(SOCKET, 1);    # I/we have stopped writing data</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shutdown(SOCKET, 1);    # Hemos dejado de escribir datos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$atime = $mtime = time;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$atime = $mtime = time;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recurse to a named subpattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T191613Z" changeid="explorer">
        <seg>Procesa de forma recursiva un sub-patrón con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl573delta	Perl changes in version 5.7.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl573delta	Cambios en la versión 5.7.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$packed_ip = gethostbyname(&quot;www.perl.org&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$packed_ip = gethostbyname(&quot;www.perl.org&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a random fractional number greater than or equal to C&lt;0&gt; and less
than the value of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve un número decimal aleatorio mayor o igual a C&lt;0&gt; y menor que el valor de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDERR &quot;This is your final warning.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235449Z" changeid="zipf">
        <seg>print STDERR &quot;Ésta es la última advertencia.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments can be embedded in a TEMPLATE using C&lt;#&gt; through the end of line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comentarios pueden ser integrados en una PLANTILLA usando C&lt;#&gt; hasta el final de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If POSITION is specified, returns the
last occurrence beginning at or before that position.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sí POSICIÓN es especificada, devuelve la última ocurrencia comenzando en o antes de esta posición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's
a bug in the compiler (APAR PQ18812) that generates some bad code
the optimizer is on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102001Z" changeid="explorer">
        <seg>Hay un error en el compilador (APAR PQ18812) que genera mal código cuando el optimizador está activo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A zero-width negative look-ahead assertion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T210034Z" changeid="explorer">
        <seg>Una aserción consiguiente negativa de ancho cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So you
should use C&lt;defined&gt; only when questioning the integrity of what
you're trying to do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que puede usar C&lt;defined&gt; sólo cuando está cuestionando la integridad de lo que está intentando hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 F&lt;AUTHORS&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014948Z" changeid="explorer">
        <seg>=head2 F&lt;AUTHORS&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Search pattern not terminated or ternary operator parsed as search pattern</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040338Z" changeid="explorer">
        <seg>=head2 Search pattern not terminated or ternary operator parsed as search pattern</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;use locale&gt; is in effect, C&lt;sort LIST&gt; sorts LIST according to the
current collation locale.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando C&lt;use locale&gt; esté activo, C&lt;sort LIST&gt; ordena LISTA de acuerdo con la actual configuración regional de intercalación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach my $file ( @goners ) {
         unlink $file or warn &quot;Could not unlink $file: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052353Z" changeid="explorer">
        <seg>foreach my $archivo ( @goners ) {
         unlink $archivo or warn &quot;No puedo borrar $archivo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Breaks the binding between a DBM file and a hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Rompe la ligadura entre un archivo DBM y un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8.5 23:59:59 GMT, Wednesday June 30th 2004</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5.8.5 23:59:59 GMT miércoles, 30 de junio 2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;delete local EXPR&gt; construct can also be used to localize the deletion
of array/hash elements to the current block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La construcción C&lt;delete local EXPR&gt; también se puede utilizar para localizar la supresión de elementos de un array o hash en el bloque actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$retval = ioctl(...) || -1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$retval = ioctl(...) || -1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns like C&lt;ioctl&gt;: the undefined value for error,
C&lt;&quot;0 but true&quot;&gt; for zero, or the actual return value otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve lo mismo que C&lt;ioctl&gt;: el valor indefinido para error, C&lt;&quot;0 but true&quot;&gt; para el cero, o el valor de retorno real, en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int( &lt;STDIN&gt; )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>int( &lt;STDIN&gt; )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open 'dbase.mine' for update: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir 'dbase.mine' para actualizar: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item PodParser</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item PodParser</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;delete local&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010450Z" changeid="explorer">
        <seg>=head2 C&lt;delete local&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function isn't all that useful for
cryptography (for that, look for F&lt;Crypt&gt; modules on your nearby CPAN
mirror) and the name &quot;crypt&quot; is a bit of a misnomer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función no es muy útil para criptografía (para esto, mire en los módulos F&lt;Crypt&gt; en su espejo CPAN más cercano) y el nombre &quot;crypt&quot; es un poco equívoco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because variable references always start with '$', '@', or '%', the
&quot;reserved&quot; words aren't in fact reserved with respect to variable
names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puesto que los nombres de variables siempre empiezan por '$', '@', o '%', las palabras &quot;reservadas&quot;, de hecho, no están reservadas con respecto a los nombres de variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the packed sockaddr address of this end of the SOCKET connection,
in case you don't know the address because you have several different
IPs that the connection might have come in on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la dirección de socket empaquetada de este final de la conexión SOCKET, en el caso de que no conozca la dirección porque tenga diferentes IP por las que la conexión se pudo haber realizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%scientists =</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%cientificos =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ne  inequality</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120440Z" changeid="zipf">
        <seg>ne  distinto que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a leading underscore to indicate that a variable or
function should not be used outside the package that defined it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar un guión bajo inicial para indicar que una variable o función no debe ser usado fuera del paquete que lo define.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Logical or, Defined or, and Exclusive Or
X&lt;operator, logical, or&gt; X&lt;operator, logical, xor&gt;
X&lt;operator, logical, defined or&gt; X&lt;operator, logical, exclusive or&gt;
X&lt;or&gt; X&lt;xor&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002241Z" changeid="explorer">
        <seg>=head2 Or, Defined y Or exclusivos lógicos
X&lt;operator, logical, or&gt; X&lt;operator, logical, xor&gt;
X&lt;operator, logical, defined or&gt; X&lt;operator, logical, exclusive or&gt;
X&lt;or&gt; X&lt;xor&gt; X&lt;operador, lógico, or&gt; X&lt;operador, lógico, xor&gt; X&lt;operador, lógico, or exclusivo&gt; X&lt;operador, lógico, definido&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has three built-in data types: scalars, arrays of scalars, and
associative arrays of scalars, known as &quot;hashes&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl tiene tres estructuras de datos incorporadas al lenguaje: Los escalares, los arrays de escalares, y los arrays asociativos de escalares, también conocidos como &quot;hashes&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>goto (&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>goto (&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for processes and process groups
X&lt;process&gt; X&lt;pid&gt; X&lt;process id&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201820Z" changeid="explorer">
        <seg>=item Funciones para procesos y grupos de procesos
X&lt;process&gt; X&lt;pid&gt; X&lt;process id&gt; X&lt;proceso&gt; X&lt;id proceso&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
scalar context it reads a single line from the filehandle, and in list
context it reads the whole file in, assigning each line to an element of
the list:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225314Z" changeid="explorer">
        <seg>En contexto escalar, este operador lee una sola línea del identificador de archivo, mientras que en contexto de lista lee todo el archivo y asigna cada línea a un elemento de la lista:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pesto</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pisto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updates for 5.8.0 by Nicholas Clark &lt;nick@ccl4.org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234147Z" changeid="explorer">
        <seg>Actualizaciones para 5.8.0 de Nicholas Clark &lt;nick@ccl4.org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, C&lt;a*&gt; inside
C&lt;a*ab&gt; will match fewer characters than a standalone C&lt;a*&gt;, since
this makes the tail match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T012801Z" changeid="explorer">
        <seg>En particular, C&lt;a*&gt; dentro de C&lt;a*ab&gt; coincidirá con menos caracteres que con solo C&lt;a*&gt;, para permitir que el resto del patrón coincida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item stat FILEHANDLE
X&lt;stat&gt; X&lt;file, status&gt; X&lt;ctime&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012609Z" changeid="explorer">
        <seg>=item stat IDENTIFICADOR_ARCHIVO
X&lt;stat&gt; X&lt;file, status&gt; X&lt;ctime&gt; X&lt;archivo, estado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 SEE ALSO</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T155609Z" changeid="zipf">
        <seg>=head1 VEA TAMBIÉN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will never match, as the C&lt;a++&gt; will gobble up all the C&lt;a&gt;'s in the
string and won't leave any for the remaining part of the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>nunca coincidirá, porque el C&lt;a++&gt; devorará todas las C&lt;a&gt; en la cadena y no dejará ninguna para el resto del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perluniprops	Index of Unicode Version 6.0.0 properties in Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T140914Z" changeid="explorer">
        <seg>perluniprops	Propiedades de Unicode versión 6.0.0 en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last updated January 12, 2006 @ 2100 UTC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Última actualización 12 de enero de 2006 @ 2100 UTC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The VMS port has been improved.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014111Z" changeid="explorer">
        <seg>La adaptación a VMS ha sido mejorada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's
learning curve is therefore shallow (easy to learn) and long (there's
a whole lot you can do if you really want).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230344Z" changeid="explorer">
        <seg>Así, la curva de aprendizaje de Perl tiene una pendiente suave (es fácil de aprender) y larga (si desea seguir profundizando, puede aprender a hacer muchas cosas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;defined($pid)&gt; or C&lt;//&gt; to determine whether the open was successful.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005713Z" changeid="explorer">
        <seg>Use C&lt;defined($pid)&gt; o C&lt;//&gt; para determinar cuándo el open se realizó correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldata - Perl data types</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldata - Perl data types</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>integer values _and_ if Perl has been compiled to support those.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>enteros de 64 bits __y__ si Perl ha sido compilado para soportarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be nice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sea amable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sysopen FILEHANDLE,FILENAME,MODE
X&lt;sysopen&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012749Z" changeid="explorer">
        <seg>=item sysopen IDENTIFICADOR_ARCHIVO,ARCHIVO,MODO
X&lt;sysopen&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Under Unicode rules, there are a few case-insensitive matches that cross
the 255/256 boundary.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T165439Z" changeid="explorer">
        <seg>Según las normas Unicode, hay unos pocos casos que cruzan el límite 255/256 de las coincidencias de mayúsculas y minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from being smaller and possibly faster, there
should be no user-detectable changes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051518Z" changeid="explorer">
        <seg>Además de ser má pequeño y, posiblemente, más rápido, no debería haber cambios detectables por el usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$i = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$i = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, string
concatenation happens at compile time between literals that don't do
variable substitution.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, concatenación de cadenas que sucede en tiempo de compilación entre literales que no hacen sustitución de variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Socket qw(IPPROTO_TCP TCP_NODELAY);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Socket qw(IPPROTO_TCP TCP_NODELAY);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't know what to do with microperl
you probably shouldn't.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no sabe qué hacer con microperl probablemente no debería construirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$nums[$b] &lt;=&gt; $nums[$a]
            ||</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051440Z" changeid="explorer">
        <seg>$numeros[$b] &lt;=&gt; $numeros[$a]
            ||</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sub-minor version numbers are usually used
for changes which do not affect functionality, such as documentation
patches.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025354Z" changeid="explorer">
        <seg>Números de versión de menor importancia se utilizan generalmente para los cambios que no afectan a la funcionalidad, tales como los parches en la documentación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Alpha</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225453Z" changeid="explorer">
        <seg>=item Alpha</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;ext/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014407Z" changeid="explorer">
        <seg>=item * F&lt;ext/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry Wall &lt;larry@wall.org&gt;, with the help of oodles of other folks.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001522Z" changeid="explorer">
        <seg>Larry Wall &lt;larry@wall.org&gt;, con la ayuda de muchas personas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true on success,
otherwise it returns C&lt;undef&gt; and sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero en éxito; de lo contrario devuelve C&lt;undef&gt; y pone C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a generalization of the old behaviour
that tested whether the array contained the scalar.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T222355Z" changeid="explorer">
        <seg>Esta es una generalización del comportamiento anterior que ponía a prueba si el array contenía el escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;reverse sort ...&gt; is now optimized to sort in reverse, avoiding the
generation of a temporary intermediate list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T210629Z" changeid="explorer">
        <seg>C&lt;reverse sort ...&gt; se ha optimizado para ordenar a la inversa, evitando la generación de una lista temporal intermedia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new command-line switch, B&lt;-A&gt;, is used to activate
assertions, which are declared with the C&lt;assertions&gt; pragma.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142917Z" changeid="explorer">
        <seg>Una nueva opción en la línea de comandos, B&lt;-A&gt;, se utiliza para activar aserciones, que son declaradas con el pragma C&lt;assertions&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As
with most other power tools, power comes together with the ability
to wreak havoc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230316Z" changeid="explorer">
        <seg>Al igual que con la mayoría de otras herramientas poderosas, este poder viene junto con la capacidad para causar estragos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($a =~ /foo/) { ... }  # true if $a contains &quot;foo&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T212800Z" changeid="zipf">
        <seg>if ($a =~ /foo/) { ... }  # verdadero si $a contiene &quot;foo&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is called a I&lt;backreference&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T000915Z" changeid="explorer">
        <seg>A esto se le llama una I&lt;contrareferencia&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since C&lt;&lt; &lt;&gt; &gt;&gt; isn't explicitly opened,
as a normal filehandle is, an C&lt;eof()&gt; before C&lt;&lt; &lt;&gt; &gt;&gt; has been
used will cause C&lt;@ARGV&gt; to be examined to determine if input is
available.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010004Z" changeid="explorer">
        <seg>Como C&lt;&lt; &lt;&gt; &gt;&gt; no es explícitamente abierto, como lo sería un identificador de archivo, un C&lt;eof()&gt; antes de que un C&lt;&lt; &lt;&gt; &gt;&gt; sea usado, causará que C&lt;@ARGV&gt; sea examinado para determinar si la entrada está disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns a (possibly empty) list of filename expansions on
the value of EXPR such as the standard Unix shell F&lt;/bin/csh&gt; would do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contecto lista, devuelve una (posiblemente vacía) lista de la expansión de nombres de archivo del valor de EXPR como si el shell estandar Unix F&lt;/bin/csh&gt; lo hiciera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note
that the meanings don't change, just the &quot;greediness&quot;:
X&lt;metacharacter&gt; X&lt;greedy&gt; X&lt;greediness&gt;
X&lt;?&gt; X&lt;*?&gt; X&lt;+?&gt; X&lt;??&gt; X&lt;{n}?&gt; X&lt;{n,}?&gt; X&lt;{n,m}?&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001449Z" changeid="explorer">
        <seg>Tenga en cuanta que los significados no cambian, solo la &quot;avaricia&quot;:
X&lt;metacarácter&gt; X&lt;codicia&gt; X&lt;avaricia&gt;
X&lt;?&gt; X&lt;*?&gt; X&lt;+?&gt; X&lt;??&gt; X&lt;{n}?&gt; X&lt;{n,}?&gt; X&lt;{n,m}?&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close ARGV  if eof;		# reset $.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T212218Z" changeid="explorer">
        <seg>close ARGV  if eof;		# reinicia $.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Between the C&lt;%&gt; and the format letter, you may specify several
additional attributes controlling the interpretation of the format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entre el C&lt;%&gt; y la letra de formato, puede especificar varios atributos adicionales controlando la interpretación del formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the Perl 6 &quot;commit pattern&quot; C&lt;&lt; &lt;commit&gt; &gt;&gt; or C&lt;:::&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T141814Z" changeid="explorer">
        <seg>Este es &quot;patrón de acometida&quot; C&lt;&lt; &lt;commit&gt; &gt;&gt; o C&lt;:::&gt; de Perl 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is free software; you can redistribute it and/or modify
it under the terms of either:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl es software libre, puede redistribuirlo y/o modificarlo bajo los términos de:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This restriction is due to the wide-spread and remarkably convenient
custom of using run-time determined strings as patterns.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T222800Z" changeid="explorer">
        <seg>Esta restricción se debe a la muy extendida y muy cómoda costumbre de usar determinadas cadenas, como patrones, en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry expects that he'll be certified before Perl is.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230225Z" changeid="explorer">
        <seg>Larry espera obtener la certificación antes que Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An INSTALL file should be included, and should contain simple installation 
instructions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024857Z" changeid="explorer">
        <seg>Un archivo INSTALL debe ser incluido, y debe contener las más sencillas instrucciones de instalación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, these operators are covered in precedence order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En las secciones siguientes, estos operadores están descritos en orden de precedencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation changes only</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Solo cambios en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ((caller(0))[3] eq 'subname') { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195255Z" changeid="explorer">
        <seg>if ((caller(0))[3] eq 'subnombre') { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transliterates all occurrences of the characters found in the search list
with the corresponding character in the replacement list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Translitera todas las apariciones de los caracteres que se encuentran en la lista de búsqueda con el carácter correspondiente en la lista de reemplazo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
most projects, this information will probably suffice.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234236Z" changeid="explorer">
        <seg>Sin embargo, es probable que para la mayoría de los proyectos baste con esta información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Conditions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Condiciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the command &quot;make install&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejecute el comando &quot;make install&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The warning, however,
is not serious and can be ignored.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T002219Z" changeid="explorer">
        <seg>La advertencia, sin embargo, no es grave y puede ser ignorada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub unimplemented { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub no_implementado { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/ A (*THEN) B /</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050641Z" changeid="explorer">
        <seg>/ A (*THEN) B /</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL until (EXPR) BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA until (EXPR) BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$HOST = $host =~ tr/a-z/A-Z/r    # chained with s///r
                  =~ s/:/ -p/r;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035139Z" changeid="explorer">
        <seg>$HOST = $host =~ tr/a-z/A-Z/r	# encadenado con s///r
                  =~ s/:/ -p/r;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@them          = @folks[0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ellos          = @gente[0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutine call to a named capture group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003511Z" changeid="explorer">
        <seg>Llamada de una subrutina con un grupo de captura con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @part, $AoA[$x][$y];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053000Z" changeid="explorer">
        <seg>push @part, $AoA[$x][$y];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specify version requirements for other Perl modules in the
pre-requisites in your Makefile.PL or Build.PL.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030305Z" changeid="explorer">
        <seg>Especifique los requisitos de versión para otros módulos Perl en los pre-requisitos de su Makefile.PL o Build.PL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl applies the format to
each integer in turn, then joins the resulting strings with a separator (a
dot C&lt;.&gt; by default).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl aplica el formato a cada entero por turno, luego une las cadenas resultantes con un separador (un punto C&lt;.&gt; por defecto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configure: 1 hour</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Configure: 1 hora</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A named capture group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002712Z" changeid="explorer">
        <seg>Un grupo de captura con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub&gt; for examples of using these as indirect filehandles
in functions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003639Z" changeid="explorer">
        <seg>Vea L&lt;perlsub&gt; por ejemplos del uso de estos identificadores indirectos de archivo en funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;=&quot; is the ordinary assignment operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;=&quot; es el operador ordinario de asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Setuid\n&quot; if -u _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Setuid\n&quot; if -u _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|  e   |  2   |</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225611Z" changeid="explorer">
        <seg>|  e   |  2   |</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would not have worked, since a pattern match in scalar context will
only return true or false, rather than a count of matches.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no habría funcionado, ya que una expresión regular en contexto escalar sólo devolverá verdadero o falso, en lugar de un recuento de las coincidencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print join &quot;\n&quot;, @files;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T005605Z" changeid="explorer">
        <seg>print join &quot;\n&quot;, @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both last cases, the last expression is evaluated in the context that
was applied to the C&lt;given&gt; block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223324Z" changeid="explorer">
        <seg>En los dos últimos casos, la última expresión se evalúa en el contexto en el que se aplicó al bloque C&lt;given&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I18N::LangTags upgraded to version 0.35</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>I18N::LangTags actualizado a la versión 0.35</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $mixed[$#mixed];       # last element, prints 1.23</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121156Z" changeid="zipf">
        <seg>print $mezcla[$#mezcla];  # último elemento, imprime 1.23 en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We hope.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esperamos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlos2		Perl notes for OS/2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlos2		Notas para OS/2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can also be that long doubles and doubles are the same thing:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede ser que los long doubles y doubles sean la misma cosa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have an optional comma before the closing parenthesis of a
list literal, so that you can say:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede tener una coma opcional, antes del paréntesis de cierre en una lista literal, de modo que puede decir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other characters are encoded as two or more
(up to six) bytes using a complex scheme.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234504Z" changeid="explorer">
        <seg>Todos los demás caracteres se codifican como dos o más bytes (hasta seis) mediante un esquema complejo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>outputs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050602Z" changeid="explorer">
        <seg>sale</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keys %hash = 200;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>keys %hash = 200;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;a3 x2 /A A*&quot;, &quot;007: Bond, J.&quot;)  gives (&quot;Bond, J&quot;, &quot;.&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;a3 x2 /A A*&quot;, &quot;007: Bond, J.&quot;)  da (&quot;Bond, J&quot;, &quot;.&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;given&gt; is analogous to the C&lt;switch&gt; keyword in other languages.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T235308Z" changeid="explorer">
        <seg>C&lt;given&gt; es análogo a la palabra clave C&lt;switch&gt;, de otros lenguajes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the general backwards
compatibility is maintained, several changes must be noted:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233725Z" changeid="explorer">
        <seg>Mientras que la compatibilidad con versiones anteriores, en general, se mantiene, se deben tenerse en cuenta diversos cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See your native chmod(2) and stat(2) documentation for more details
about the C&lt;S_*&gt; constants.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consulte su documentación de las nativas chmod(2) y stat(2) para obtener más detalles acerca de las constantes C&lt;S_*&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @INC, [ \&amp;my_sub, $x, $y, ... ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @INC, [ \&amp;mi_sub, $x, $y, ... ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&gt;&gt;&quot; returns the value of its left argument shifted right by
the number of bits specified by the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&gt;&gt;&quot; devuelve el valor de su argumento izquierdo desplazado a la derecha por el número de bits especificado por el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is what C&lt;(.+)+&gt; is doing, and C&lt;(.+)+&gt; is similar
to a subpattern of the above pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T214239Z" changeid="explorer">
        <seg>Esto es lo que hace C&lt;(.+)+&gt;, y C&lt;(.+)+&gt; es similar a un subpatrón del patrón comentado antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pop ARRAY
X&lt;pop&gt; X&lt;stack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192604Z" changeid="explorer">
        <seg>=item pop ARRAY
X&lt;pop&gt; X&lt;stack&gt; X&lt;pila&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;@utmp1&quot; eq &quot;@utmp2&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># &quot;@utmp1&quot; eq &quot;@utmp2&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$val\n&quot; while defined($val = pop(@ary));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$valor\n&quot; while defined($valor = pop(@ary));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 1-59059-391-X [3rd edition April 2010]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003332Z" changeid="explorer">
        <seg>ISBN 1-59059-391-X [3ª edición - Abril de 2010]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LABEL is optional, and if present, consists of an identifier followed
by a colon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La ETIQUETA es opcional, y si está presente, consiste en un identificador seguido por el carácter dos puntos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens because the pattern match is in list context (since it
is being assigned to the empty list), and will therefore return a list
of all matching parts of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto sucede porque la expresión regular está en contexto lista (ya que se asigna a la lista vacía), y por lo tanto se obtendrá una lista de todas las coincidencias de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;prove&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234634Z" changeid="explorer">
        <seg>=item L&lt;prove&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System calls also set the special C&lt;$!&gt;
variable on failure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001657Z" changeid="explorer">
        <seg>Llamadas al sistema también actualizan la variable especial C&lt;$!&gt; en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item default BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T024235Z" changeid="explorer">
        <seg>=item default BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>regular($_) when [ qw/Chris David Ellen/ ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>normal($_) when [ qw/Chris David Ellen/ ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir DIRHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005214Z" changeid="explorer">
        <seg>=item chdir IDENTIFICADOR_DIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly like C:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Exactamente igual que en C:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item kflags</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114055Z" changeid="explorer">
        <seg>=item kflags</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $ref-&gt;{&quot;Some key&quot;})    { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $ref-&gt;{&quot;Alguna clave&quot;})    { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private_sv = MRO_GET_PRIVATE_DATA(meta, &amp;my_mro_alg);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115206Z" changeid="explorer">
        <seg>private_sv = MRO_GET_PRIVATE_DATA(meta, &amp;my_mro_alg);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is now a run-time error to use the smart match operator C&lt;~~&gt;
with an object that has no overload defined for it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T185433Z" changeid="explorer">
        <seg>Ahora es un error en tiempo de ejecución usar el operador de coincidencia inteligente C&lt;~~&gt; con un objeto que no tenga la sobrecarga definida para él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to worry about finding or paying for Perl; it's freely
available and several popular operating systems come with Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232451Z" changeid="explorer">
        <seg>No tiene que preocuparse de buscar o pagar por usar Perl; está disponible gratuitamente y varios sistemas operativos populares lo incluyen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(3,2,3);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>set_vec(3,2,3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIMIT is negative, it is treated as if an arbitrarily large LIMIT
had been specified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LÍMITE es negativo, se trata como si se hubiera especificado un LÍMITE arbitrariamente grande.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $p = $#idx;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>my $p = $#idx;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item B&lt;filter_store_value&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190455Z" changeid="zipf">
        <seg>=item B&lt;filter_store_value&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need an installed and working gccsdk cross compiler
L&lt;http://gccsdk.riscos.info/&gt; and REXEN
L&lt;http://www.cp15.org/programming/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Necesita tener instalado y funcionando un compilador cruzado gccsdk L&lt;http://gccsdk.riscos.info/&gt; y REXEN L&lt;http://www.cp15.org/programming/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To summarise:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T153257Z" changeid="zipf">
        <seg>Su funcionamiento se puede resumir de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is %d\n&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es %d\n&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The range operator also works on strings, using the magical
auto-increment, see below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador rango también trabaja en las cadenas, usando el auto-incremento mágico, ver abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$key=$value\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$clave=$valor\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or for initializing hash references to be used as records:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o para inicializar referencias hash para ser utilizados como registros:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting C&lt;$CGI::TMPDIRECTORY&gt; is now effective</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025557Z" changeid="explorer">
        <seg>Ahora funciona la variable C&lt;$CGI::TMPDIRECTORY&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To suppress this warning, say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>To suppress this warning, say</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closing the read end of a pipe before the process writing to it at the
other end is done writing results in the writer receiving a SIGPIPE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cerrar la lectura final de una tubería antes de que el proceso de escritura en el otro extremo termine resulta en que el escritor recibe un SIGPIPE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlre		Perl regular expressions, the rest of the story</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000317Z" changeid="explorer">
        <seg>perlre		Expresiones regulares: el resto de la historia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Bugs that have been fixed in 5.8.1)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030858Z" changeid="explorer">
        <seg>(Errores que han sido corregidos en 5.8.1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support fchmod(2), you may pass filehandles among the
files.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005259Z" changeid="explorer">
        <seg>En sistemas que soporten fchmod(2), puede pasar identificadores de archivo entre los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of these books are available as free downloads.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003704Z" changeid="explorer">
        <seg>Algunos de estos libros están disponibles como descargas gratuitas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;S??&gt;, C&lt;S*?&gt;, C&lt;S+?&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045958Z" changeid="explorer">
        <seg>=item C&lt;S??&gt;, C&lt;S*?&gt;, C&lt;S+?&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBROUTINE can be a bareword,
a scalar variable or a subroutine beginning with C&lt;&amp;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T154524Z" changeid="explorer">
        <seg>SUBRUTINA puede ser una palabra simple, una variable escalar o una subrutina comenzando por C&lt;&amp;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Quoting metacharacters</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T230505Z" changeid="explorer">
        <seg>=head2 Escapando metacaracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On failure, the C&lt;$REGERROR&gt; variable will be set to the ARG value of the
verb pattern, if the verb was involved in the failure of the match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T005915Z" changeid="explorer">
        <seg>En caso de fallo, la variable C&lt;$REGERROR&gt;  se establecerá al valor ARG del verbo patrón, si el verbo estaba involucrado en el fallo de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/base/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014550Z" changeid="explorer">
        <seg>=item * F&lt;t/base/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, the following:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040548Z" changeid="explorer">
        <seg>Por otra parte, lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name( '*.pm' )-&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225446Z" changeid="explorer">
        <seg>name( '*.pm' )-&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?x-ims:foo)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T051432Z" changeid="explorer">
        <seg>(?x-ims:foo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Goto
X&lt;goto&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042956Z" changeid="explorer">
        <seg>=head2 Goto
X&lt;goto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used with C&lt;Z&gt;, a C&lt;*&gt; as the repeat count is guaranteed to add a
trailing null byte, so the resulting string is always one byte longer than
the byte length of the item itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se utiliza con C&lt;Z&gt;, un C&lt;*&gt; como el número de repeticiones, está garantizado que añadirá un byte nulo final, por lo que la cadena resultante es siempre un byte más largo que la longitud en bytes del propio elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the combination C&lt;\\&gt; is left intact, since escaped delimiters
are not available for here-docs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que la combinación C&lt;\\&gt; se mantiene intacta, ya que no están disponibles delimitadores escapados para los documentos incrustados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For three or more arguments if MODE is C&lt;|-&gt;, the filename is
interpreted as a command to which output is to be piped, and if MODE
is C&lt;-|&gt;, the filename is interpreted as a command that pipes
output to us.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003023Z" changeid="explorer">
        <seg>Para tres o más argumentos, cuando MODO es C&lt;|-&gt;, el nombre del archivo es interpretado como un comando cuya salida va a ser entubada, y si MODO es &lt;-|&gt;, el nombre del archivo es interpretado como un comando que entuba la salida hacia nosotros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?!S)&gt;, C&lt;(?&lt;!S)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045945Z" changeid="explorer">
        <seg>=item C&lt;(?!S)&gt;, C&lt;(?&lt;!S)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If PID is omitted, returns the process
group of the current process.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T162142Z" changeid="explorer">
        <seg>Si PID se omite, devuelve el grupo del proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certainly they mean two
different things on the I&lt;left&gt; side of the C&lt;s///&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230021Z" changeid="explorer">
        <seg>Significan dos cosas diferentes en el lado I&lt;izquierdo&gt; del C&lt;s///&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;/x&gt;, C&lt;/l&gt;, C&lt;/u&gt;, C&lt;/a&gt; and C&lt;/d&gt; modifiers need a little more
explanation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163216Z" changeid="explorer">
        <seg>Los modificadores C&lt;/x&gt;, C&lt;/l&gt;, C&lt;/u&gt;, C&lt;/a&gt; y C&lt;/d&gt; necesitan un poco más de explicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are interested in the VM/ESA, z/OS (formerly known as OS/390)
and POSIX-BC (BS2000) ports of Perl then see the perl-mvs mailing list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225259Z" changeid="explorer">
        <seg>Si está interesado en las versiones VM/ESA, z/OS (anteriormente conocido como OS/390) y POSIX-BC (BS2000) de Perl, entonces vea la lista de correo perl-mvs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the environment variable PERL_DESTRUCT_LEVEL is set to a non-zero
value, or if Perl is exiting a spawned thread, it will also destruct
the ordinary references and the symbol tables that are no longer in use.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T140040Z" changeid="explorer">
        <seg>Si la variable de entorno PERL_DESTRUCT_LEVEL se establece a un valor distinto de cero, o si Perl está saliendo de un hilo, también destruirá las referencias comunes y las tablas de símbolos que ya no están en uso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Gory details of parsing quoted constructs
X&lt;quote, gory details&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010437Z" changeid="explorer">
        <seg>=head2 Detalles sangrientos del análisis de construcciones entrecomilladas
X&lt;quote, gory details&gt; X&lt;entrecomillado, detalles sangrientos&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some brief examples:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235546Z" changeid="zipf">
        <seg>Algunos ejemplos breves:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For cryptographic purposes, however, you need something much more random 
than the default seed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para propósitos criptográficos, necesita algo mucho más aleatorio para el valor por defecto de la semilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Win32::GUI</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225454Z" changeid="explorer">
        <seg>=item Win32::GUI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Potential problems exist if
an extension bypasses the official APIs and directly modifies the PV
of an SV: the UTF-8 cache does not get cleared as it should.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T001613Z" changeid="explorer">
        <seg>Existen problemas potenciales si una extensión no pasa por la API oficial y modifica directamente el PV de un SV: el caché UTF-8 no es borrado como debiera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some systems the $comment field may be $class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas el campo $comentario puede ser $clase.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;blib&gt; upgraded to version 1.03</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T024205Z" changeid="explorer">
        <seg>C&lt;blib&gt; actualizado a la versión 1.03</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They're discussed in Part 3 of this FAQ, along with CPAN, which is
discussed in Part 2.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230616Z" changeid="explorer">
        <seg>Se describen en la parte 3 de este conjunto de documentos sobre preguntas más frecuentes. CPAN se describe en la parte 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.sunfreeware.com/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225435Z" changeid="explorer">
        <seg>http://www.sunfreeware.com/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please don't report bugs in microperl; fix the
bugs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223022Z" changeid="explorer">
        <seg>Por favor, no informe de errores en microperl; corrija los errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the end of all C&lt;when&gt; blocks, there is an implicit C&lt;next&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al final de todos los bloques C&lt;when&gt;, hay un implícito C&lt;next&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Perl Glossary</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013700Z" changeid="explorer">
        <seg>=head2 Glosario Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 /x</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163224Z" changeid="explorer">
        <seg>=head3 /x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LAYER is omitted or specified as C&lt;:raw&gt; the filehandle is made
suitable for passing binary data.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005043Z" changeid="explorer">
        <seg>Si se omite CAPA o se especifica como C&lt;:raw&gt; el identificador se prepara para pasar datos binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUPER-UX: add hints file</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004048Z" changeid="explorer">
        <seg>SUPER-UX: añadido archivo de sugerencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use File::Spec::Functions;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015238Z" changeid="explorer">
        <seg>use File::Spec::Functions;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $x;           # prints &quot;foo&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002203Z" changeid="zipf">
        <seg>print $x;           # imprime &quot;foo&quot; en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rindex STR,SUBSTR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item rindex CADENA,SUBCADENA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a non-empty string if EXPR is a reference, the empty
string otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una cadena no vacía si EXPR es una referencia; de otra manera, devuelve una cadena vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The build process on both VMS and Windows has had several minor improvements
made.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T105345Z" changeid="explorer">
        <seg>El proceso de compilación, tanto en VMS como en Windows han tenido pequeñas mejoras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That
might mean that Perl either saves them something (time, headaches, money)
or gives them something (flexibility, power, testability).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232307Z" changeid="explorer">
        <seg>Esta ayuda puede implicar un ahorro (de tiempo, dinero o dolores de cabeza) o una aportación (en forma de flexibilidad, eficacia o facilidad para realizar pruebas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@sortedclass = sort byage @class;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@claseordenada = sort por_edad @clase;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it does guess wrong, or if you're just
plain paranoid, you can force the correct interpretation with curly
braces as above.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se equivoca, o si es usted un sencillo paranoico, puede forzar la interpretación correcta con llaves, como en el caso anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 4) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 4) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fixed various memory leaks</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033010Z" changeid="explorer">
        <seg>Arregladas varias pérdidas de memoria</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#days		# the last index of array @days</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#dias		# el último índice del array @dias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map {  lc($_) =&gt; 1  } @array  # as does this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map {  lc($_) =&gt; 1  } @array  # y como esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an internal function used by C&lt;format&gt;s, though you may call it,
too.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es una función interna usada por C&lt;format&gt;, aunque también puede llamarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/dbm.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010018Z" changeid="explorer">
        <seg>=item t/op/dbm.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List values are denoted by separating individual values by commas
(and enclosing the list in parentheses where precedence requires it):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lista de valores se indican mediante la separación de los valores individuales por comas (y encerrando la lista entre paréntesis donde la precedencia lo requiera):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since I am running a very recent Hurd snapshot, in which a lot of
bugs that were exposed by the Perl test suite have been fixed, you may
encounter more failures.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020120Z" changeid="explorer">
        <seg>Sin embargo, como estoy ejecutando una instantánea muy reciente de Hurd, en la que se han corregido muchos de los errores expuestos por el conjunto de pruebas de Perl, es posible que otros usuarios encuentren más errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Address-of operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operador Dirección-de.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The B&lt;-w&gt; switch is not mandatory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001710Z" changeid="explorer">
        <seg>El uso del modificador B&lt;-w&gt; no es obligatorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/([^ ]*) *([^ ]*)/$2 $1/;	# reverse 1st two fields</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/([^ ]*) *([^ ]*)/$2 $1/;	# invierte los dos primeros campos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlport		Perl portability guide</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlport		Guía de portabilidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Same as C&lt;tr///&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Igual que C&lt;tr///&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $item (split(/:[\\\n:]*/, $ENV{TERMCAP})) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $item (split(/:[\\\n:]*/, $ENV{TERMCAP})) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfunc - Perl builtin functions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110803T113552Z" changeid="explorer">
        <seg>perlfunc - Funciones integradas en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact semantics and interface of TYPE and ATTRS are still
evolving.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La semántica exacta e interfaz de TIPO y ATRIBUTOS están aún en evolución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How about this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194306Z" changeid="explorer">
        <seg>¿Qué le parece esto?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 5.14, all characters whose code points are above 127 are not
quoted in UTF8-encoded strings, but all are quoted in UTF-8 strings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011025Z" changeid="explorer">
        <seg>En Perl 5.14, todos los caracteres cuyo código de punto esté por encima de 127 no son escapados como strings codificados en UTF-8, sino que todos son escapados en strings UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/substr_thr.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010043Z" changeid="explorer">
        <seg>=item t/op/substr_thr.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
C&lt;continue&gt; block, if any, is not executed:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bloque C&lt;continue&gt;, si está, no es ejecutado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;B&gt; upgraded to version 1.09_01</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T024104Z" changeid="explorer">
        <seg>C&lt;B&gt; actualizado a la versión 1.09_01</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl592delta	Perl changes in version 5.9.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl592delta	Cambios en la versión 5.9.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At any rate, the first field should be &quot;uts&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T213954Z" changeid="explorer">
        <seg>En cualquier caso, el primer campo debe ser &quot;uts&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main use of typeglobs in modern Perl is create symbol table aliases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso principal de los typeglobs en el Perl moderno es crear alias en la tabla de símbolos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the cosine of EXPR (expressed in radians).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el coseno de EXPR (expresado en radianes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a Unicode encoding, multiple subsequent bytes can be used to
store a single code point, or simply: character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234424Z" changeid="explorer">
        <seg>En una codificación de Unicode se pueden utilizar varios bytes seguidos para almacenar un solo código de carácter (o carácter).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do just
C&lt;&lt; open(A, &quot;&gt;&gt;&amp;B&quot;) &gt;&gt;, the filehandle A will not have the same file
descriptor as B, and therefore flock(A) will not flock(B) nor vice
versa.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004629Z" changeid="explorer">
        <seg>Si hace sólo C&lt;&lt; open(A, &quot;&gt;&gt;&amp;B&quot;) &gt;&gt;, el identificador de archivo A no tendrá el mismo descriptor de archivo que B, y por lo tanto flock(A) no hará un flock(B), y viceversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a/b is 9/44</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033451Z" changeid="explorer">
        <seg>a/b es 9/44</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C-style Logical Or
X&lt;||&gt; X&lt;operator, logical, or&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235541Z" changeid="explorer">
        <seg>=head2 Or lógico al estilo del C
X&lt;||&gt; X&lt;operator, logical, or&gt; X&lt;operador, lógico, or&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum depth is compiled
into perl, so changing it requires a custom build.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185812Z" changeid="explorer">
        <seg>La profundidad máxima está compilada en perl, por lo que su modificación requiere una generación personalizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used interactively or
imperatively.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235047Z" changeid="explorer">
        <seg>Se puede usar de manera interactiva o imperativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the F&lt;h2ph&gt; documentation for more on how
to convert a whole bunch of header files at once.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234511Z" changeid="explorer">
        <seg>Consulte la documentación de F&lt;h2ph&gt; para obtener más información sobre la manera de convertir varios archivos de encabezado a la vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;bits are %0*v8b\n&quot;, &quot; &quot;, $bits;   # random bitstring</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;bits son %0*v8b\n&quot;, &quot; &quot;, $bits;     # cadena de bits aleatoria</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Perl programmers are encouraged to use the
Perl-specific syntax, the following are also accepted:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003116Z" changeid="explorer">
        <seg>Mientras que se anima a los programadores de Perl a usar la sintaxis específica de Perl, lo siguiente también es aceptado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.00, 1.10, 1.11, 1.20, 1.30, 1.31, 1.32</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025421Z" changeid="explorer">
        <seg>1.00, 1.10, 1.11, 1.20, 1.30, 1.31, 1.32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perldata&gt;, L&lt;perlref&gt;, L&lt;perldsc&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200441Z" changeid="explorer">
        <seg>L&lt;perldata&gt;, L&lt;perlref&gt;, L&lt;perldsc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Enginsite</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>=item Enginsite</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-S&gt; ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-S&gt; ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>alarm $timeout;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>alarm $timeout;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current position I&lt;in bytes&gt; for FILEHANDLE, or -1 on
error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013128Z" changeid="explorer">
        <seg>Devuelve la posición actual I&lt;en bytes&gt; para IDENTIFICADOR_ARCHIVO, o -1 en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Mark-Jason Dominus</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003543Z" changeid="explorer">
        <seg>Mark-Jason Dominus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;tr/$oldlist/$newlist/, 1&quot; or die $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;tr/$viejalista/$nuevalista/, 1&quot; or die $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a good idea to run this on a pod file you've patched.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014848Z" changeid="explorer">
        <seg>Tras aplicar una revisión a un archivo pod, es recomendable ejecutar este programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The header files living in the Byte File System (you could put the
there if you want); 2.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102548Z" changeid="explorer">
        <seg>Los archivos cabecera residen en el I&lt;Byte File System &gt; (puede ponerla ahí si quiere); 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those functions all
have return values, so use them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todas estas funciones tienen valores de retorno, así que úselos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readlink</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item readlink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See pod/perlbook.pod for more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220611Z" changeid="explorer">
        <seg>Vea pod/perlbook.pod para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use Perl on the Hurd, I recommend using the Debian
GNU/Hurd distribution ( see http://www.debian.org/ ), even if an
official, stable release has not yet been made.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020005Z" changeid="explorer">
        <seg>Si desea usar Perl en Hurd, la distribución recomendada es Debian GNU/Hurd (visite http://www.debian.org/ ), aunque aún no existe una versión oficial estable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sunfreeware.com: Solaris 2.5 to Solaris 10 (SPARC and x86)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225744Z" changeid="explorer">
        <seg>Sunfreeware.com: Solaris 2.5 a Solaris 10 (SPARC y x86)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$db-&gt;filter_store_value( sub { $_ .= &quot;\0&quot; } );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190140Z" changeid="zipf">
        <seg>$db-&gt;filter_store_value( sub { $_ .= &quot;\0&quot; } );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common abuse of this power stems from the ability to make infinite
loops using regular expressions, with something as innocuous as:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230402Z" changeid="explorer">
        <seg>Un abuso común de este poder se deriva de la capacidad de hacer bucles infinitos mediante expresiones regulares, con algo tan inocuo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item given EXPR BLOCK
X&lt;given&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T234655Z" changeid="explorer">
        <seg>=item given EXPR BLOQUE
X&lt;given&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules which can be
released on cpan are known as &quot;dual-life&quot; modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014345Z" changeid="explorer">
        <seg>Los módulos que se pueden publicar en CPAN se denominan módulos de «evolución dual».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readdir DIRHANDLE
X&lt;readdir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020757Z" changeid="explorer">
        <seg>=item readdir IDENTIFICADOR_DIR
X&lt;readdir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3 new characters added to the ISO-8859-7 encoding</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030859Z" changeid="explorer">
        <seg>3 nuevos caracteres añadidos en la codificación ISO-8859-7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;Unicode::UCD/num()&gt; can be used to sort this out.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T173017Z" changeid="explorer">
        <seg>L&lt;Unicode::UCD/num()&gt; se puede utilizar para resolver esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generalized quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comillas generales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the examples in
L&lt;perlipc/&quot;Sockets: Client/Server Communication&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver los ejemplos en L&lt;perlipc/&quot;Sockets: Comunicación Cliente/Servidor&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those examples also illustrate that you should not try to use
C&lt;pack&gt;/C&lt;unpack&gt; as a substitute for the L&lt;Encode&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003831Z" changeid="explorer">
        <seg>Estos ejemplos también ilustran que no debería tratar de usar C&lt;pack&gt;/C&lt;unpack&gt; como un sustituto del módulo L&lt;Encode&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify a character class, by enclosing a list of characters
in C&lt;[]&gt;, which will match any character from the list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212521Z" changeid="explorer">
        <seg>Puede especificar una clase de caracteres, encerrando una lista de caracteres en C&lt;[]&gt;, que coincidirá con cualquier carácter de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sequence     Note  Description</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T190020Z" changeid="explorer">
        <seg>Secuencia	Nota					Descripción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>threadsafe DynaLoader, re, Opcode, File::Glob, and B</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DynaLoader, re, Opcode, File::Glob, y B, compatibles con threads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (@a) {
            return 0 if pop(@a) ne pop(@b);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051518Z" changeid="explorer">
        <seg>while (@a) {
            return 0 if pop(@a) ne pop(@b);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;abcd&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># &quot;abcd&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This keyword is available only when the C&lt;&quot;say&quot;&gt; feature is enabled; see
L&lt;feature&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T012041Z" changeid="explorer">
        <seg>Esta palabra clave sólo está disponible cuando la característica C&lt;&quot;say&quot;&gt; está habilitada; vea L&lt;feature&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when C&lt;use integer&gt; is in scope, &quot;%&quot; gives you direct access
to the modulo operator as implemented by your C compiler.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que cuando C&lt;use integer&gt; está en su ámbito, &quot;%&quot; le da acceso directo al operador módulo, implementado por su compilador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;Encode&gt; and L&lt;perlunicode&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;Encode&gt; y L&lt;perlunicode&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here is a loop that inserts index producing entries
before any line containing a certain pattern:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, aquí hay un bucle que inserta índices de entradas antes de cualquier línea que contenga un cierto patrón:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 5 of Perl changed the semantics of C&lt;$[&gt;: files that don't set
the value of C&lt;$[&gt; no longer need to worry about whether another
file changed its value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La versión 5 de Perl cambió la semántica de C&lt;$[&gt;: los archivos que no asignen un valor a C&lt;$[&gt; no necesitan preocuparse nunca más de si otro archivo ha cambiado su valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or programmatically via the C&lt;Config&gt; module:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o programáticamente vía el módulo C&lt;Config&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;use locale&gt; is in effect, the C&lt;\U&gt; will use locale
rules; if C&lt;use feature 'unicode_strings'&gt; is in effect, it will
use Unicode rules, etc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T164252Z" changeid="explorer">
        <seg>Si C&lt;use locale&gt; está en vigor, el C&lt;\U&gt; usará las reglas regionales; si C&lt;use feature 'unicode_strings'&gt; está en vigor, usará las reglas Unicode, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (undef) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (undef) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a                 # non-zero</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231721Z" changeid="explorer">
        <seg>a                 # no cero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the program's responsibility to
C&lt;close DATA&gt; when it is done reading from it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es responsabilidad del programa hacer C&lt;close DATA&gt; cuando se termine la lectura del mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt; &quot;EOF&quot;; # same as above</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt; &quot;EOF&quot;; # lo mismo que el anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact numbers stored in the native integer format may be stored either
in the signed native form, or in the unsigned native form.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232601Z" changeid="explorer">
        <seg>De hecho, los números almacenados en formato de entero nativo se pueden almacenar en forma nativa con signo o sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As part of the C&lt;Test::Harness&gt; 2.x to 3.x upgrade, the experimental
C&lt;Test::Harness::Straps&gt; module has been removed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190553Z" changeid="explorer">
        <seg>Como parte de la actualización de C&lt;Test::Harness&gt; 2.x a la 3.x, se ha eliminado el módulo experimental C&lt;Test::Harness::Straps&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
C&lt;require&gt; makes sure the module is loaded into memory if it hasn't been
yet.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;require&gt; se asegura que el módulo esté cargado en memoria, si todavía no lo está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(VMS)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014833Z" changeid="explorer">
        <seg>(VMS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;aa&quot; =~ /${a}/;      # True</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191705Z" changeid="explorer">
        <seg>&quot;aa&quot; =~ /${a}/;      # Verdadero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># line 345 &quot;goop&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># line 345 &quot;goop&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this program</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050213Z" changeid="explorer">
        <seg>Por ejemplo, este programa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You really should build the whole distribution on the machine it will
eventually live on, and then type C&lt;make install&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225845Z" changeid="explorer">
        <seg>Es muy recomendable compilar toda la distribución en el equipo en el que se va a instalar y después ejecutar el comando C&lt;make install&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item resolve</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114009Z" changeid="explorer">
        <seg>=item resolve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behavior of this function varies wildly depending on your system
implementation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento de esta función varía enormemente dependiendo de la implementación de su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;POSIX::getattr&gt; function can do this more portably on
systems purporting POSIX compliance.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función C&lt;POSIX::getattr&gt; puede hacer esto de forma más portable en sistemas compatibles con POSIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make h2ph understand constants like 1234L and 5678LL</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make h2ph entiende las constantes como 1234L y 5678LL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @numbers = (23, 42, 69);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025651Z" changeid="explorer">
        <seg>my @numeros  = (23, 42, 69);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C code</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T013238Z" changeid="explorer">
        <seg>=head2 Código C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is available for most operating systems, including virtually
all Unix-like platforms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001503Z" changeid="explorer">
        <seg>Perl está disponible para la mayoría de los sistemas operativos (incluidas prácticamente todas las plataformas Unix).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/oct&gt;, if all you have is a string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/oct&gt;, si todo lo que tiene es una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, it's getting a bit complicated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194003Z" changeid="explorer">
        <seg>Como puede ver, se está haciendo un poco complicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to retain compatibility with
the older behavior, set PERL5SHELL in your environment to C&lt;cmd /x/c&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142554Z" changeid="explorer">
        <seg>Si desea mantener la compatibilidad con el antiguo comportamiento, establezca PERL5SHELL en su entorno a C&lt;cmd /x/c&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following blocks are more or less equivalent:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T174515Z" changeid="explorer">
        <seg>Los siguientes bloques son, más o menos, equivalentes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Win32, VMS, S&lt;RISC OS&gt;, VOS)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015628Z" changeid="explorer">
        <seg>(Win32, VMS, S&lt;RISC OS&gt;, VOS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would use C&lt;$a&gt; for the width and precision, and C&lt;$b&gt; as the
value to format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>usaría C&lt;$a&gt; para el ancho y precisión, y C&lt;$b&gt; como el valor a formatear.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, interpolating a regex into a larger regex
would ignore the original compilation in favor of whatever was in effect
at the time of the second compilation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T000413Z" changeid="explorer">
        <seg>Sin embargo, la interpolación de una expresión regular en una expresión regular más grande ignoraría la compilación original en favor de lo que estaba en vigor en el momento de la segunda compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a context not requiring a list value, the value of what appears
to be a list literal is simply the value of the final element, as
with the C comma operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En un contexto que no requiera una lista de valores, el valor de lo que parece ser una lista literal es, simplemente, el valor del último elemento, como ocurre con el operador coma en C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns a
list of lines (however you've defined lines with $/ or
$INPUT_RECORD_SEPARATOR), or an empty list if the command failed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, devuelve una lista de líneas (según haya definido líneas con $/ o $INPUT_RECORD_SEPARATOR), o una lista vacía si el comando ha fallado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proper way
to get a 4-digit year is simply:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma apropiada para obtener un año con los 4 dígitos es simplemente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/anydbm.t                 12    1   8.33%  12</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lib/anydbm.t                 12    1   8.33%  12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,27, 1) = 1   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,27, 1) = 1   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some platforms (like Linux) that use glibc the minimum memory
footprint of one ithread has been reduced by several hundred kilobytes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180034Z" changeid="explorer">
        <seg>En algunas plataformas (como Linux) que usan glibc, el consumo mínimo de memoria de un ithread se ha reducido en varios cientos de kilobytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local $_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl will now use the C library calls C&lt;unsetenv&gt; and C&lt;clearenv&gt; if present
to delete keys from C&lt;%ENV&gt; and delete C&lt;%ENV&gt; entirely, thanks to a patch
from Alan Burlison.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T050652Z" changeid="explorer">
        <seg>Perl ahora utilizará las funciones de la biblioteca C C&lt;unsetenv&gt; y C&lt;clearenv&gt; si se indica que se deben borrar claves de C&lt;%ENV&gt; o si se elimina C&lt;%ENV&gt; por completo, gracias a un parche de Alan Burlison.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that Module I&lt;must&gt; be a bareword.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>excepto que el módulo I&lt;debe&gt; ser una palabra simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$1 = foo(bar(baz)+baz(bop))</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185659Z" changeid="explorer">
        <seg>$1 = foo(bar(baz)+baz(bop))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function behaves the same way under various pragma, such as in a locale,
as L&lt;/lc&gt; does.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175338Z" changeid="explorer">
        <seg>Esta función se comporta de la misma manera bajo varios I&lt;pragma&gt;, como por ejemplo en una configuración regional, como lo hace L&lt;/lc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># my $tcp = IPPROTO_TCP; # Alternative</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># my $tcp = IPPROTO_TCP; # Alternativa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Local::Maketext</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014824Z" changeid="explorer">
        <seg>=item Local::Maketext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no filehandle (previous item),
then this subroutine is expected to generate one line of source code per
call, writing the line into C&lt;$_&gt; and returning 1, then finally at end of
file returning 0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011543Z" changeid="explorer">
        <seg>Si no hay un identificador de archivo (punto anterior), entonces de esta subrutina se espera que genere una línea de código fuente por llamada, escribiendo la línea en C&lt;$_&gt; y devolviendo 1, para luego, finalmente, devolver un 0 al final del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use User::pwent;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use User::pwent;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub log10 {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub log10 {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next LINE if /^#/;  # discard comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next LINEA if /^#/;  # descartar comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using ACLs, there is a pragma called C&lt;filetest&gt; that may
produce more accurate results than the bare stat() mode bits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está usando ACL, hay un pragma llamado C&lt;filetest&gt; que puede producir resultados más precisos que los simples bits de modo de stat().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As more recent versions of autoconf require flock() support, I wrote a flock()
emulation (flock_server) and released it on BeBits:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como las versiones más recientes de autoconf requieren soporte de flock(), he escrito una emulación de flock() (flock_server) y la publiqué en BeBits:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This zero-width assertion evaluates any embedded Perl code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T215545Z" changeid="explorer">
        <seg>Esta aserción de ancho cero evalúa cualquier código Perl empotrado en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(at least in platforms of ASCII progeny)  Perl 5.8.1 restored the
more natural interpretation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T141519Z" changeid="explorer">
        <seg>(al menos en las plataformas de la progenie ASCII). Perl 5.8.1 restauró la interpretación más natural</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;say()&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T194751Z" changeid="explorer">
        <seg>=head2 C&lt;say()&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5136delta	Perl changes in version 5.13.6</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141355Z" changeid="explorer">
        <seg>perl5136delta	Cambios en la versión 5.13.6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to C&lt;(??{ code })&gt; except it does not involve compiling any code,
instead it treats the contents of a capture group as an independent
pattern that must match at the current position.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T202333Z" changeid="explorer">
        <seg>Similar a C&lt;(??{ código })&gt; excepto que no incluye la compilación de ningún código; en vez de eso trata a los contenidos de un grupo de captura como un patrón independiente que debe coincidir en la posición actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I have built and tested Perl 5.8.6 and 5.9.1 under BeOS R5 x86 net server.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He construido y probado Perl 5.8.6 y 5.9.1 bajo BeOS R5 x86 net server.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5110delta	Perl changes in version 5.11.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5110delta	Cambios en la versión 5.11.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Yow!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110204T164416Z" changeid="zipf">
        <seg>print &quot;¡Caramba!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So C&lt;&lt; ((?&gt;a*)|(?&gt;b*))ar &gt;&gt; will still match &quot;bar&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213841Z" changeid="explorer">
        <seg>Por tanto C&lt;&lt; ((?&gt;a*)|(?&gt;b*))ar &gt;&gt; aún lo haría con &quot;bar&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There were a number of
inconsistencies (bugs) with the C&lt;/d&gt; modifier, where Unicode rules
would be used when inappropriate, and vice versa.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T000556Z" changeid="explorer">
        <seg>Hubo una serie de inconsistencias (errores) con el modificador C&lt;/d&gt;, donde reglas Unicode serían usadas de forma inadecuada, y viceversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item system LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item system LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The equivalent numeric version should be used instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se debe usar en su lugar la versión equivalente numérica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item seek FILEHANDLE,POSITION,WHENCE
X&lt;seek&gt; X&lt;fseek&gt; X&lt;filehandle, position&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013103Z" changeid="explorer">
        <seg>=item seek IDENTIFICADOR_ARCHIVO,POSICIÓN,DÓNDE
X&lt;seek&gt; X&lt;fseek&gt; X&lt;filehandle, position&gt; X&lt;identificador de archivo, posición&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This start line assumes you have the B&lt;env&gt; program.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T001820Z" changeid="zipf">
        <seg>(En esta línea se supone que dispone del programa B&lt;env&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n = 0x1234;	    # hexadecimal integer</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232304Z" changeid="explorer">
        <seg>$n = 0x1234;            # entero hexadecimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item perl Build install</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025003Z" changeid="explorer">
        <seg>=item perl Build install</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>arbitrarily nested data structures and anonymous functions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001329Z" changeid="explorer">
        <seg>estructuras de datos anidadas de profundidad arbitraria y funciones anónimas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldoc perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222147Z" changeid="explorer">
        <seg>perldoc perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ?PATTERN?msixpodualgc</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030230Z" changeid="explorer">
        <seg>=item ?PATRÓN?msixpodualgc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings that would cause
integer overflow trigger a warning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Strings que podrían causar desbordamiento de enteros lanzará un aviso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;cpan2dist&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235049Z" changeid="explorer">
        <seg>=item L&lt;cpan2dist&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when( /^[+-]?(?=\.?\d)\d*\.?\d*(?:e[+-]?\d+)?\z/i)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225622Z" changeid="explorer">
        <seg>when( /^[+-]?(?=\.?\d)\d*\.?\d*(?:e[+-]?\d+)?\z/i)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?(condition)yes-pattern|no-pattern)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T000515Z" changeid="explorer">
        <seg>=item C&lt;(?(condición)patrón-sí|patrón-no)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Test::Simple</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015324Z" changeid="explorer">
        <seg>=item Test::Simple</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\h        [3]  Horizontal whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224945Z" changeid="explorer">
        <seg>\h        [3]  Espacio en blanco horizontal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $byte_count = length $body;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235321Z" changeid="explorer">
        <seg>my $numero_bytes = length $cuerpo_texto;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to C&lt;&lt; \g{NAME} &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003405Z" changeid="explorer">
        <seg>Equivalente a C&lt;&lt; \g{NOMBRE} &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the second way hides the main point of the statement in a
modifier.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>porque la segunda forma esconde el objetivo principal de la instrucción dentro de un modificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rin = fhbits('STDIN TTY SOCK');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$rin = fhbits('STDIN TTY SOCK');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item no MODULE LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item no MÓDULO LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all fields are supported on all filesystem types.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No todos los campos están soportados por todos los sistemas de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting from Perl 5.8.1, the above B&lt;will&gt; cause an error to be
raised.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T175250Z" changeid="explorer">
        <seg>A partir de Perl 5.8.1, lo anterior B&lt;provocará&gt; un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Occasionally, you can't use just a C&lt;/g&gt; to get all the changes
to occur that you might want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De vez en cuando, no solo se puede utilizar un C&lt;/g&gt; para obtener todos los cambios posibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wanted just to append to a row, you'd have
to do something a bit funnier looking:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sólo quiere añadir a una fila, tendrá que hacer algo un poco más divertido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a question, you can be sure someone has already asked the
same question at some point on c.l.p.m.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230956Z" changeid="explorer">
        <seg>Si quiere preguntar algo, puede estar seguro de que alguien ya ha tenido esa duda antes y ha pedido ayuda en c.l.p.m.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the availability and the exact meaning of these fields
in your system, please consult getpwnam(3) and your system's 
F&lt;pwd.h&gt; file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T234609Z" changeid="explorer">
        <seg>Para la disponibilidad y el significado exacto de estos campos, en su sistema, por favor consulte getpwnam(3) y su archivo F&lt;pwd.h&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual location
where C&lt;\G&gt; will match can also be influenced by using C&lt;pos()&gt; as
an lvalue: see L&lt;perlfunc/pos&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220512Z" changeid="explorer">
        <seg>La ubicación actual donde C&lt;\G&gt; coincidirá también puede modificarse usando C&lt;pos()&gt; como un I&lt;ivalor&gt;: vea L&lt;perlfunc/pos&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The point of the function is to &quot;seed&quot; the C&lt;rand&gt; function so that
C&lt;rand&gt; can produce a different sequence each time you run your
program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La misión de la función es &quot;alimentar&quot; a la función C&lt;rand&gt; para que C&lt;rand&gt; pueda producir una secuencia diferente cada vez que ejecute su programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If multiple groups
have the same name then it refers to the leftmost defined group in
the current match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T214830Z" changeid="explorer">
        <seg>Si varios grupos tienen el mismo nombre entonces se refiere al grupo más a la izquierda de la coincidencia actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the terminator of
C&lt;(?{...})&gt; is found using the same rules as for finding the
terminator of a C&lt;{}&gt;-delimited construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, el terminador de C&lt;(?{...})&gt; es encontrado usando las mismas reglas como para encontrar el terminador de una construcción delimitada por C&lt;{}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;pos&gt; is only updated on a C&lt;/g&gt; match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;pos&gt; sólo es actualizado en una coincidencia C&lt;/g&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$baz = pack('s.l', 12, 4, 34);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$baz = pack('s.l', 12, 4, 34);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;lib/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014346Z" changeid="explorer">
        <seg>=item * F&lt;lib/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This check is the regex equivalent of</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195238Z" changeid="explorer">
        <seg>Esto comprueba si la regex equivale a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should build miniperl and then fail when it tries to run it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto debería construir miniperl y luego fallar cuando trate de ejecutarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$fh = newopen('/etc/passwd');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$fh = nuevoopen('/etc/passwd');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $&amp;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $&amp;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Finding the end</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Encontrando el final</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item reset EXPR
X&lt;reset&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194628Z" changeid="explorer">
        <seg>=item reset EXPR
X&lt;reset&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LIMIT parameter can be used to split a line partially</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El parámetro LÍMITE puede usarse para dividir una línea de forma parcial</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on writing subroutines, see L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225537Z" changeid="explorer">
        <seg>Para obtener más información sobre cómo escribir subrutinas, consulte L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Storable</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015256Z" changeid="explorer">
        <seg>=item Storable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;LABEL&gt; is omitted, restarts the program from the top.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite C&lt;ETIQUETA&gt;, reinicia el programa desde el principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @newAoA, [ @{ $AoA[$x] } [ 7..12 ] ];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053017Z" changeid="explorer">
        <seg>push @newAoA, [ @{ $AoA[$x] } [ 7..12 ] ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
UTF-7 encoding has been added (making Encode feature-complete with
Unicode::String).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T173211Z" changeid="explorer">
        <seg>La codificación UTF-7 ha sido añadida (haciendo que Encode tenga las características completas con Unicode::String).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the format specification
uses C&lt;*&gt; to require additional arguments, these are consumed from
the argument list in the order they appear in the format
specification I&lt;before&gt; the value to format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la especificación de formato utiliza C&lt;*&gt; para exigir argumentos adicionales, estos se consumen de la lista de argumentos en el orden en que aparecen en la especificación del formato I&lt;antes&gt; del valor a dar formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General examples:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplos generales:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;array&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;array&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... than to have a long list of unnamed parameters like this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021629Z" changeid="explorer">
        <seg>... que tener una larga lista de parámetros sin nombre, como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fixes for certain bugs in C&lt;make&gt; and C&lt;emake&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033135Z" changeid="explorer">
        <seg>Correcciones de errores determinados en C&lt;make&gt; y C&lt;emake&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is written in the POD format (see pod/perlpod.pod) which is
specifically designed to be readable as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está escrito en formato POD (ver pod/perlpod.pod) que está específicamente diseñado para ser legible de forma sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Cygwin</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005638Z" changeid="explorer">
        <seg>=item Cygwin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$search .= &quot;++\$seen{\$ARGV} if /\\b$word\\b/;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$buscar .= &quot;++\$visto{\$ARGV} if /\\b$palabra\\b/;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dec = unpack(&quot;N&quot;, pack(&quot;H8&quot;, substr(&quot;0&quot; x 8 . &quot;DEADBEEF&quot;, -8)));</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225513Z" changeid="explorer">
        <seg>$dec = unpack(&quot;N&quot;, pack(&quot;H8&quot;, substr(&quot;0&quot; x 8 . &quot;DEADBEEF&quot;, -8)));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl you can backtrack into
a recursed group, in PCRE and Python the recursed into group is treated
as atomic.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T191024Z" changeid="explorer">
        <seg>En Perl se puede dar marcha atrás en un grupo recursivo, en PCRE y lenguajes de programación Python el grupo recursivo es tratado de forma atómica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 VMS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015208Z" changeid="explorer">
        <seg>=head2 VMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit the LIST, C&lt;$_&gt; is used;
to use FILEHANDLE without a LIST, you must use a real filehandle like
C&lt;FH&gt;, not an indirect one like C&lt;$fh&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T010605Z" changeid="explorer">
        <seg>Si omite la LISTA, se usará C&lt;$_&gt;; para usar un IDENTIFICADOR_ARCHIVO sin una LISTA, debe usar un identificador de archivo real, como C&lt;FH&gt;, no uno indirecto como C&lt;$fh&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./Configure -de</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>./Configure -de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Encode qw(encode decode);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234949Z" changeid="explorer">
        <seg>use Encode qw(encode decode);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PRINTF this, format, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>PRINTF este, formato, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no double interpolation in Perl, so the C&lt;$100&gt; is left as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay doble interpolación en Perl, por lo que el C&lt;$100&gt; se deja tal como está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-t  Filehandle is opened to a tty.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004524Z" changeid="explorer">
        <seg>-t  El identificador está abierto a una tty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact numbers depend on the Perl configuration and on the operating
system platform.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003636Z" changeid="explorer">
        <seg>El número exacto dependerá de la configuración de Perl y de la plataforma del sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;http://www.xray.mpe.mpg.de/mailing-lists/perl-mvs/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T064841Z" changeid="explorer">
        <seg>L&lt;http://www.xray.mpe.mpg.de/mailing-lists/perl-mvs/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;is_deeply()&gt; no longer fails to work for many cases</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040034Z" changeid="explorer">
        <seg>C&lt;is_deeply()&gt; ya no falla en la mayoría de los casos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FINIS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T021930Z" changeid="explorer">
        <seg>FINIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;last&gt; command immediately exits the loop in question.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;last&gt; sale inmediatamente del bucle en cuestión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To display and change the libnet configuration run the libnetcfg command.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234322Z" changeid="explorer">
        <seg>Para mostrar y modificar la configuración de libnet, ejecute el comando libnetcfg.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$search .= &quot;}&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$buscar .= &quot;}&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that $foo
and @foo are two different variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Significa entonces que $foo y @foo son dos variables distintas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También tenga en cuenta que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't start sort: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo iniciar sort: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Perl Best Practices&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003532Z" changeid="explorer">
        <seg>=item I&lt;Perl Best Practices&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, the shortest way to do the above is:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por supuesto, el camino más corto para hacer lo anterior es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfaq8&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215815Z" changeid="explorer">
        <seg>Vea L&lt;perlfaq8&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use diagnostics -verbose;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225507Z" changeid="explorer">
        <seg>use diagnostics -verbose;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $mbox, &quot;&gt;&gt;&quot;, &quot;/usr/spool/mail/$ENV{'USER'}&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $mbox, &quot;&gt;&gt;&quot;, &quot;/usr/spool/mail/$ENV{'USER'}&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File types such
as terminals may lose the end-of-file condition if you do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tipos de archivos como por ejemplo terminales pueden perder la condición de fin-de-archivo si lo hace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bucle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (m?^$?) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205921Z" changeid="explorer">
        <seg>if (m?^$?) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a script that saves, redirects, and restores C&lt;STDOUT&gt; and
C&lt;STDERR&gt; using various methods:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un script que salva, redirecciona, y restaura C&lt;STDOUT&gt; y C&lt;STDERR&gt; usando varios métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Learning Perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003337Z" changeid="explorer">
        <seg>=item I&lt;Learning Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This solves a number of misparsing issues when a global C&lt;_&gt;
subroutine is defined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T191855Z" changeid="explorer">
        <seg>Esto soluciona una serie de cuestiones de mala interpretación cuando esté definida una subrutina global C&lt;_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's often used to
remove the newline from the end of an input record when you're worried
that the final record may be missing its newline.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se utiliza a menudo para eliminar el carácter de nueva línea del final de un registro de entrada cuando es importante que el registro al final le pueda faltar ese carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, you can define a set of regular expression rules that can be
bundled into any pattern you choose.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T202937Z" changeid="explorer">
        <seg>De esta manera, puede definir un conjunto de reglas de expresiones regulares que pueden ser agrupadas en el patrón que usted elija.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/Math/BigInt/t/bigintc..........ok</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214804Z" changeid="explorer">
        <seg>lib/Math/BigInt/t/bigintc..........ok</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;FindBin&gt; now works better with directories where access rights are more
restrictive than usual.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045027Z" changeid="explorer">
        <seg>C&lt;FindBin&gt; ahora funciona mejor con los directorios donde los derechos de acceso sean más restrictivos de lo habitual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, change &quot;^&quot; and &quot;$&quot; from matching
the start or end of the string to matching the start or end of any
line anywhere within the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, cambia &quot;^&quot; y &quot;$&quot; de coincidir con el inicio y el final de la cadena a coincidir con el inicio y el final de cualquier línea en cualquier lugar dentro de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># wipe out *all* compile-time warnings</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># limpiar *todas* las advertencias en tiempo de compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@bits = split(//, unpack(&quot;b*&quot;, $vector));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@bits = split(//, unpack(&quot;b*&quot;, $vector));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your platform supports NaNs (not-a-numbers) as numeric
values, using them with &quot;&lt;=&gt;&quot; returns undef.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su plataforma es compatible con NaN (I&lt;not-anumbers&gt;, no-es-un-número) como valores numéricos, usándolos con &quot;&lt;=&gt;&quot; devuelve undef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%p    a pointer (outputs the Perl value's address in hexadecimal)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%p    un puntero (sale la dirección del valor Perl en hexadecimal)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As your reader
continues through the document, they should receive a progressively
greater amount of knowledge.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024448Z" changeid="explorer">
        <seg>A medida que el lector siga a través del documento, debe recibir una cantidad cada vez mayor de conocimientos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eval EXPR
X&lt;eval&gt; X&lt;try&gt; X&lt;catch&gt; X&lt;evaluate&gt; X&lt;parse&gt; X&lt;execute&gt;
X&lt;error, handling&gt; X&lt;exception, handling&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eval EXPR
X&lt;eval&gt; X&lt;try&gt; X&lt;catch&gt; X&lt;evaluate&gt; X&lt;parse&gt; X&lt;execute&gt; X&lt;error, handling&gt; X&lt;exception, handling&gt; X&lt;manejo de excepciones&gt; X&lt;interpretar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>^                   start of string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235515Z" changeid="zipf">
        <seg>^                   principio de una cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resets only package
variables; lexical variables are unaffected, but they clean themselves
up on scope exit anyway, so you'll probably want to use them instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Restablece sólo las variables del paquete; las variables léxicas no se ven afectadas, pero ellas mismas se limpiarán, de todos modos, a la salida de su ámbito, por lo que probablemente querrá usarlas en su lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you actually want to test if
at least one of C&lt;$a&gt; and C&lt;$b&gt; is defined, use C&lt;defined($a // $b)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T184940Z" changeid="explorer">
        <seg>Si realmente desea probar si al menos uno de los dos, C&lt;$a&gt; o C&lt;$b&gt;, están definidos, use C&lt;defined($a // $b)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($min, $max) = ($max, $min)  if  $min &gt; $max;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225521Z" changeid="explorer">
        <seg>($min, $max) = ($max, $min)  if  $min &gt; $max;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Malloc in Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003937Z" changeid="explorer">
        <seg>=head2 Malloc en Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlopentut	Perl open() tutorial</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000300Z" changeid="explorer">
        <seg>perlopentut	Tutorial de open()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;false\n&quot; if (8 | 2) != 10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;falso\n&quot; if (8 | 2) != 10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># am the child; use STDIN/STDOUT normally</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010007Z" changeid="explorer">
        <seg># soy el hijo; use STDIN/STDOUT de forma normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ISO 8859-6 conversion table has been corrected (the 0x30..0x39
erroneously mapped to U+0660..U+0669, instead of U+0030..U+0039).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T173049Z" changeid="explorer">
        <seg>La tabla de conversión ISO 8859-6 ha sido corregida (el 0x30..0x39 erróneamente estaba asignado a U+0660..U+0669, en lugar de U+0030..U+0039).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version strings or v-strings (see L&lt;perldata/&quot;Version Strings&quot;&gt;)
feature introduced in Perl 5.6.0 has been a source of some confusion--
especially when the user did not want to use it, but Perl thought it
knew better.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T141336Z" changeid="explorer">
        <seg>Las cadenas de versión o v-strings (vea L&lt;perldata/&quot;Cadenas de versión&quot;&gt; ), característica introducida en Perl 5.6.0, ha sido una fuente de confusión -especialmente cuando el usuario no desea utilizarla, pero Perl piensa que sabe más que él-.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As usual, some optimizations took place and made the math overall a tad
faster.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T173704Z" changeid="explorer">
        <seg>Como de costumbre, algunas optimizaciones se llevaron a cabo y se hizo que el proceso matemático fuera, en general, un poco más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because you'll get just references listed, and perl will never
automatically dereference things for you.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193407Z" changeid="explorer">
        <seg>porque solo va a conseguir un listado de referencias, y perl nunca desreferencia de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays are zero-indexed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T000921Z" changeid="zipf">
        <seg>El índice de un array empieza en cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;C0U4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;C0U4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;http://www.unicode.org/versions/Unicode5.1.0/#Notable_Changes&gt; for the
notable changes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T191927Z" changeid="explorer">
        <seg>Vea L&lt;http://www.unicode.org/versions/Unicode5.1.0/#Notable_Changes&gt; para consultar los cambios principales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's why
sometimes is easier to take a temporary on your way through:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194158Z" changeid="explorer">
        <seg>Es por eso que a veces es más fácil tomar un descanso en su marcha campo a través:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.vim.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://www.vim.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2  &quot;wilma&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032546Z" changeid="explorer">
        <seg>2  &quot;wilma&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPSTRING must be a packed array of
semop structures.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>OPSTRING debe ser un array empaquetado de estructuras semop.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space after last parenthesis matching on current line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio después del último paréntesis coincidente en la línea actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, and
C&lt;\l&gt; string-interpolation escapes on the right side of a substitution
operator will perform correct case-mappings, but C&lt;tr[a-z][A-Z]&gt; will not
(except sometimes on legacy 7-bit data).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T032325Z" changeid="explorer">
        <seg>Las secuencias de escapado en la interpolación de cadenas (C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, y C&lt;\l&gt;) en el lado derecho de un operador de sustitución realizará un correcto mapeado entre mayúsculas y minúsculas, pero C&lt;tr[a-z][A-Z]&gt;, no (excepto en algunos viejos sistemas de 7 bits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$days[28]		# the 29th element of array @days</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$dias[28]		# el elemento número 29 del array @dias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This was due to incorrect UTF8 offsets being
cached, and is now fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se debió a que se almacenaban desplazamientos UTF8 incorrectos, y ahora ya está arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example in the latter case the
test is trying to send a UDP ping to the IP address 127.0.0.1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T002813Z" changeid="explorer">
        <seg>Un ejemplo de la última prueba sería la de intentar enviar un ping UDP a la dirección IP 127.0.0.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the moment the hints file for VM/ESA basically bypasses all of the
automatic configuration process.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T102406Z" changeid="explorer">
        <seg>En este momento el archivo de sugerencias para VM/ESA, básicamente, pasa por alto todo el proceso de configuración automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tom Christiansen &lt;F&lt;tchrist@perl.com&gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200445Z" changeid="explorer">
        <seg>Tom Christiansen &lt;F&lt;tchrist@perl.com&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For B&lt;sed&gt; devotees, C&lt;y&gt; is provided as a synonym for C&lt;tr&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para los devotos de B&lt;sed&gt;, C&lt;y&gt; se ofrece como un sinónimo de C&lt;tr&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/i matching so that no ASCII character will match a non-ASCII</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T225459Z" changeid="explorer">
        <seg>coincidencia de /i de forma que ningún carácter ASCII coincida con ningún no ASCII</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Custom matching via overloading</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Coincidencia personalizada vía sobrecarga del operador</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filehandle behaves normally for the parent, but I/O to that
filehandle is piped from/to the STDOUT/STDIN of the child process.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010121Z" changeid="explorer">
        <seg>El identificador de archivo se comporta de forma normal para el padre, pero la E/S del identificador de archivo es entubada desde/hacia el STDOUT/STDIN del proceso hijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The major changes made in 5.12.0 are described in L&lt;perl5120delta&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225850Z" changeid="explorer">
        <seg>Los principales cambios realizados en 5.12.0 se describen en L&lt;perl5120delta&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FUNCTION RETURN LISTS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224330Z" changeid="explorer">
        <seg>LISTAS RETORNO FUNCIONES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was planned a long time ago, but wasn't quite working
until now.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T001525Z" changeid="explorer">
        <seg>Esta característica fue planeada hace mucho tiempo, pero no estuvo funcionando hasta ahora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What happens for any of these
other characters currently though, is that the value is derived by inverting
the 7th bit (0x40).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T205516Z" changeid="explorer">
        <seg>Sin embargo, lo que le sucede ahora, para cualquiera de estos otros caracteres, es que el valor se obtiene invirtiendo el bit 7 (0x40).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\s+$//;           # trim trailing whitespace</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/\s+$//;           # quita los últimos espacios en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^=end/) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233435Z" changeid="explorer">
        <seg>/^=end/) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When doing a lookup in %ENV from within
Perl, the elements are combined into a single value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000453Z" changeid="explorer">
        <seg>Al hacer una búsqueda en %ENV desde dentro de Perl, los elementos son combinados en un solo valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an alternation like
this, an array ref will work, because this will instigate smart matching:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T222418Z" changeid="explorer">
        <seg>Para una alternativa como ésta, una referencia a un array funcionará, porque esto lanzará a la coincidencia inteligente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our earlier example, C&lt;$days{'Feb'}&gt; can be written as
C&lt;$days{Feb}&gt; and the quotes will be assumed automatically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En un ejemplo anterior, C&lt;$dias{'Feb'}&gt; puede ser escrito como C&lt;$dias{Feb}&gt; y las comillas serán asumidas automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto&gt;-LABEL form finds the statement labeled with LABEL and resumes
execution there.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013546Z" changeid="explorer">
        <seg>La forma C&lt;goto&gt;-ETIQUETA busca la instrucción etiquetada con ETIQUETA y continua la ejecución desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple methods for simple tasks</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013521Z" changeid="explorer">
        <seg>Métodos sencillos para tareas sencillas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setuid scripts have additional constraints that can produce error
messages such as &quot;Insecure dependency&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001655Z" changeid="explorer">
        <seg>Los scripts setuid tienen restricciones adicionales que pueden producir mensajes de error como &quot;Insecure dependency&quot; (dependencia insegura).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item q/STRING/
X&lt;q&gt; X&lt;quote, single&gt; X&lt;'&gt; X&lt;''&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010125Z" changeid="explorer">
        <seg>=item q/CADENA/
X&lt;q&gt; X&lt;quote, single&gt; X&lt;'&gt; X&lt;''&gt; X&lt;comilla, simple&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the notion of &quot;line&quot;
used here is whatever you may have defined with C&lt;$/&gt; or
C&lt;$INPUT_RECORD_SEPARATOR&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la noción de &quot;línea&quot; usada aquí es según tenga definido C&lt;$/&gt; o C&lt;$INPUT_RECORD_SEPARATOR&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234439Z" changeid="explorer">
        <seg>En UTF-8 los primeros 128 códigos de carácter (0 a 127) son equivalentes a ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the output, the only failures you should see should look like:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T002229Z" changeid="explorer">
        <seg>En la salida, los únicos errores que debe ver deben ser similares a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 (Win32) The -C Switch Has Been Repurposed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T141631Z" changeid="explorer">
        <seg>=head2 (Win32) La opción -C ha sido reasignada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open returns nonzero on success, the undefined value otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open() devuelve un valor distinto de cero en caso de éxito, indefinido en otro caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.enginsite.com/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>http://www.enginsite.com/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readline EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item readline EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>searches</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>búsquedas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\b Mrs )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025603Z" changeid="explorer">
        <seg>\b Mrs )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if all deleted elements fall at the end of an
array, the array's size shrinks to the position of the highest element that
still tests true for exists(), or to 0 if none do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si todos los elementos eliminados están al final del array, el tamaño del array se reduce al de la posición del elemento más alto que aún devuelve verdadero para exists(), o 0 si no hay ninguno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050151Z" changeid="explorer">
        <seg>print $1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or to block until something becomes ready just do this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o bloquear hasta que algo esté preparado, sólo hacemos esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basically, Intel and VAX CPUs are little-endian, while everybody else,
including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are
big-endian.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Básicamente, Intel y VAX son little-endian, mientras que todos los demás, incluyendo Motorola m68k/88k, PPC, Sparc, HP PA, Power y Cray, son big-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!   sSlLiI     Forces native (short, long, int) sizes instead
                   of fixed (16-/32-bit) sizes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050548Z" changeid="explorer">
        <seg>!   sSlLiI     Fuerza a tamaños nativos (short, long, int) en lugar
                   de tamaños fijos (16/32 bit)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%f&gt;', 1;    # prints &quot;&lt;1.000000&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%f&gt;', 1;    # imprime &quot;&lt;1.000000&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated to version 2.126.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052635Z" changeid="explorer">
        <seg>Actualizado a la versión 2.126.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several fixes, for example for join() problems and memory
leaks.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T175933Z" changeid="explorer">
        <seg>Varias correcciones, por ejemplo para problemas y pérdidas de memoria en join().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used without arguments in scalar context, reverse() reverses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se utiliza sin argumentos en contexto escalar, reverse() invierte C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-f  File is a plain file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004637Z" changeid="explorer">
        <seg>-f  Archivo es un archivo normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar&gt; for a description of Perl's built-in variables and
a discussion of legal variable names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar&gt; para una descripción de las variables internas de Perl y una discusión de nombres de variables legales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hexdigit = (0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$hexdigito = (0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read L&lt;perlboot&gt;, L&lt;perltoot&gt;, L&lt;perltooc&gt; and L&lt;perlobj&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225544Z" changeid="explorer">
        <seg>Lea L&lt;perlboot&gt;, L&lt;perltoot&gt;, L&lt;perltooc&gt; y L&lt;perlobj&gt; para obtener más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $result = $num * $num;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235526Z" changeid="zipf">
        <seg>my $resultado = $num * $num;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Compilation improvements</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T201231Z" changeid="explorer">
        <seg>=head2 Mejoras en la compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dogmatically advocating anything tends to make
people discount your message.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232539Z" changeid="explorer">
        <seg>En cambio, si defiende sus ideas de manera dogmática, hará que las personas desconfíen de su mensaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the file named by FILENAME does not exist and the C&lt;open&gt; call creates
it (typically because MODE includes the C&lt;O_CREAT&gt; flag), then the value of
PERMS specifies the permissions of the newly created file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el archivo con el nombre ARCHIVO no existe y la llamada C&lt;open&gt; lo crea (por lo general porque el modo incluye la bandera C&lt;O_CREAT&gt;), entonces el valor de PERMISOS especifica los permisos del archivo recién creado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,21, 1) = 1   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,21, 1) = 1   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getppid</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getppid</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $re;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002215Z" changeid="explorer">
        <seg>return $re;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matches C&lt;yes-pattern&gt; if C&lt;condition&gt; yields
a true value, matches C&lt;no-pattern&gt; otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T212955Z" changeid="explorer">
        <seg>Busca el C&lt;patrón-sí&gt; si C&lt;condición&gt; devuelve un valor verdadero, sino, busca el patrón C&lt;patrón-no&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use feature &quot;state&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112018Z" changeid="explorer">
        <seg>use feature &quot;state&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># this sorts the %age hash by value instead of key</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># esto ordena el hash %edad por valor en lugar de por clave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression providing the return value is evaluated
in void, scalar, or list context, depending on the context of the C&lt;eval&gt; 
itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La expresión que da el valor de retorno es evaluada en contexto vacío (void), escalar o lista, dependiendo del contexto en que se encuentre el C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default    { say '$foo does not contain a y' }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>default    { say '$foo no contiene una y' }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($uid, $dir)   = (getpwnam(&quot;daemon&quot;))[2,7]; # list slice</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($uid, $dir)    = (getpwnam(&quot;daemon&quot;))[2,7]; # porción lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use feature ':5.11';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T001323Z" changeid="explorer">
        <seg>use feature ':5.11';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Although case 2 has misleading double quotes making
the reader wonder what else might be happening (nothing is).)  Cases 3
and 4 likewise behave in the same way: they run the code C&lt;'$x'&gt;, which
does nothing but return the value of $x.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Aunque el caso 2 tiene unas engañosas dobles comillas haciendo maravillar al lector de qué es lo que que puede pasar -que es nada-).  Los casos 3 y 4 se comportan de la misma manera: ejecutan el código C&lt;'$x'&gt;, que no hace nada excepto devolver el valor de $x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One may also use pod directives to quickly comment out a section
of code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Uno puede también usar directivas pod para comentar, de forma rápida, una sección de código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class implementing a filehandle should have the following methods:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013233Z" changeid="explorer">
        <seg>Una clase que implementa un identificador de archivo debe tener los siguientes métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following
all do the same thing:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo lo siguiente hace lo mismo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To read more about them check their respective manual pages at L&lt;strict&gt;
and L&lt;warnings&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224716Z" changeid="explorer">
        <seg>Para obtener más información, consulte las páginas de manual correspondientes a L&lt;strict&gt; y L&lt;warnings&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options (specified by the following modifiers) are:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222943Z" changeid="explorer">
        <seg>Opciones (especificado por los siguientes modificadores) son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(  Start of a ()-group.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(  Inicia un grupo ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These URLs might also be useful:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230336Z" changeid="explorer">
        <seg>Las siguientes direcciones URL también pueden resultarle de utilidad:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;p&gt; format packs a pointer to a null-terminated string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El formato C&lt;p&gt; empaqueta un puntero a una cadena terminada en nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;each&gt;, C&lt;keys&gt;, C&lt;pop&gt;, C&lt;push&gt;, C&lt;shift&gt;, C&lt;splice&gt;, C&lt;unshift&gt;, C&lt;values&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152127Z" changeid="explorer">
        <seg>C&lt;each&gt;, C&lt;keys&gt;, C&lt;pop&gt;, C&lt;push&gt;, C&lt;shift&gt;, C&lt;splice&gt;, C&lt;unshift&gt;, C&lt;values&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local  *FH;  # not my!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local  *FH;  # ¡no my!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before starting the child process, but this may not be supported
on some platforms (see L&lt;perlport&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de la versión v5.6.0, Perl intentará vaciar todos los archivos abiertos para salida antes de iniciar un proceso hijo, pero esto puede no estar soportado en todas las plataformas (ver L&lt;perlport&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using perl on VM/ESA please keep in mind that the EBCDIC and ASCII
character sets are different.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T111644Z" changeid="explorer">
        <seg>Cuando se utiliza perl en VM/ESA por favor, tenga en cuenta que los juegos de caracteres EBCDIC y ASCII son diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12542</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12542</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't fall into the trap of writing for the wrong audience.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031600Z" changeid="explorer">
        <seg>No caiga en la trampa de escribir para el público equivocado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use L&lt;/exists&gt; for the latter
purpose.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use L&lt;/exists&gt; para este propósito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>42;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>42;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operands
C&lt;$a&gt; and C&lt;$b&gt; are floating point values and the absolute value of
C&lt;$b&gt; (that is C&lt;abs($b)&gt;) is less than C&lt;(UV_MAX + 1)&gt;, only
the integer portion of C&lt;$a&gt; and C&lt;$b&gt; will be used in the operation
(Note: here C&lt;UV_MAX&gt; means the maximum of the unsigned integer type).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los operandos C&lt;$a&gt; y C&lt;$b&gt; son valores en punto flotante y el valor absoluto de C&lt;$b&gt; (es decir, C&lt;abs($b)&gt;) es menor que C&lt;(UV_MAX + 1)&gt;, solo la porción de entero de C&lt;$a&gt; y C&lt;$b&gt; será usada en la operación (Nota: aquí C&lt;UV_MAX&gt; significa el máximo valor del tipo entero sin signo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that whether C&lt;select&gt; gets restarted after signals (say, SIGALRM)
is implementation-dependent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que cuando C&lt;select&gt; es reiniciado después de señales (por ejemplo, SIGALRM) es algo dependiente de la implementación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Any good book on software engineering</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T032154Z" changeid="explorer">
        <seg>=item Cualquier buen libro de ingeniería del software</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before Perl knew how to execute interpolated code within a pattern,
this operation was completely safe from a security point of view,
although it could raise an exception from an illegal pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T223040Z" changeid="explorer">
        <seg>Antes de que Perl supiera cómo ejecutar código interpolado dentro de un patrón, esta operación era completamente segura desde un punto de vista de la seguridad, aunque podría levantar una excepción si se pasa un patrón ilegal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># MPW</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225504Z" changeid="explorer">
        <seg># MPW</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     Hash      hash entry existence     exists $b-&gt;{$a}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  Hash       existencia de un valor hash      exists $b-&gt;{$a}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A position
of zero is returned as the string C&lt;&quot;0 but true&quot;&gt;; thus C&lt;sysseek&gt; returns
true on success and false on failure, yet you can still easily determine
the new position.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001828Z" changeid="explorer">
        <seg>Una posición de cero es devuelto como cadena C&lt;&quot;0 but true&quot;&gt; (I&lt;&quot;0 pero verdadero&quot;&gt;), por lo que C&lt;sysseek&gt; devuelve verdadero o falso en caso de error, sin embargo, usted puede determinar fácilmente la nueva posición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some programmers choose to use an explicit conversion so as to 
leave nothing to doubt:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos programadores eligen usar una conversión explícita para que no haya ninguna duda:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the C&lt;-a&gt; option to run I&lt;all&gt; tests.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T042026Z" changeid="explorer">
        <seg>Use la opción C&lt;-a&gt; para correr I&lt;todas&gt; las pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state $prettily = new Dumpvalue::</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032209Z" changeid="explorer">
        <seg>state $bellamente = new Dumpvalue::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%x    an unsigned integer, in hexadecimal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%x    un entero sin signo, en hexadecimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace mostly serves to separate tokens, unlike
languages like Python where it is an important part of the syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco sirve para separar los elementos, a diferencia de lenguajes como Python donde es una parte importante de la sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of loading of
modules does not risk altering your namespace.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma de cargar módulos no tiene el riesgo de alterar el espacio de nombres propio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variable substitution inside strings is limited to
scalar variables, arrays, and array or hash slices.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sustitución de variables dentro de cadenas se limita a variables escalares, arrays y porciones de array y hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taints the variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Contamina la variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the numeric (the native 8-bit encoding, like ASCII or EBCDIC,
or Unicode) value of the first character of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor numérico (en la codificación nativa de 8 bits, como ASCII o EBCDIC, o Unicode) del primer carácter de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, C&lt;$year&gt; is C&lt;123&gt; in year 2023.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, $anno es C&lt;123&gt; para el año 2023.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the new C&lt;-a&gt;
option to run I&lt;all&gt; tests.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013651Z" changeid="explorer">
        <seg>Use la nueva opción C&lt;-a&gt; para correr I&lt;todas&gt; las pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5120delta	Perl changes in version 5.12.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5120delta	Cambios en la versión 5.12.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dump</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item dump</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@values = values %ENV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@values = values %ENV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 4) = 2   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 4) = 2   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, contrary to 5.10.0, evaluating the flip-flop operators in boolean
context ensures it can now be useful in a C&lt;when()&gt;, notably for
implementing bistable conditions, like in:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233424Z" changeid="explorer">
        <seg>Sin embargo, contrariamente a 5.10.0, la evaluación de los operadores flip-flop en contexto booleano asegura que ahora puede ser útil en un C&lt;when()&gt;, especialmente para implementar condiciones biestable, como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More details can be found in L&lt;PerlIO::encoding&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Más detalles se pueden encontrar en L&lt;PerlIO::encoding&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-52010-6 [5th edition June 2008]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003340Z" changeid="explorer">
        <seg>ISBN 978-0-596-52010-6 [5ª edición - Junio de 2008]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>200) { print; }	# print $_ 100 times</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035913Z" changeid="explorer">
        <seg>200) { print; }		# imprime $_ 100 veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item If C&lt;use bytes&gt; is in effect:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174258Z" changeid="explorer">
        <seg>=item Si C&lt;use bytes&gt; está activo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise documented, it returns C&lt;1&gt; for true and C&lt;''&gt; for false, or
the undefined value if the file doesn't exist.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004413Z" changeid="explorer">
        <seg>Mientras no se diga lo contrario, se devuelve C&lt;1&gt; para verdadero y C&lt;''&gt; para falso, o el valor indefinido si el archivo no existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$kid = waitpid(-1, WNOHANG);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$hijo = waitpid(-1, WNOHANG);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you see, this can be a bit tricky.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110905T003513Z" changeid="explorer">
        <seg>Como puede ver, puede ser un poco complicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is seldom what you want.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T012848Z" changeid="explorer">
        <seg>Es muy raro que quiera hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also discussion of list operators in L&lt;Terms and List Operators (Leftward)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220100Z" changeid="explorer">
        <seg>Vea también la discusión de los Operadores de lista en L&lt;Términos y Operadores de listas (por la izquierda)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over 10</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=over 10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str =~ /^\w/;       # No match, as $str isn't in UTF-8 format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001157Z" changeid="explorer">
        <seg>$str =~ /^\w/;       # No coincide, porque $str no está en formato UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Never release anything (even a one-word documentation patch) without
incrementing the number.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025954Z" changeid="explorer">
        <seg>Nunca lance nada (ni siquiera un parche de documentación de una sola palabra) sin incrementar el número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;$x&quot;;      # CASE 2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;$x&quot;;      # CASO 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Stability</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013713Z" changeid="explorer">
        <seg>=head2 Estabilidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll have to check their
respective release notes to see just what the differences are.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225414Z" changeid="explorer">
        <seg>Para averiguar cuáles son las diferencias, consulte las notas de la versión correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a four-element list giving the user and system times in
seconds for this process and any exited children of this process.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T023955Z" changeid="explorer">
        <seg>Devuelve una lista de cuatro elementos dando los tiempos de usuario y sistema en segundos, para este proceso y cualquier hijo de este proceso que haya terminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash subscripts are similar, only instead of square brackets curly brackets
are used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234515Z" changeid="explorer">
        <seg>Los índices en los Hash son similares, pero en lugar de usar corchetes se usan llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If locale matching rules are in effect, the case map is taken from the
current
locale for code points less than 255, and from Unicode rules for larger
code points.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T220410Z" changeid="explorer">
        <seg>Si están activas las reglas de coincidencia local, el mapeo de caja se toma de la configuración local actual para los puntos de código menores que 255, y de las reglas Unicode para los puntos de código superiores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options are as with m// with the addition of the following replacement
specific options:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las opciones son como las de m// con la adición de las opciones de reemplazo específicas siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
string cannot be cleanly converted to a numeric, Perl will give the warning
B&lt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena no se puede convertir de una forma limpia a numérico, Perl mostrará la advertencia B&lt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with Perl 5.9.2, integer and floating-point formats, along with
the C&lt;p&gt; and C&lt;P&gt; formats and C&lt;()&gt; groups, may all be followed by the 
C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt; endianness modifiers to respectively enforce big-
or little-endian byte-order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de Perl 5.9.2, los formatos enteros y de punto flotante, junto con los formatos C&lt;p&gt; y C&lt;P&gt; y los grupos C&lt;()&gt;, podrán ser seguidos por los modificadores de ordenación de bytes C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt;, para forzar, respectivamente, el orden de bytes big-endian o little-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use ExtUtils::Installed;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225446Z" changeid="explorer">
        <seg>use ExtUtils::Installed;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n = 0b1110011;	    # binary integer</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232302Z" changeid="explorer">
        <seg>$n = 0b1110011;         # entero binario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If I&lt;both&gt;
operands pass the test, then the expression is treated
as boolean; otherwise, smart matching is used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T214233Z" changeid="explorer">
        <seg>Si I&lt;ambos&gt; operandos pasan el test, entonces la expresión es tratada como un booleano; de otra forma, se usará coincidencia inteligente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;$@&gt; 
is a global variable and C&lt;eval&gt; may be used within object implementations,
be careful that analyzing the error object doesn't replace the reference in
the global variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que C&lt;$@&gt; es una variable global y C&lt;eval&gt; puede ser usado dentro de las implementaciones de objetos, tenga el cuidado que al analizar el objeto error no sustituya la referencia en la variable global.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or do this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o haga esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\A  Match only at beginning of string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225721Z" changeid="explorer">
        <seg>\A  Coincide solo con el comienzo de la cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE:&gt; C&lt;$REGERROR&gt; and C&lt;$REGMARK&gt; are not magic variables like C&lt;$1&gt;
and most other regex-related variables.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T010524Z" changeid="explorer">
        <seg>B&lt;NOTE:&gt; C&lt;$REGERROR&gt; y C&lt;$REGMARK&gt; no son variables mágicas como C&lt;$1&gt; y la mayoría de las otras variables relacionadas con las expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument will be dereferenced
automatically.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T160234Z" changeid="explorer">
        <seg>El argumento es desreferenciado automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;die&gt; raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170653Z" changeid="explorer">
        <seg>C&lt;die&gt; lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>status for next file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para el siguiente archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shmctl ID,CMD,ARG
X&lt;shmctl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200602Z" changeid="explorer">
        <seg>=item shmctl ID,CMD,ARG
X&lt;shmctl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>^        Match the beginning of the line</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042514Z" changeid="explorer">
        <seg>^	Coincide con el principio de la línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, C&lt;use integer; ~0&gt; is C&lt;-1&gt; on two's-complement
machines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, C&lt;use integer; ~0&gt; es C&lt;-1&gt; en las máquinas con complemento a dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is serious if stdin is
attached to a terminal, and perl is running as root.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110839Z" changeid="explorer">
        <seg>Esto es grave si stdin está conectado a un terminal, y perl es ejecutado como root.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The patterns used in Perl pattern matching evolved from those supplied in
the Version 8 regex routines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los patrones usados en el sistema de coincidencias de Perl evolucionaron desde los suministrados por las rutinas I&lt;regex&gt; versión 8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $vector = '';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225604Z" changeid="explorer">
        <seg>my $vector = '';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por desgracia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for my $elem (@elements) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for my $elemento (@elementos) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a digest string exactly like the crypt(3) function in the C
library (assuming that you actually have a version there that has not
been extirpated as a potential munition).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea una cadena resumen exactamente igual que la función crypt(3) de la biblioteca C (asumiendo que realmente tenga una versión de la que no haya sido extirpada por ser considerada un arma potencial).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, the two zero-width assertions next to each other work as though
they're ANDed together, just as you'd use any built-in assertions:  C&lt;/^$/&gt;
matches only if you're at the beginning of the line AND the end of the
line simultaneously.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T172022Z" changeid="explorer">
        <seg>En otras palabras, las dos aserciones de ancho cero, una junto a la otra, trabajan como si fueran unidas por un Y, tal y como lo haría usando cualquier aserción integrada: C&lt;/^$/&gt; coincide sólo si está al comienzo de la línea Y al final de la línea, al mismo tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\1&gt; through C&lt;\9&gt; are always interpreted as backreferences.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T190743Z" changeid="explorer">
        <seg>De C&lt;\1&gt; a C&lt;\9&gt;, son siempre interpretadas como contrareferencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T124528Z" changeid="explorer">
        <seg>Consideremos el siguiente patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl the groups are
numbered sequentially regardless of being named or not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002814Z" changeid="explorer">
        <seg>En Perl los grupos están numerados secuencialmente, independientemente de tener nombres o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example that makes sure that whoever runs this program knows
their password:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo que se asegura que quien corra el programa conoce su contraseña:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their usage in production code should
be noted to avoid problems during upgrades.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T002707Z" changeid="explorer">
        <seg>Su uso en el código de producción debe anotarse para evitar problemas durante las actualizaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although Perl 
automatically converts strings into numbers as needed, this automatic
conversion assumes base 10.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque Perl convierte automáticamente las cadenas en números según sea necesario, esta conversión automática asume que es en base 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S  An unsigned short value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S  Un valor de un corto sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current plan is for code freezes
as follows</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El plan actual es que el código quede congelado de la siguiente manera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($_ = $ARGV[0], /^-/) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($_ = $ARGV[0], /^-/) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thank you, Perl Monks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Gracias, Perl Monks.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;S&gt; can match, it is a better match than when only C&lt;T&gt; can match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235535Z" changeid="explorer">
        <seg>Cuando C&lt;S&gt; puede coincidir, es una mejor coincidencia que cuando sólo puede coincidir C&lt;T&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head4 Character set modifier behavior prior to Perl 5.14</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T000125Z" changeid="explorer">
        <seg>=head4 Comportamiento del modificador del conjunto de caracteres anterior a Perl 5.14</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;User::grent&gt; upgraded to version 1.01</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041123Z" changeid="explorer">
        <seg>C&lt;User::grent&gt; actualizado a la versión 1.01</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't be afraid to use loop labels--they're there to enhance
readability as well as to allow multilevel loop breaks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se asuste de usar etiquetas de bucles -están para aumentar la legibilidad así como permitir rupturas de bucles multiniveles-.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or warn $!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or warn $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider making your
code run cleanly with C&lt;use strict&gt; and C&lt;use warnings&gt; (or B&lt;-w&gt;) in
effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere hacer su código limpio utilizando C&lt;use strict&gt; y C&lt;use warnings&gt; (o B&lt;-w&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NaN != NaN
returns true, as does NaN != anything else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NaN != NaN devuelve verdadero, como con NaN != con cualquier otra cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some other more substantive style issues to think about:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay otras cuestiones de estilo que sí que hay que recordar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Access and Printing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193135Z" changeid="explorer">
        <seg>=head2 Acceso e impresión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $f implicitly closed here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># $f cerrado aquí implícitamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>now do localise variables, given that the $x is a valid variable name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170647Z" changeid="explorer">
        <seg>ahora localizan variables, teniendo en cuenta que $x es un nombre válido de variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a precompiled pattern is embedded in a larger pattern then the effect
of &quot;msixpluad&quot; will be propagated appropriately.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T024629Z" changeid="explorer">
        <seg>Si un patrón precompilado se incrusta en un patrón más grande entonces los efectos de 'msixpluad' serán propagados apropiadamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Special Literals
X&lt;special literal&gt; X&lt;__END__&gt; X&lt;__DATA__&gt; X&lt;END&gt; X&lt;DATA&gt;
X&lt;end&gt; X&lt;data&gt; X&lt;^D&gt; X&lt;^Z&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035526Z" changeid="explorer">
        <seg>=head3 Literales especiales
X&lt;special literal&gt; X&lt;__END__&gt; X&lt;__DATA__&gt; X&lt;END&gt; X&lt;DATA&gt;
X&lt;end&gt; X&lt;data&gt; X&lt;^D&gt; X&lt;^Z&gt; X&lt;literal especial&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $x, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225535Z" changeid="explorer">
        <seg>print $x, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $bits = unpack &quot;b*&quot;, $vec;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225602Z" changeid="explorer">
        <seg>my $bits = unpack &quot;b*&quot;, $vec;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 2) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 2) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the construct is a here-doc, the ending delimiter is a line
that has a terminating string as the content.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la construcción es un documento incrustado, el delimitador final es una línea que tiene como contenido una cadena de terminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The regression test ext/threads/shared/t/wait.t fails on early RedHat 9
and HP-UX 10.20 due to bugs in their threading implementations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El test de regresión ext/threads/shared/t/wait.t falla en los primeros RedHat 9 y HP-UX 10.20 debido a errores en las implementaciones de los hilos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item threads::shared</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item threads::shared</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NEXTKEY this, lastkey</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NEXTKEY este, últimaclave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	terms and list operators (leftward)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T190256Z" changeid="explorer">
        <seg>izquierda	términos y operadores de listas (por la izquierda)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The modifiers C&lt;/imsxadlup&gt;
may also be embedded within the regular expression itself using
the C&lt;(?...)&gt; construct, see L&lt;/Extended Patterns&gt; below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220345Z" changeid="explorer">
        <seg>Estos modificadores C&lt;/imsxadlup&gt; también pueden ser incorporados dentro de la propia expresión regular usando la construcción C&lt;(?...)&gt;; vea L&lt;/Patrones extendidos&gt; más abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bin = unpack(&quot;B*&quot;, pack(&quot;N&quot;, 3735928559));</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225516Z" changeid="explorer">
        <seg>$bin = unpack(&quot;B*&quot;, pack(&quot;N&quot;, 3735928559));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This matches the same substring as a standalone
C&lt;a+&gt;, and the following C&lt;\g{-1}&gt; eats the matched string; it therefore
makes a zero-length assertion into an analogue of C&lt;&lt; (?&gt;...) &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T214043Z" changeid="explorer">
        <seg>Esto busca la misma subcadena como en C&lt;a+&gt;, y el siguiente C&lt;\g{-1}&gt; se come la cadena coincidente; por lo tanto, hace una aserción de longitud cero, como un análogo de C&lt;&lt; (?&gt;...) &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's
how it works: the first time &lt;&gt; is evaluated, the @ARGV array is
checked, and if it is empty, C&lt;$ARGV[0]&gt; is set to &quot;-&quot;, which when opened
gives you standard input.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>He aquí cómo funciona: la primera vez que &lt;&gt; es evaluado, el array @ARGV es comprobado, y si está vacío, C&lt;$ARGV[0]&gt; es configurado a &quot;-&quot;, que cuando sea abierto le ofrecerá a usted la entrada estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>( (?i) blah ) \s+ \g1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T051617Z" changeid="explorer">
        <seg>( (?i) bla ) \s+ \g1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call your subroutines as if they were
functions or list operators to avoid excessive ampersands and parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llame a sus subrutinas como si fueran funciones u operadores de lista para evitar el excesivo número de ligaduras (&amp;&amp;) y paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8.2
contains an improved implementation which is both source and binary
compatible with both 5.8.0 and 5.8.1, and remains robust against the form of
attack which prompted the change for 5.8.1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5.8.2 contiene una implementación mejorada que es a la vez compatible a nivel de código fuente y binario con 5.8.0 y 5.8.1, y se mantiene robusto contra la forma de ataque que provocó el cambio de 5.8.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any backslashed sequences including C&lt;\\&gt; are treated at the stage
to L&lt;/&quot;parsing regular expressions&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier secuencia de barras invertidas, incluyendo C&lt;\\&gt; son tratadas en la fase L&lt;/&quot;analizando expresiones regulares&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;1: '&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;1: '&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item hex</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item hex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U  A Unicode character number.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>U  Un número de un carácter Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print;          # prints contents of $_ by default</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T213456Z" changeid="explorer">
        <seg>print;    # imprime el contenido de $_ de manera predeterminada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pops and returns the last value of the array, shortening the array by
one element.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Extrae y devuelve el último valor del array, acortando el array en un elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have
to make &quot;/hurd/pfinet&quot; the translator for &quot;/servers/socket/2&quot;, giving
it the right arguments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020049Z" changeid="explorer">
        <seg>Debe establecer &quot;/hurd/pfinet&quot; como traductor de &quot;/servers/socket/2&quot;, suministrándole los argumentos correctos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the only problem was that the program exited non-zero, C&lt;$!&gt;
will be set to C&lt;0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el único problema fue que el programa salió distinto de cero, C&lt;$!&gt; se establecerá a C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/x&gt; modifier enables
whitespace formatting, a simple C&lt;#&gt; will suffice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el modificador C&lt;/x&gt; permite formateo con espacio en blanco, un simple C&lt;#&gt; será suficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a character that isn't an octal digit is encountered, a warning is raised,
and the value is based on the octal digits before it, discarding it and all
following characters up to the closing brace.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T205754Z" changeid="explorer">
        <seg>Si se encuentra un carácter que no es un dígito octal, se produce una advertencia, y el valor se calcula en los dígitos octales anteriores a él, descartandolo a él y a todos los caracteres siguientes hasta la llave de cierre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDOUT &quot;stdout 1\n&quot;;  # this works for</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print STDOUT &quot;stdout 1\n&quot;;  # esto funciona</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will now fail with the error:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031139Z" changeid="explorer">
        <seg>ahora fallará con el error:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;use&gt; takes effect at compile time, it doesn't respect the
ordinary flow control of the code being compiled.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que C&lt;use&gt; entra en vigor en tiempo de compilación, no respeta el control de flujo de operaciones del código compilado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this doesn't
mean everything is an integer, merely that Perl will use integer
operations for arithmetic, comparison, and bitwise operators.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T214948Z" changeid="explorer">
        <seg>Tenga en cuenta que esto no significa que todo sea un número entero, sino simplemente que Perl utilizará operaciones de enteros para los operadores aritméticos, de comparación y de operaciones con bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line numbers (C&lt;$.&gt;)
continue as though the input were one big happy file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los números de línea (C&lt;$.&gt;) continuarán como si la entrada fuese un único archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$i = 0;  $j = 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$i = 0;  $j = 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;\x&gt; is followed
by fewer than two valid digits, any valid digits will be zero-padded.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110522T175805Z" changeid="explorer">
        <seg>Cuando C&lt;\x&gt; esté seguido por menos de dos dígitos válidos, los dígitos válidos serán rellenados con ceros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 How can I get a binary version of perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225434Z" changeid="explorer">
        <seg>=head2 ¿Cómo puedo obtener una versión binaria de perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are similar
C&lt;\p{...}&gt; constructs that can match white space and Posix classes
beyond ASCII.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T212347Z" changeid="explorer">
        <seg>Hay construcciones C&lt;\p{...}&gt; similares que pueden coincidir con espacio en blanco y clases Posix más allá del ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you had C&lt;en_US.UTF-8&gt; as your locale, your STDIN and
STDOUT were automatically &quot;UTF-8&quot;, in other words an implicit
binmode(..., &quot;:utf8&quot;) was made.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143820Z" changeid="explorer">
        <seg>Por ejemplo, si usted tenía C&lt;en_US.UTF-8&gt; como su configuración local, su STDIN y STDOUT fueron automáticamente &quot;UTF-8&quot;, en otras palabras, se hizo un binmode(..., &quot;: utf8&quot;) de forma implícita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nytprofhtml</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225449Z" changeid="explorer">
        <seg>nytprofhtml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the 5.6.1 kit was being assembled
the following &quot;failures&quot; were known to appear on some machines
during &quot;make test&quot; (mostly due to ASCII vs. EBCDIC conflicts),
your results may differ:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T111554Z" changeid="explorer">
        <seg>A medida que el kit 5.6.1 se estaba ensamblando, aparecieron los siguientes &quot;fallos&quot; en algunas máquinas durante el &quot;make test&quot; (en su mayoría debido a los conflictos ASCII vs EBCDIC), los resultados pueden ser diferentes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]\Q$1\E$([!$2]/gs;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225532Z" changeid="explorer">
        <seg>($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]\Q$1\E$([!$2]/gs;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the following will only
return an alpha:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que lo siguiente sólo devolverá un alfa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\N{U+263D}  Unicode character     (example: FIRST QUARTER MOON)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043712Z" changeid="explorer">
        <seg>\N{U+263D}	carácter Unicode	(ejemplo: FIRST QUARTER MOON)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, most networking protocols expect
and prefer a CR+LF (C&lt;&quot;\015\012&quot;&gt; or C&lt;&quot;\cM\cJ&quot;&gt;) for line terminators,
and although they often accept just C&lt;&quot;\012&quot;&gt;, they seldom tolerate just
C&lt;&quot;\015&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, la mayoría de protocolos de red esperan y prefieren un CR+LF (C&lt;&quot;\015\012&quot;&gt; o C&lt;&quot;\cM\cJ&quot;&gt;) como terminadores de línea, y aunque a menudo aceptan sólo C&lt;&quot;\012&quot;&gt;, rara vez tolerarán sólo un C&lt;&quot;\015&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
statements are simply written in the script in a straightforward
fashion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224723Z" changeid="explorer">
        <seg>Estas instrucciones se escriben directamente en el script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// $ENV{LOGDIR}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224304Z" changeid="explorer">
        <seg>// $ENV{LOGDIR}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Text after __DATA__ may be read via the filehandle C&lt;PACKNAME::DATA&gt;,
where C&lt;PACKNAME&gt; is the package that was current when the __DATA__
token was encountered.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003449Z" changeid="explorer">
        <seg>El texto después de __DATA__ se puede leer a través del identificador de archivo C&lt;PAQUETE::DATA&gt;, donde C&lt;PAQUETE&gt; es el paquete que estaba en curso cuando se encontró el símbolo __DATA__.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is caused by the fact that a block by itself acts as a loop that
executes once, see L&lt;&quot;Basic BLOCKs&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto funciona así por el hecho de que un bloque, por sí mismo, actúa como un bucle que se ejecuta una sola vez. Ver L&lt;&quot;BLOQUES básicos&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature caused too many problems,
so the feature was turned off and redesigned: see L&lt;/&quot;Core Enhancements&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T140835Z" changeid="explorer">
        <seg>Esta característica causaba muchos problemas, por lo que la función se ha desactivado y rediseñado: vea L&lt;/&quot;Mejoras del núcleo&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double values _and_ if Perl has been compiled to support those.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dobles __y__ si Perl ha sido compilado para soportarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlembed&gt;, L&lt;perlxstut&gt;, L&lt;perlxs&gt;, L&lt;perlcall&gt;,
L&lt;perlguts&gt;, and L&lt;xsubpp&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001152Z" changeid="explorer">
        <seg>Se describe en L&lt;perlembed&gt;, L&lt;perlxstut&gt;, L&lt;perlxs&gt;, L&lt;perlcall&gt;, L&lt;perlguts&gt; y L&lt;xsubpp&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always check the return codes of system calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre compruebe los valores devueltos por las llamadas al sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;alias&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;alias&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus this modifier changes behavior only when
the C&lt;&quot;/i&quot;&gt; modifier is also specified, and it turns out it affects only
two characters, giving them full Unicode semantics: the C&lt;MICRO SIGN&gt;
will match the Greek capital and small letters C&lt;MU&gt;, otherwise not; and
the C&lt;LATIN CAPITAL LETTER SHARP S&gt; will match any of C&lt;SS&gt;, C&lt;Ss&gt;,
C&lt;sS&gt;, and C&lt;ss&gt;, otherwise not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T173722Z" changeid="explorer">
        <seg>Así, este modificador sólo cambia el comportamiento cuando el modificador C&lt;&quot;/i&quot;&gt; también es especificado, y resulte que sólo afecte a dos caracteres, dándoles una semántica completa de Unicode: el C&lt;MICRO SIGN&gt; coincidirá con las letras griegas mayúscula y minúscula de C&lt;MU&gt;, de lo contrario, no; y la C&lt;LATIN CAPITAL LETTER SHARP S&gt; coincidirá con cualquiera de C&lt;SS&gt;, C&lt;Ss&gt;, C&lt;sS&gt;, y C&lt;ss&gt;; de lo contrario, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;defined $$x&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T034727Z" changeid="explorer">
        <seg>=head2 C&lt;defined $$x&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Useful modules to help you write tests (with minimum impact on your 
development process or your time) include Test::Simple, Carp::Assert 
and Test::Inline.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030637Z" changeid="explorer">
        <seg>Módulos útiles que le ayudarán a escribir las pruebas (con un impacto mínimo en el proceso de desarrollo o de su tiempo) son Test::Simple, Carp::Assert y Test::Inline.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $_ = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225543Z" changeid="explorer">
        <seg>local $_ = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an introduction to the language's features, see pod/perlintro.pod.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T221744Z" changeid="explorer">
        <seg>Para una introducción a las características del lenguaje, consulte pod/perlintro.pod.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason I said &quot;in this instance&quot; is because that I&lt;only&gt; works
because C&lt;$AoA[0]&gt; already held an array reference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031003Z" changeid="explorer">
        <seg>La razón por la que he dicho &quot;en este caso&quot; se debe a que funciona I&lt;solo&gt; porque C&lt;$AoA[0]&gt; ya contiene, realmente, una referencia a un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/uni/tie.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010054Z" changeid="explorer">
        <seg>=item t/uni/tie.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also do</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002725Z" changeid="explorer">
        <seg>También puede hacer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These examples of the triple-dot work:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225432Z" changeid="explorer">
        <seg>Estos ejemplos del triple punto funcionan:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>head `whence perldoc`</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T064958Z" changeid="explorer">
        <seg>head `whence perldoc`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Effective Perl Programming&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003411Z" changeid="explorer">
        <seg>=item I&lt;Effective Perl Programming&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All list elements are numeric and come straight out of the C `struct
tm'.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000100Z" changeid="explorer">
        <seg>Todos los elementos de la lista son numéricos y derivan de la 'struct tm' de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has been added to
solve semantic problems with the C&lt;isa()&gt; method.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T000858Z" changeid="explorer">
        <seg>Se ha añadido para resolver los problemas de semántica con el método C&lt;isa()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;Standard Version&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Versión Estándar&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map { get_a_key_for($_) =&gt; $_ } @array;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map { una_clave_para($_) =&gt; $_ } @array;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string = &quot;Just another Perl Hacker&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225534Z" changeid="explorer">
        <seg>$string = &quot;Just another Perl Hacker&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/upgrade.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010045Z" changeid="explorer">
        <seg>=item t/op/upgrade.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>flock($fh, LOCK_EX) or die &quot;Cannot lock mailbox - $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>flock($fh, LOCK_EX) or die &quot;No puedo bloquear el buzón - $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is whoever is named in the copyright or
copyrights for the package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es el que se nombra en el derecho de autor o derechos de autor para el paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX qw( setlocale localeconv )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use POSIX qw( setlocale localeconv )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4_294_967_296       # underscore for legibility</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>4_294_967_296       # guión bajo para legibilidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perl590delta&gt;, L&lt;perl591delta&gt; and
L&lt;perl592delta&gt; for the differences between 5.8.0 and 5.9.2.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215156Z" changeid="explorer">
        <seg>Vea L&lt;perl590delta&gt;, L&lt;perl591delta&gt; y L&lt;perl592delta&gt; para las diferencias entre 5.8.0 y 5.9.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;&lt;&quot;foo&quot;, &lt;&lt;&quot;bar&quot;; # you can stack them</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;&lt;&quot;foo&quot;, &lt;&lt;&quot;bar&quot;; # puede apilarles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prior to that
there were no named nor relative numbered capture groups.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T185155Z" changeid="explorer">
        <seg>Antes de esto, no existían los grupos de captura numerados de forma relativa, o mediante un nombre de grupo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces the output 'h:i:t:h:e:r:e'.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce la salida 'h:o:l:a:p:o:r:a:q:u:i'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Math::BigInt::FastCalc&gt; is an XS-enabled, and thus faster, version of
C&lt;Math::BigInt::Calc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200953Z" changeid="explorer">
        <seg>C&lt;Math::BigInt::FastCalc&gt; es una versión XS, y por lo tanto más rápida, de C&lt;Math::BigInt::Calc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Strictness and warnings</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022915Z" changeid="explorer">
        <seg>=head2 Rigor y advertencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sun Microsystems has released a port of their Sun Studio compilers for
Linux.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150915Z" changeid="explorer">
        <seg>Sun Microsystems ha lanzado una versión de sus compiladores Sun Studio para Linux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;aa0&quot; =~ /${a}0/;    # False!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191722Z" changeid="explorer">
        <seg>&quot;aa0&quot; =~ /${a}0/;    # ¡Falso!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the integer portion of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la parte entera de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chr NUMBER
X&lt;chr&gt; X&lt;character&gt; X&lt;ASCII&gt; X&lt;Unicode&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170235Z" changeid="explorer">
        <seg>=item chr NÚMERO
X&lt;chr&gt; X&lt;character&gt; X&lt;ASCII&gt; X&lt;Unicode&gt; X&lt;carácter&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space before the opening curly of a multi-line BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio antes de llave de apertura de un BLOQUE multilínea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perltodo&gt; now lists a rough roadmap to Perl 5.10.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013752Z" changeid="explorer">
        <seg>L&lt;perltodo&gt; ahora lista una hoja de ruta aproximada de Perl 5.10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?(DEFINE)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T203502Z" changeid="explorer">
        <seg>(?(DEFINE)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
GSM 03.38 conversion did not handle escape sequences correctly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T173115Z" changeid="explorer">
        <seg>La conversión GSM 03.38 no maneja correctamente las secuencias de escape.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Inappropriate documentation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031548Z" changeid="explorer">
        <seg>=head2 Documentación inapropiada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open   (FH, $path)          or  return undef;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open   (FH, $ruta)          or  return undef;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But if you're not, you should as always feel perfectly
free to write for your own system's idiosyncrasies (sometimes called
&quot;features&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Pero si no, puede siempre sentirse libre de escribir sus propias idiosincrasias del sistema (algunas veces llamadas &quot;features&quot; -características-).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is a contextually
polymorphic language whose scalars can be strings, numbers, or
references (which includes objects).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl es un lenguaje contextualmente polimórfico según el contexto, cuyos escalares pueden ser cadenas, números o referencias (las cuales incluyen a los objetos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forcing a numeric value to a particular format does not
change the number stored in the value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232920Z" changeid="explorer">
        <seg>Forzar la conversión de un valor numérico a un formato específico no cambia el número almacenado en el valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See F&lt;Cross/README&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014930Z" changeid="explorer">
        <seg>Puede ver más detalles en F&lt;Cross/README&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also using C&lt;&lt; +&lt; &gt;&gt;
works for symmetry, but you really should consider writing something
to the temporary file first.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003645Z" changeid="explorer">
        <seg>También, usando C&lt;&lt; +&lt; &gt;&gt; trabaja de forma simétrica, pero debe considerar, escribir antes algo en el archivo temporal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then do the compilation with</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entonces, realice la compilación con</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write documentation in POD</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013819Z" changeid="explorer">
        <seg>Escriba documentación en POD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are really two tracks of perl development: a maintenance version
and an experimental version.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T225547Z" changeid="explorer">
        <seg>Hay dos líneas de desarrollo de perl: una versión de mantenimiento y una versión experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: An improved implementation of C&lt;threads::shared&gt; is available on
CPAN - this will be merged into 5.8.9 if it proves stable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040710Z" changeid="explorer">
        <seg>Nota: Una mejor implementación de C&lt;threads::shared&gt; está disponible en CPAN - esto será fusionado en 5.8.9 si se prueba que es estable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new internal variable, C&lt;${^CHILD_ERROR_NATIVE}&gt;, gives the native
status returned by the last pipe close, backtick command, successful call
to wait() or waitpid(), or from the system() operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T195727Z" changeid="explorer">
        <seg>Una nueva variable interna, C&lt;${^CHILD_ERROR_NATIVE}&gt;, indica el estado nativo devuelto por la última tubería cerrada, comando con acento grave, llamada exitosa a wait() o waitpid(), o desde el operador system().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;for (reverse @foo)&gt; now iterates in reverse, avoiding the generation of a
temporary reversed list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T210708Z" changeid="explorer">
        <seg>C&lt;for (reverse @foo)&gt; ahora se repite a la inversa, evitando la generación de una lista invertida temporal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare with L&lt;/require&gt;, which can do a similar check at run time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compare con L&lt;/require&gt;, que puede hacer un control similar en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This bug fix may cause some programs to start correctly issuing warnings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T043946Z" changeid="explorer">
        <seg>Esta corrección de error puede causar que algunos programas inicien, de forma correcta, la emisión de advertencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;croak()&gt; only when your module absolutely cannot figure out what to
do.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023412Z" changeid="explorer">
        <seg>C&lt;croak()&gt; solo cuando el módulo no puede averiguar, de forma absoluta, qué debe de hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$+{foo} will be the same as $2, and $3 will contain 'z' instead of
the opposite which is what a .NET regex hacker might expect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T213953Z" changeid="explorer">
        <seg>$+{foo} será lo mismo que $2, y $3 contendrá 'z' en lugar de lo opuesto que un hacker en regex .NET podría esperar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the two digests
match, the password is correct.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T154030Z" changeid="explorer">
        <seg>Si los dos I&lt;digest&gt; coinciden, la contraseña es correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
first character after the &quot;[&quot; is &quot;^&quot;, the class matches any character not
in the list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212549Z" changeid="explorer">
        <seg>Si el primer carácter después del &quot;[&quot; es &quot;^&quot;, la clase coincide con cualquier carácter que no esté en la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To set your private value, call C&lt;Perl_mro_set_private_data()&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115242Z" changeid="explorer">
        <seg>Para establecer el valor privado, llame a C&lt;Perl_mro_set_private_data()&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$biz = &quot;$foo&quot; ^ &quot;$bar&quot;;	# both ops explicitly stringy</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$biz = &quot;$foo&quot; ^ &quot;$bar&quot;;	# ambas op. explícitamente como literales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I didn't dare yet
to try enabling it and see what problems occur.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No me atrevía aún a activarlo y ver qué problemas pueden ocurrir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/Extended Patterns&gt; below for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220502Z" changeid="explorer">
        <seg>Vea más abajo L&lt;/Patrones extendidos&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># poor man's grep</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un grep para pobres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;binmode&gt;, C&lt;close&gt;, C&lt;closedir&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;die&gt;, C&lt;eof&gt;,
C&lt;fileno&gt;, C&lt;flock&gt;, C&lt;format&gt;, C&lt;getc&gt;, C&lt;print&gt;, C&lt;printf&gt;, C&lt;read&gt;,
C&lt;readdir&gt;, C&lt;rewinddir&gt;, C&lt;say&gt;, C&lt;seek&gt;, C&lt;seekdir&gt;, C&lt;select&gt;, C&lt;syscall&gt;,
C&lt;sysread&gt;, C&lt;sysseek&gt;, C&lt;syswrite&gt;, C&lt;tell&gt;, C&lt;telldir&gt;, C&lt;truncate&gt;,
C&lt;warn&gt;, C&lt;write&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;binmode&gt;, C&lt;close&gt;, C&lt;closedir&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;die&gt;, C&lt;eof&gt;, C&lt;fileno&gt;, C&lt;flock&gt;, C&lt;format&gt;, C&lt;getc&gt;, C&lt;print&gt;, C&lt;printf&gt;, C&lt;read&gt;, C&lt;readdir&gt;, C&lt;rewinddir&gt;, C&lt;seek&gt;, C&lt;seekdir&gt;, C&lt;select&gt;, C&lt;syscall&gt;, C&lt;sysread&gt;, C&lt;sysseek&gt;, C&lt;syswrite&gt;, C&lt;tell&gt;, C&lt;telldir&gt;, C&lt;truncate&gt;, C&lt;warn&gt;, C&lt;write&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The Filter</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190443Z" changeid="zipf">
        <seg>=head2 El filtro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to Hannu Napari &lt;Hannu.Napari@hut.fi&gt; for the IRIX</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004537Z" changeid="explorer">
        <seg>Gracias a Hannu Napari &lt;Hannu.Napari@hut.fi&gt; por la información</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VISTA</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T032832Z" changeid="explorer">
        <seg>VISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;piconv&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234705Z" changeid="explorer">
        <seg>=item L&lt;piconv&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es equivalente a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$width = 2**$w;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ancho = 2**$w;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=cut back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=cut regreso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Carp</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014814Z" changeid="explorer">
        <seg>=item Carp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$floor  = floor(3.5);  # 3</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225511Z" changeid="explorer">
        <seg>$floor  = floor(3.5);  # 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The equivalent numeric
version should be used instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se debe usar en su lugar la versión equivalente numérica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.8.7 release and
the 5.8.8 release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T023756Z" changeid="explorer">
        <seg>Este documento describe las diferencias entre la versión 5.8.7 y la versión 5.8.8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>arrayref  ${$$foo[1]}[2] aka $foo-&gt;[1]-&gt;[2]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224144Z" changeid="explorer">
        <seg>anónimo    ${$$foo[1]}[2] equivale a $foo-&gt;[1]-&gt;[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, without
internal optimizations done by the regular expression engine, this will
take a painfully long time to run:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T172338Z" changeid="explorer">
        <seg>Por ejemplo, sin optimizaciones internas realizadas por el motor de expresiones regulares, esto tomará un tiempo dolorosamente largo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a list, the &quot;-&quot; character specifies a
range, so that C&lt;a-z&gt; represents all characters between &quot;a&quot; and &quot;z&quot;,
inclusive.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212652Z" changeid="explorer">
        <seg>Dentro de una lista, el carácter &quot;-&quot; indica un intervalo, de modo que C&lt;a-z&gt; representa todos los caracteres entre &quot;a&quot; y &quot;z&quot;, ambos inclusive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.apress.com/book/view/1430227931</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003335Z" changeid="explorer">
        <seg>http://www.apress.com/book/view/1430227931</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FILEHANDLE, &quot;&lt;&amp;=&quot;, $fd)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FILEHANDLE, &quot;&lt;&amp;=&quot;, $fd)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recursing deeper than 50 times without consuming any input string will
result in a fatal error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T183257Z" changeid="explorer">
        <seg>Realizar un proceso recursivo más de 50 veces sin consumir ninguna cadena de entrada resultará en un error fatal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another common way to create a similar cycle
is with the looping modifier C&lt;//g&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230656Z" changeid="explorer">
        <seg>Otra forma común de crear un ciclo similar es con el modificador de bucle C&lt;//g&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following shows how using negative indexing can make it
easier to embed recursive patterns inside of a C&lt;qr//&gt; construct
for later use:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T190134Z" changeid="explorer">
        <seg>A continuación se muestra cómo el uso de indexación negativa puede hacer que sea más fácil de integrar dentro de los patrones recurrentes de una construcción C&lt;qr//&gt; para su uso posterior:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $file (sort keys(%seen)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $archivo (sort keys(%visto)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;a*b is &quot;, $a*$b;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033347Z" changeid="explorer">
        <seg>say &quot;a*b es &quot;, $a*$b;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Formerly, the indices passed to C&lt;FETCH&gt;, C&lt;STORE&gt;, C&lt;EXISTS&gt;, and
C&lt;DELETE&gt; methods in tied array class were always non-negative.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170255Z" changeid="explorer">
        <seg>Anteriormente, los índices que se pasaban a los métodos C&lt;FETCH&gt;, C&lt;STORE&gt;, C&lt;EXISTS&gt;, y C&lt;DELETE&gt; de la clase array enlazada eran siempre no negativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@fields = split(/\b(?:a|b|c)\b/)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232041Z" changeid="explorer">
        <seg>@campos = split(/\b(?:a|b|c)\b/)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print OUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print OUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the platform-specific
release notes for more details about your particular environment.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220206Z" changeid="explorer">
        <seg>Vea las notas específicas de la plataforma para obtener más detalles acerca de su entorno particular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
package in which the variable is entered is determined at the point
of the declaration, not at the point of use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El paquete en el que se introduce la variable se determina en el punto de la declaración, no en el momento de ser usada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if
you were to declare the subroutine as C&lt;sub myname ($)&gt;, then
C&lt;myname&gt; would function as a unary operator, so either C&lt;or&gt; or
C&lt;||&gt; would work.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si declara la subrutina como C&lt;sub minombre ($)&gt;, entonces C&lt;minombre&gt; funcionará como un operador unario, así que servirán tanto C&lt;or&gt; como C&lt;||&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
there is a C&lt;continue&gt; BLOCK attached to a BLOCK (typically in a C&lt;while&gt; or
C&lt;foreach&gt;), it is always executed just before the conditional is about to
be evaluated again, just like the third part of a C&lt;for&gt; loop in C.  Thus
it can be used to increment a loop variable, even when the loop has been
continued via the C&lt;next&gt; statement (which is similar to the C C&lt;continue&gt;
statement).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103505Z" changeid="explorer">
        <seg>Si existe un BLOQUE C&lt;continue&gt; adjunto a un BLOQUE (típicamente en un C&lt;while&gt; o C&lt;foreach&gt;), siempre es ejecutado justo antes de que la condicional sea de nuevo evaluada, igual que la tercera parte de un bucle C&lt;for&gt; en C. Esto puede ser utilizado para incrementar una variable de bucle, incluso cuando el bucle ha sido interrumpido por la instrucción C&lt;next&gt; (que es similar a la instrucción C&lt;continue&gt; del C).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All this is experimental.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo esto es experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tries to minimally patch
the uconfig.sh using your *current* Perl so that your microperl has
the correct basic types and sizes and byteorder.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto intenta parchear mínimamente el uconfig.sh utilizando su *actual* Perl para que su microperl tenga los tipos y tamaños básicos y orden de los bytes correcto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>longlongsize='8';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>longlongsize='8';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cd ~/config/lib; ln -s perl5/5.8.6/BePC-beos/CORE/libperl.so .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>cd ~/config/lib; ln -s perl5/5.8.6/BePC-beos/CORE/libperl.so .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings that match
parenthesized parts of a regular expression are saved under names
containing only digits after the C&lt;$&gt; (see L&lt;perlop&gt; and L&lt;perlre&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215239Z" changeid="explorer">
        <seg>Las cadenas que coinciden con las partes encerradas entre paréntesis de una expresión regular se guardan con nombres que contienen sólo dígitos después del C&lt;$&gt; (vea L&lt;perlre&gt; y L&lt;perlop&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regexp-like quote.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entrecomillado de expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;File is %s, size is %s, perm %04o, mtime %s\n&quot;,
           $filename, $sb-&gt;size, $sb-&gt;mode &amp; 07777,
           scalar localtime $sb-&gt;mtime;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051902Z" changeid="explorer">
        <seg>printf &quot;Archivo es %s, tamaño es %s, perm %04o, mtime %s\n&quot;,
           $archivo, $sb-&gt;size, $sb-&gt;mode &amp; 07777,
           scalar localtime $sb-&gt;mtime;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;my&gt; X&lt;local&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;my&gt; X&lt;local&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For numeric conversions, you can specify the size to interpret the
number as using C&lt;l&gt;, C&lt;h&gt;, C&lt;V&gt;, C&lt;q&gt;, C&lt;L&gt;, or C&lt;ll&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para conversiones numéricas, se puede especificar el tamaño del número a interpretar usando C&lt;l&gt;, C&lt;h&gt;, C&lt;V&gt;, C&lt;q&gt;, C&lt;L&gt;, o C&lt;ll&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ponie stands for &quot;Perl On the New Internal Engine&quot;, started by Arthur
Bergman from Fotango in 2003, and subsequently run as a project of The
Perl Foundation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T225930Z" changeid="explorer">
        <seg>Ponie significa &quot;Perl On the New Internal Engine&quot; (Perl en el nuevo motor interno). Este proyecto lo inició Arthur Bergman (de Fotango) en 2003, y posteriormente lo adoptó The Perl Foundation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot
use this for look-behind.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T210523Z" changeid="explorer">
        <seg>No puede usar esto para las búsquedas antecedentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replace C&lt;/path/to/flock/server/headers&gt; with the path to the directory
containing the C&lt;flock.h&gt; header.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Reemplace C&lt;/ruta/a/cabeceras/servidor/flock&gt; con la ruta al directorio que contiene la cabecera C&lt;flock.h&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the access and modification times on each file of a list of
files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia los tiempos de acceso y modificación de cada archivo de una lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last if /fred/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last if /pedro/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Saying
C&lt;-exp($foo)&gt; still works as expected, however: only single letters
following a minus are interpreted as file tests.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Decir C&lt;-exp($foo)&gt; sigue funcionando como se espera que lo haga: sólo letras sueltas, por detrás de un menos, son interpretadas como test de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use v5.14;     # using the + prototype, new to v5.14</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032157Z" changeid="explorer">
        <seg>use v5.14;     # usando el prototipo +, nuevo en v5.14</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Configure Perl on VM/ESA</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101638Z" changeid="explorer">
        <seg>=head2 Configurar Perl en VM/ESA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $patterns = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $patrones   = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub foo { ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub foo { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;foreach&gt; on threads::shared array used to be able to crash Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T210923Z" changeid="explorer">
        <seg>C&lt;foreach&gt; sobre un array threads::shared era capaz de colgar Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The C&lt;feature&gt; pragma</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192628Z" changeid="explorer">
        <seg>=head2 El pragma C&lt;feature&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a^b == (a+1)^(b+1)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a^b == (a+1)^(b+1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;IPC::Open2&gt; upgraded to version 1.02</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032835Z" changeid="explorer">
        <seg>C&lt;IPC::Open2&gt; actualizado a la versión 1.02</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the cost of some space and
considerable speed, they avoid the normal pitfalls associated with
limited-precision representations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A costa de algún espacio y velocidad, evitan los peligros asociados a la limitada precisión de las representaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>p  A pointer to a null-terminated string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>p  Un puntero a una cadena terminada en nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to grab non-empty comments into $1, one should use either
one of these:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T221850Z" changeid="explorer">
        <seg>Por ejemplo, para capturar la parte no vacía de los comentarios, en $1, debería usar uno de estos patrones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shift</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item shift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's an alternative to C&lt;make test&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234642Z" changeid="explorer">
        <seg>Es una alternativa a C&lt;make test&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(foo|bar|baz)       matches any of the alternatives specified</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121727Z" changeid="zipf">
        <seg>(foo|bar|baz)       cualquiera de las alternativas especificadas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may embed this Package's interpreter within
an executable of yours (by linking); this shall be construed as a mere
form of aggregation, provided that the complete Standard Version of the
interpreter is so embedded.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede integrar el intérprete de este Paquete dentro de un ejecutable suyo (mediante montaje o linkado); esto se entenderá como una mera forma de agregación, siempre que la Versión Estándar completa del intérprete esté empotrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the EBCDIC platforms that Perl handles, the native character set is
equivalent to Latin-1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T173317Z" changeid="explorer">
        <seg>En las plataformas EBCDIC que maneja Perl, el conjunto de caracteres nativo, es equivalente a Latin-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On many Unix systems, fdopen() is known to fail when file descriptors
exceed a certain value, typically 255.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En muchos sistemas Unix, fdopen() se conoce que falla cuando los descriptores de archivo exceden un valor determinado, por lo general 255.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, in the source to be cross compiled:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Luego, en el código fuente para ser compilado de forma cruzada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The perl5 development team are implementing changes to help address this
problem, which should go live in early 2004.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El equipo de desarrollo de perl5 está implementando cambios para ayudar a resolver este problema, que debería aparecer a principios de 2004.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item flip-flop operators</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233106Z" changeid="explorer">
        <seg>=item Operadores flip-flop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 local ${$x}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015151Z" changeid="explorer">
        <seg>=head2 local ${$x}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(chromatic)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005340Z" changeid="explorer">
        <seg>(chromatic)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pack(&quot;a/W2&quot;, ord(&quot;a&quot;) ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pack(&quot;a/W2&quot;, ord(&quot;a&quot;) ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IRWXG S_IRGRP S_IWGRP S_IXGRP</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_IRWXG S_IRGRP S_IWGRP S_IXGRP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in the latter case, it is usually highly counter-productive
to declare $a and $b as lexicals.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014334Z" changeid="explorer">
        <seg>Tenga en cuenta que en el último caso, suele ser altamente contraproducente declarar $a y $b como léxicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to read LENGTH bytes of data into variable SCALAR from the
specified FILEHANDLE, using the read(2).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012855Z" changeid="explorer">
        <seg>Intenta leer LONGITUD bytes de datos en la variable ESCALAR desde el IDENTIFICADOR_ARCHIVO especificado, utilizando read(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $Config{longlongsize}, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $Config{longlongsize}, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the book, Randal
Schwartz capitalised the language's name to make it stand out better
when typeset.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231510Z" changeid="explorer">
        <seg>En el libro, Randal Schwartz escribió el nombre del lenguaje con inicial mayúscula para que destacara mejor en la composición tipográfica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unshift ARRAY,LIST
X&lt;unshift&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210346Z" changeid="explorer">
        <seg>=item unshift ARRAY,LISTA
X&lt;unshift&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We try not to do this more than we have to.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Tratamos de no hacer esto no más de lo necesario).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the list of operators in
the next section for information on comparison and boolean logic operators,
which are commonly used in conditional statements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225116Z" changeid="explorer">
        <seg>Consulte la lista de operadores de la siguiente sección para obtener información sobre los operadores lógicos booleanos y de comparación que se suelen usar en instrucciones condicionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$_\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$_\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces the list value</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce la lista de valores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New &quot;Pseudo-hashes are deprecated&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011902Z" changeid="explorer">
        <seg>=head2 Nuevo &quot;Pseudo-hashes are deprecated&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>format STDOUT =</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>format STDOUT =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Breaks the binding between a variable and a package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Rompe el enlace entre una variable y un paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or spaced out a bit:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032628Z" changeid="explorer">
        <seg>o un poco más espaciado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $/;  # slurp!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local $/;  # ¡sorber!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;&quot;	qq{}	      Literal		  yes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;&quot;	qq{}	      Literal		  sí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encodes to a character in character mode</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Codifica a un carácter en modo de caracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item delete EXPR
X&lt;delete&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170450Z" changeid="explorer">
        <seg>=item delete EXPR
X&lt;delete&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the differences being that it generates a real list at compile time, and
in scalar context it returns the last element in the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>siendo diferente en que genera una lista real en tiempo de compilación, y en contexto escalar devuelve el último elemento de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;if&gt; executes the statement once I&lt;if&gt; and only if the condition is
true.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013027Z" changeid="explorer">
        <seg>C&lt;if&gt; ejecuta la instrucción una vez I&lt;si&gt; y sólo si la condición es verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$b&gt; will now work as expected when either $a or $b is C&lt;undef&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$b&gt; ahora funcionará como se espera cuando $a o $b sean C&lt;undef&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 A proper interface for pluggable Method Resolution Orders</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T193315Z" changeid="explorer">
        <seg>=head2 Una interfaz adecuada para un Método de Resolución de Órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5121delta	Perl changes in version 5.12.1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000707Z" changeid="explorer">
        <seg>perl5121delta	Cambios en la versión 5.12.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which enables a switch feature that is closely based on the
Perl 6 proposal.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>que activa la característica conmutador, que se basa estrechamente en la propuesta en Perl 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As it happens, using C&lt;@array&gt; where Perl
expects to find a scalar value (&quot;in scalar context&quot;) will give you the number
of elements in the array:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224859Z" changeid="explorer">
        <seg>Si utiliza C&lt;@array&gt; donde Perl espera encontrar un valor escalar (&quot;en contexto escalar&quot;), obtendrá el número de elementos del array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your routine changes its behaviour significantly based on its
arguments, it's a sign that you should have two (or more) separate
routines.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020652Z" changeid="explorer">
        <seg>Si su rutina cambia su comportamiento de manera significativa sobre la base de sus argumentos, es una señal de que debe tener dos (o más) rutinas separadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, it does not check the full recursion stack.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195441Z" changeid="explorer">
        <seg>En otras palabras, no comprueba la pila completa de la recursión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	&amp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Leading whitespace is not stripped,
unlike oct().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacios en blanco aledaños, no son eliminados, a diferencia de oct().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact behaviour may change in a future version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T160305Z" changeid="explorer">
        <seg>El comportamiento exacto puede cambiar en una futura versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://lists.perl.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225440Z" changeid="explorer">
        <seg>http://lists.perl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces the output 'h:i: :t:h:e:r:e'.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce la salida 'h:o:l:a: :p:o:r: :a:q:u:i'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef @ARRAY;   # forget @ARRAY ever existed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef @ARRAY;   # hacer que @ARRAY nunca existió</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,14, 2) = 2   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,14, 2) = 2   ==  536870912 00000000000000000000000000000100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmodstyle	Perl modules: how to write modules with style</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000435Z" changeid="explorer">
        <seg>perlmodstyle	Cómo programar módulos Perl con estilo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(There is a Perl script called B&lt;h2ph&gt; that comes with the Perl kit that
may help you in this, but it's nontrivial.)  SCALAR will be read and/or
written depending on the FUNCTION; a C pointer to the string value of SCALAR
will be passed as the third argument of the actual C&lt;ioctl&gt; call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Existe un script Perl llamado B&lt;h2ph&gt; que viene con el kit Perl que puede ayudarle en esto, pero no es nada trivial). ESCALAR será leído o escrito dependiendo de la FUNCIÓN; un puntero C al valor de la cadena ESCALAR será pasado como tercer argumento de la actual llamada C&lt;ioctl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We've already seen how to print to standard output using C&lt;print()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225351Z" changeid="explorer">
        <seg>Ya hemos visto la manera de imprimir en la salida estándar mediante C&lt;print()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special case the three-argument form with a read/write mode and the third
argument being C&lt;undef&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003513Z" changeid="explorer">
        <seg>Como un caso especial, la forma de tres argumentos con un modo de lectura/escritura y el tercer argumento siendo C&lt;undef&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># am the parent:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005904Z" changeid="explorer">
        <seg># soy el padre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutine references are the simplest case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Referencias a subrutinas son el caso más simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must yourself do any alignment or padding by inserting, for example,
enough C&lt;&quot;x&quot;&gt;es while packing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe hacer cualquier alineamiento o rellenado, insertando, por ejemplo, suficientes C&lt;&quot;x&quot;&gt;, mientras desempaqueta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &quot;Freely Available&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item &quot;Libre Disponibilidad&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will call this syntactic construct a BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llamaremos a esta construcción sintáctica un BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may still see C&lt;require 'syscall.ph'&gt; or similar
around - the F&lt;.ph&gt; file should be created by running F&lt;h2ph&gt; on the
corresponding F&lt;.h&gt; file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234505Z" changeid="explorer">
        <seg>Es posible que se encuentre código en el que se usa C&lt;require 'syscall.ph'&gt; o algo similar; para crear el archivo F&lt;.ph&gt; se debe ejecutar F&lt;h2ph&gt; en el archivo F&lt;.h&gt; correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because print takes a LIST, anything in the LIST is evaluated in
list context, including any subroutines whose return lists you pass to
C&lt;print&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T005937Z" changeid="explorer">
        <seg>Debido a que print toma una LISTA, cualquier cosa en la LISTA es evaluada en contexto de lista, incluyendo cualquier subrutina que devuelva listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Assertions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Aserciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\g{name}  [5]  Named backreference</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224609Z" changeid="explorer">
        <seg>\g{name}  [5]  Contrareferencia nominal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ioctl FILEHANDLE,FUNCTION,SCALAR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014820Z" changeid="explorer">
        <seg>=item ioctl IDENTIFICADOR_ARCHIVO,FUNCIÓN,ESCALAR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A (file)glob evaluates its (embedded) argument only when it is
starting a new list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una expansión evalúa sus argumentos (incorporados) sólo cuando está iniciando una nueva lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the absence of parentheses, the precedence of list operators such as
C&lt;print&gt;, C&lt;sort&gt;, or C&lt;chmod&gt; is either very high or very low depending on
whether you are looking at the left side or the right side of the operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En ausencia de paréntesis, la precedencia de los operadores de lista como C&lt;print&gt;, C&lt;sort&gt;, o C&lt;chmod&gt; es, o muy alta o muy baja, dependiendo de si usted está mirando al lado izquierdo o al lado derecho del operador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lstat EXPR
X&lt;lstat&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191329Z" changeid="explorer">
        <seg>=item lstat EXPR
X&lt;lstat&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>details).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>detalles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current package has a subroutine named C&lt;ToLower&gt;, it will be used to
change the case
(See L&lt;perlunicode/&quot;User-Defined Case Mappings (for serious hackers only)&quot;&gt;.)
Otherwise Unicode semantics are used for the case change.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165602Z" changeid="explorer">
        <seg>Si el paquete actual tiene un subrutina denominada C&lt;ToLower&gt;, será utilizada para cambiar el tamaño de caja (ver L&lt;perlunicode/Mapeos de caja definidos por el usuario (solo para hackers serios)&gt;). De lo contrario se utiliza la semántica Unicode para el cambio de tamaño de caja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators return the
length of the list that would have been returned in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven la longitud de la lista que se hubiera devuelto en contexto lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;until&gt; does the opposite, it repeats the statement I&lt;until&gt; the
condition is true (or while the condition is false):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013136Z" changeid="explorer">
        <seg>C&lt;until&gt; hace lo opuesto, repite la instrucción I&lt;hasta&gt; que la condición sea verdadera (o mientras la condición sea falsa):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also differs in that code evaluated with C&lt;do FILENAME&gt;
cannot see lexicals in the enclosing scope; C&lt;eval STRING&gt; does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También difiere en que el código evaluado con C&lt;do NOMBREARCHIVO&gt; no puede ver a las variables léxicas en el ámbito en que se ejecuta; C&lt;eval STRING&gt; sí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpreter initialization is more complete when -DMULTIPLICITY is off.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El Intérprete de inicialización es más completo cuando -DMULTIPLICITY está desactivado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;perlcc -B&gt; works now at least somewhat better, while C&lt;perlcc -c&gt;
is rather more broken.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180548Z" changeid="explorer">
        <seg>C&lt;perlcc -B&gt; trabaja ahora por lo menos un poco mejor, mientras que C&lt;perlcc -c&gt; está algo más roto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make -f Makefile.micro regen_uconfig64</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223508Z" changeid="explorer">
        <seg>make -f Makefile.micro regen_uconfig64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The best way
to build a Perl for PASE is to use an AIX host as a cross-compilation
environment.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T190813Z" changeid="explorer">
        <seg>La mejor manera de construir un Perl para PASE es utilizar un host AIX como entorno de compilación cruzado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$uid   = getpwnam($name);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$uid     = getpwnam($nombre);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item import LIST
X&lt;import&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173915Z" changeid="explorer">
        <seg>=item import LISTA
X&lt;import&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several memory leaks in ithreads were closed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045048Z" changeid="explorer">
        <seg>Varias fugas de memoria en ithreads fueron cerradas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chop( LIST )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chop( LISTA )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, C&lt;$myarray[-1]&gt; would have been 
5000, and C&lt;$myarray[-2]&gt; would have been 500.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En nuestro ejemplo, C&lt;$miarray[-1]&gt; habría sido 5000, y C&lt;$miarray[-2]&gt; habría sido 500.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item CamelBones</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225455Z" changeid="explorer">
        <seg>=item CamelBones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UTF-8 length and position cache: to speed up the handling of Unicode
(UTF-8) scalars, a cache was introduced.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T001501Z" changeid="explorer">
        <seg>Longitud y posición de la caché UTF-8: para acelerar la tramitación de escalares Unicode (UTF-8), se introdujo una memoria caché.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Data::Diver qw(Dive);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225619Z" changeid="explorer">
        <seg>use Data::Diver qw(Dive);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*x&gt;', 6, 1;    # prints &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*x&gt;', 6, 1;    # imprime &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That doesn't mean you should go out of your way to avoid backticks
when they're the right way to get something done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Eso no significa que deba evitar las comillas invertidas cuando sea la forma correcta de hacer algo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator is
bistable, like a flip-flop, and emulates the line-range (comma)
operator of B&lt;sed&gt;, B&lt;awk&gt;, and various editors.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador es biestable, como un flip-flop, y emula el operador rango-de-línea de B&lt;sed&gt;, B&lt;awk&gt;, y diversos editores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>500_005) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225519Z" changeid="explorer">
        <seg>500_005) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, use C&lt;\034&gt; or C&lt;\x1c&gt; at the end of quoted constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En su lugar, utilice C&lt;\034&gt; o C&lt;\x1c&gt; al final de la construcción entrecomillada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2: got ABC</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170258Z" changeid="explorer">
        <seg>2: tenemos ABC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may be able to evaluate
multiple commands in a single line by separating them with the command
separator character, if your shell supports that (e.g. C&lt;;&gt; on many Unix
shells; C&lt;&amp;&gt; on the Windows NT C&lt;cmd&gt; shell).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Quizás sea capaz de evaluar múltiples comandos en una sola línea, separándoles con el carácter separador de comandos, si el shell lo soporta (por ejemplo, C&lt;;&gt; en muchos shell Unix; C&lt;&amp;&gt; en el shell C&lt;cmd&gt; de Windows NT).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.14&gt; will not do what
you want in scalar context because each of the operands are evaluated
using their integer representation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3,14&gt; no harán lo que quiere hacer en contexto escalar porque cada uno de los operandos son evaluados utilizando su representación entera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($string =~ /^\d+$/) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234530Z" changeid="explorer">
        <seg>if ($cadena =~ /^\d+$/) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>oct() and hex() in glorious 64 bit</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>oct() y hex() en el glorioso mundo de los 64 bits</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Term::ANSIColor&gt; upgraded to version 1.10</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035301Z" changeid="explorer">
        <seg>C&lt;Term::ANSIColor&gt; actualizado a la versión 1.10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-p  File is a named pipe (FIFO), or Filehandle is a pipe.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004507Z" changeid="explorer">
        <seg>-p  Archivo es una tubería con nombre (FIFO), o el identificador de archivo es una tubería.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $first;                      # Or here.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T000420Z" changeid="explorer">
        <seg>return $first;                      # O aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the C&lt;IPC::SysV&gt;
and C&lt;IPC::SysV::Msg&gt; documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215435Z" changeid="explorer">
        <seg>Vea también la documentación de C&lt;IPC::SysV&gt; y C&lt;IPC::SysV::Msg&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;Changes&gt; file for an explanation of how to view exhaustive
details on what changed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052938Z" changeid="explorer">
        <seg>El archivo F&lt;Changes&gt; (Cambios) para obtener más información exhaustiva sobre lo que ha cambiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example C&lt;/foo(?!bar)/&gt;
matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T210136Z" changeid="explorer">
        <seg>por ejemplo, C&lt;/foo(?!bar)/&gt; coincide con cualquier ocurrencia de &quot;foo&quot; que no esté seguido por &quot;bar&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that programs that do not also use
C&lt;flock&gt; may modify files locked with C&lt;flock&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T161826Z" changeid="explorer">
        <seg>Esto significa que los programas que no usen C&lt;flock&gt; pueden modificar archivos bloqueados con C&lt;flock&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\r          return                (CR)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043334Z" changeid="explorer">
        <seg>\r		retorno			(CR)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you know the exact length in bits, it can be used in place of the C&lt;*&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si conoce la longitud exacta en bits, puede ser utilizada en lugar de la C&lt;*&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failed 2/229 test scripts, 99.13% okay.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Failed 2/229 test scripts, 99.13% okay.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, references to variables related to
output will refer to this output channel.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En segundo lugar, las referencias a variables relacionadas con la salida se referirán a este canal de salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># foo eq &quot;AB\0\0CD&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># foo es &quot;AB\0\0CD&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\cA      chr(1)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034619Z" changeid="explorer">
        <seg>\cA      chr(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;xsubpp&gt; is a compiler to convert Perl XS code into C code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234619Z" changeid="explorer">
        <seg>F&lt;xsubpp&gt; es un compilador que permite convertir código XS de Perl en código C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Net::Ping 450_service and 510_ping_udp failures</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T002630Z" changeid="explorer">
        <seg>=head2 Fallos en Net::Ping 450_service y 510_ping_udp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Damian Conway</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003534Z" changeid="explorer">
        <seg>Damian Conway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/setpgrpstack.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010041Z" changeid="explorer">
        <seg>=item t/op/setpgrpstack.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.strawberryperl.com</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225435Z" changeid="explorer">
        <seg>http://www.strawberryperl.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Text strings&gt;, or B&lt;character strings&gt; are made of characters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234515Z" changeid="explorer">
        <seg>Las B&lt;cadenas de texto&gt;, o B&lt;cadenas de caracteres&gt;, están constituidas por caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is because, as mentioned below, the regex
compilation may be done at execution time, and C&lt;\N{...}&gt; is a compile-time
construct.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto se debe a que, como se menciona más abajo, la compilación de expresiones regulares se puede hacer en tiempo de ejecución, y C&lt;\N{...}&gt; es una construcción en tiempo de compilación).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $logfile $logmessage;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T222046Z" changeid="zipf">
        <seg>print $registro $mensaje_registro;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl587delta	Perl changes in version 5.8.7</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl587delta	Cambios en la versión 5.8.7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $inst    = ExtUtils::Installed-&gt;new();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225446Z" changeid="explorer">
        <seg>my $inst    = ExtUtils::Installed-&gt;new();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?{
           local $cnt = $cnt + 1;      # Update $cnt, backtracking-safe.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T051114Z" changeid="explorer">
        <seg>(?{
           local $cnt = $cnt + 1;      # Actualiza $cnt, independiente de si hay que retrotraer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $price = do { given ($item) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223429Z" changeid="explorer">
        <seg>my $precio = do { given ($item) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{$thisperl .= $Config{_exe} unless $thisperl =~ m/$Config{_exe}$/i;}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015233Z" changeid="explorer">
        <seg>{$thisperl .= $Config{_exe} unless $thisperl =~ m/$Config{_exe}$/i;}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $ref-&gt;[$x][$y]{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $ref-&gt;[$x][$y]{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically all the declarations are put at
the beginning or the end of the script.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Típicamente, todas las declaraciones se ponen al comienzo o al final del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl also defines a consistent extension syntax for features not
found in standard tools like B&lt;awk&gt; and
B&lt;lex&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T192102Z" changeid="explorer">
        <seg>Perl también define una coherente sintaxis extendida de características no encontradas en las herramientas estándar, como B&lt;awk&gt; y B&lt;lex&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a run-time error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un error en tiempo de ejecución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previous steps were performed during the compilation of Perl code,
but this one happens at run time, although it may be optimized to
be calculated at compile time if appropriate.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pasos previos se realizaron durante la compilación de código Perl, pero éste sucede en tiempo de ejecución, aunque puede ser optimizado para ser valorado en tiempo de compilación, si procede.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>start of the innermost ()-group.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>inicio del grupo () más interno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows programmers to be B&lt;lazy&gt; and to
code in a style with which they are comfortable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Permite a los programadores ser B&lt;perezosos&gt; y codificar en el estilo en que se encuentran más cómodos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item keys EXPR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165138Z" changeid="explorer">
        <seg>=item keys EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is one new feature deprecation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T010315Z" changeid="explorer">
        <seg>Hay una nueva característica desaprobada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (values $obj-&gt;get_arrayref) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183826Z" changeid="explorer">
        <seg>for (values $obj-&gt;get_arrayref) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># __DIE__ hooks may modify error messages</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># llamadas __DIE__ pueden modificar los mensajes de error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the time, the longest possible text that does not include
spaces between components and which contains matching braces or
brackets.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de las veces, el texto más largo posible que no incluya espacios entre los componentes y que contenga un juego de llaves o corchetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar(@whatever) == $#whatever - $[ + 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>scalar(@loquesea) == $#loquesea - $[ + 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = @b || @c;		# this is wrong</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@a = @b || @c;		# esto es un error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perluts - Perl under UTS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perluts - Perl bajo UTS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may find it helpful to use letter case to indicate the scope
or nature of a variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede encontrar útil usar el tamaño de caja de las letras para indicar el ámbito o naturaleza de una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From this we can determine that Perl is different
things to different people, but that lots of people think it's at least
worth writing about.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224632Z" changeid="explorer">
        <seg>Esto refleja el hecho de que, aunque Perl tiene muchos públicos distintos, muchas personas piensan que merece la pena escribir sobre este lenguaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open($handle, &quot;&lt;&quot;, &quot;myfile&quot;) or die &quot;myfile: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T000232Z" changeid="explorer">
        <seg>open($handle, &quot;&lt;&quot;, &quot;miarchivo&quot;) or die &quot;miarchivo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;=  greater than or equal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&gt;=  mayor o igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the 5.000 release, we have
averaged only about one production release per year.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230222Z" changeid="explorer">
        <seg>Desde el lanzamiento de la versión 5.000 no hemos lanzado más de una versión de producción al año (en promedio).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After C&lt;each&gt; has returned all entries from the hash or array, the next
call to C&lt;each&gt; returns the empty list in list context and C&lt;undef&gt; in
scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110803T113513Z" changeid="explorer">
        <seg>Después de que C&lt;each&gt; haya devuelto todas las entradas del hash o del array, la siguiente llamada a C&lt;each&gt; devuelve la lista vacía en contexto lista y C&lt;undef&gt; en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5139delta	Perl changes in version 5.13.9</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141318Z" changeid="explorer">
        <seg>perl5139delta	Cambios en la versión 5.13.9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that if you put literal backslashes (those not inside
interpolated variables) between C&lt;\Q&gt; and C&lt;\E&gt;, double-quotish
backslash interpolation may lead to confusing results.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si pone contrabarras literales (no dentro delas variables interpoladas) entre C&lt;\Q&gt; y C&lt;\E&gt;, una interpolación con doble escapado de contrabarras puede llevar a resultados confusos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># do something</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># hacer algo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These have all been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235642Z" changeid="explorer">
        <seg>Han sido todos corregidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$VERSION = &quot;1.12_01&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025709Z" changeid="explorer">
        <seg>$VERSION = &quot;1.12_01&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Double quotes indicate that the text will be interpolated using exactly
the same rules as normal double quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las dobles comillas indican que el texto será interpolado usando exactamente las mismas reglas que las cadenas con dobles comillas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you read this file _as_is_, just ignore the funny characters you
see.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si lees este archivo _tal_como_es_, ignora los caracteres curiosos que veas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%i    a synonym for %d</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%i    un sinónimo para %d</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-s($file) + 1024   # probably wrong; same as -s($file + 1024)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152731Z" changeid="explorer">
        <seg>-s($archivo) + 1024   # probablemente mal; lo mismo que -s($archivo + 1024)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Leading white space is ignored without warning, as too are any trailing 
non-digits, such as a decimal point (C&lt;oct&gt; only handles non-negative
integers, not negative integers or floating point).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco que le rodea es ignorado sin avisar, como también cualquier otro carácter que no sea un dígito, como un punto decimal (C&lt;oct&gt; sólo maneja números enteros no negativos, no enteros negativos o en punto flotante).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This string is true in boolean context and C&lt;0&gt;
in numeric context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta cadena es verdadero en contexto booleano y C&lt;0&gt; en contexto numérico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Detached threads aren't supported on Windows yet, as they may lead to 
memory access violation problems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hilos independientes todavía no son compatibles con Windows, ya que pueden provocar problemas de violación de acceso a memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perluts		Perl notes for UTS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perluts		Notas para UTS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $x ( 3, 7, 9 ) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $x ( 3, 7, 9 ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summing up, Perl numeric values can store only those numbers which have
a finite decimal expansion or a &quot;short&quot; binary expansion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232618Z" changeid="explorer">
        <seg>En resumen, en Perl los valores numéricos solo pueden almacenar números que tengan una expansión decimal finita o una expansión binaria &quot;corta&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( /(.*)(\d*)/ ) {                                # Wrong!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233102Z" changeid="explorer">
        <seg>if ( /(.*)(\d*)/ ) {                                # ¡Incorrecto!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignore the warning.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004832Z" changeid="explorer">
        <seg>No haga caso de la advertencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2  ARRAY(0x803e10)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032553Z" changeid="explorer">
        <seg>2  ARRAY(0x803e10)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execution of /tmp/a aborted due to compilation errors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031706Z" changeid="explorer">
        <seg>Execution of /tmp/a aborted due to compilation errors.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is exactly equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es exáctamente equivalente a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir($foo) * 20;	# (chdir $foo) * 20</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir($foo) * 20;	# (chdir $foo) * 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl progname.pl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl nombre_programa.pl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T215450Z" changeid="explorer">
        <seg>Código ejecutado que tenga efectos colaterales puede quizás no funcionar de forma idéntica en sucesivas versiones debido a los efectos de futuras optimizaciones en el motor de expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A correct CPAN version number is a floating point number with at least 
2 digits after the decimal.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025447Z" changeid="explorer">
        <seg>Un número correcto de versión en CPAN es un número de punto flotante con al menos dos dígitos después del decimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example in C&lt;\x{...}&gt;, regardless of the C&lt;/x&gt; modifier, there can be no
spaces.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, en C&lt;\x{...}&gt;, independientemente del modificador C&lt;/x&gt;, no puede tener espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned values are copies of the original keys in the hash, so
modifying them will not affect the original hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores devueltos son copias de las claves originales en el hash, así que modificarlas no afectará al hash original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the &quot;branch reset&quot; pattern, which has the special property
that the capture groups are numbered from the same starting point
in each alternation branch.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T200041Z" changeid="explorer">
        <seg>Este es el patrón &quot;reinicio de rama&quot;, que tiene la propiedad especial de numerar los grupos de captura desde el mismo punto inicial en cada rama de la alternancia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a Unix-like system, these documentation files will usually also be
available as manpages for use with the F&lt;man&gt; program.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000926Z" changeid="explorer">
        <seg>En un sistema Unix, esta documentación estará también disponible, por lo general, en forma de páginas de manual que se pueden consultar con el programa F&lt;man&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following table, a C&lt;{}&gt; represents
any pair of delimiters you choose.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la siguiente tabla, un C&lt;{}&gt; representa cualquier par de delimitadores que usted elija.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return wantarray ? @a : &quot;@a&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052539Z" changeid="explorer">
        <seg>return wantarray ? @a : &quot;@a&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl
bug database at http://bugs.perl.org/ .  There may also be
information at http://www.perl.com/ , the Perl Home Page.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005303Z" changeid="explorer">
        <seg>Si encuentra algo que piensa que es un error, debe revisar los artículos publicados recientemente en el grupo de noticias comp.lang.perl.misc y la base de datos de errores de perl en http://bugs.perl.org/ . Hay también información en la página principal de Perl, http://www.perl.org/ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use 5.014;  # for hh/j/t/z/ printf modifiers</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182504Z" changeid="explorer">
        <seg>use 5.014;  # para los modificadores hh/j/t/z/ en printf</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;const in void context&quot; warning has been suppressed for a constant in an
optimised-away boolean expression such as C&lt;5 || print;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110726Z" changeid="explorer">
        <seg>La advertencia &quot;I&lt;const in void context&gt; (constante en contexto vacío)&quot; ha sido suprimida de las expresiones booleanas optimizadas, como en C&lt;5 || print;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12652</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12652</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But the empty C&lt;package;&gt; is no longer supported, as of version
5.10.)
X&lt;__FILE__&gt; X&lt;__LINE__&gt; X&lt;__PACKAGE__&gt; X&lt;line&gt; X&lt;file&gt; X&lt;package&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T145821Z" changeid="explorer">
        <seg>(Pero el C&lt;package;&gt; vacío ya no está soportado, a partir de la versión 5.10.)
X&lt;__FILE__&gt; X&lt;__LINE__&gt; X&lt;__PACKAGE__&gt; X&lt;line&gt; X&lt;file&gt; X&lt;package&gt; X&lt;línea&gt; X&lt;archivo&gt; X&lt;paquete&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No idea
how to fix this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No tengo idea de cómo solucionar este problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting a hash element to the undefined value does
not remove its key, but deleting it does; see L&lt;/exists&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215347Z" changeid="explorer">
        <seg>Poner un elemento hash al valor indefinido no elimina su clave, pero eliminándolo sí que lo hace; vea L&lt;/exists&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of subroutine call is deprecated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma de llamada de subrutina ha sido depreciada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it's exactly the same as C&lt;||&gt;, except that it
tests the left hand side's definedness instead of its truth.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De hecho, es exactamente lo mismo que C&lt;||&gt;, excepto que comprueba la definición del lado izquierdo en lugar de su estado de verdad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unlink LIST
X&lt;unlink&gt; X&lt;delete&gt; X&lt;remove&gt; X&lt;rm&gt; X&lt;del&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210151Z" changeid="explorer">
        <seg>=item unlink LISTA
X&lt;unlink&gt; X&lt;delete&gt; X&lt;remove&gt; X&lt;rm&gt; X&lt;del&gt; X&lt;elimina&gt; X&lt;borra&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can avoid this
problem by using C&lt;pipe&gt; instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede evitar este problema mediante el uso, en su lugar, de C&lt;pipe&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the C&lt;m&gt;
you can use any pair of non-whitespace (ASCII) characters
as delimiters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T024719Z" changeid="explorer">
        <seg>Con la C&lt;m&gt; puede usar cualquier par de caracteres no-blancos (ASCII) como delimitadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// die &quot;You're homeless!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224345Z" changeid="explorer">
        <seg>// die &quot;¡Eres un sintecho!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If CMD is IPC_STAT or
GETALL, then ARG must be a variable that will hold the returned
semid_ds structure or semaphore value array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si CMD es IPC_STAT o GETALL, entonces ARG debe ser una variable que contendrá la estructura semid_ds devuelta o el array de semáforos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example under C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver ejemplo en C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in doubt, use C&lt;*FH&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de duda, use C&lt;*FH&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;exec&gt; will not call your C&lt;END&gt; blocks, nor will it invoke
C&lt;DESTROY&gt; methods on your objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;exec&gt; no llamará a sus bloques C&lt;END&gt;, ni llamará a ningún método C&lt;DESTROY&gt; de sus objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variables are thousands of characters long and you know that they
don't change, and you need to wring out the last little bit of speed by
having Perl skip testing for that.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T204420Z" changeid="explorer">
        <seg>Las variables tienen miles y miles de caracteres de longitud y sabe que no cambiarán, y necesita exprimir hasta la última gota de la velocidad de Perl, obviando estas pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlrun		Perl execution and options</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000308Z" changeid="explorer">
        <seg>perlrun		Ejecución y opciones de ejecución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This warning is now emitted in more consistent cases; in short, when one
of the declarations involved is a C&lt;my&gt; variable:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040513Z" changeid="explorer">
        <seg>Esta advertencia es ahora emitida en casos más consistentes; en resumen, cuando una de las declaraciones en cuestión es una variable C&lt;my&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use Module VERSION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item use Módulo VERSIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results follow ASCII semantics.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174525Z" changeid="explorer">
        <seg>Los resultados siguen la semántica ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that splitting an EXPR that evaluates to the
empty string always returns the empty list, regardless of the LIMIT
specified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que la división de una EXPR que evalúe a una cadena vacía siempre devuelve una lista vacía, sin importar el LÍMITE especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item B::Bytecode</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015211Z" changeid="explorer">
        <seg>=item B::Bytecode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because each operand is evaluated in integer form, C&lt;2.18 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que cada operando es evaluado en forma de número entero, C&lt;2,18 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initially, you write something
like this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T144854Z" changeid="explorer">
        <seg>En un principio, escribirá algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid statements like:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012110Z" changeid="explorer">
        <seg>Evite instrucciones como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to the following Perl-like pseudo code:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es equivalente al siguiente pseudo código Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $num = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232654Z" changeid="explorer">
        <seg>my $num = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub fp_equal {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub fp_igual {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates the directory specified by FILENAME, with permissions
specified by MASK (as modified by C&lt;umask&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea el directorio especificado por el nombre de ARCHIVO, con permisos especificados por la MÁSCARA (y modificada por C&lt;umask&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names that start with a digit may contain only more digits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres que comienzan con un dígito, solo pueden contener más dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each attempt to access
pseudo-hashes will trigger the warning C&lt;Pseudo-hashes are deprecated&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T010534Z" changeid="explorer">
        <seg>Cada intento de acceso a los pseudo-hashes activará la alerta C&lt;Pseudo-hashes are deprecated&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-W  File is writable by real uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004551Z" changeid="explorer">
        <seg>-W  Archivo es escribible por el uid/gid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double d;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>double d;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $substring = 'quick.*?fox';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T193102Z" changeid="explorer">
        <seg>my $subcadena = 'rápido.*?zorro';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $array[ $i++ % @array ], &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>print $array[ $i++ % @array ], &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a text string, you would do things like:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234524Z" changeid="explorer">
        <seg>Con una cadena de texto puede realizar operaciones como estas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;SDBM_File&gt; upgraded to version 1.05</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034559Z" changeid="explorer">
        <seg>C&lt;SDBM_File&gt; actualizado a la versión 1.05</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;.&quot; concatenates two strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;.&quot; concatena dos cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So how come you can write these:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que ¿cómo entonces puede escribir lo siguiente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it
returns a true value, then no objects of that class will be cloned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T195305Z" changeid="explorer">
        <seg>Si devuelve un valor verdadero, entonces ningún objeto de esa clase se clonará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that the interpolation code needs to make a decision on
where the interpolated scalar ends.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta también que el código de interpolación tiene que tomar una decisión sobre dónde termina el escalar interpolado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 8, 2) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 8, 2) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qx/STRING/
X&lt;qx&gt; X&lt;`&gt; X&lt;``&gt; X&lt;backtick&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010238Z" changeid="explorer">
        <seg>=item qx/CADENA/
X&lt;qx&gt; X&lt;`&gt; X&lt;``&gt; X&lt;backtick&gt; X&lt;comilla invertida&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*s&gt;',  7, &quot;string&quot;;   # prints &quot;&lt;string&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*s&gt;',  7, &quot;cadena&quot;;   # imprime &quot;&lt;cadena&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @INC, \&amp;my_sub;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @INC, \&amp;mi_sub;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.23E-10             # a very small number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>.23E-10             # un número muy pequeño</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>binary0.1110011001100...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232510Z" changeid="explorer">
        <seg>binary0.1110011001100...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlnewmod&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215933Z" changeid="explorer">
        <seg>Vea también L&lt;perlnewmod&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the PATTERN evaluates to the empty string, the last
I&lt;successfully&gt; matched regular expression is used instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el PATRÓN se evalúa como la cadena vacía, es usada en su lugar la última I&lt;exitosa&gt; expresión regular coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item name</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114029Z" changeid="explorer">
        <seg>=item nombre</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LICENSING
=========</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222756Z" changeid="explorer">
        <seg>LICENCIAS
=========</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Get your book listed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003835Z" changeid="explorer">
        <seg>=head2 Cómo incluir su libro en la lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which makes the intention more clear.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171826Z" changeid="explorer">
        <seg>lo que hace más clara nuestras intenciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;use strict 'refs'&gt; forbids such practice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;use strict 'refs'&gt; prohíbe tal práctica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@list = sort { $a &lt;=&gt; $b } @list;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>@list = sort { $a &lt;=&gt; $b } @list;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behaviour is determined by the following table: the first row
that applies determines the match behaviour (which is thus mostly
determined by the type of the right operand).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento está determinado por la siguiente tabla: la primera fila que se pueda aplicar determina el comportamiento de la coincidencia (que principalmente está determinado por el tipo del operando derecho).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>modulo (%) preserving 64-bit integers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>módulo (%) preserva los enteros de 64 bits</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%h = ( 'v65' =&gt; 42 );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015117Z" changeid="explorer">
        <seg>%h = ( 'v65' =&gt; 42 );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Larry Wall, Tom Christiansen, and Jon Orwant</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003003Z" changeid="explorer">
        <seg>Larry Wall, Tom Christiansen y Jon Orwant</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050529Z" changeid="explorer">
        <seg>Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlport&gt; for notes on the
portability of C&lt;select&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215555Z" changeid="explorer">
        <seg>Vea también L&lt;perlport&gt; para las notas sobre la portabilidad de C&lt;select&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Look-Around Assertions
X&lt;look-around assertion&gt; X&lt;lookaround assertion&gt; X&lt;look-around&gt; X&lt;lookaround&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T202744Z" changeid="explorer">
        <seg>=item Aserciones cercanas
X&lt;aserciones cercanas&gt; X&lt;aserción cercana&gt; X&lt;cercano&gt; X&lt;cercana&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*)(\d+)$</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233806Z" changeid="explorer">
        <seg>(.*)(\d+)$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{bar}  # with bar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{bar}  # por bar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll have to negotiate C&lt;$|&gt;
on your own, though.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque, tendrá que negociar también con C&lt;$|&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CPAN, or the Comprehensive Perl Archive Network (
http://www.cpan.org/ ), is a replicated, worldwide repository of Perl
software.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231424Z" changeid="explorer">
        <seg>CPAN, o Comprehensive Perl Archive Network ( http://www.cpan.org/ ), es un repositorio de software Perl replicado en todo el mundo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and it should output</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>y debe de salir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl debugger (F&lt;lib/perl5db.pl&gt;) has now been extensively
documented and bugs found while documenting have been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180516Z" changeid="explorer">
        <seg>El depurador de Perl (F&lt;lib/perl5db.pl&gt;) ha sido ampliamente documentado y los errores encontrados, mientras que la documentación se ha fijado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SHIFT this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SHIFT este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All variables and arrays beginning with one of
those letters are reset to their pristine state.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todas las variables y arrays que comiencen con una de esas letras son restablecidas a su estado prístino.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;glob&gt; splits its arguments on whitespace and treats
each segment as separate pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que C&lt;glob&gt; divide sus argumentos por los espacios en blanco y trata a cada segmento como patrones independientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that this does not always work for quoting Perl code:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nótese, sin embargo, que esto no siempre funciona para entrecomillar código Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close ARGV if eof;  # Not eof()!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close ARGV if eof;  # ¡No eof()!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>statements;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>instrucciones;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = [ somefunc($i) ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$i] = [ algunafuncion($i) ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These differ in their precedence relationship with a
following comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Difieren en su relación de precedencia cuando son seguidos por una coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New utilities: refaddr, isvstring, looks_like_number, set_prototype.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T174506Z" changeid="explorer">
        <seg>Nuevas utilerías: refaddr, isvstring, looks_like_number, set_prototype.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do case-insensitive pattern matching.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace coincidencia de patrones sin importar si son mayúsculas o minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elsif ($?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>elsif ($?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is only one scalar argument, the argument
is checked for shell metacharacters, and if there are any, the
entire argument is passed to the system's command shell for parsing
(this is C&lt;/bin/sh -c&gt; on Unix platforms, but varies on other
platforms).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sólo hay un argumento escalar, se comprueba si el argumento tiene metacaracteres, y si hay alguno, el argumento entero es pasado al shell de comandos para que sea interpretado (suele ser C&lt;/bin/sh -c&gt; en plataformas Unix, pero varía en otras plataformas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for regex related functions or behaviour.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014643Z" changeid="explorer">
        <seg>Pruebas de funciones o comportamientos relacionados con expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This might
as well break the build, though.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto, sin embargo, también podría romper la compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The old semantics
of this switch only made sense in Win32 and only in the &quot;use utf8&quot;
universe in 5.6.x releases, and do not make sense for the Unicode
implementation in 5.8.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T141815Z" changeid="explorer">
        <seg>La semántica anterior de esta opción sólo tiene sentido en Win32 y sólo con &quot;use utf8&quot; en el universo de versiones 5.6.x, y no tienen sentido para la implementación de Unicode en 5.8.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, a list of
values is returned, one per line of output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, se devuelve una lista de valores, uno por cada línea de la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And now some examples as a list operator:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y ahora algunos ejemplos como un operadores de lista:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;seek&gt; doesn't change the position,
but it I&lt;does&gt; clear the end-of-file condition on the handle, so that the
next C&lt;&lt; &lt;FILE&gt; &gt;&gt; makes Perl try again to read something.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020947Z" changeid="explorer">
        <seg>El C&lt;seek&gt; no cambia la posición, pero I&lt;borra&gt; la condición de final de archivo en el identificador de archivo, para que el próximo C&lt;&lt; &lt;FILE&gt; &gt;&gt; haga que Perl intente de nuevo leer algo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Fetching user and group info
X&lt;user&gt; X&lt;group&gt; X&lt;password&gt; X&lt;uid&gt; X&lt;gid&gt;  X&lt;passwd&gt; X&lt;/etc/passwd&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202358Z" changeid="explorer">
        <seg>=item Obteniendo información de usuarios y grupos
X&lt;user&gt; X&lt;group&gt; X&lt;password&gt; X&lt;uid&gt; X&lt;gid&gt; X&lt;passwd&gt; X&lt;/etc/passwd&gt; X&lt;usuario&gt; X&lt;grupo&gt; X&lt;contraseña&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can be
used to capture the results of parts of the regexp match for later use.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225501Z" changeid="explorer">
        <seg>se pueden usar para capturar los resultados de partes de una expresión regular a fin de usarlos posteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;suidperl&gt;
is neither built nor installed by default, and has been deprecated since
perl 5.8.0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;suidperl&gt; no es construido ni instalado por defecto, y es obsoleto desde perl 5.8.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't use a
string literal (or other read-only string) as an argument to C&lt;syscall&gt;
because Perl has to assume that any string pointer might be written
through.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se puede utilizar una cadena literal (u otras cadenas de sólo lectura) como un argumento a C&lt;syscall&gt; porque Perl tiene que asumir que cualquier puntero de cadena puede ser escrita a través de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of characters sent,
or the undefined value on error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de caracteres enviados, o el valor indefinido en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Time::Local;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225527Z" changeid="explorer">
        <seg>use Time::Local;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These built-ins now always operate in &quot;binary&quot; mode (even if sysopen()
was passed the O_TEXT flag, or if binmode() was used on the file
handle).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T004749Z" changeid="explorer">
        <seg>Estos funciones incorporadas, ahora, funcionan siempre en modo &quot;binario&quot; (incluso si se pasó a sysopen() la bandera O_TEXT, o si se utilizó binmode() con el identificador de archivo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;endgrent&gt;, C&lt;endhostent&gt;, C&lt;endnetent&gt;, C&lt;endpwent&gt;, C&lt;getgrent&gt;,
C&lt;getgrgid&gt;, C&lt;getgrnam&gt;, C&lt;getlogin&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;,
C&lt;getpwuid&gt;, C&lt;setgrent&gt;, C&lt;setpwent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202400Z" changeid="explorer">
        <seg>C&lt;endgrent&gt;, C&lt;endhostent&gt;, C&lt;endnetent&gt;, C&lt;endpwent&gt;, C&lt;getgrent&gt;,
C&lt;getgrgid&gt;, C&lt;getgrnam&gt;, C&lt;getlogin&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;,
C&lt;getpwuid&gt;, C&lt;setgrent&gt;, C&lt;setpwent&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;HV&gt;'s array of C&lt;HE*&gt;s is now allocated at the correct (minimal) size,
thanks to another change by Nicholas Clark.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T052241Z" changeid="explorer">
        <seg>El array de C&lt;HV&gt; de los C&lt;HE*&gt; es ahora asignado al correcto (y mínimo) tamaño, gracias a un nuevo cambio de Nicholas Clark.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a += 1;        # same as $a = $a + 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a += 1;        # igual que $a = $a + 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is called with a pointer to the stash, and
a I&lt;level&gt; of 0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114350Z" changeid="explorer">
        <seg>Es llamado con un puntero al esquema, y un I&lt;nivel&gt; de 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110223T235549Z" changeid="explorer">
        <seg>void</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @transformed = map {; ... } @input; # ; disambiguates</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @transformado = map {; ... } @entrada; # ; desambigüedad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not want to call the package's C&lt;import&gt; method (for instance,
to stop your namespace from being altered), explicitly supply the empty list:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no desea llamar al método C&lt;import&gt; del paquete (por ejemplo, para impedir que su espacio de nombres sea alterado), indique, de manera explícita, una lista vacía:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Document each publically accessible method or subroutine, including params and return values</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013939Z" changeid="explorer">
        <seg>Documente cada método públicamente accesible o subrutina, incluyendo parámetros y valores de retorno</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor, as determined by the
value of $^F.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soportan la bandera cerrar-en-ejecución sobre archivos, la bandera será puesta para el nuevo descriptor de archivo abierto, determinado por el valor de $^F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you really want to continue using pseudo-hashes but not to see the
deprecation warnings, use:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011356Z" changeid="explorer">
        <seg>Si de verdad quiere seguir usando pseudo-hash, pero no quiere ver la advertencia de obsolescencia, utilice:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo, 94,  1) = 1;      # 'PerlPerlPerl'
                                   # 'l' is &quot;\x6c&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052430Z" changeid="explorer">
        <seg>vec($foo, 94,  1) = 1;      # 'PerlPerlPerl'
                                   # 'l' es &quot;\x6c&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does exactly the same thing as C&lt;exec LIST&gt;, except that a fork is
done first and the parent process waits for the child process to
exit.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T023126Z" changeid="explorer">
        <seg>Hace exactamente lo mismo que C&lt;exec LISTA&gt;, excepto que se hace primero un fork y el proceso padre espera a que el proceso hijo termine.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$in_body   = /^$/ ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$en_cuerpo   = /^$/ ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Typeglobs and Filehandles
X&lt;typeglob&gt; X&lt;filehandle&gt; X&lt;*&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003557Z" changeid="explorer">
        <seg>=head2 Typeglobs e identificadores de archivo
X&lt;typeglob&gt; X&lt;filehandle&gt; X&lt;*&gt; X&lt;controlador de archivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>echo hi there</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>echo Hola, qué tal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there's an error, returns the undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay un error, devuelve el valor indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 9, 1) = 1   ==        512 00000000010000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 9, 1) = 1   ==        512 00000000010000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>()       Grouping</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042544Z" changeid="explorer">
        <seg>()	Agrupación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Attempt to set length of freed array</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T050907Z" changeid="explorer">
        <seg>=head2 Intento de asignar una longitud a un array liberado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The additional state of being I&lt;matched with zero-length&gt; is associated with
the matched string, and is reset by each assignment to pos().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T233112Z" changeid="explorer">
        <seg>El estado adicional de ser I&lt;encontrado con longitud cero&gt; es asociado con la cadena coincidente, y es restablecido con cada asignación de pos().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before Perl 5.14, the assignment to C&lt;$@&gt; occurred before restoration 
of localised variables, which means that for your code to run on older
versions, a temporary is required if you want to mask some but not all
errors:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T160853Z" changeid="explorer">
        <seg>Antes de Perl 5.14, la asignación a C&lt;$@&gt; ocurría antes de la restauración de las variables localizadas, lo que significa que su código, al ejecutarse en versiones anteriores, requería de una variable temporal si deseaba enmascarar algunos pero no todos los errores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several special variables also refer back to portions of the previous
match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Varias variables especiales también se refieren a porciones de la coincidencia anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the 'aaab' at the start of the string has matched, and the C&lt;(*SKIP)&gt;
executed, the next starting point will be where the cursor was when the
C&lt;(*SKIP)&gt; was executed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T011941Z" changeid="explorer">
        <seg>Una vez que el 'aaab', en el inicio de la cadena, ha sido encontrado, y el C&lt;(*SKIP)&gt; ejecutado, el siguiente punto de partida será el lugar donde estaba el cursor cuando fue ejecutado C&lt;(*SKIP)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This change was very prudent
because so many Unix vendors already provide a F&lt;/usr/bin/perl&gt;,
but simultaneously many system utilities may depend on that
exact version of Perl, so better not to overwrite it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T181317Z" changeid="explorer">
        <seg>Este cambio fue muy prudente, porque muchos de los instaladores de Unix ya ofrecen un F&lt;/usr/bin/perl&gt;, pero al mismo tiempo muchas utilidades del sistema puede depender de la versión exacta de Perl, así que es mejor no sobrescribirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your system supports
only the older DBM functions, you may make only one C&lt;dbmopen&gt; call in your
program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su sistema sólo soporta las viejas funciones DBM, sólo puede realizar una llamada C&lt;dbmopen&gt; en su programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://learn.perl.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225443Z" changeid="explorer">
        <seg>http://learn.perl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>list ops         ()    capture</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225254Z" changeid="explorer">
        <seg>ops lista        ()    captura</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supplying a count to the I&lt;length-item&gt; format letter is only useful with
C&lt;A&gt;, C&lt;a&gt;, or C&lt;Z&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192320Z" changeid="explorer">
        <seg>Indicando un contador al formato I&lt;longitud-item&gt; solo es útil para C&lt;A&gt;, C&lt;a&gt;, o C&lt;Z&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For threaded builds for modules calling certain re-entrant system calls,
binary compatibility was accidentally lost between 5.8.0 and 5.8.1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se perdió, accidentalmente, la compatibilidad binaria entre 5.8.0 y 5.8.1, en la construcción de módulos en paralelo, al llamar a ciertas llamadas del sistema reentrantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.10.0 release and
the 5.11.0 development release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T232752Z" changeid="explorer">
        <seg>Este documento describe las diferencias entre la versión 5.10.0 y la versión 5.11.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exceeds size threshold; to optimize this procedure, use -Olimit option</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004826Z" changeid="explorer">
        <seg>exceeds size threshold; to optimize this procedure, use -Olimit option</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As C&lt;\d*&gt; can match on an empty string the complete
regular expression matched successfully.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233515Z" changeid="explorer">
        <seg>Como C&lt;\d*&gt; puede coincidir con una cadena vacía, la expresión regular completa coincide con éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($x = 4; $x &lt;= 8; $x++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053014Z" changeid="explorer">
        <seg>for ($x = 4; $x &lt;= 8; $x++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function causes an immediate core dump.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función provoca un volcado inmediato del núcleo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lvalue subroutines are again able to return copy-on-write scalars.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230413Z" changeid="explorer">
        <seg>Las subrutinas ivalue pueden, nuevamente, devolver escalares por copia-en-escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing, but much more efficiently;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, pero mucho más eficiente;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trailing spaces are now trimmed from C&lt;$!&gt; and C&lt;$^E&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045149Z" changeid="explorer">
        <seg>Los espacios finales de C&lt;$!&gt; y C&lt;$^E&gt; ahora son recortados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset 'a-z';    # reset lower case variables</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>reset 'a-z';    # reinicia las variables con minúsculas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (-s $file &gt; 5 + 100 * 2**16) {  }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (-s $archivo &gt; 5 + 100 * 2**16) {  }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the name is given in UTF-8, set this to C&lt;HVhek_UTF8&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114112Z" changeid="explorer">
        <seg>Si el nombre se da en UTF-8, ponga esto en C&lt;HVhek_UTF8&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>jJfFdDpP   (The &quot;big end&quot; touches the construct.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>jJfFdDpP   (El &quot;big end&quot; toca la construcción).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Editorial adjustments by Gurusamy Sarathy &lt;gsar@ActiveState.com&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234143Z" changeid="explorer">
        <seg>Ajustes editoriales de Gurusamy Sarathy &lt;gsar@ActiveState.com&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
workaround is to use global (C&lt;our&gt;) variables.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T223430Z" changeid="explorer">
        <seg>La solución consiste en el uso de variables globales (C&lt;our&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $var;           $$variable_name  perl.com</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224325Z" changeid="explorer">
        <seg>my $var;           $$nombre_variable      perl.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now the whatever works:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225939Z" changeid="explorer">
        <seg>Ahora la cosa funciona:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print pop(@keys), '=', pop(@values), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print pop(@keys), '=', pop(@values), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example: when matching C&lt;foo|foot&gt; against &quot;barefoot&quot;, only the &quot;foo&quot;
part will match, as that is the first alternative tried, and it successfully
matches the target string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T223701Z" changeid="explorer">
        <seg>Por ejemplo: cuando se compara C&lt;foo|foot&gt; contra &quot;barefoot&quot;, sólo la parte &quot;foo&quot; coincidirá, ya que es la primera alternativa intentada, y coincide de forma exitosa con la cadena objetivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is one of the
requirements of C&lt;use strict;&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T230806Z" changeid="explorer">
        <seg>(Éste es uno de los requisitos de C&lt;use strict;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0xdead_beef         # more hex</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0xdead_beef         # más hex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* unless the delimiter is ''.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>* excepto si el delimitador es ''.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Complex not as efficient as POSIX, but
POSIX can't work with complex numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::Complex no es tan eficiente como POSIX, pero POSIX no puede trabajar con números complejos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In ASCII the character in the 80th position (indexed
from 0) is the letter &quot;P&quot;, and in EBCDIC it is the ampersand symbol &quot;&amp;&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T220644Z" changeid="explorer">
        <seg>En ASCII el carácter en la posición 80 (basado en 0) es la letra &quot;P&quot;, y en EBCDIC es el símbolo del signo &quot;&amp;&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This file contains instructions how to build Perl under BeOS and lists
known problems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este archivo contiene instrucciones de cómo construir Perl para BeOS y listas de problemas conocidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;&lt; (?&gt;pattern) &gt;&gt; does not disable backtracking altogether once it has
matched.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213714Z" changeid="explorer">
        <seg>C&lt;&lt; (?&gt;patrón) &gt;&gt; no desactiva la vuelta atrás una vez que ha coincidido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default sprintf
will format the next unused argument in the list, but this allows you
to take the arguments out of order:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por defecto sprintf formateará el siguiente argumento no utilizado en la lista, pero esto le permite tomar los argumentos fuera de orden:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated to 3.09.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052646Z" changeid="explorer">
        <seg>Actualizado a 3.09.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a corresponding C&lt;no&gt; declaration that unimports meanings imported
by C&lt;use&gt;, i.e., it calls C&lt;unimport Module LIST&gt; instead of C&lt;import&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024557Z" changeid="explorer">
        <seg>Existe un correspondiente comando C&lt;no&gt; que des-importa los significados importados por C&lt;use&gt;, es decir, llama a C&lt;unimport Módulo LISTA&gt; en lugar de C&lt;import&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;DB_File&gt;, L&lt;GDBM_File&gt;, L&lt;NDBM_File&gt;, L&lt;ODBM_File&gt; and L&lt;SDBM_File&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190429Z" changeid="zipf">
        <seg>L&lt;DB_File&gt;, L&lt;GDBM_File&gt;, L&lt;NDBM_File&gt;, L&lt;ODBM_File&gt; y L&lt;SDBM_File&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict;        DON'T</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224319Z" changeid="explorer">
        <seg>use strict;        INCORRECTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod 0644, $_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod 0644, $_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the latter will alternate between returning a filename and
returning false.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ya que este último alternará entre devolver un nombre de archivo y devolver falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will not automatically invoke the overload method with X as an argument;
instead the table above is consulted as normal, and based in the type of X,
overloading may or may not be invoked.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no invocará automáticamente el método sobrecargado con X como argumento; en su lugar, será consultada la tabla anterior, y en base al tipo de X, la sobrecarga será o no invocada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This used
to raise a syntax error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045623Z" changeid="explorer">
        <seg>Esto se usaba para levantar un error de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alpha and MIPS can be either: Digital/Compaq uses (well, used) 
them in little-endian mode, but SGI/Cray uses them in big-endian mode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003033Z" changeid="explorer">
        <seg>Alpha y MIPS pueden ser: Digital/Compaq utilizados (bueno usados) en modo I&lt;little-endian&gt;, pero SGI/Cray los usa en modo I&lt;big-endian&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it has no repeat count or uses a '*', the number
of available items is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no tiene contador de repeticiones o utiliza un '*', se utiliza el número de elementos disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;EXPR&gt; following the modifier is referred to as the &quot;condition&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La C&lt;EXPR&gt; siguiente al modificador es referida como la &quot;condición&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, S&lt;C&lt;split(' ')&gt;&gt; can
be used to emulate B&lt;awk&gt;'s default behavior, whereas S&lt;C&lt;split(/ /)&gt;&gt;
will give you as many initial null fields (empty string) as there are leading spaces.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto, S&lt;C&lt;split(' ')&gt;&gt; puede ser utilizado para emular el comportamiento por defecto de B&lt;awk&gt;, mientras que S&lt;C&lt;split(/ /)&gt;&gt; le dará tantos campos nulos iniciales (cadenas vacías) como espacios haya allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 0-201-11889-0 [January 1988]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003734Z" changeid="explorer">
        <seg>ISBN 0-201-11889-0 [Enero de 1988]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You
can truncate an array down to nothing by assigning the null list
() to it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede truncarse un array para dejarlo vacío asignándole la lista nula ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What mailing lists are there for Perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230926Z" changeid="explorer">
        <seg>=head2 ¿Qué listas de correo sobre Perl existen?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Text::Balanced</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015329Z" changeid="explorer">
        <seg>=item Text::Balanced</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ALL_CAPS_HERE   constants only (beware clashes with perl vars!)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$TODO_MAYUSCULAS    Sólo constantes (¡cuidado con variables perl!)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;assertions&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142952Z" changeid="explorer">
        <seg>Vea L&lt;aserciones&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Installation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235017Z" changeid="explorer">
        <seg>=head2 Instalación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = tr/*/*/;		# count the stars in $_</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = tr/*/*/;		# cuenta los asteriscos en $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Changes to Existing Documentation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003605Z" changeid="explorer">
        <seg>=head1 Cambios en la documentación actual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, while searching
for closing C&lt;]&gt; paired with the opening C&lt;[&gt;, combinations of C&lt;\\&gt;, C&lt;\]&gt;,
and C&lt;\[&gt; are all skipped, and nested C&lt;[&gt; and C&lt;]&gt; are skipped as well.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, mientras se busca el C&lt;]&gt; de cierre  emparejado con el de apertura C&lt;[&gt;, combinaciones de C&lt;\\&gt;, C&lt;\]&gt; y C&lt;\[&gt; son todos omitidos, y anidados de C&lt;[&gt; y C&lt;]&gt; se pasan también por alto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$db-&gt;filter_store_key  ( sub { $_ .= &quot;\0&quot; } );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190130Z" changeid="zipf">
        <seg>$db-&gt;filter_store_key  ( sub { $_ .= &quot;\0&quot; } );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$setbits = unpack(&quot;%32b*&quot;, $selectmask);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bitspuestos = unpack(&quot;%32b*&quot;, $mascara);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Demands a version of Perl specified by VERSION, or demands some semantics
specified by EXPR or by C&lt;$_&gt; if EXPR is not supplied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Exige una versión de Perl especificada por VERSIÓN, o exige una semántica especificada por EXPR, o por C&lt;$_&gt; si EXPR se omite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a pattern does not contain a special backtracking verb that allows an
argument, then C&lt;$REGERROR&gt; and C&lt;$REGMARK&gt; are not touched at all.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T010922Z" changeid="explorer">
        <seg>Si un patrón no contiene un verbo especial de vuelta atrás que permita un argumento, entonces C&lt;$REGERROR&gt; y C&lt;$REGMARK&gt; no son modificados de ninguna manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the BSD 4.2 version of C&lt;setpgrp&gt; does not
accept any arguments, so only C&lt;setpgrp(0,0)&gt; is portable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que la versión de BSD 4.2 de C&lt;setpgrp&gt; no acepta ningún argumento, por lo que sólo C&lt;setpgrp(0,0)&gt; es portátil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the POSIX version of C&lt;getpgrp&gt;
does not accept a PID argument, so only C&lt;PID==0&gt; is truly portable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la versión POSIX de C&lt;getpgrp&gt; no acepta un argumento PID, por lo que sólo C&lt;PID==0&gt; es verdaderamente portable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pipes and sockets are now automatically in binary mode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001150Z" changeid="explorer">
        <seg>Tuberías y I&lt;sockets&gt; están, ahora, automáticamente, en modo binario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-  Installing the built perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-  Instalando el perl compilado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>||  or</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232644Z" changeid="explorer">
        <seg>||  or</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example C&lt;\x{50}&gt; and C&lt;\o{120}&gt; both are the number 80 in
decimal, which is less than 256, so the number is interpreted in the native
character set encoding.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T220619Z" changeid="explorer">
        <seg>Por ejemplo, ambos C&lt;\x{50}&gt; y C&lt;\o{120}&gt; son el número 80 en decimal, que es menos de 256, por lo que el número se interpreta en la codificación de caracteres nativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these effects take place for the next match, so
you can't affect the position with C&lt;pos&gt; during the current match,
such as in C&lt;(?{pos() = 5})&gt; or C&lt;s//pos() = 5/e&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T180134Z" changeid="explorer">
        <seg>Estos dos efectos toman lugar en la siguiente coincidencia, por lo que no puede afectar a la posición con C&lt;pos&gt; durante la coincidencia actual, como en C&lt;(?{pos() = 5})&gt; o C&lt;s//pos() = 5/e&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die unless $@ =~ /Expected exception/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die unless $@ =~ /Expected exception/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,28, 1) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,28, 1) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item no VERSION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item no VERSIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( /$pattern/ ) { }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234725Z" changeid="explorer">
        <seg>if ( /$patron/ ) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The documentation for the special code blocks (BEGIN, CHECK, INIT, END)
has been improved.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La documentación de los bloques especiales (BEGIN, CHECK, INIT, FIN) ha sido mejorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's now only recognized when explicitly turned on (and is
then a regular keyword).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T193650Z" changeid="explorer">
        <seg>Ahora sólo se reconoce cuando se activa explícitamente (y entonces se considera como una palabra clave normal).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, with C&lt;Configure -Dprefix=/usr&gt;
you can now really replace the Apple-supplied Perl (B&lt;please be careful&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T183452Z" changeid="explorer">
        <seg>Por otro lado, con C&lt;Configure -Dprefix=/usr&gt; ahora puede, realmente, cambiar el Perl suministrado por Apple (B&lt;por favor, tenga cuidado&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to write true lexically scoped pragmas will be introduced,
perhaps via a C&lt;pragma&gt; pragma.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T005415Z" changeid="explorer">
        <seg>La capacidad de escribir verdaderos pragmas léxicos será indicada, quizás, a través de un pragma C&lt;pragma&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;a &quot; . $b -&gt; {c};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054416Z" changeid="explorer">
        <seg>&quot;a &quot; . $b -&gt; {c};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$line = &lt;$fh&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$linea = &lt;$fh&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do 'stat.pl';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do 'stat.pl';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, use either</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005745Z" changeid="explorer">
        <seg>Por ejemplo, utilice esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time::HiRes upgraded to version 1.65</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Time::HiRes actualizado a la versión 1.65</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfaq4&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220311Z" changeid="explorer">
        <seg>Vea L&lt;perlfaq4&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Exporter</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014816Z" changeid="explorer">
        <seg>=item Exporter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bar	# NOT a comment, this slash / terminated m//!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>bar	# ¡NO es un comentario, esta barra / termina m//!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub import {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045923Z" changeid="explorer">
        <seg>sub import {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;state&gt; declares a lexically scoped variable, just like C&lt;my&gt; does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;state&gt; declara una variable de ámbito léxico, como lo hace C&lt;my&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;instmodsh&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235331Z" changeid="explorer">
        <seg>=item L&lt;instmodsh&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-c  File is a character special file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004741Z" changeid="explorer">
        <seg>-c  Archivo es un archivo especial de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You shouldn't worry about what this format is, because conversion is
automatically done when you decode or encode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234925Z" changeid="explorer">
        <seg>No tiene que preocuparse por los detalles, ya que la conversión se realiza automáticamente al descodificar y codificar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$output = `cmd 2&gt;/dev/null`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$salida = `comando 2&gt;/dev/null`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return (pop(@foo),pop(@foo))[0];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return (pop(@foo),pop(@foo))[0];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BITS therefore specifies the number of bits
that are reserved for each element in the bit vector.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BITS, por tanto, especifica el número de bits que son reservados para cada elemento en el vector de bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Deprecations</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235506Z" changeid="explorer">
        <seg>=head1 Obsolescencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All data in Perl is a scalar, an array of scalars, or a hash of
scalars.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo dato en Perl es un escalar, un array de escalares o un hash de escalares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.manning.com/jenness</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003645Z" changeid="explorer">
        <seg>http://www.manning.com/jenness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo,  2, 16) = 0x5065; # 'PerlPe'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($foo,  2, 16) = 0x5065; # 'PerlPe'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Declaration and Access of Arrays of Arrays</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Declaración y acceso de los array de array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make switching optimization and debugging levels during Perl builds
easier via the OPTIMIZE environment variable</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>realizar la optimización de conexión y los niveles de depuración durante la compilación de Perl es más fácil usando la variable de entorno OPTIMIZE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$shell_info = qx'ps $$';            # that's the new shell's $$</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$shell_info = qx'ps $$';            # es el $$ del nuevo shell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Pod::Parser&gt; upgraded to version 1.32</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034326Z" changeid="explorer">
        <seg>C&lt;Pod::Parser&gt; actualizado a la versión 1.32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Platform-specific enhancements</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031329Z" changeid="explorer">
        <seg>=head2 Mejoras específicas por plataforma</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eof ()</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eof ()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Extended Patterns</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Patrones extendidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also use Perl's four-argument
version of select() leaving the first three arguments undefined, or you
might be able to use the C&lt;syscall&gt; interface to access setitimer(2) if
your system supports it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede también usar la versión de select() de cuatro argumentos, dejando los tres primeros indefinidos, o puede usar la interfaz C&lt;syscall&gt; para acceder a setitimer(2) si su sistema lo soporta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;not&quot; returns the logical negation of the expression to its right.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unario &quot;not&quot; devuelve la negación lógica de la expresión a su derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All modules should be tested before distribution (using &quot;make disttest&quot;),
and the tests should also be available to people installing the modules 
(using &quot;make test&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030401Z" changeid="explorer">
        <seg>Todos los módulos deben ser probados antes de su distribución (con &quot;make disttest&quot;), y las pruebas también deben estar disponibles para la gente que instala los módulos (con &quot;make test&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Programming the Perl DBI&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003525Z" changeid="explorer">
        <seg>=item I&lt;Programming the Perl DBI&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;keys&gt;, C&lt;values&gt;, and C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005852Z" changeid="explorer">
        <seg>Vea también C&lt;keys&gt;, C&lt;values&gt; y C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the permissions of a list of files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia los permisos de una lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 4) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 4) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>myfunc(&lt;&lt; &quot;THIS&quot;, 23, &lt;&lt;'THAT');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>myfunc(&lt;&lt; &quot;ESTE&quot;, 23, &lt;&lt;'ESE');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>support for Unicode, internationalization, and localization</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001408Z" changeid="explorer">
        <seg>compatibilidad con Unicode, internacionalización y localización</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\*/	# Match the closing delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\*/	# Busca el delimitador de cierre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;ExtUtils::MakeMaker&gt;, L&lt;Module::Build&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T032034Z" changeid="explorer">
        <seg>L&lt;ExtUtils::MakeMaker&gt;, L&lt;Module::Build&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is similar to pre-extending
an array by assigning a larger number to $#array.)  If you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto es similar a pre-extender un array asignándole un gran número a $#array). Si dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$can_chown_giveaway = not sysconf(_PC_CHOWN_RESTRICTED);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$can_chown_giveaway = not sysconf(_PC_CHOWN_RESTRICTED);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lock THING
X&lt;lock&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T190718Z" changeid="explorer">
        <seg>=item lock COSA
X&lt;lock&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\N{U+263D}   [4,8]  Unicode character (example: FIRST QUARTER MOON)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T185751Z" changeid="explorer">
        <seg>\N{U+263D}	[4,8]	Carácter Unicode		(ejemplo: FIRST QUARTER MOON)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If instead you want to sort the array @key with the comparison routine
C&lt;find_records()&gt; then you can use:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si, en cambio, quiere ordenar el array @claves con la rutina de comparación C&lt;busca_registros()&gt; entonces puede usar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It introduced the
concept of references, complex data structures, and modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004324Z" changeid="explorer">
        <seg>Perl 5 incorpora referencias, estructuras de datos complejas y módulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.8.2 release and
the 5.8.3 release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe las diferencias entre la versión 5.8.2 y la versión 5.8.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Digest::MD5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Digest::MD5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now implements UCA Revision 14 (based on Unicode 4.1.0).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041026Z" changeid="explorer">
        <seg>Ahora implementa la UCA Revisión 14 (basada en Unicode 4.1.0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use sort 'stable';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use sort 'stable';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Bug Fixes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230206Z" changeid="explorer">
        <seg>=head1 Arreglo de errores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@keys = keys %ENV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@keys = keys %ENV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as the first line of the handler (see L&lt;perlvar/$^S&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>como primera línea del gestor (ver L&lt;perlvar/$^S&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub lock {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub lock {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A thread's interpreter is now freed after C&lt;&lt; $t-&gt;join() &gt;&gt; rather than after
C&lt;undef $t&gt;, which should fix some C&lt;ithreads&gt; memory leaks.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040604Z" changeid="explorer">
        <seg>Un intérprete de una hebra es ahora liberado después de un C&lt;&lt; $t-&gt;join() &gt;&gt; en lugar de después de C&lt;undef $t&gt;, que debería fijar un poco las pérdidas de memoria de C&lt;ithreads&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/\U$1/xg;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225536Z" changeid="explorer">
        <seg>/\U$1/xg;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>t/io/fs.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T053455Z" changeid="explorer">
        <seg>t/io/fs.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On typical hardware, floating
point values can store numbers with up to 53 binary digits, and with binary
exponents between -1024 and 1024.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232524Z" changeid="explorer">
        <seg>En el hardware típico, los valores de punto flotante pueden almacenar números que tengan hasta 53 dígitos binarios, y con exponentes binarios entre -1024 y 1024.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tied VARIABLE
X&lt;tied&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T205919Z" changeid="explorer">
        <seg>=item tied VARIABLE
X&lt;tied&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A module which purports to be stable or which hopes to achieve wide 
use should adhere to as strict a testing regime as possible.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030541Z" changeid="explorer">
        <seg>Un módulo que pretende ser estable o que se espera lograr un uso amplio debe cumplir con un régimen estricto de pruebas tanto como sea posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval $x;        # CASE 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval $x;        # CASO 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 DTrace support</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003004Z" changeid="explorer">
        <seg>=head2 Soporte DTrace</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The repeat count for C&lt;u&gt; is interpreted as the maximal number of bytes
to encode per line of output, with 0, 1 and 2 replaced by 45.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de repeticiones para C&lt;u&gt; se interpreta como el número máximo de bytes para codificar por línea de salida, con 0, 1 y 2 sustituidos por 45.&lt;/u&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($Config{use64bitint} eq &quot;define&quot; || $Config{longsize} &gt;= 8) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($Config{use64bitint} eq &quot;define&quot; || $Config{longsize} &gt;= 8) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L  An unsigned long value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>L  Un valor de un largo sin signo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $vec = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>my $vec = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Warning on \1 Instead of $1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T224721Z" changeid="explorer">
        <seg>=head2 Atención sobre \1 en lugar de $1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string =~ s/([\w']+)/\u\L$1/g;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225536Z" changeid="explorer">
        <seg>$string =~ s/([\w']+)/\u\L$1/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new utility, C&lt;prove&gt;, makes it easy to run an individual regression test
at the command line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una nueva utilidad, C&lt;prove&gt;, hace que sea fácil ejecutar una prueba de regresión individual en la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print '-' x 80;		# print row of dashes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print '-' x 80;		# imprime una fila de guiones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;ptardiff&gt; is a small utility that produces a diff between an extracted
archive and an unextracted one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234947Z" changeid="explorer">
        <seg>F&lt;ptardiff&gt; es una pequeña utilidad que genera las diferencias entre un archivo de almacenamiento extraído y uno sin extraer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used
without a name the &quot;skip point&quot; is where the match point was when
executing the (*SKIP) pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T011643Z" changeid="explorer">
        <seg>Cuando es usado sin nombre, el &quot;punto de salto&quot; es donde estaba el punto de coincidencia cuando se ejecutaba el patrón (*SKIP).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(On other statements the loop modifiers test the conditional
first.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012017Z" changeid="explorer">
        <seg>(En otras instrucciones los modificadores de bucle comprueban primero la condición).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub myname;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub minombre;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 1-930110-00-6 [1st edition 2001]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003621Z" changeid="explorer">
        <seg>ISBN 1-930110-00-6 [1ª edición - 2001]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LISTs do automatic interpolation of sublists.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LISTAs hacen una interpolación automática de las sublistas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function semget(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC semget(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using substr() on a UTF8 string could cause subsequent accesses on that
string to return garbage.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando substr() en una cadena UTF8 podría causar que los subsecuentes accesos a dicha cadena devuelvan basura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hexdigit = ('a','b','c','d','e','f')[$digit-10];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$digitohex = ('a','b','c','d','e','f')[$digito-10];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regarding precedence, the filetest operators, like C&lt;-f&gt;, C&lt;-M&gt;, etc. are
treated like named unary operators, but they don't follow this functional
parenthesis rule.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En cuanto a la precedencia, los operadores test de archivos, como C&lt;-f&gt;, C&lt;-M&gt;, etc, son tratados como operadores unarios con nombre, pero no siguen esta regla funcional de los paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be understood as being roughly
equivalent to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser entendida como equivalente a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%B    like %b, but using an upper-case &quot;B&quot; with the # flag</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%B    como %b, pero usando una letra &quot;B&quot; mayúscula con la bandera #</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each &quot;..&quot; operator
maintains its own boolean state, even across calls to a subroutine
that contains it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada operador &quot;..&quot; mantiene su estado booleano propio, incluso a través de llamadas a la subrutina que lo contenga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 PCRE/Python Support</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002908Z" changeid="explorer">
        <seg>=head2 Soporte PCRE/Python</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ponie.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un poni.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[3]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[3]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item format parameter index</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item índice de parámetro de formato</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$(&gt; and C&lt;$)&gt; now return groups in the order where the OS returns them,
thanks to Gisle Aas.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200843Z" changeid="explorer">
        <seg>C&lt;$(&gt; y C&lt;$)&gt; ahora devuelven grupos en el orden en que el SO los devuelve, gracias a Gisle Aas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New &quot;read() on %s filehandle %s&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002719Z" changeid="explorer">
        <seg>=head2 Nuevo &quot;I&lt;read() on %s filehandle %s&gt;&quot; (read() en identificador %s de archivo %s)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(STDOUT, &quot;&gt;&amp;&quot;, $oldout) or die &quot;Can't dup \$oldout: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004535Z" changeid="explorer">
        <seg>open(STDOUT, &quot;&gt;&amp;&quot;, $oldout) or die &quot;No puedo duplicar \$oldout: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is C&lt;... &amp;&amp; ...&gt; or C&lt;... and ...&gt;, the test
is applied recursively to both operands.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T212445Z" changeid="explorer">
        <seg>Si EXPR es C&lt;... &amp;&amp; ...&gt; o C&lt;... and ...&gt;, el test se aplica recursivamente a ambos operandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use C&lt;while&gt; in a post-condition:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T224606Z" changeid="zipf">
        <seg>También puede usar C&lt;while&gt; en una condición posterior:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>| ^</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000317Z" changeid="explorer">
        <seg>| ^</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following escape sequences are available in constructs that interpolate,
but not in transliterations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las siguientes secuencias de escape están disponibles en construcciones que interpolan, pero no en transliteraciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item y/SEARCHLIST/REPLACEMENTLIST/cdsr</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T214219Z" changeid="explorer">
        <seg>=item y/LISTA_BÚSQUEDA/LISTA_REEMPLAZO/cdsr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>| ,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225537Z" changeid="explorer">
        <seg>| ,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A test suite for the s2p converter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014736Z" changeid="explorer">
        <seg>Conjuntos de pruebas del conversor s2p.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also
L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, and C&lt;IPC::SysV::Semaphore&gt;
documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215739Z" changeid="explorer">
        <seg>Vea también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, y C&lt;IPC::Semaphore&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>goto((&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>goto((&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 HISTORY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 HISTORIA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>de tal manera que serán definidas ${^PREMATCH}, ${^MATCH} y ${^POSTMATCH}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any additional arguments are passed to the C&lt;new&gt;
method of the class (meaning C&lt;TIESCALAR&gt;, C&lt;TIEHANDLE&gt;, C&lt;TIEARRAY&gt;,
or C&lt;TIEHASH&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualesquiera argumentos adicionales son pasados al método C&lt;new&gt; de la clase (es decir, C&lt;TIESCALAR&gt;, C&lt;TIEHANDLE&gt;, C&lt;TIEARRAY&gt;, o C&lt;TIEHASH&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;\I&lt;digit&gt;&gt; notation also works in certain circumstances outside
the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191137Z" changeid="explorer">
        <seg>La notación C&lt;\I&lt;dígito&gt;&gt; también funciona, en ciertas circunstancias, fuera del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently (in Perl 5.8.x) the stdio
library is still used if Perl thinks it can use certain tricks to
make stdio go B&lt;really&gt; fast.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014130Z" changeid="explorer">
        <seg>En la actualidad (en Perl 5.8.x) la biblioteca stdio todavía es utilizada si Perl piensa que puede usar ciertos trucos para hacer que stdio vaya B&lt;realmente&gt; más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$file =~ s#^(\s)#./$1#;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$archivo =~ s#^(\s)#./$1#;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;when&gt; executes the statement I&lt;when&gt; C&lt;$_&gt; smart matches C&lt;EXPR&gt;, and
then either C&lt;break&gt;s out if it's enclosed in a C&lt;given&gt; scope or skips
to the C&lt;next&gt; element when it lies directly inside a C&lt;for&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013046Z" changeid="explorer">
        <seg>C&lt;when&gt; ejecuta la instrucción I&lt;cuando&gt; C&lt;$_&gt; coincide inteligentemente con C&lt;EXPR&gt;, y después, o bien C&lt;salta&gt; fuera si está encerrada en un ámbito C&lt;given&gt; o salta al C&lt;siguiente&gt; elemento cuando reside dentro de un bucle C&lt;for&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operating and filesystems do not get
this right, so Perl automatically removes all trailing slashes to keep
everyone happy.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos sistemas operativos y de sistemas de archivos no interpretan esto de forma correcta, por lo que Perl automáticamente elimina todas las barras inclinadas finales para tener a todo el mundo feliz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s	Treat string as single line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s	Trata la cadena como una única línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
the range operator is changed to C&lt;...&gt;, it will also print the
&quot;Baz&quot; line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el operador se cambia a C&lt;...&gt;, también se imprimirá la línea &quot;Baz&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl573delta has been added to list the differences between the
(now quite obsolete) development releases 5.7.2 and 5.7.3.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180645Z" changeid="explorer">
        <seg>perl573delta se ha añadido a la lista de las diferencias entre las versiones de desarrollo (ya bastante obsoletas) 5.7.2 y 5.7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello, world\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233902Z" changeid="zipf">
        <seg>print &quot;Hola a todos\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>may be closer to the conjectural I&lt;intention&gt; of the writer of C&lt;&quot;\Q\t\E&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>puede conjeturar que puede estar muy cerca de la I&lt;intención&gt; de quien escribió C&lt;&quot;\Q\t\E&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The search engine will initially match C&lt;\D*&gt; with &quot;ABC&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170831Z" changeid="explorer">
        <seg>El motor de búsqueda inicialmente coincidirá C&lt;\D*&gt; con &quot;ABC&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># now process $line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ahora, procesa $linea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns I&lt;e&gt; (the natural logarithm base) to the power of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve I&lt;e&gt; (la base natural del logaritmo) a la potencia de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 5.8.0 many Unicode features were introduced.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143556Z" changeid="explorer">
        <seg>En Perl 5.8.0 se introdujeron muchas características Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This 'integer' is _at_least_ 32 bits wide.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Este 'entero' es _al_menos_, de 32 bit de ancho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/ (?&gt; \# [ \t]* ) (        .+ ) /x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002933Z" changeid="explorer">
        <seg>/ (?&gt; \# [ \t]* ) (        .+ ) /x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Class::ISA&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T020327Z" changeid="explorer">
        <seg>C&lt;Class::ISA&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Win32::GetOSVersion</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015348Z" changeid="explorer">
        <seg>=item Win32::GetOSVersion</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item time
X&lt;time&gt; X&lt;epoch&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T205923Z" changeid="explorer">
        <seg>=item time
X&lt;time&gt; X&lt;epoch&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>c  A signed char (8-bit) value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>c  Un valor de un carácter con signo (8 bit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlgpl&gt; and L&lt;perlartistic&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215942Z" changeid="explorer">
        <seg>Vea L&lt;perlgpl&gt; y L&lt;perlartistic&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a change to the behaviour documented for
5.10.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010730Z" changeid="explorer">
        <seg>Esto es un cambio en el comportamiento documentado para 5.10.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first delimiter is not an opening punctuation, three delimiters must
be same such as C&lt;s!!!&gt; and C&lt;tr)))&gt;, in which case the second delimiter
terminates the left part and starts the right part at once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el primer delimitador no es un carácter de puntuación de apertura, los tres delimitadores deben ser el mismo, como C&lt;s!!!&gt; y C&lt;tr)))&gt;, en cuyo caso el segundo delimitador termina la parte izquierda y, a la vez, comienza la parte derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$who = &quot;Larry&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$quien = &quot;Larry&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't get the UTF-8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No obtiene los bytes UTF-8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Safe&gt; upgraded to version 2.12</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034547Z" changeid="explorer">
        <seg>C&lt;Safe&gt; actualizado a la versión 2.12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bits;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bits;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvms&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014119Z" changeid="explorer">
        <seg>Vea L&lt;perlvms&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't turn on the compiler optimization flag &quot;-O&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101924Z" changeid="explorer">
        <seg>No active el indicador &quot;-O&quot; de optimización del compilador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item for</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232634Z" changeid="explorer">
        <seg>=item for</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try not to launch headlong into developing your module without spending
some time thinking first.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014515Z" changeid="explorer">
        <seg>Trate de no poner en marcha, de memoria, el desarrollo de su módulo, sin pasar en primer lugar algún tiempo pensándolo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it retains most of
the original content from its O'Reilly Network, it is now hosted by
The Perl Foundation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231313Z" changeid="explorer">
        <seg>Aunque conserva la mayor parte del contenido original de O'Reilly Network, ahora se hospeda en The Perl Foundation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the next directory entry for a directory opened by C&lt;opendir&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la siguiente entrada de directorio de un directorio abierto con C&lt;opendir&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\X        [4]  Match Unicode &quot;eXtended grapheme cluster&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223832Z" changeid="explorer">
        <seg>\X	 [4]  Coincide con una &quot;agrupación de grafemas eXtendida&quot; Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about the portability of these functions, see
L&lt;perlport&gt; and other available platform-specific documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información sobre la portabilidad de estas funciones, ver L&lt;perlport&gt; y cualquier otra documentación específica de la plataforma que esté disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Perl program consists of a sequence of declarations and statements
which run from the top to the bottom.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012150Z" changeid="explorer">
        <seg>Un programa Perl consiste en una secuencia de declaraciones e instrucciones que se ejecutan de arriba hacia abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX qw(strftime);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use POSIX qw(strftime);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't do that either.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco haga esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count=9</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003130Z" changeid="explorer">
        <seg>Contador=9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Attribute::Handlers</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T015042Z" changeid="explorer">
        <seg>=item Attribute::Handlers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count=2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003206Z" changeid="explorer">
        <seg>Contador=2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Supported Platforms</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015423Z" changeid="explorer">
        <seg>=head1 Plataformas soportadas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># as a sort subroutine (including other package's subroutines)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># como una subrutina para sort (incluyendo subrutinas de otros paquetes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count=3</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003145Z" changeid="explorer">
        <seg>Contador=3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators borrowed from
C keep the same precedence relationship with each other, even where
C's precedence is slightly screwy.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los operadores tomados del C mantienen la misma relación de precedencia entre sí, incluso donde la precedencia de C está ligeramente chiflada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count=1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003212Z" changeid="explorer">
        <seg>Contador=1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;&lt; (?&gt;pattern) &gt;&gt; and possessive quantifiers for other ways to
control backtracking.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T010353Z" changeid="explorer">
        <seg>Vea también C&lt;&lt; (?&gt;patrón) &gt;&gt; y los cuantificadores posesivos para ver otras formas de control de la vuelta atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context,
returns the caller's package name if there I&lt;is&gt; a caller (that is, if
we're in a subroutine or C&lt;eval&gt; or C&lt;require&gt;) and the undefined value
otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el nombre del paquete del llamante si aquel I&lt;es&gt; un llamante, es decir, si estamos en una subrutina, C&lt;eval&gt; o C&lt;require&gt;, y el valor indefinido en otro caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlunicode 	Perl Unicode support</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000416Z" changeid="explorer">
        <seg>perlunicode 	Compatibilidad con Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exit;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010011Z" changeid="explorer">
        <seg>exit;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 An Example: the NULL termination problem.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T160043Z" changeid="zipf">
        <seg>=head2 Ejemplo: el problema de la terminación de cadenas con un carácter NULL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec {'/bin/csh'} '-sh';  # pretend it's a login shell</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec {'/bin/csh'} '-sh';  # finge que es un shell de login</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -MTime::Piece -le 'print localtime-&gt;julian_day'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>$ perl -MTime::Piece -le 'print localtime-&gt;julian_day'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s![^/+]*$!man!&amp;&amp;-d&amp;&amp;!$s{$_}++&amp;&amp;push@m,$_;END{print&quot;@m&quot;}'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T011036Z" changeid="explorer">
        <seg>s![^/+]*$!man!&amp;&amp;-d&amp;&amp;!$s{$_}++&amp;&amp;push@m,$_;END{print&quot;@m&quot;}'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;Named Unary Operators&gt; for more discussion of this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;Operadores unarios con nombre&gt; para una discusión más sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exp</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Hash Randomisation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Aleatorización Hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc&gt; for more examples of
forking and reaping moribund children.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;perlipc&gt; para más ejemplos de fork y borrado de hijos moribundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add DEL to [:cntrl:]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadir DEL a [:cntrl:]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to the switch feature</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110704T234243Z" changeid="explorer">
        <seg>=item Palabras clave relativas a la característica switch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, if you want only one
of the elements, it's trivial:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193218Z" changeid="explorer">
        <seg>Bueno, si desea sólo uno de los elementos, es trivial:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Same as C&lt;S{0,1}&gt;, C&lt;S{0,BIG_NUMBER}&gt;, C&lt;S{1,BIG_NUMBER}&gt; respectively.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235820Z" changeid="explorer">
        <seg>Lo mismo que C&lt;S{0,1}&gt;, C&lt;S{0,BIG_NUMBER}&gt;, C&lt;S{1,BIG_NUMBER}&gt;, respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;i9pl&quot;, gmtime);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;i9pl&quot;, gmtime);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print($foo), exit;	# Or this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print($foo), exit;	# O esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What are Perl 4, Perl 5, or Perl 6?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T225632Z" changeid="explorer">
        <seg>=head2 ¿Qué son Perl 4, Perl 5 y Perl 6?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns C&lt;1&gt; for success, C&lt;0&gt; otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve C&lt;1&gt; en caso de éxito; de otra manera, C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Date::Calc;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225523Z" changeid="explorer">
        <seg>use Date::Calc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ord EXPR
X&lt;ord&gt; X&lt;encoding&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191933Z" changeid="explorer">
        <seg>=item ord EXPR
X&lt;ord&gt; X&lt;encoding&gt; X&lt;codificación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl5.004 builds out of the box on Unix, Plan 9, LynxOS, VMS, OS/2,
QNX, AmigaOS, and Windows NT.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl5.004 se compila en Unix, Plan 9, LynxOS, VMS, OS / 2, QNX, AmigaOS y Windows NT.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can always find the latest version of perl on a CPAN (Comprehensive Perl
Archive Network) site near you at http://www.cpan.org/src/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222615Z" changeid="explorer">
        <seg>Siempre puede encontrar la última versión de perl en un sitio CPAN (Comprehensive Perl Archive Network) cerca de usted en http://www.cpan.org/src/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$other  = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$otro   = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The earlier immediate
handling easily could corrupt the internal state of Perl, resulting
in mysterious crashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T152531Z" changeid="explorer">
        <seg>El manejo inmediato anterior podría dañar el estado interno de Perl, lo que resulta en caídas misteriosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, C&lt;*FH&gt; must be used to create new symbol table entries;
C&lt;*foo{THING}&gt; cannot.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T005613Z" changeid="explorer">
        <seg>En otras palabras, C&lt;*FH&gt; debe ser usado para crear nuevas entradas de en la tabla de símbolos; C&lt;*foo{COSA}&gt;, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is much more efficient than C&lt;s/.$//s&gt; because it neither
scans nor copies the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más eficiente que C&lt;s/.$//s&gt; porque ni escanea ni copia el string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can now specify installation directories for site and vendor man
and HTML pages, and site and vendor scripts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T181557Z" changeid="explorer">
        <seg>Ahora se pueden especificar directorios de instalación para las páginas man y HTML, y scripts para el propio equipo y para el instalador del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;File contains: &quot;, &lt;HANDLE&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El archivo contiene: &quot;, &lt;HANDLE&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$max;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232640Z" changeid="explorer">
        <seg>$max;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The difference between these two constructs is that the second one
uses a capturing group, thus shifting ordinals of backreferences
in the rest of a regular expression.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T013253Z" changeid="explorer">
        <seg>(La diferencia entre estas dos construcciones es que el segundo utiliza un grupo de captura, aumentando el número de contrareferencias en el resto de la expresión regular.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list assignment in scalar
context will translate that into the number of elements (here, the
number of times the pattern matched) and assign that to $count.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La lista de asignación en contexto escalar se traducirá en el número de elementos (en este caso, el número de veces que el patrón coincide) y los asigna a $cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to the more verbose</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232448Z" changeid="explorer">
        <seg>es equivalente al más verboso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which perhaps unexpectedly yields:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T154829Z" changeid="explorer">
        <seg>del que, inesperadamente, sale:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The multi-number v-strings like v65.66 and 65.66.67 still continue to
be v-strings in Perl 5.8.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T141555Z" changeid="explorer">
        <seg>v-strings con múltiples números como C&lt;v65.66&gt; y C&lt;65.66.67&gt; siguen siendo v-strings en Perl 5.8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.optiperl.com/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>http://www.optiperl.com/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, it's better to have:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021323Z" changeid="explorer">
        <seg>Por ejemplo, es mejor tener:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does the opposite of a C&lt;shift&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El opuesto de un C&lt;shift&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A number of regressions on VMS have been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230629Z" changeid="explorer">
        <seg>Una serie de regresiones en VMS han sido corregidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item kill SIGNAL, LIST
X&lt;kill&gt; X&lt;signal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174146Z" changeid="explorer">
        <seg>=item kill SEÑAL, LISTA
X&lt;kill&gt; X&lt;signal&gt; X&lt;señal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n = 1234;		    # decimal integer</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232259Z" changeid="explorer">
        <seg>$n = 1234;              # entero decimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perltoot&gt; and L&lt;perlobj&gt; for more about the blessing (and blessings)
of objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perltoot&gt; y L&lt;perlobj&gt; para saber más sobre bautizos (y bautizar) de objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@args = ( &quot;echo surprise&quot; );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@args = ( &quot;echo sorpresa&quot; );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?^x:foo)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T051117Z" changeid="explorer">
        <seg>(?^x:foo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 SUMMARY</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235407Z" changeid="explorer">
        <seg>=head1 RESUMEN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;h2xs&gt; implements a new option C&lt;--use-xsloader&gt; to force use of
C&lt;XSLoader&gt; even in backwards compatible modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013556Z" changeid="explorer">
        <seg>C&lt;h2xs&gt; implementa una nueva opción: C&lt;--use-xsloader&gt;, para forzar el uso de C&lt;XSLoader&gt; incluso en módulos retro-compatibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This modifier may be specified to be the default by C&lt;use locale&gt;, but
see L&lt;/Which character set modifier is in effect?&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220418Z" changeid="explorer">
        <seg>Este modificador se puede especificar que sea el predeterminado por C&lt;use locale&gt;, pero vea L&lt;/¿Qué modificador de conjunto de caracteres está en vigor?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;grep&gt;, C&lt;join&gt;, C&lt;map&gt;, C&lt;qw//&gt;, C&lt;reverse&gt;, C&lt;sort&gt;, C&lt;unpack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;grep&gt;, C&lt;join&gt;, C&lt;map&gt;, C&lt;qw/STRING/&gt;, C&lt;reverse&gt;, C&lt;sort&gt;, C&lt;unpack&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#       ensure the leading &quot;0&quot; for any octal,
           prefix non-zero hexadecimal with &quot;0x&quot; or &quot;0X&quot;,
           prefix non-zero binary with &quot;0b&quot; or &quot;0B&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051738Z" changeid="explorer">
        <seg>#       garantiza el &quot;0&quot; inicial para todos los octales,
           prefija hexadecimales no ceros con &quot;0x&quot; o &quot;0X&quot;,
           prefija binarios no cero con &quot;0b&quot; o &quot;0B&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slices in scalar context return the last item of the slice.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150207Z" changeid="explorer">
        <seg>Las porciones, en contexto escalar, devuelven el último elemento de la porción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return 1+int((((localtime(shift || time))[5] + 1899))/1000);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225523Z" changeid="explorer">
        <seg>return 1+int((((localtime(shift || time))[5] + 1899))/1000);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is an empty string, returns 0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T001632Z" changeid="explorer">
        <seg>Si EXPR es una cadena vacía, devuelve 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensive work on the v-strings by John Peacock.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T001402Z" changeid="explorer">
        <seg>Una amplia labor en la v-strings por parte de John Peacock.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is merely an alternate way of specifying input
to the program.)  You may also sell a binary produced by the dumping of
a running Perl script that belongs to you, provided that you provide or
offer to provide the Perl source as specified by the GPL.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T224421Z" changeid="explorer">
        <seg>(Esto no es más que una forma alternativa de especificar una entrada al programa.) También puede vender un binario producido por el volcado de una ejecución de un script en Perl que le pertenezca a usted, a condición de que proporcione u ofrezca una forma de proporcionar el código fuente de Perl según lo especificado por la GPL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlqnx		Perl notes for QNX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlqnx		Notas para QNX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the pattern
evaluates to the empty string, the last successfully executed regular
expression is used instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el patrón se evalúa a la cadena vacía, se utiliza en su lugar la última expresión regular ejecutada con éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the top-of-page
format is the name of the filehandle with &quot;_TOP&quot; appended.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T025741Z" changeid="explorer">
        <seg>De manera predeterminada, el formato de la parte superior de la página es el nombre del identificador de archivo con el sufijo &quot;_TOP&quot; añadido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$decimal = ord(pack('B8', '10110110'));</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225515Z" changeid="explorer">
        <seg>$decimal = ord(pack('B8', '10110110'));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 2) = 1   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 2) = 1   ==      16384 00000000000000100000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @squares = map { $_ &gt; 5 ? ($_ * $_) : () } @numbers;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171646Z" changeid="explorer">
        <seg>my @cuadrados = map { $_ &gt; 5 ? ($_ * $_) : () } @numeros;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When many separate operations will need to be applied to the
same set of data</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020218Z" changeid="explorer">
        <seg>Cuando muchas operaciones diferentes deberán aplicarse al mismo conjunto de datos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want the pattern compiled only once the first time
the variable is interpolated, use the C&lt;/o&gt; option.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea que el patrón sea compilado solo la primera vez que la variable sea interpola, utilice la opción C&lt;/o&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $foo eq &quot;Perl&quot; eq &quot;\x50\x65\x72\x6C&quot;, 32 bits</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># $foo eq &quot;Perl&quot; eq &quot;\x50\x65\x72\x6C&quot;, 32 bits</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, include a C&lt;use
v5.10&gt; or later to the current scope.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023015Z" changeid="explorer">
        <seg>O de otra forma, incluya un C&lt;use v5.10&gt; o posterior en el contexto actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Before you start</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013338Z" changeid="explorer">
        <seg>=head2 Antes de empezar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hash    =&gt;  {
                     description =&gt; &quot;key/value pairs&quot;,
                     sigil =&gt; '%',
                    },</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T214418Z" changeid="explorer">
        <seg>hash    =&gt;  {
                     descripcion =&gt; &quot;pares clave/valor&quot;,
                     sigilo =&gt; '%',
                    },</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failed Test                  Stat Wstat Total Fail  Failed  List of Failed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T002200Z" changeid="explorer">
        <seg>Test erróneos                Stat Wstat Total Error Errado  Lista de errores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, while
utilities have &quot;USAGE&quot; sections, Perl modules usually have &quot;SYNOPSIS&quot;
sections: C&lt;podselect -s &quot;SYNOPSIS&quot; ...&gt; will extract this section for
a given file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233445Z" changeid="explorer">
        <seg>Por ejemplo, a diferencia de las utilidades que tienen secciones &quot;USAGE&quot;, los módulos Perl generalmente tienen secciones &quot;SYNOPSIS&quot; (SINOPSIS): C&lt;podselect -s &quot;SYNOPSIS&quot; ...&gt; extrae la sección correspondiente de un archivo especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They're visible only in their lexical scope, but their value is
persistent: unlike C&lt;my&gt; variables, they're not undefined at scope entry,
but retain their previous value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T000416Z" changeid="explorer">
        <seg>Son visibles sólo en su ámbito léxico, pero su valor es persistente: a diferencia de las variables C&lt;my&gt;, que no están definidos a la entrada de su ámbito, sino que conservan su valor anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They may appear to sleep longer than that,
however, because your process might not be scheduled right away in a
busy multitasking system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, quizás puedan parecer dormir más de lo indicado, debido a que su proceso no puede ser planificado de forma inmediata en un sistema multitarea ocupado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12756</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12756</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a filter has been installed with this method, it will be invoked
every time you write a value to a DBM database.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110812T144634Z" changeid="zipf">
        <seg>Si se ha instalado un filtro con este método, se invocará cada vez que se escriba un valor en una base de datos DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($vec,$_,1) = 1 if $ints[$_];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>vec($vec,$_,1) = 1 if $ints[$_];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;threads&gt; is now a dual-life module, also available on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005353Z" changeid="explorer">
        <seg>C&lt;threads&gt; es ahora un módulo con doble vida, también disponible en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match exactly n times, not greedily (redundant)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042906Z" changeid="explorer">
        <seg>Coincide exactamente n veces, sin avaricia (redundante)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a_or_b ? $a : $b) = $c;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054051Z" changeid="explorer">
        <seg>($a_o_b ? $a : $b) = $c;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't have write access to the DBM file, you can only read hash
variables, not set them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no tiene permiso de escritura al archivo DBM, sólo podrá leer las variables hash, pero no asignarlas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is not produced nor maintained by the
Free Software Foundation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200429Z" changeid="explorer">
        <seg>La Free Software Foundation no tiene nada que ver con el desarrollo y el mantenimiento de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Individual modules in F&lt;lib/&gt;, F&lt;ext/&gt;, F&lt;dist/&gt;, and F&lt;cpan/&gt;
usually have their own documentation, either in the F&lt;Module.pm&gt; file or an
accompanying F&lt;Module.pod&gt; file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014751Z" changeid="explorer">
        <seg>En general, los módulos individuales de F&lt;lib/&gt;, F&lt;ext/&gt;, F&lt;dist/&gt; y F&lt;cpan/&gt; tienen su propia documentación, ya sea en el archivo F&lt;Módulo.pm&gt; o en un archivo F&lt;Módulo.pod&gt; adjunto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See http://www.cpan.org/modules/00modlist.long.html or
http://search.cpan.org/ for a more complete list of modules by
category.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230206Z" changeid="explorer">
        <seg>En http://www.cpan.org/modules/00modlist.long.html y http://search.cpan.org/ encontrará una lista más completa de módulos clasificados por categorías.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length of OPSTRING 
implies the number of semaphore operations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La longitud de OPSTRING implica el número de operaciones de semáforos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some literature this construct is called &quot;atomic matching&quot; or
&quot;possessive matching&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T222018Z" changeid="explorer">
        <seg>En alguna literatura esta construcción es llamada &quot;coincidencia atómica&quot; o &quot;concordancia posesiva&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.                   a single character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055609Z" changeid="explorer">
        <seg>.                   un solo carácter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This entered computer lingo via the paper &quot;On Holy Wars and a Plea for
Peace&quot; by Danny Cohen, USC/ISI IEN 137, April 1, 1980.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto entró en la jerga informática a través del documento &quot;On Holy Wars and a Plea for Peace&quot; (De las Guerras Santas y un llamamiento por la Paz), de Danny Cohen, USC/ISI IEN 137, 1 de abril de 1980.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Alphabetical Listing of Perl Functions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015652Z" changeid="explorer">
        <seg>=head2 Lista de funciones de Perl en orden alfabético</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>introduce the -t option for gentler taint checking</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>introducir la opción -t para un control de seguridad aceitoso más suave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getc FILEHANDLE
X&lt;getc&gt; X&lt;getchar&gt; X&lt;character&gt; X&lt;file, read&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010712Z" changeid="explorer">
        <seg>=item getc IDENTIFICADOR_ARCHIVO
X&lt;getc&gt; X&lt;getchar&gt; X&lt;character&gt; X&lt;file, read&gt; X&lt;archivo, lectura&gt; X&lt;carácter&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise it returns false (specifically, the empty string).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, devuelve falso (en concreto, la cadena vacía).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Semicolon omitted in &quot;short&quot; one-line BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Punto y coma omitido en BLOQUE &quot;pequeño&quot; de una sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's operator overloading facility is completely ignored here.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232317Z" changeid="explorer">
        <seg>Se omite completamente la funcionalidad de sobrecarga de operadores de Perl,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Perl variable types</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233922Z" changeid="zipf">
        <seg>=head2 Tipos de variables de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print @AoA;		# WRONG</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193252Z" changeid="explorer">
        <seg>print @AoA;		# MAL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Constant subroutines</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013950Z" changeid="explorer">
        <seg>=head2 Subrutinas constantes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldelta		Perl changes since previous version</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldelta		Cambios desde la versión anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is often more readable to use the C&lt;&lt; =&gt; &gt;&gt; operator between key/value
pairs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A menudo es más legible usar el operador C&lt;&lt; =&gt; &gt;&gt; entre los pares clave / valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but a string consisting of two null bytes (the result of C&lt;&quot;\020\020&quot;
&amp; &quot;\101\101&quot;&gt;) is not a false value in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225517Z" changeid="explorer">
        <seg>but a string consisting of two null bytes (the result of C&lt;&quot;\020\020&quot;
&amp; &quot;\101\101&quot;&gt;) is not a false value in Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;Always&gt; close the handle
yourself and inspect the return value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T000950Z" changeid="explorer">
        <seg>I&lt;Siempre&gt; cierre el C&lt;handle&gt; e inspeccione el valor devuelto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Range Operators
X&lt;operator, range&gt; X&lt;range&gt; X&lt;..&gt; X&lt;...&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001023Z" changeid="explorer">
        <seg>=head2 Operadores de rango
X&lt;operator, range&gt; X&lt;range&gt; X&lt;..&gt; X&lt;...&gt; X&lt;operador, rango&gt; X&lt;rango&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;2: got $1\n&quot; if $y =~ /^(ABC)(?!123)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170213Z" changeid="explorer">
        <seg>print &quot;2: tenemos $1\n&quot; if $y =~ /^(ABC)(?!123)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># blank line between header and body</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># línea en blanco entre cabecera y cuerpo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting from a C&lt;tied&gt; hash
or array may not necessarily return anything; it depends on the implementation
of the C&lt;tied&gt; package's DELETE method, which may do whatever it pleases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Borrando de un hash o array C&lt;enlazado&gt; no necesariamente devolverá algo; depende de la implementación del método DELETE en el paquete C&lt;enlazado&gt;, que puede hacer lo que quiera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get somewhat similar but locale-dependent date strings, set up your
locale environment variables appropriately (please see L&lt;perllocale&gt;) and
try for example:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215401Z" changeid="explorer">
        <seg>Para obtener algo similar, pero con cadenas de fecha dependiente de la configuración región, ajuste apropiadamente sus variables de entorno a la región (por favor, vea L&lt;perllocale&gt;) e intente, por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item XEmacs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item XEmacs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;\tgot sentence %d: &lt;%s&gt;\n&quot;, ++$count, $1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025836Z" changeid="explorer">
        <seg>printf &quot;\tnueva sentencia %d: &lt;%s&gt;\n&quot;, ++$cuenta, $1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(($foo &amp; 255) + 1, &quot;\n&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(($foo &amp; 255) + 1, &quot;\n&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$pattern = &quot;foobar&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234632Z" changeid="explorer">
        <seg>$patron = &quot;foobar&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $z      = substr $s, -4, 2;     # tr</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $z      = substr $s, -5, 2;     # ve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, including instructions for other platforms such as
Windows and Mac OS, read L&lt;perlrun&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224657Z" changeid="explorer">
        <seg>Para obtener más información e instrucciones para otras plataformas, como Windows y Mac OS, lea L&lt;perlrun&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no string is specified
via the C&lt;=~&gt; or C&lt;!~&gt; operator, the $_ string is searched.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se especifica una cadena vía los operadores C&lt;=~&gt; o C&lt;!~&gt;, se busca en la cadena $_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 4) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 4) = 2   ==     131072 00000000000000000100000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># either write TO_KID or else read FROM_KID</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005947Z" changeid="explorer">
        <seg># o escribo AL_HIJO o leo DESDE_EL_HIJO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@counts = ( scalar @a, scalar @b, scalar @c );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contadores = ( scalar @a, scalar @b, scalar @c );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>refers to such a Package if it has not been
modified, or has been modified in accordance with the wishes of the
Copyright Holder as specified below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>se refiere a un paquete, si no ha sido modificado o ha sido modificado de conformidad con los deseos del propietario del Titular del Copyright tal como se especifica a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recommended reading is &quot;The Absolute
Minimum Every Software Developer Absolutely, Positively Must Know About Unicode
and Character Sets (No Excuses!)&quot; by Joel Spolsky, at
L&lt;http://joelonsoftware.com/articles/Unicode.html&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234219Z" changeid="explorer">
        <seg>Para adquirir estos conocimientos básicos, es recomendable leer el artículo &quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&quot; de Joel Spolsky, en
L&lt;http://joelonsoftware.com/articles/Unicode.html&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$~ = 'Something';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$~ = 'Algo';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a 4-byte integer
0x12345678 (305419896 decimal) would be ordered natively (arranged in and
handled by the CPU registers) into bytes as</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, un entero de 4 bytes 0x12345678 (305419896 en decimal) se ordenaría nativamente (dispuesto en y manejado por los registros de la CPU) en bytes como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a, $b, @rest) = split;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a, $b, @resto) = split;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$header =~ s/\n(?=\s)//g;  # fix continuation lines</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$encabezado =~ s/\n(?=\s)//g;  # arregla la continuación de líneas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub prompt { print &quot;yes?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub prompt { print &quot;¿si?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:-) Larry now uses &quot;Perl&quot; to
signify the language proper and &quot;perl&quot; the implementation of it, i.e.
the current interpreter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231425Z" changeid="explorer">
        <seg>:-) Larry usa &quot;Perl&quot; para designar el lenguaje y &quot;perl&quot; para designar su implementación (es decir, el intérprete).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to these
changes, lots of work took place in integrating threads, PerlIO, and
Unicode; general code cleanup; and last but not least porting to
non-Unix lands such as Win32, VMS, Cygwin, DJGPP, VOS, MacOS Classic,
and EBCDIC.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de estos cambios, mucho trabajo se llevó a cabo en la integración de I&lt;threads&gt;, PerlIO, y Unicode; limpieza general del código, y por último, pero no menos importante, portar a los no-Unix, tales como Win32, VMS, Cygwin, DJGPP, VOS, Mac OS Classic, y EBCDIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>compactDump =&gt; 1,  # comment these two lines out</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032236Z" changeid="explorer">
        <seg>compactDump =&gt; 1,  # comentar estas dos líneas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't bother.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181236Z" changeid="zipf">
        <seg>No es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Build system</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014849Z" changeid="explorer">
        <seg>=head2 Sistema de compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$_&gt; is lexical in the scope where the C&lt;map&gt; appears (because it has
been declared with C&lt;my $_&gt;), then, in addition to being locally aliased to
the list elements, C&lt;$_&gt; keeps being lexical inside the block; that is, it
can't be seen from the outside, avoiding any potential side-effects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$_&gt; es léxico en el ámbito cuando el C&lt;map&gt; aparece (porque se ha declarado con C&lt;my $_&gt;), entonces, además de ser un alias local a los elementos de la lista, C&lt;$_&gt; sigue siendo léxico dentro del bloque, es decir, no puede ser visto desde el exterior, evitando cualquier potencial efecto secundario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
the current implementation, no temporary array is created when the
range operator is used as the expression in C&lt;foreach&gt; loops, but older
versions of Perl might burn a lot of memory when you write something
like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la implementación actual, no se crea ningún array temporal cuando el operador rango es usado como expresión en los bucles C&lt;foreach&gt;, pero versiones anteriores de Perl pueden quemar una gran cantidad de memoria cuando se escribe algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$days		# the simple scalar value &quot;days&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$dias		# el valor escalar único llamado &quot;dias&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod&gt; for details on this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod&gt; para detalles sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checks whether the pattern matches (or does not match, for the '!'
variants).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213422Z" changeid="explorer">
        <seg>Comprueba si el patrón coincide (o no coincide, con las variantes '!').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The higher-level loops preserve an additional state between iterations:
whether the last match was zero-length.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T232200Z" changeid="explorer">
        <seg>Los bucles de alto nivel preservan un estado adicional entre las iteraciones: cuándo la última coincidencia fue de longitud cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the current arguably broken state of C&lt;__DIE__&gt; hooks, you
may wish not to trigger any C&lt;__DIE__&gt; hooks that user code may have installed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido al posible mal estado de la llamada C&lt;__DIE__&gt;, quizás deseé no activar ninguna de las llamadas C&lt;__DIE__&gt; que el código de usuario puede haber instalado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CPAN has several JAPH programs at http://www.cpan.org/misc/japh .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232043Z" changeid="explorer">
        <seg>En CPAN encontrará varios programas JAPH, en http://www.cpan.org/misc/japh.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The defaults
are there for lazy systems programmers writing one-shot programs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores por defecto son para los programadores de sistemas perezosos escribiendo programas pequeños.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The inheritance hierarchy of the C&lt;B::&gt; modules has been corrected;
C&lt;B::NV&gt; now inherits from C&lt;B::SV&gt; (instead of C&lt;B::IV&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T024150Z" changeid="explorer">
        <seg>La jerarquía de la herencia de los módulos C&lt;B::&gt; ha sido corregida; C&lt;B::NV&gt; ahora hereda desde C&lt;B::SV&gt; (en lugar de C&lt;B::IV&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most importantly, choose modules which are as stable as possible.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030130Z" changeid="explorer">
        <seg>Lo más importante es elegir los módulos que sean lo más estables posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 10.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>b) the &quot;Artistic License&quot; which comes with this Kit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>b) la &quot;Licencia Artística&quot; que viene con este equipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\c^      chr(30)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034755Z" changeid="explorer">
        <seg>\c^      chr(30)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a socket gets closed by the server while printing to it, the client
now gets a SIGPIPE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171054Z" changeid="explorer">
        <seg>Si un I&lt;socket&gt; es cerrado por el servidor mientras se está imprimiendo en él, el cliente recibe ahora una SIGPIPE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*)\b(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110905T003446Z" changeid="explorer">
        <seg>(.*)\b(\d+)$ &lt;Tengo 2 números: &gt; &lt;53147&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a C&lt;bless&gt; is often the last thing in a constructor,
it returns the reference for convenience.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como un C&lt;bless&gt; a menudo es la última cosa de un constructor, devuelve la referencia por conveniencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is distributed
in releases and comes in well-defined packages.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231018Z" changeid="explorer">
        <seg>Se distribuye en versiones y se proporciona en paquetes bien definidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with value &gt;= 4252.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004828Z" changeid="explorer">
        <seg>with value &gt;= 4252.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class implementing a hash should have the following methods:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una clase que implementa un hash debe tener los siguientes métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The I&lt;length-item&gt; is not returned explicitly from C&lt;unpack&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La I&lt;longitud-item&gt; no se devuelve de forma explícita desde C&lt;unpack&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, that's because the rule is that on adjacent brackets only (whether
square or curly), you are free to omit the pointer dereferencing arrow.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bueno, eso es porque la regla dice que sólo en los corchetes o llaves adyacentes, es libre de omitir la flecha de referencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;pod2man|pod2man&gt; and L&lt;pod2text|pod2text&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233356Z" changeid="explorer">
        <seg>=item L&lt;pod2man|pod2man&gt; y L&lt;pod2text|pod2text&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appeal to their self interest!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232141Z" changeid="explorer">
        <seg>Hágales ver que es por su propio interés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whatever happens in the RE engine might be better discussed in L&lt;perlre&gt;,
but for the sake of continuity, we shall do so here.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pase lo que pase en el motor de RE podría estar mejor explicado en L&lt;perlre&gt;, pero en aras de la continuidad, lo haremos aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can always switch mode mid-format with an explicit 
C&lt;C0&gt; or C&lt;U0&gt; in the format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre puede cambiar de modo con un explícito C&lt;C0&gt; o C&lt;U0&gt; en mitad del formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>has meant since Perl 5.6.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T141455Z" changeid="explorer">
        <seg>ha significado desde Perl 5.6.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;eof()&gt;
with empty parentheses is different.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar C&lt;eof()&gt; con paréntesis vacíos es diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise if
FILEHANDLE is an expression, its value is the real filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T001340Z" changeid="explorer">
        <seg>De lo contrario, si IDENTIFICADOR_ARCHIVO es una expresión, su valor es el identificador de archivo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may want to
call L&lt;seek|/&quot;seek FILEHANDLE,POSITION,WHENCE&quot;&gt; before writing to the file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013407Z" changeid="explorer">
        <seg>Puede llamar a L&lt;seek|/&quot;seek IDENTIFICADOR_ARCHIVO,POSICIÓN,DESDE&quot;&gt; antes de escribir al archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a[$i] = $y         splice(@a,$i,1,$y)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a[$i] = $y         splice(@a,$i,1,$y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provide links to further information (URL, email)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014022Z" changeid="explorer">
        <seg>Ofrezca enlaces a información adicional (URL, correo electrónico)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value is passed
direct as the parameter I&lt;kflags&gt; to C&lt;hv_common()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114140Z" changeid="explorer">
        <seg>El valor es pasado directamente como el parámetro I&lt;kflags&gt; a C&lt;hv_common()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is yet another way to print your environment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay otra forma de imprimir su entorno:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each plugin should register itself with C&lt;Perl_mro_register&gt; by providing
the following structure</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114525Z" changeid="explorer">
        <seg>Cada complemento debe registrarse con C&lt;Perl_mro_register&gt; proporcionando la siguiente estructura</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = 'pq';  print $x,&quot;\n&quot;;    # prints 5pq9</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = 'pq';  print $x,&quot;\n&quot;;    # imprime 5pq9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &lt;$f&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &lt;$f&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl591delta - what is new for perl v5.9.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl591delta - qué hay de nuevo en perl v5.9.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It means &quot;use the standard size for a Perl
integer or floating-point number&quot;, which is the default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa &quot;usar el tamaño estándar de un entero Perl o punto de número de coma flotante&quot;, que es el predeterminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-z  File has zero size (is empty).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004620Z" changeid="explorer">
        <seg>-z  Archivo tiene tamaño cero (está vacío).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can dispense with numbers altogether and create named capture groups.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002401Z" changeid="explorer">
        <seg>Puede prescindir de los números y crear grupos de captura con nombres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And the tables used by hashes (sometimes called
&quot;associative arrays&quot;) grow as necessary to prevent degraded
performance.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001050Z" changeid="explorer">
        <seg>Y las tablas usadas por los hashes (a veces denominados &quot;arrays asociativos&quot;) se expanden cuando es necesario para que el rendimiento no se vea afectado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use sigtrap&gt; and even C&lt;use diagnostics&gt; pragmas
may also prove useful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El pragma C&lt;use sigtrap&gt; e incluso el C&lt;use diagnostics&gt; pueden ser también muy útiles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is an incompatibility in
OpenBSD's C&lt;getprotobyname_r&gt; and C&lt;getservbyname_r&gt; function in versions 3.7
and later that will cause a SEGV when called without doing a C&lt;bzero&gt; on
their return structs prior to calling these functions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T151118Z" changeid="explorer">
        <seg>Existe una incompatibilidad en las funciones de OpenBSD C&lt;getprotobyname_r&gt; y C&lt;getservbyname_r&gt; en las versiones 3.7 y superiores que causarán un SEGV cuando se llamen sin haber hecho antes un C&lt;bzero&gt; en sus estructuras de retorno antes de llamar a estas funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the C&lt;(*SKIP:NAME)&gt; pattern has special significance.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T011228Z" changeid="explorer">
        <seg>El nombre del patrón C&lt;(*SKIP:NOMBRE)&gt; tiene un significado especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;ptardiff&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013323Z" changeid="explorer">
        <seg>=head2 C&lt;ptardiff&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 When shouldn't I program in Perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231050Z" changeid="explorer">
        <seg>=head2 ¿Cuándo no debo elegir Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;atan2(0, i)&gt; now works, as do all the (computable) complex argument cases</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033122Z" changeid="explorer">
        <seg>C&lt;atan2(0, i)&gt; ahora funciona, así como todos los casos (computables) de argumentos complejos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means, for example, that C&lt;-f($file).&quot;.bak&quot;&gt; is
equivalent to C&lt;-f &quot;$file.bak&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234937Z" changeid="explorer">
        <seg>Esto significa, por ejemplo, que C&lt;-f($archivo).&quot;.bak&quot;&gt; es equivalente a C&lt;-f &quot;$file.bak&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bugfix related to the handling of the C&lt;/m&gt; modifier and C&lt;qr&gt; resulted
in a change of behaviour between 5.8.x and 5.10.0:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190917Z" changeid="explorer">
        <seg>Una corrección de errores relacionados con el manejo del modificador C&lt;/m&gt; y C&lt;qr&gt; resultó en un cambio de comportamiento entre 5.8.x y 5.10.0:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;pack&gt;, C&lt;read&gt;, C&lt;syscall&gt;, C&lt;sysread&gt;, C&lt;syswrite&gt;, C&lt;unpack&gt;, C&lt;vec&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;pack&gt;, C&lt;read&gt;, C&lt;syscall&gt;, C&lt;sysread&gt;, C&lt;syswrite&gt;, C&lt;unpack&gt;, C&lt;vec&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;$+&gt; X&lt;$^N&gt; X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;$+&gt; X&lt;$^N&gt; X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General Perl style guide</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031932Z" changeid="explorer">
        <seg>Guía de estilo general programación Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcheat		Perl cheat sheet</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000222Z" changeid="explorer">
        <seg>perlcheat		Referencia rápida de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>login( $username =&gt; $password );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>login( $usuario =&gt; $contraseña );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Probably only the first of these
is what you want:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003527Z" changeid="explorer">
        <seg>Probablemente le valga con algunos de estos ejemplos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These modifiers do not carry over into named subpatterns called in the
enclosing group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T231612Z" changeid="explorer">
        <seg>Estos modificadores no se transfieren a sub-patrones nominados en el grupo que los envuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item last LABEL
X&lt;last&gt; X&lt;break&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174200Z" changeid="explorer">
        <seg>=item last ETIQUETA
X&lt;last&gt; X&lt;break&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/reg_posixcc.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010038Z" changeid="explorer">
        <seg>=item t/op/reg_posixcc.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $BASE = 8;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225604Z" changeid="explorer">
        <seg>my $BASE = 8;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make install</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make install</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$year&gt; is the number of years since 1900, B&lt;not&gt; just the last two digits
of the year.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000209Z" changeid="explorer">
        <seg>C&lt;$anno&gt; es el número de años desde 1900, B&lt;no&gt; sólo los dos últimos dígitos del año.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;feature&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005450Z" changeid="explorer">
        <seg>=item C&lt;feature&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, if the left operand is enclosed in
parentheses or is a list formed by C&lt;qw/STRING/&gt;, it repeats the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, si el operando de la izquierda se encierra entre paréntesis o es una lista formada por C&lt;qw/CADENA/&gt;, repite la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously it would erroneously turn off all warnings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T043848Z" changeid="explorer">
        <seg>Anteriormente, desactivaría erróneamente todas las advertencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at bzzzt line 201.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at bzzzt line 201.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Quote and Quote-like Operators
X&lt;operator, quote&gt; X&lt;operator, quote-like&gt; X&lt;q&gt; X&lt;qq&gt; X&lt;qx&gt; X&lt;qw&gt; X&lt;m&gt;
X&lt;qr&gt; X&lt;s&gt; X&lt;tr&gt; X&lt;'&gt; X&lt;''&gt; X&lt;&quot;&gt; X&lt;&quot;&quot;&gt; X&lt;//&gt; X&lt;`&gt; X&lt;``&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;
X&lt;escape sequence&gt; X&lt;escape&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185057Z" changeid="explorer">
        <seg>=head2 Comillas y Operadores de comillas
X&lt;operator, quote&gt; X&lt;operator, quote-like&gt; X&lt;q&gt; X&lt;qq&gt; X&lt;qx&gt; X&lt;qw&gt; X&lt;m&gt;
X&lt;qr&gt; X&lt;s&gt; X&lt;tr&gt; X&lt;'&gt; X&lt;''&gt; X&lt;&quot;&gt; X&lt;&quot;&quot;&gt; X&lt;//&gt; X&lt;`&gt; X&lt;``&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;
X&lt;escape sequence&gt; X&lt;escape&gt; X&lt;escapado&gt; X&lt;operador, comilla&gt; X&lt;operador, entrecomillado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new class of variables has been introduced.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T000213Z" changeid="explorer">
        <seg>Una nueva clase de variables ha sido introducida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>show @AoA;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032348Z" changeid="explorer">
        <seg>show @AoA;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./configure.gnu --prefix=/boot/home/config</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>./configure.gnu --prefix=/boot/home/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following rules apply:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se aplica las siguientes reglas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus it breaks up
                   characters into their UTF-8 bytes, so you may end up
                   with malformed pieces of UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T044621Z" changeid="explorer">
        <seg>Por lo tanto, rompe
                   los caracteres UTF-8 en sus respectivos bytes, por lo
                   que puede terminar con partes incorrectas de UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = (</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225618Z" changeid="explorer">
        <seg>%hash = (</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use customre;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045921Z" changeid="explorer">
        <seg>use customre;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%-8s %s\n&quot;, $user, $home;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%-8s %s\n&quot;, $user, $home;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub backwards { $b cmp $a }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub al_reves { $b cmp $a }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot;, &quot;judy&quot;, ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot;, &quot;judy&quot;, ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other values are true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todos los demás valores son verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getgrent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getgrent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likely candidates are: &quot;op/stat&quot;, &quot;lib/io_pipe&quot;,
&quot;lib/io_sock&quot;, &quot;lib/io_udp&quot; and &quot;lib/time&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020122Z" changeid="explorer">
        <seg>Los candidatos probables son: &quot;op/stat&quot;, &quot;lib/io_pipe&quot;, &quot;lib/io_sock&quot;, &quot;lib/io_udp&quot; y &quot;lib/time&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item perl Build.PL</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025000Z" changeid="explorer">
        <seg>=item perl Build.PL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n}         Match exactly n times</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042652Z" changeid="explorer">
        <seg>{n}	Coincide exactamente n veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a // $b</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015123Z" changeid="explorer">
        <seg>$a // $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array indices start with 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los índices de array empiezan por 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perldiag&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112347Z" changeid="explorer">
        <seg>Vea L&lt;perldiag&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;state&gt; is available only if the C&lt;&quot;state&quot;&gt; feature is enabled.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022235Z" changeid="explorer">
        <seg>C&lt;state&gt; solo está disponible si está activa la característica C&lt;&quot;state&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the name of a file; an existing file NEWNAME will be
clobbered.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia el nombre de un archivo; un archivo existente que se llame NOMBRE_NUEVO será sobreescrito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;Permissions are %04o\n&quot;, S_IMODE($mode), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Permisos son %04o\n&quot;, S_IMODE($modo), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array   Regex     array grep               grep /$b/, @$a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Array       Regex      grep array                       grep /$b/, @$a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But you can use perl anyway.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222743Z" changeid="explorer">
        <seg>Pero puede usar perl, de todos modos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
are our best guesses at the moment: we reserve the right to rethink.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T013518Z" changeid="explorer">
        <seg>Estas son nuestras mejores estimaciones por el momento: nos reservamos el derecho de reconsiderarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 4) = 2   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 4) = 2   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Where can I get information on Perl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230227Z" changeid="explorer">
        <seg>=head2 ¿Dónde puedo obtener información sobre Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The STDIN filehandle used by the command is inherited from Perl's STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T021154Z" changeid="explorer">
        <seg>El identificador de archivo STDIN utilizado por el comando se hereda del STDIN de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both OFFSET and LENGTH are omitted, removes everything.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ambos DESPLAZAMIENTO y LONGITUD se omiten, quita todo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># short 12, zero fill to position 4, long 34</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un 12 short, relleno con ceros a la posición 4, un 34 long</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in C, the scalar assignment operator produces a valid lvalue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203531Z" changeid="explorer">
        <seg>A diferencia de C, el operador de asignación escalar produce un I&lt;ivalor&gt; válido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILENAME is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite NOMBRE_DIRECTORIO, utiliza C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some documentation typo fixes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas correcciones ortográficas en la documentación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(SPLAT, &quot;stuff&quot;)   || die &quot;can't open stuff: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031253Z" changeid="explorer">
        <seg>open(SPLAT, &quot;stuff&quot;)   || die &quot;no puedo abrir stuff: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Quantifier Form     Bracketing Form</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232318Z" changeid="explorer">
        <seg>Forma Cuantificador Forma con paréntesis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;a3/A A*&quot;, &quot;007 Bond  J &quot;)       gives (&quot; Bond&quot;, &quot;J&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;a3/A A*&quot;, &quot;007 Bond  J &quot;)       da (&quot; Bond&quot;, &quot;J&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be honest about possible disadvantages
to your choice of Perl since any choice has trade-offs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232544Z" changeid="explorer">
        <seg>Sea honesto y admita posibles desventajas de elegir Perl. Al fin y al cabo, toda elección conlleva ventajas y desventajas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;/a&gt;
X&lt;/aa&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000351Z" changeid="explorer">
        <seg>X&lt;/a&gt;
X&lt;/aa&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it has no direct equivalent in C, Perl's C&lt;//&gt; operator is related
to its C-style or.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A pesar de que no tiene equivalente directo en C, el operador Perl C&lt;//&gt; está relacionado con el operador or del C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the sine of EXPR (expressed in radians).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el seno de EXPR (expresado en radianes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes a block is delimited by the file containing it (in the case
of a required file, or the program as a whole), and sometimes a block
is delimited by the extent of a string (in the case of an eval).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas veces un bloque está delimitado por el archivo que lo contiene (en el caso de un archivo requerido, o el programa entero) y otras veces un bloque está delimitado por la extensión de una cadena (en el caso de un C&lt;eval&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the C&lt;use&gt; function, of which C&lt;no&gt; is the opposite.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver la función C&lt;use&gt;, de la cuál C&lt;no&gt; es lo opuesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>object-oriented programming</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>programación orientada a objetos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is
considered a symbolic reference, so C&lt;use strict &quot;refs&quot;&gt; should I&lt;not&gt; be
in effect.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T001418Z" changeid="explorer">
        <seg>(Esto se considera una referencia simbólica, por lo que C&lt;use strict &quot;refs&quot;&gt; I&lt;no&gt; debe estar activado.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may make and give away verbatim copies of the source form of the
Standard Version of this Package without restriction, provided that you
duplicate all of the original copyright notices and associated disclaimers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede hacer y regalar copias literales del contenido original de la Versión Estándar de este Paquete sin restricciones, siempre que se dupliquen todos los avisos de copyright y las renuncias asociadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a mailbox appender for BSD systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es un agregador de correo para sistemas BSD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subtests 9 and 18 of lib/Net/Ping/t/450_service.t, and the
subtest 2 of lib/Net/Ping/t/510_ping_udp.t might fail if you have
an unusual networking setup.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T002701Z" changeid="explorer">
        <seg>Los subtests 9 y 18 de lib/Net/Ping/t/450_service.t, y el subtest 2 de lib/Net/Ping/t/510_ping_udp.t pueden fallar si usted tiene una inusual configuración de red.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;map&gt; in void context is no longer expensive.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170930Z" changeid="explorer">
        <seg>C&lt;map&gt; en contexto vacío ya no es oneroso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single-quoted, literal string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un entrecomillado simple, una cadena de caracteres literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl593delta	Perl changes in version 5.9.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl593delta	Cambios en la versión 5.9.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$some_dir/$_\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$algun_dir/$_\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See C&lt;i&gt; under L&lt;/Modifiers&gt; above.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003907Z" changeid="explorer">
        <seg>Vea C&lt;i&gt; bajo L&lt;/Modificadores&gt;, más arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl
has no way of checking whether the value passed to C&lt;unpack()&gt;
corresponds to a valid memory location, passing a pointer value that's
not known to be valid is likely to have disastrous consequences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que Perl no tiene manera de comprobar si el valor pasado a C&lt;unpack()&gt; corresponde a una ubicación de memoria válida, pasando un valor de puntero que no se sabe de su validez, puede tener consecuencias desastrosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Otherwise, if C&lt;use locale&gt; is in effect</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174844Z" changeid="explorer">
        <seg>=item De lo contrario, si C&lt;use locale&gt; está activo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;-s/a/b/&gt; does not do a negated substitution.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;-s/a/b/&gt; no realiza una substitución negada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may not even need to write the module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014543Z" changeid="explorer">
        <seg>Puede que ni siquiera tenga que escribir el módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is CPAN?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225949Z" changeid="explorer">
        <seg>¿Qué es CPAN?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the $comment field is unsupported,
it is an empty scalar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el campo $comentario no está soportado, es un escalar vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;!~&quot; is just like &quot;=~&quot; except the return value is negated in
the logical sense.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;!~&quot; es justo como &quot;=~&quot; excepto que el valor de retorno es negado, en el sentido lógico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item require EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item require EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my (@AoA, $i);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my (@AoA, $i);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;Test::Simple&gt;, L&lt;Test::Inline&gt;, L&lt;Carp::Assert&gt;, L&lt;Test::More&gt;, L&lt;Test::MockObject&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T032047Z" changeid="explorer">
        <seg>L&lt;Test::Simple&gt;, L&lt;Test::Inline&gt;, L&lt;Carp::Assert&gt;, L&lt;Test::More&gt;, L&lt;Test::MockObject&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -V:byteorder</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ perl -V:byteorder</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 suidperl less insecure</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T015011Z" changeid="explorer">
        <seg>=head2 suidperl menos inseguro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\N        [7]  Any character but \n (experimental).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224852Z" changeid="explorer">
        <seg>\N        [7]  Cualquier carácter excepto \n (experimental)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Writable\n&quot; if -w _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Escribible\n&quot; if -w _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The various named unary operators are treated as functions with one
argument, with optional parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los distintos operadores unarios con nombre son tratados como funciones con un argumento, con paréntesis opcionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrun&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001515Z" changeid="explorer">
        <seg>Vea L&lt;perlrun&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it
exits the current subroutine (losing any changes set by local()) and
immediately calls in its place the named subroutine using the current
value of @_.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En cambio, sale de la subrutina actual (perdiendo cualquier cambio hecho por local()) e inmediatamente llama a la subrutina indicada pasandole el valor actual de @_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Digest::SHA&gt; is a module used to calculate many types of SHA digests,
has been included for SHA support in the CPAN module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013539Z" changeid="explorer">
        <seg>C&lt;Digest::SHA&gt; es un módulo usado para calcular cuántos tipos de resúmenes SHA, han sido incluidos para el soporte SHA en el módulo de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certain Perl core C APIs like cxinc and regatom are no longer
available at all to code outside the Perl core of the Perl core
extensions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T001755Z" changeid="explorer">
        <seg>Ciertas API de C del núcleo de Perl, como cxinc y regatom ya no están disponibles en todo el código que esté fuera del núcleo principal de las extensiones de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for the C&lt;-A&gt; command-line switch has changed; it now accepts
an optional module name, defaulting to C&lt;assertions::activate&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200001Z" changeid="explorer">
        <seg>La sintaxis del comando C&lt;-A&gt; ha cambiado; ahora acepta un nombre de un módulo opcional, por defecto C&lt;assertions::activate&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>53401</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>53401</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;/e&gt; will cause the
replacement portion to be treated as a full-fledged Perl expression
and evaluated right then and there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;/e&gt; hará que la parte de reemplazo sea tratada como una verdadera expresión Perl y evaluada ahí y en ese mismo momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;O_RDONLY&gt; X&lt;O_RDWR&gt; X&lt;O_WRONLY&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;O_RDONLY&gt; X&lt;O_RDWR&gt; X&lt;O_WRONLY&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item m
X&lt;/m&gt; X&lt;regex, multiline&gt; X&lt;regexp, multiline&gt; X&lt;regular expression, multiline&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222635Z" changeid="explorer">
        <seg>=item m
X&lt;/m&gt; X&lt;regex, multiline&gt; X&lt;regexp, multiline&gt; X&lt;regular expression, multiline&gt; X&lt;regex, multilínea&gt; X&lt;expresión regular, multilínea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>../lib/sort.t                   0   138   119   72  60.50%  48-119</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055026Z" changeid="explorer">
        <seg>../lib/sort.t                   0   138   119   72  60.50%  48-119</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $hash{'a'}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225611Z" changeid="explorer">
        <seg>undef $hash{'a'}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to C&lt;&lt; (?&lt;NAME&gt;pattern) &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003212Z" changeid="explorer">
        <seg>Equivalente a C&lt;&lt; (?&lt;NOMBRE&gt;patrón) &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>% perl5.12 -E 'say scalar localtime( 0x9FFF_FFFFFFFF )'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225528Z" changeid="explorer">
        <seg>% perl5.12 -E 'say scalar localtime( 0x9FFF_FFFFFFFF )'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This contains instructions on how to build perl for the Haiku platform.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003545Z" changeid="explorer">
        <seg>Contiene instrucciones para compilar perl para la plataforma Haiku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s//utf8/ if m?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030356Z" changeid="explorer">
        <seg>s//utf8/ if m?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;File::Spec-&gt;rootdir()&gt; now returns C&lt;\&gt; on Win32, instead of C&lt;/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031836Z" changeid="explorer">
        <seg>C&lt;File::Spec-&gt;rootdir()&gt; ahora devuelve C&lt;\&gt; en Win32, en lugar de C&lt;/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\t          tab                   (HT, TAB)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043319Z" changeid="explorer">
        <seg>\t		tab			(HT, TAB)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;++&gt; behaves as the other operators above, except that if it is a string
matching the format C&lt;/^[a-zA-Z]*[0-9]*\z/&gt; the string increment described
in L&lt;perlop&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T233948Z" changeid="explorer">
        <seg>C&lt;++&gt; se comporta como los operadores anteriores, con la diferencia de que si se aplica a una cadena que tenga el formato C&lt;/^[a-zA-Z]*[0-9]*\z/&gt;, se usa el incremento de cadena descrito en L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dump LABEL
X&lt;dump&gt; X&lt;core&gt; X&lt;undump&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171508Z" changeid="explorer">
        <seg>=item dump ETIQUETA
X&lt;dump&gt; X&lt;core&gt; X&lt;undump&gt; X&lt;volcado&gt; X&lt;núcleo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that pod translators should look at only paragraphs beginning
with a pod directive (it makes parsing easier), whereas the compiler
actually knows to look for pod escapes even in the middle of a
paragraph.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que los traductores pod suelen mirar sólo en los párrafos que comiencen por una directiva pod (hace el parseo más fácil), mientras que el compilador realmente sabe mirar por las secuencias pod incluso en el medio de un párrafo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If non-empty braces are the only wildcard characters used in the
C&lt;glob&gt;, no filenames are matched, but potentially many strings
are returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los únicos caracteres comodín en C&lt;glob&gt; son llaves, no se coincidirá con ningún archivo, pero, potencialmente, se devuelven muchas cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get status info for a symbolic link
instead of the target file behind the link, use the C&lt;lstat&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener información de estado de un enlace simbólico en lugar del archivo de destino tras el enlace, utilice la función C&lt;lstat&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deprecated C&lt;$#&gt; variable (output format for numbers) has been
removed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192253Z" changeid="explorer">
        <seg>La variable obsoleta C&lt;$#&gt; (formato de salida para los números) se ha eliminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rename any non-standard executables so the names do not conflict with
standard executables, which must also be provided, and provide a
separate manual page for each non-standard executable that clearly
documents how it differs from the Standard Version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>cambie el nombre de cualquier ejecutable no estándar para que los nombres no entren en conflicto con los ejecutables estándar, que también se debe proporcionar, y proporcionar una página de manual por separado por cada ejecutable no estándar que documente claramente en qué se diferencia de la versión estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 4) = 8   ==          8 00010000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 4) = 8   ==          8 00010000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, si dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::BigRat upgraded to version 0.13</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Math::BigRat actualizado a la versión 0.13</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that the block is automatically broken out of by a
successful C&lt;when&gt; or an explicit C&lt;break&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>excepto que el bloque es, automáticamente, parado, por un C&lt;when&gt; con éxito o un explícito C&lt;break&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that it short-circuits: the right
expression is evaluated only if the left expression is true.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230303Z" changeid="explorer">
        <seg>Esto significa que cortocircuita: es decir, la expresión de la derecha sólo se evalúa si la expresión de la izquierda es verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is called an &quot;array slice&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T001749Z" changeid="zipf">
        <seg>Esto se denomina una &quot;porción de array&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>55608</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>55608</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Road goes ever on and on,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El camino sigue y sigue,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, long experience has shown that many programming tasks may
be significantly simplified by using repeated subexpressions that
may match zero-length substrings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230856Z" changeid="explorer">
        <seg>Sin embargo, la experiencia ha demostrado que muchas de las tareas de programación se pueden simplificar considerablemente mediante el uso de subexpresiones repetidas que coincidan con subcadenas de longitud cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;L&lt;use re 'E&lt;sol&gt;foo'|re/'E&lt;sol&gt;flags' mode&quot;&gt;&gt; pragma can be used to set
default modifiers (including these) for regular expressions compiled
within its scope.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001816Z" changeid="explorer">
        <seg>El pragma C&lt;L&lt;use re 'E&lt;sol&gt;foo'|re/'Banderas E&lt;sol&gt;'&quot;&gt;&gt; se puede utilizar para establecer los modificadores por defecto (incluyendo éstos) para las expresiones regulares compiladas dentro de su ámbito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include ExtUtils::ModuleMaker and h2xs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030928Z" changeid="explorer">
        <seg>Estos incluyen ExtUtils::ModuleMaker y h2xs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When invoked as F&lt;psed&gt;, it behaves as a F&lt;sed&gt; implementation, written in
Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234221Z" changeid="explorer">
        <seg>Cuando se invoca como F&lt;psed&gt;, se comporta como una implementación de F&lt;sed&gt; escrita en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Regular Expression Pocket Reference&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003313Z" changeid="explorer">
        <seg>=item I&lt;Regular Expression Pocket Reference&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Otherwise:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165644Z" changeid="explorer">
        <seg>=item De lo contrario:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return the positive square root of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la raíz cuadrada positiva de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Package names are sometimes an exception to this rule.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres de los paquetes son, en alguna ocasión, una excepción a esta regla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same template may generally also be used in unpack().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La misma plantilla puede ser usada, generalmente, con unpack().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although Perl has promised since version 5.8 that C&lt;sort()&gt; would be
stable, the two cases C&lt;sort {$b cmp $a}&gt; and C&lt;&lt; sort {$b &lt;=&gt; $a} &gt;&gt; could
produce non-stable sorts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212224Z" changeid="explorer">
        <seg>Aunque Perl prometió, desde la versión 5.8, que C&lt;sort()&gt; sería estable, los dos casos C&lt;sort {$b cmp $a}&gt; y C&lt;&lt; sort {$b &lt;=&gt; $a} &gt;&gt; puede producir ordenaciones no estables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>kill 9, @goners;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>kill 9, @finalizadores;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$s = q{ if($a eq &quot;}&quot;) ... }; # WRONG</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$s = q{ if($a eq &quot;}&quot;) ... }; # MAL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if there were a C&lt;continue&gt; block on the above code, it would
get executed only on lines discarded by the regex (since redo skips the
continue block).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que si existiese un bloque C&lt;continue&gt; en este código, sería ejecutado sólo en las líneas descartadas por la expresión regular (debido a que C&lt;redo&gt; salta el bloque C&lt;continue&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a hash.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T015303Z" changeid="explorer">
        <seg>Use a hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Language-Specific</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Idiomas específicos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your module should include documentation aimed at Perl developers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023812Z" changeid="explorer">
        <seg>Su módulo debe incluir la documentación dirigida a los desarrolladores de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 DOCUMENTING YOUR MODULE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023800Z" changeid="explorer">
        <seg>=head1 DOCUMENTANDO SU MÓDULO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several groups devoted to the Perl language are on Usenet:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230352Z" changeid="explorer">
        <seg>En Usenet existen varios grupos dedicados al lenguaje Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $aref ( @AoA ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052822Z" changeid="explorer">
        <seg>for $aref ( @AoA ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, Perl inspects the operands of the binary boolean operators to
decide whether to use smart matching for each one by applying the above test to
the operands:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T212356Z" changeid="explorer">
        <seg>Además, Perl inspecciona los operandos de los operadores booleanos binarios para decidir si se debe usar coincidencia inteligente para cada uno de ellos mediante la aplicación de la prueba anterior a los operandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Socket</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014836Z" changeid="explorer">
        <seg>=item Socket</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most important Perl parsing rule is the first one discussed
below: when processing a quoted construct, Perl first finds the end
of that construct, then interprets its contents.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La más importante regla de análisis de Perl es la primera que se explica a continuación: cuando se procesa una construcción entrecomillada, Perl primero encuentra al final de esa construcción; a continuación, interpreta su contenido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make perl executable and create a symlink for libperl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace a perl ejecutable y crea un enlace simbólico para libperl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to build a Perl with flock() support, you have to install this
package first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere construir un Perl con soporte de flock(), tiene que instalar este paquete en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For functions that can be used in either a scalar or list context,
nonabortive failure is generally indicated in scalar context by
returning the undefined value, and in list context by returning the
empty list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110704T234135Z" changeid="explorer">
        <seg>Para funciones que pueden ser usadas tanto en contexto escalar como en contexto de lista, un error no abortivo es indicado, generalmente, por un valor indefinido en el contexto escalar, y en contexto lista por una lista vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m{ ( \( )?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195913Z" changeid="explorer">
        <seg>m{ ( \( )?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's how to do one operation using a loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194641Z" changeid="explorer">
        <seg>Aquí está cómo hacer una operación con un bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So your build will fail if you choose the defaults.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que su compilación producirá un error si usted elige los valores predeterminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters special to the
RE engine (such as C&lt;|&gt;) generate corresponding nodes or groups of
nodes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Caracteres especiales al motor de RE (como C&lt;|&gt;) generan sus correspondientes nodos o grupos de nodos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 32  ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 32  ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function C&lt;again&gt; is provided to resolve problems where modules in different
directories wish to use FindBin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se proporciona, C&lt;de nuevo&gt;, una función para resolver los problemas donde módulos en diferentes directorios desean utilizar FindBin.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9781565927162</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003636Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9781565927162</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hints files have been
updated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003742Z" changeid="explorer">
        <seg>Los archivos de pistas han sido actualizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlutil - utilities packaged with the Perl distribution</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233206Z" changeid="explorer">
        <seg>perlutil - Utilidades incluidas en la distribución de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$is_set = vec($vector, 23, 1);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>$is_set = vec($vector, 23, 1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -de 42</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225444Z" changeid="explorer">
        <seg>perl -de 42</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's some of the thing you'll find in it:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T013236Z" changeid="explorer">
        <seg>Contiene cosas como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A I&lt;stable&gt; sort
preserves the input order of elements that compare equal.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Un sort I&lt;estable&gt; preserva el orden de los elementos de entrada que sean iguales en la comparación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/require&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T001536Z" changeid="explorer">
        <seg>Vea L&lt;perlfunc/require&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's another way to check for sentences in a paragraph:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025315Z" changeid="explorer">
        <seg>Aquí hay otra forma de buscar sentencias en un párrafo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using such
a module, see the module's documentation for details of the syntax that
it defines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está usando un módulo así, mire la documentación del módulo para ver los detalles de la sintaxis que define.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Single-number v-strings are no longer v-strings before &quot;=&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T141108Z" changeid="explorer">
        <seg>=head2 Las cadenas v-strings de un solo dígito ya no son v-strings delante de un &quot;=&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rebuilt to be compatible with mod_perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Reconstruido para ser compatible con mod_perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are still reading this and you are itching to try out microperl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si aún sigue leyendo esto y está ansioso por probar microperl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0 dev    0 second     0 package      $_    default variable</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224336Z" changeid="explorer">
        <seg>0 dev    0 segundo    0 paquete         $_    variable predeterminada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item our TYPE EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item our TIPO EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Configuration and Building</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Configuración y construcción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlboot		Perl OO tutorial for beginners</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000210Z" changeid="explorer">
        <seg>perlboot		Programación orientada a objetos para principiantes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die $@ unless $@ eq &quot;Alarm!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die $@ unless $@ eq &quot;¡Alarma!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;-lnet&gt; is needed on net server systems only and if the compiler doesn't
add it automatically (Be's R5 gcc does, Oliver Tappe's gcc 2.95.3 does not).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;-lnet&gt; es necesario en los sistemas net server solo si el compilador no lo agrega de forma automática (El gcc de Be R5 así lo hace; el gcc de Oliver Tappe 2.95.3, no).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.1f&gt;', 1;  # prints &quot;&lt;1.0&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.1f&gt;', 1;  # imprime &quot;&lt;1.0&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = &lt;&lt;'EOL';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = &lt;&lt;'EOL';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;splain|splain&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233533Z" changeid="explorer">
        <seg>=item L&lt;splain|splain&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/use&gt;, L&lt;perlmod&gt;, and L&lt;Exporter&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/use&gt;, L&lt;perlmod&gt; y L&lt;Exporter&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, \xI&lt;nn&gt;, where I&lt;nn&gt; are hexadecimal digits,
matches the character whose ordinal is I&lt;nn&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T222906Z" changeid="explorer">
        <seg>Del mismo modo, \xI&lt;nn&gt;, donde I&lt;nn&gt; son dígitos hexadecimales, coincide con el carácter cuyo ordinal es I&lt;nn&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the PATTERN contains parentheses, additional list elements are
created from each matching substring in the delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el PATRÓN contiene paréntesis, se crean elementos de lista adicionales por cada subcadena coincidente con el delimitador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when($foo)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when($foo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TEST_JOBS=3 make test_harness  # Run 3 tests in parallel</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T002204Z" changeid="explorer">
        <seg>TEST_JOBS=3 make test_harness  # Ejecuta 3 test en paralelo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Salvador FandiÃ±o provided improvements to reduce the memory usage of C&lt;sort&gt;
and to speed up some cases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T042350Z" changeid="explorer">
        <seg>Salvador Fandiño proporcionó mejoras para reducir la memoria usada por C&lt;sort&gt; y para mejorar la velocidad en algunos casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Digest::MD5&gt; upgraded to version 2.36</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030447Z" changeid="explorer">
        <seg>C&lt;Digest::MD5&gt; actualizado a la versión 2.36</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item read FILEHANDLE,SCALAR,LENGTH,OFFSET
X&lt;read&gt; X&lt;file, read&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011558Z" changeid="explorer">
        <seg>=item read IDENTIFICADOR_ARCHIVO,ESCALAR,LONGITUD,DESPLAZAMIENTO
X&lt;read&gt; X&lt;file, read&gt; X&lt;archivo, leer&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To determine if a module came with your version of Perl, you can
use the C&lt;Module::CoreList&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231203Z" changeid="explorer">
        <seg>Para determinar si un módulo está incluido en su versión de Perl, puede usar C&lt;Module::CoreList&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While C&lt;use integer&gt; provides integer-only arithmetic, there is no
analogous mechanism to provide automatic rounding or truncation to a
certain number of decimal places.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras que C&lt;use integer&gt; sólo proporciona aritmética de enteros, no existe un mecanismo análogo para proporcionar redondeo automático o truncamiento a un determinado número de decimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select undef, undef, undef, 0.25;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select undef, undef, undef, 0.25;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes turning off possible CRLF
translation and marking it as bytes (as opposed to Unicode characters).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto incluye desactivar posibles traducciones CRLF y marcarlas como bytes (como opuesto a los caracteres Unicode).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item On EBCDIC platforms</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174321Z" changeid="explorer">
        <seg>=item En plataformas EBCDIC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So C&lt;given(@foo)&gt; is the same as C&lt;given(\@foo)&gt;,
for example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Asi que, por ejemplo, C&lt;given(@foo)&gt; es lo mismo que C&lt;given(\@foo)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then use it like:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235306Z" changeid="zipf">
        <seg>Puede asignar el valor devuelto así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tutorial started in the Llama continues in the Alpaca, which
introduces the intermediate features of references, data structures,
object-oriented programming, and modules:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003129Z" changeid="explorer">
        <seg>El tutorial iniciado en el Libro de la Llama continúa en el Libro de la Alpaca, que presenta material de nivel intermedio, como referencias, estructuras de datos, programación orientada a objetos y módulos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Matching repetitions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113619Z" changeid="explorer">
        <seg>=head2 Coincidiendo con repeticiones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Details are in L&lt;perlop/Quote and Quote-like Operators&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185113Z" changeid="explorer">
        <seg>Los detalles están en L&lt;perlop/Comillas y Operadores de comillas&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opens the file whose filename is given by EXPR, and associates it with
FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011136Z" changeid="explorer">
        <seg>Abre el archivo cuyo nombre viene dado por EXPR, y lo asocia con IDENTIFICADOR_ARCHIVO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlink glob &quot;*.bak&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlink glob &quot;*.bak&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$db-&gt;filter_fetch_key  ( sub { $_ = unpack(&quot;i&quot;, $_) } );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190155Z" changeid="zipf">
        <seg>$db-&gt;filter_fetch_key  ( sub { $_ = unpack(&quot;i&quot;, $_) } );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A compound expression involving the defined-or operator, as in
C&lt;when (expr1 // expr2)&gt;, will be treated as boolean if the first
expression is boolean.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T221051Z" changeid="explorer">
        <seg>Una expresión compuesta, que incluya al operador definido-or, como en C&lt;when (expr1 // expr2)&gt;, será tratada como booleana si la primera expresión es booleana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach my $pat (@compiled) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach my $pat (@compilados) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eof</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eof</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?:pattern)&gt;
X&lt;(?:)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T231851Z" changeid="explorer">
        <seg>=item C&lt;(?:patrón)&gt;
X&lt;(?:)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To view the differences between the
5.7.0 release and the 5.7.1 release, see L&lt;perl571delta&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215116Z" changeid="explorer">
        <seg>(Para ver las diferencias entre la versión 5.7.0 y la versión 5.7.1, vea L&lt;perl571delta&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;!=&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;!=&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO) ? 'hi mom' : die &quot;Can't open $FOO: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054547Z" changeid="explorer">
        <seg>open(FOO) ? 'hola mamá' : die &quot;No puedo abrir $FOO: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using &quot;or&quot; for assignment is unlikely to do what you want; see below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220055Z" changeid="explorer">
        <seg>Es poco probable que quiera usar &quot;or&quot; para hacer asignaciones; vea más adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It still
counts as scalar context for functions that care whether or not
they're being called in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, también cuenta como contexto escalar para las funciones a las que les interesa saber si han sido llamadas en contexto lista o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that although the warning
says the illegal character is ignored, it is only ignored as part of the
escape and will still be used as the subsequent character in the string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T231610Z" changeid="explorer">
        <seg>Tenga en cuenta que, si bien la advertencia dice que el carácter ilegal no se tiene en cuenta, sólo es ignorado como parte del escapado y aún así es utilizado como el carácter siguiente en la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a list
of these books, some with extensive reviews, at http://books.perl.org/
. We list some of the books here, and while listing a book implies our
endorsement, don't think that not including a book means anything.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T002856Z" changeid="explorer">
        <seg>En http://books.perl.org/ encontrará una lista de libros y extensas reseñas. En este documento se hace referencia a algunos de estos libros. Los que figuran en la lista son libros que recomendamos; no obstante, el que un libro no figure en la lista no quiere decir que sea malo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughout this document you'll see references to other parts of the
Perl documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224550Z" changeid="explorer">
        <seg>En este documento se incluyen referencias a otras partes de la documentación de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;~&gt; X&lt;negation, binary&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;~&gt; X&lt;negation, binary&gt; X&lt;negación, binario&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}sx;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025702Z" changeid="explorer">
        <seg>}sx;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcheat has been added: it is a Perl cheat sheet.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180835Z" changeid="explorer">
        <seg>perlcheat ha sido añadida: se trata de una hoja de trucos Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New C&lt;-noperldoc&gt; switch for C&lt;pod2usage&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034445Z" changeid="explorer">
        <seg>Nueva opción C&lt;-noperldoc&gt; para C&lt;pod2usage&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once upon a time, Perl would recompile regular expressions
unnecessarily, and this modifier was useful to tell it not to do so, in the
interests of speed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T204155Z" changeid="explorer">
        <seg>Hace algún tiempo, Perl hubiera recompilado expresiones regulares innecesariamente, y este modificador era útil para decirle que no lo hiciese, en aras de aumentar la velocidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pack TEMPLATE,LIST
X&lt;pack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191948Z" changeid="explorer">
        <seg>=item pack PLANTILLA,LISTA
X&lt;pack&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;chdir&gt;, C&lt;chmod&gt; and C&lt;chown&gt; can now work on filehandles as well as
filenames, if the system supports respectively C&lt;fchdir&gt;, C&lt;fchmod&gt; and
C&lt;fchown&gt;, thanks to a patch provided by Gisle Aas.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T000914Z" changeid="explorer">
        <seg>C&lt;chdir&gt;, C&lt;chmod&gt; y C&lt;chown&gt; ahora pueden trabajar tanto con nombres de ficheros como con identificadores de archivos, si el sistema soporta, respectivamente, C&lt;fchdir&gt;, C&lt;fchmod&gt; y C&lt;fchown&gt;, gracias a un parche proporcionado por Gisle Aas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means
that if you're in the C&lt;main&gt; package and type</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que si usted está en el paquete C&lt;main&gt; y escribe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instead of having to write these:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>en lugar de tener que escribir lo siguiente?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item F&lt;perl5db.pl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003520Z" changeid="explorer">
        <seg>=item F&lt;perl5db.pl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The port of Perl to to Mac OS was officially removed as of Perl 5.12,
though the last official production release of MacPerl corresponded to 
Perl 5.6.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T151027Z" changeid="explorer">
        <seg>La versión de Perl para el Mac OS se retiró oficialmente como Perl 5.12, aunque el lanzamiento oficial de la última versión de producción MacPerl correspondió a Perl 5.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Quantifiers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Cuantificadores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 1) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 1) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cost = &lt;&lt;'VISTA';  # hasta la ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T032758Z" changeid="explorer">
        <seg>$cost = &lt;&lt;'VISTA';  # hasta la ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$herhostname    = gethostbyaddr($iaddr, AF_INET);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$herhostname    = gethostbyaddr($iaddr, AF_INET);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As well as grouping, parentheses serve a second purpose.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120836Z" changeid="zipf">
        <seg>Además de para agrupar, los paréntesis también</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pattern matches nothing and causes the end of successful matching at
the point at which the C&lt;(*ACCEPT)&gt; pattern was encountered, regardless of
whether there is actually more to match in the string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T144231Z" changeid="explorer">
        <seg>Este patrón no coincide con nada y provoca el final de una coincidencia con éxito en el lugar en que el patrón C&lt;(*ACCEPT)&gt; se encontraba, sin importar si pudiera haber más coincidencias en la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as though the argument to C&lt;given&gt; were an element of the hash
C&lt;%foo&gt;, interpreting the braces as hash-element syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>como si el argumento a C&lt;given&gt; fuera un elemento del hash C&lt;%foo&gt;, interpretando las llaves como la sintaxis de un elemento de un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>they'll be politely informed that</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031718Z" changeid="explorer">
        <seg>va a ser cortésmente informado de que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;echo $temp&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;echo $temporal&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It collects
information about your installation to include with your message, then
sends the message to the right place.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231159Z" changeid="explorer">
        <seg>Esta utilidad recopila información sobre la instalación para incluirla en el mensaje y después envía el informe a la dirección adecuada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;.&gt; X&lt;/s&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;.&gt; X&lt;/s&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item local EXPR
X&lt;local&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T175427Z" changeid="explorer">
        <seg>=item local EXPR
X&lt;local&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print if $printit;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234216Z" changeid="explorer">
        <seg>print if $imprimir;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters may be specified using a metacharacter syntax much like that
used in C: &quot;\n&quot; matches a newline, &quot;\t&quot; a tab, &quot;\r&quot; a carriage return,
&quot;\f&quot; a form feed, etc.  More generally, \I&lt;nnn&gt;, where I&lt;nnn&gt; is a string
of three octal digits, matches the character whose coded character set value
is I&lt;nnn&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T222831Z" changeid="explorer">
        <seg>Los caracteres pueden ser especificados utilizando una sintaxis metacarácter al igual que la utilizada en C: &quot;\n&quot; coincide con un nueva línea, &quot;\t&quot; un tabulador, &quot;\r&quot; un retorno de carro, &quot;\f&quot; un avance de página, etc. En términos más generales, \I&lt;nnn&gt;, donde I&lt;nnn&gt; es una cadena de tres dígitos octales, coincide con el carácter cuyo código de valor del conjunto de caracteres es I&lt;nnn&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Digest&gt; upgraded to version 1.14</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030420Z" changeid="explorer">
        <seg>C&lt;Digest&gt; actualizado a la versión 1.14</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 2) = 2   ==        128 00000001000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 2) = 2   ==        128 00000001000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;code&gt; is properly scoped in the following sense: If the assertion
is backtracked (compare L&lt;&quot;Backtracking&quot;&gt;), all changes introduced after
C&lt;local&gt;ization are undone, so that</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T220953Z" changeid="explorer">
        <seg>El C&lt;código&gt; está apropiadamente encerrado en un ámbito, en el sentido siguiente: si la aserción es retrotraída (comparar con L&lt;&quot;Retrotraer&quot;&gt;), todos los cambios introducidos después de la C&lt;local&gt;ización son deshechos, por lo que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This would be clearer to the casual reader:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto será más claro para el lector casual:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>are also always exempt from such warnings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>están también exentos de tales avisos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\d+/sprintf(&quot;%5d&quot;,$&amp;)/e;	# yields 'abc  246xyz'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035019Z" changeid="explorer">
        <seg>s/\d+/sprintf(&quot;%5d&quot;,$&amp;)/e;			# queda como 'abc  246xyz'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$scalar ~~ @array&gt; now always distributes the smart match across the
elements of the array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T222203Z" changeid="explorer">
        <seg>C&lt;$scalar ~~ @array&gt; ahora siempre distribuye la coincidencia inteligente a lo largo de todos los elementos del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfreebsd 	Perl notes for FreeBSD</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfreebsd 	Notas para FreeBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Unix permission C&lt;rwxr-x---&gt; is represented as three sets of three
bits, or three octal digits: C&lt;0750&gt; (the leading 0 indicates octal
and isn't one of the digits).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los permisos Unix C&lt;rwxr-x---&gt; son representados como tres conjuntos de tres bits, o tres dígitos octales: C&lt;0750&gt; (el 0 precedente indica que es octal, y que no es uno de los dígitos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, however, the order varies between
different runs of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135048Z" changeid="explorer">
        <seg>Ahora, sin embargo, el orden varía entre diferentes ejecuciones de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This works on machines only for which the device number is negative
under NFS.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto funciona solo en máquinas en las cuales el número de dispositivo es negativo para NFS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?:               *     zero or more         /x ign.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224240Z" changeid="explorer">
        <seg>?:               *     cero o varios            /x ign.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Threaded Perl on DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Perl con I&lt;threads&gt; en DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line up corresponding things vertically, especially if it'd be too long
to fit on one line anyway.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alineé elementos correspondientes verticalmente, especialmente si es demasiado largo el espacio que ocupan como para entrar en una sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the C&lt;&lt; $COMPILING &gt;&gt; variable has been added</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031045Z" changeid="explorer">
        <seg>La variable C&lt;&lt; $COMPILING &gt;&gt; ha sido añadida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given integer
operands C&lt;$a&gt; and C&lt;$b&gt;: If C&lt;$b&gt; is positive, then C&lt;$a % $b&gt; is
C&lt;$a&gt; minus the largest multiple of C&lt;$b&gt; less than or equal to
C&lt;$a&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dados los operandos enteros C&lt;$a&gt; y C&lt;$b&gt;: si C&lt;$b&gt; es positivo, entonces C&lt;$a % $b&gt; es C&lt;$a&gt; menos el mayor múltiplo de C&lt;$b&gt; menor o igual a C&lt;$a&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\1        [5]  Backreference to a specific capture group or buffer.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T044923Z" changeid="explorer">
        <seg>\1        [5]  Contrareferencia a un específico grupo de captura o búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To subscribe, send an empty message to perl-mvs-subscribe@perl.org.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225130Z" changeid="explorer">
        <seg>Para suscribirse, envíe un mensaje vacío a perl-mvs-subscribe@perl.org.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of the last command in the
sequence of commands indicated by BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor del último comando en la secuencia de comandos indicada por BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>crypt() is a one-way hash function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>crypt() es una función hash de un sólo sentido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(STDOUT, '&gt;', &quot;foo.out&quot;) or die &quot;Can't redirect STDOUT: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004511Z" changeid="explorer">
        <seg>open(STDOUT, '&gt;', &quot;foo.out&quot;) or die &quot;No puedo redirigir STDOUT: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;gmtime&gt;, C&lt;localtime&gt;, C&lt;time&gt;, C&lt;times&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;gmtime&gt;, C&lt;localtime&gt;, C&lt;time&gt;, C&lt;times&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @array = 'a'..'d';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225558Z" changeid="explorer">
        <seg>my @array = 'a'..'d';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to run a threaded Perl on OpenBSD
3.7 or higher, you will need to upgrade to at least Perl 5.8.7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere correr un Perl con hilos sobre OpenBSD 3.7 o superior, necesitará actualizar Perl al menos a la versión 5.8.7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlunitut		Perl Unicode tutorial</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000425Z" changeid="explorer">
        <seg>perlunitut		Tutorial de Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some programmers may prefer to think of filehandles as objects with
methods, preferring to write the last example as:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012321Z" changeid="explorer">
        <seg>Algunos programadores prefieren pensar en identificadores de archivo como objetos con métodos, prefiriendo escribir el último ejemplo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach ( 1 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>foreach ( 1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl586delta	Perl changes in version 5.8.6</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl586delta	Cambios en la versión 5.8.6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!/usr/bin/perl -n</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>#!/usr/bin/perl -n</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string is broken into chunks described by the TEMPLATE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La cadena se rompe en trozos descritos por la PLANTILLA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @old;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@nuevo = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @viejo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 state() variables</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112008Z" changeid="explorer">
        <seg>=head2 Variables state()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns the value or values deleted, or the last such
element in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T232753Z" changeid="explorer">
        <seg>En contexto de lista, devuelve el valor o los valores borrados, o el último elemento de este tipo en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.9.2 and the 5.9.3
development releases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T191514Z" changeid="explorer">
        <seg>Este documento describe las diferencias entre las versiones de desarrollo 5.9.2 y la 5.9.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watch out for this one, then, because an arrayref is always a true value, which
makes it effectively redundant.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215440Z" changeid="explorer">
        <seg>Tenga cuidado con esto, porque una referencia a un array es siempre un valor verdadero, lo que, efectivamente, es redundante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11410</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11410</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This convention was adopted by the community, and the
second edition became I&lt;Programming Perl&gt;, using the capitalized
version of the name to refer to the language.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231519Z" changeid="explorer">
        <seg>La comunidad adoptó esta convención y la segunda edición pasó a llamarse I&lt;Programming Perl&gt;, con la versión con inicial mayúscula en el nombre para referirse al lenguaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while( &lt;&gt; ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225538Z" changeid="explorer">
        <seg>while( &lt;&gt; ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, uses
C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also
very useful for creating skeletons of pure Perl modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234546Z" changeid="explorer">
        <seg>También resulta muy útil para crear la estructura inicial de módulos Perl puros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two flag bits are currently supported.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T011335Z" changeid="explorer">
        <seg>Actualmente están soportados dos bit de esa bandera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Perl closes
the comment as soon as it sees a C&lt;)&gt;, so there is no way to put a literal
C&lt;)&gt; in the comment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que Perl cierra el comentario tan pronto como vea un C&lt;)&gt;, por lo que no hay manera de poner un C&lt;)&gt; literal en el comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default VERSION method, inherited from
the UNIVERSAL class, croaks if the given version is larger than the
value of the variable C&lt;$Module::VERSION&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El método VERSIÓN por defecto, heredado de la clase UNIVERSAL, croa si la versión dada es mayor que el valor de la variable C&lt;$Módulo::VERSIÓN&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Statement Modifiers
X&lt;statement modifier&gt; X&lt;modifier&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt;
X&lt;until&gt; X&lt;when&gt; X&lt;foreach&gt; X&lt;for&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004715Z" changeid="explorer">
        <seg>=head2 Modificadores de instrucciones
X&lt;statement modifier&gt; X&lt;modifier&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt;
X&lt;until&gt; X&lt;when&gt; X&lt;foreach&gt; X&lt;for&gt; X&lt;modificador de instrucción&gt; X&lt;modificador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's how a C programmer might code up a particular algorithm in Perl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo de cómo un programador de C codificaría un determinado algoritmo en Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11405</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11405</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you meant the empty regex, just
use parentheses or spaces to disambiguate, or even prefix the empty
regex with an C&lt;m&gt; (so C&lt;//&gt; becomes C&lt;m//&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted quiere decir la expresión regular vacía, sólo tiene que utilizar paréntesis o espacios para eliminar la ambigüedad, o incluso el prefijar con una C&lt;m&gt; (así que C&lt;//&gt; se convierte en C&lt;m//&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be avoided if you always use O_NONBLOCK on the
socket.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013601Z" changeid="explorer">
        <seg>Esto puede evitarse si siempre utiliza O_NONBLOCK en el I&lt;socket&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the description
below C&lt;S&gt; and C&lt;T&gt; are regular subexpressions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T234843Z" changeid="explorer">
        <seg>En la siguiente descripción C&lt;S&gt; y C&lt;T&gt; son subexpresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The pseudo code above doesn't work because it treats
&lt;ARGV&gt; as non-magical.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(El pseudo código anterior no funciona porque trata a &lt;ARGV&gt; como no-mágico).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you chomp a list, each element is chomped, and the total number of
characters removed is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si recorta una lista, cada elemento es recortado y se devuelve el número total de caracteres eliminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\W        [3]  Match a non-&quot;word&quot; character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223624Z" changeid="explorer">
        <seg>\W	 [3]  Coincide con un carácter que no es de &quot;palabra&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use named parameters (a hash or hashref) when there are more than two
parameters</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013706Z" changeid="explorer">
        <seg>Use parámetros nominados (un hash o referencia a un hash) cuando haya más de dos parámetros</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ucfirst</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item ucfirst</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Minor documentation enhancement</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mejora menor en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Steve Peters provided new C&lt;*_set&gt; macros and reworked the core to
use these rather than assigning to macros in LVALUE context.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051843Z" changeid="explorer">
        <seg>Steve Peters proporcionó nuevas macros C&lt;*_set&gt; y rediseñó el núcleo para utilizar éstas en lugar de asignar a macros en contexto de IVALOR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also useful for applications emulating C&lt;tail -f&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto también es útil para aplicaciones que emulen C&lt;tail -f&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, these answers may not suffice for managers who require a
purchase order from a company whom they can sue should anything go awry.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231045Z" changeid="explorer">
        <seg>Sin embargo, es posible que estos argumentos no basten para convencer a los jefes que siempre exigen un pedido de compra de una empresa a la que puedan demandar si algo sale mal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(ActiveState)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112323Z" changeid="explorer">
        <seg>(ActiveState)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;Porting&gt; directory contains a grab bag of code and documentation
intended to help porters work on Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014805Z" changeid="explorer">
        <seg>El directorio F&lt;Porting&gt; contiene un conjunto de fragmentos de código y documentación que pueden servir de ayuda a los mantenedores de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are passed an argument like the other code references (even if they
choose to ignore it).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005148Z" changeid="explorer">
        <seg>Se les pasa un argumento como a otras referencias de código (incluso si deciden ignorarlo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this behaviour is
sometimes undesirable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, este comportamiento es a veces indeseable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You can set C&lt;$/&gt; to use
a different line terminator.)  The command is executed each time the
pseudo-literal is evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Puede configurar C&lt;$/&gt; para utilizar un terminador de línea diferente). El comando es ejecutado cada vez que el pseudo-literal es evaluado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub my_sub {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub mi_sub {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not worry, you've apparently got
the ASCII-&gt;EBCDIC translation worked out correctly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T215040Z" changeid="explorer">
        <seg>No se preocupe, parece que le funcionó correctamente la traducción EBCDIC-&gt;ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (EXPR) BLOCK else BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (EXPR) BLOQUE else BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator is also handy for inverting a hash, although there are some
caveats.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este operador también es útil para invertir un hash, aunque existen algunas salvedades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SCALAR is of length zero, you can only use an OFFSET of 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ESCALAR es de longitud cero, sólo se puede utilizar un DESPLAZAMIENTO de 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/ ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T124756Z" changeid="explorer">
        <seg>/ ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable holds
the undefined value (C&lt;undef&gt;) until it has been assigned a defined
value, which is anything other than C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una variable almacena el valor indefinido (C&lt;undef&gt;) hasta que se le asigna un valor definido, que es cualquier otra cosa distinta de C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These last until their block is exited, but may be passed back.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos últimos duran hasta que se sale de su bloque, pero puede ser traspasado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will only affect people who have a threaded perl 5.8.1, and compiled
modules which use these calls, and now attempt to run the compiled modules
with 5.8.2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto sólo afectará a las personas que tienen un perl 5.8.1 multihilo, y los módulos compilados que utilizan estas llamadas, y ahora intenta ejecutar los módulos compilados con 5.8.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when ([qw(foo bar)] || /^baz/) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215158Z" changeid="explorer">
        <seg>when ([qw(foo bar)] || /^baz/) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlthrtut&gt; and L&lt;threads&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001404Z" changeid="explorer">
        <seg>Se describe en L&lt;perlthrtut&gt; y L&lt;threads&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = 'a';   print $x,&quot;\n&quot;;    # prints 1a4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = 'a';   print $x,&quot;\n&quot;;    # imprime 1a4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that the vast majority of people weren't: for example
in RedHat releases 8 and 9 the B&lt;default&gt; locale setting is UTF-8, so
all RedHat users got UTF-8 filehandles, whether they wanted it or not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T144220Z" changeid="explorer">
        <seg>El problema es que la gran mayoría de la gente no lo era: por ejemplo, en RedHat versiones 8 y 9, la configuración local B&lt;por defecto&gt; es UTF-8, por lo que todos los usuarios de RedHat obtenían identificadores de archivo UTF-8, lo quisieran o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a new warning, produced in situations such as this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T050806Z" changeid="explorer">
        <seg>Esta es una nueva advertencia, en situaciones como ésta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
the documentation of your operating system's I&lt;open&gt;(2) syscall to see
which values and flag bits are available.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T020625Z" changeid="explorer">
        <seg>Consulte la documentación de la llamada del sistema I&lt;open&gt;(2) de su sistema operativo para ver qué valores y bits de bandera están disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item File::Spec</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item File::Spec</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item POSIX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item POSIX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[...]     [1]  Match a character according to the rules of the
                   bracketed character class defined by the &quot;...&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T044015Z" changeid="explorer">
        <seg>[...]     [1]  Busca un carácter de acuerdo a las reglas de la clase
                    carácter definida por &quot;...&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of prior m//g)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>de la anterior m//g)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Boolean value telling whether EXPR has a value other than
the undefined value C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve un valor Booleano indicando si EXPR tiene un valor que no sea el valor indefinido C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identical in every respect to normal capturing
parentheses C&lt;()&gt; but for the additional fact that the group
can be referred to by name in various regular expression
constructs (like C&lt;\g{NAME}&gt;) and can be accessed by name
after a successful match via C&lt;%+&gt; or C&lt;%-&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T201220Z" changeid="explorer">
        <seg>Idéntico en todos los aspectos respecto a la captura normal con paréntesis C&lt;()&gt; pero con el hecho adicional de que C&lt;%+&gt; o C&lt;%-&gt; pueden ser usados para referirse por nombre en distintas construcciones de expresiones regulares (como C&lt;\g{NOMBRE}&gt;) y puede ser accedido por nombre después de una coincidencia exitosa, con C&lt;%+&gt; o C&lt;%-&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value replaces the value in
C&lt;$@&gt;;  i.e., as if C&lt;&lt; $@ = eval { $@-&gt;PROPAGATE(__FILE__, __LINE__) }; &gt;&gt;
were called.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T154402Z" changeid="explorer">
        <seg>El valor de retorno reemplaza el valor en C&lt;$@&gt;; es decir, como si se ejecutara C&lt;&lt; $@ = eval { $@-&gt;PROPAGATE(__FILE__, __LINE__) }; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $log, &quot;&gt;&gt;&quot;, &quot;my.log&quot;)     or die &quot;Can't open my.log: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T031032Z" changeid="explorer">
        <seg>open(my $registro, &quot;&gt;&gt;&quot;, &quot;mi.registro&quot;) or die &quot;No se puede abrir mi.registro: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo, 93,  1) = 1;      # 'PerlPerlPer'  . &quot;\x2c&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052421Z" changeid="explorer">
        <seg>vec($foo, 93,  1) = 1;      # 'PerlPerlPer'  . &quot;\x2c&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;&lt; =&gt; &gt;&gt; doesn't quote compound identifiers, that contain
double colons.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;&lt; =&gt; &gt;&gt; no entrecomilla identificadores compuestos, que contengan dos dobles puntos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.8.0 had accidentally broken the capability for users
to define their own uppercase&lt;-&gt;lowercase Unicode mappings
(as advertised by the Camel).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T011242Z" changeid="explorer">
        <seg>Perl 5.8.0 había roto accidentalmente la capacidad de los usuarios de definir sus propias asignaciones mayúsculas &lt;-&gt; minúsculas en Unicode (como se indicaba en el libro del camello).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is provided as a more readable version of C&lt;if (!I&lt;condition&gt;)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225130Z" changeid="explorer">
        <seg>Esto se proporciona como una versión más legible de C&lt;if  (!I&lt;condición&gt;)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -le 'for(@ARGV) {print if -f &amp;&amp; -T _}' *</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225503Z" changeid="explorer">
        <seg>perl -le 'for(@ARGV) {print if -f &amp;&amp; -T _}' *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The file must return true as the last statement to indicate
successful execution of any initialization code, so it's customary to
end such a file with C&lt;1;&gt; unless you're sure it'll return true
otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012644Z" changeid="explorer">
        <seg>El archivo debe devolver verdadero como última instrucción para indicar una ejecución exitosa de cualquier código de inicialización, por lo que es habitual a tal efecto que un archivo termine con un C&lt;1;&gt; a menos que esté seguro de que devolverá cierto, de otra manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hash randomisation introduced with 5.8.1 has been amended.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La asignación al azar hash introducido con 5.8.1 ha sido modificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;a2p|a2p&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234144Z" changeid="explorer">
        <seg>=item L&lt;a2p|a2p&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state is passed in as C&lt;$_[1]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El estado es pasado en C&lt;$_[1]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12056</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12056</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>25);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225519Z" changeid="explorer">
        <seg>25);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING:&gt; These patterns are experimental and subject to change or
removal in a future version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T002635Z" changeid="explorer">
        <seg>B&lt;ADVERTENCIA:&gt; Estos patrones son experimentales y sujetos a cambio o eliminación en una futura versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># This is a comment</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Esto es un comentario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	&amp;&amp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	&amp;&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlsub/&quot;Private Variables via my()&quot;&gt; for details, and L&lt;fields&gt;,
L&lt;attributes&gt;, and L&lt;Attribute::Handlers&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub/&quot;Variables privadas vía my()&quot;&gt; para más detalles, y L&lt;fields&gt;, L&lt;attributes&gt;, y L&lt;Attribute::Handlers&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can import symbolic mode constants (C&lt;S_IF*&gt;) and functions
(C&lt;S_IS*&gt;) from the Fcntl module:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede importar constantes simbólicas (C&lt;S_IF*&gt;) y funciones (C&lt;S_IS*&gt;) desde el módulo Fcntl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># scalar context</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># contexto escalar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The innermost always has priority over any outer ones, and one applying
to the whole expression has priority over any of the default settings that are
described in the remainder of this section.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001612Z" changeid="explorer">
        <seg>La parte más interior siempre tiene prioridad sobre cualquier otra externa, y la que se aplica a toda la expresión tiene prioridad sobre cualquiera de los ajustes por defecto que se describen en el resto de esta sección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is now a simple command line frontend to the CPAN.pm
module called F&lt;cpan&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171735Z" changeid="explorer">
        <seg>En la actualidad existe una interfaz de línea de comandos simple para el módulo CPAN.pm llamado F&lt;cpan&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/chomp&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/chomp&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, the source code of perl has been refactored, tied up, and
optimized in many places.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040958Z" changeid="explorer">
        <seg>En general, el código fuente de perl ha sido refactorizado, enlazado, y optimizado en muchos lugares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>document the new taint behaviour of exec LIST and system LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>documentar el comportamiento del nuevo comportamiento de I&lt;taint&gt; de exec LISTA y system LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Possessive quantifiers are equivalent to putting the item they are applied
to inside of one of these constructs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232228Z" changeid="explorer">
        <seg>Cuantificadores posesivos son equivalentes a poner el elemento a los que se aplica, dentro de una de estas construcciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can omit the EXPR, in which case nothing is
undefined, but you still get an undefined value that you could, for
instance, return from a subroutine, assign to a variable, or pass as a
parameter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede omitir la EXPR, en tal caso, nada queda indefinido, pero aún obtiene un valor indefinido que podría, por ejemplo, devolver de una subrutina, asignar a una variable, o pasar como un parámetro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>decimal string        --&gt; native floating point	(*)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113051Z" changeid="explorer">
        <seg>cadena decimal        --&gt; punto flotante nativo (*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$search = 'while (&lt;&gt;) { study;';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$buscar = 'while (&lt;&gt;) { study;';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional two OPs are not added anymore into op tree for shift and pop
calls without argument (when it works on C&lt;@_&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T054114Z" changeid="explorer">
        <seg>Dos OP adicionales ya no son añadidos en el árbol op para las llamadas shift y pop sin argumentos (cuando trabajan sobre C&lt;@_&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This change should only affect platform
maintainers writing configuration hints files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este cambio sólo debe afectar a los mantenedores de la plataforma al escribir sugerencias en los archivos de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $bar;    # prints 20, as it refers to $Foo::bar</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $bar;    # pinta 20, porque se refiere a $Foo::bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1404</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004230Z" changeid="explorer">
        <seg>1404</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last update: Tue Apr 26 18:30:55 MDT 2011</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110704T234453Z" changeid="explorer">
        <seg>Última actualización: Mar Abr 26 18:30:55 MDT 2011</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right	not</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>derecha	not</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-pna&gt; ] [ B&lt;-F&gt;I&lt;pattern&gt; ] [ B&lt;-l&gt;[I&lt;octal&gt;] ] [ B&lt;-0&gt;[I&lt;octal/hexadecimal&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-pna&gt; ] [ B&lt;-F&gt;I&lt;patrón&gt; ] [ B&lt;-l&gt;[I&lt;octal&gt;] ] [ B&lt;-0&gt;[I&lt;octal/hexadecimal&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltrap		Perl traps for the unwary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perltrap		Trampas para los incautos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-00478-1 [1st edition March 2006]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003142Z" changeid="explorer">
        <seg>ISBN 978-0-596-00478-1 [1ª edición - Marzo de 2006]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%-10.6x&gt;', 1;   # prints &quot;&lt;000001    &gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%-10.6x&gt;', 1;   # imprime &quot;&lt;000001    &gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, an explicit empty brace (C&lt;\x{}&gt;)
will not cause a warning (currently).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T231335Z" changeid="explorer">
        <seg>Sin embargo, una explícita pareja de llaves vacía (C&lt;\x{}&gt;) no provocará ninguna advertencia (actualmente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latest versions of perl have more bug fixes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200721Z" changeid="explorer">
        <seg>Las versiones más recientes de Perl incorporan más correcciones de errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In searching for C&lt;/\bfoo\b/&gt;, only locations in C&lt;$_&gt; that contain C&lt;f&gt;
will be looked at, because C&lt;f&gt; is rarer than C&lt;o&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la búsqueda de C&lt;/\bfoo\b/&gt;, los únicos lugares que serán examinados de C&lt;$_&gt; serán los que contengan una C&lt;f&gt;, debido a que C&lt;f&gt; es más rara que una C&lt;o&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlform		Perl formats</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000334Z" changeid="explorer">
        <seg>perlform		Formatos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, if something strange has gone wrong with your program and you're
not sure where you should look for help, try the B&lt;-w&gt; switch first.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000931Z" changeid="explorer">
        <seg>Si sucede algo raro con el programa y no está seguro de dónde debe buscar ayuda, pruebe primero el modificador B&lt;-w&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now it's time to print your data structure out.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193154Z" changeid="explorer">
        <seg>Ahora es el momento de imprimir la estructura de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 by Larry Wall
and others.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T163748Z" changeid="explorer">
        <seg>Perl is Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 by Larry Wall
and others.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($arrayref, $filename) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($arrayref, $archivo) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is not what you want, use C&lt;\Q&gt; to
interpolate a variable literally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no es esto lo que quiere, use C&lt;\Q&gt; para interpolar una variable literalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 AUTHOR</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T232605Z" changeid="zipf">
        <seg>=head1 AUTOR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[.?!]                       # followed by a sentence ender</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025622Z" changeid="explorer">
        <seg>[.?!]                       # seguido por un terminador de sentencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if there is no such group, it
will take virtually forever on a long string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T013538Z" changeid="explorer">
        <seg>Sin embargo, si no existe tal grupo, le tomará casi un tiempo infinito si la cadena es muy larga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the subroutine's prototype is C&lt;($$)&gt;, the elements to be compared are
passed by reference in C&lt;@_&gt;, as for a normal subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014227Z" changeid="explorer">
        <seg>Si el prototipo de la subrutina es C&lt;($$)&gt;, los elementos a ser comparados son pasados por referencia en C&lt;@_&gt;, como en una subrutina normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since C&lt;SIGINT&gt; and C&lt;SIGQUIT&gt; are ignored during the execution of
C&lt;system&gt;, if you expect your program to terminate on receipt of these
signals you will need to arrange to do so yourself based on the return
value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puesto que C&lt;SIGINT&gt; y C&lt;SIGQUIT&gt; son ignoradas durante la ejecución de C&lt;system&gt;, si espera que su programa termine a la recepción de estas señales tendrá que disponer lo necesario para hacerlo usted mismo en función del valor de retorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File::Find provides an example of this with its 
C&lt;find(\&amp;wanted, $dir)&gt; syntax.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020944Z" changeid="explorer">
        <seg>File::Find ofrece un ejemplo de esto con su sintaxis C&lt;find(\&amp;buscado, $dir)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing in reversed order</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, en orden inverso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
fact, C&lt;(?!)&gt; gets optimised into C&lt;(*FAIL)&gt; internally.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T143921Z" changeid="explorer">
        <seg>De hecho, C&lt;(?!)&gt; internamente está optimizado para ser C&lt;(*FAIL)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a filter has been installed with this method, it will be invoked
every time you read a value from a DBM database.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110812T144715Z" changeid="zipf">
        <seg>Si se ha instalado un filtro con este método, se invocará cada vez que se lea un valor de una base de datos DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regexp::Copy was affected by this change.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001600Z" changeid="explorer">
        <seg>Regexp::Copy se vio afectada por este cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're running Perl on a system that distinguishes between text
files and binary files, then you should check out L&lt;/binmode&gt; for tips
for dealing with this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está usando Perl en un sistema que distingue entre archivos de texto y archivos binarios, entonces debería consultar L&lt;/binmode&gt; para ver sugerencias para tratar con esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new pragma, C&lt;feature&gt;, has been added; see above in L&lt;/&quot;Core
Enhancements&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T012906Z" changeid="explorer">
        <seg>Un nuevo pragma, C&lt;feature&gt;, ha sido añadido; vea más arriba en L&lt;/&quot;Mejoras principales&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Decoding</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234724Z" changeid="explorer">
        <seg>=head3 Descodificación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># now case-insensitively</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ahora, independiente del tamaño de caja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New &quot;Missing control char name in \c&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002102Z" changeid="explorer">
        <seg>=head2 Nuevo &quot;I&lt;Missing control char name in \c&gt;&quot; (Falta nombre de carácter de control en \c)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, you may need to set C&lt;$|&gt; ($AUTOFLUSH
in English) or call the C&lt;autoflush()&gt; method of C&lt;IO::Handle&gt; on any
open handles to avoid lost output.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020513Z" changeid="explorer">
        <seg>Para estar seguros, puede necesitar poner C&lt;$|&gt; ($AUTOFLUSH en el módulo English) o llamar el método C&lt;autoflush()&gt; de C&lt;IO::Handle&gt; en cualquiera de los identificadores de archivo abiertos para evitar la pérdida de datos en la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Especially troublesome has been the feature that before
a &quot;=&gt;&quot; a version string (a &quot;v&quot; followed by digits) has been interpreted
as a v-string instead of a string literal.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T141447Z" changeid="explorer">
        <seg>Especialmente preocupante ha sido la característica de que antes de un &quot;=&gt;&quot;, una cadena de versión (una &quot;v&quot; seguida de dígitos) se ha interpretado como un v-string en lugar de una cadena literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$Config{longlongsize}&gt; is undefined on systems without 
long long support.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$Config{longlongsize}&gt; es indefinido en sistemas sin soporte de long largo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While none of the built-in data types have any arbitrary size limits
(apart from memory size), there are still a few arbitrary limits:  a
given variable name may not be longer than 251 characters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001747Z" changeid="explorer">
        <seg>Aunque ninguno de los tipos de datos integrados tiene un límite de tamaño (aparte del tamaño de la memoria disponible), hay algunos límites arbitrarios. Por ejemplo, un nombre de variable no puede tener más de 251 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also go the other direction, and write your
main program in C or C++, and then link in some Perl code on the fly,
to create a powerful application.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230946Z" changeid="explorer">
        <seg>También puede optar por trabajar en sentido contrario: desarrollar el programa principal en C o C++, y después vincular código Perl sobre la marcha para crear una aplicación eficaz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to interacting with the C&lt;(*SKIP)&gt; pattern, C&lt;(*MARK:NAME)&gt;
can be used to &quot;label&quot; a pattern branch, so that after matching, the
program can determine which branches of the pattern were involved in the
match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T124828Z" changeid="explorer">
        <seg>Además de interactuar con el patrón C&lt;(*SKIP)&gt;, C&lt;(*MARK:NOMBRE)&gt; puede ser usado para &quot;marcar&quot; una rama de del patrón, para que después de la búsqueda, el programa puede determinar qué ramas del patrón participaron en la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But benchmarks indicated that for some inputs, on some platforms,
the original quicksort was faster.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero los benchmarks indicaron que, para algunas entradas, en algunas plataformas, el quicksort original era más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Production releases, which incorporate bug fixes and new functionality,
are widely tested before release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230208Z" changeid="explorer">
        <seg>Las versiones de producción, que incorporan correcciones de errores y funcionalidad nueva, se someten a pruebas intensivas antes de su lanzamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if your forked child inherits system file descriptors like
STDIN and STDOUT that are actually connected by a pipe or socket, even
if you exit, then the remote server (such as, say, a CGI script or a
backgrounded job launched from a remote shell) won't think you're done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que si su hijo hereda los descriptores de archivo del sistema como STDIN y STDOUT que estén conectados a un pipe o a un socket, incluso si usted sale del programa, el servidor remoto (por ejemplo, un script CGI o un proceso lanzado en segundo plano desde un shell remoto) no se dará cuenta de que se ha ido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;\l&gt; X&lt;\u&gt; X&lt;\L&gt; X&lt;\U&gt; X&lt;\E&gt; X&lt;\Q&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;\l&gt; X&lt;\u&gt; X&lt;\L&gt; X&lt;\U&gt; X&lt;\E&gt; X&lt;\Q&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl tries to be all things
to all people, but nothing special to anyone.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231044Z" changeid="explorer">
        <seg>Perl trata de cubrir todas las necesidades, en lugar de limitarse a fines específicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which of these modifiers is in effect at any given point in a regular
expression depends on a fairly complex set of interactions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001441Z" changeid="explorer">
        <seg>Cuáles de estos modificares están activos en un determinado punto de una expresión regular depende de un conjunto muy complejo de interacciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allow building perl with -DUSE_UTF8_SCRIPTS which makes UTF-8
the default script encoding (not the default since that would
break all scripts having legacy eight-bit data in them)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>permitir la construcción de perl con -DUSE_UTF8_SCRIPTS que hace que sea la codificación UTF-8 la de por defecto en el codificado de los script (no está por defecto ya que rompería todos los script que tiene un legado de ocho bits de datos dentro de si)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of these books are available online through Safari Books Online
( http://safaribooksonline.com/ ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T002945Z" changeid="explorer">
        <seg>La mayoría de estos libros están disponibles en línea a través de Safari Books Online
( http://safaribooksonline.com/ ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the section on
C&lt;use VERSION&gt; of L&lt;perlfunc/require&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030336Z" changeid="explorer">
        <seg>Vea la sección C&lt;use VERSION&gt; de L&lt;perlfunc/require&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I
consider linking in C subroutines in this manner to be the moral
equivalent of defining subroutines in the Perl language itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T223905Z" changeid="explorer">
        <seg>Considero que el enlazado de las subrutinas en C, de esta manera, sean moralmente equivalentes a las definiciones de subrutinas en el propio lenguaje Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlintro -- a brief introduction and overview of Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T225748Z" changeid="zipf">
        <seg>perlintro -- Breve introducción y descripción general de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's ultimately
up to you (and possibly your management) which tasks you'll use Perl
for and which you won't.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230841Z" changeid="explorer">
        <seg>En última instancia, el usuario (y posiblemente sus jefes) deberán decidir para qué tareas pueden usar Perl, y para cuáles no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;s2&quot;,1,2);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;s2&quot;,1,2);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Scalars</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Escalares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are
responsible for ensuring that the string is not a temporary value, as that
could potentially get deallocated before you got around to using the packed
result.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted es responsable de asegurarse que la cadena no es un valor temporal, ya que podría quedar desasignado antes de poder usar el resultado empaquetado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/io/perlio_fail.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010001Z" changeid="explorer">
        <seg>=item t/io/perlio_fail.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New Or Improved Platforms</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014043Z" changeid="explorer">
        <seg>=head2 Nuevas o mejoras plataformas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The auto-increment operator has a little extra builtin magic to it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador de auto incremento tiene un poco más de magia en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>d  A double-precision float in native format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>d  Un flotante en doble precisión en formato nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just &quot;outdent&quot; it a little to make it more visible:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo &quot;desángrelo&quot; un poco para hacerlo más visible:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a struct utmp (BSDish)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># una struct utmp (del BSD)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;autouse&gt; upgraded to version 1.05</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T024031Z" changeid="explorer">
        <seg>C&lt;autouse&gt; actualizado a la versión 1.05</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#10.6x&gt;', 1;   # prints &quot;&lt;  0x000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#10.6x&gt;', 1;   # imprime &quot;&lt;  0x000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;P&gt; format packs a pointer to a structure of the size indicated
by the length.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El formato C&lt;P&gt; empaqueta un puntero a una estructura del tamaño indicado por la longitud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be a scalar variable containing the name of or a reference
to the filehandle, thus introducing one level of indirection.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T004907Z" changeid="explorer">
        <seg>IDENTIFICADOR_ARCHIVO puede ser una variable escalar conteniendo el nombre de o una referencia al identificador de archivo, introduciendo así un nivel más de indirección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub Foo::INC {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub Foo::INC {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A space or a newline is now required after a C&lt;&quot;#line XXX&quot;&gt; directive.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T191830Z" changeid="explorer">
        <seg>Ahora se requiere un espacio o una nueva línea después de una directiva C&lt;&quot;#line XXX&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to learn the basics of Perl, you might start with the
Llama book, which assumes that you already know a little about
programming:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003054Z" changeid="explorer">
        <seg>Si desea aprender los conceptos básicos de Perl, puede empezar por el Libro de la Llama, cuya lectura requiere unos conocimientos mínimos de programación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item binmode FILEHANDLE, LAYER
X&lt;binmode&gt; X&lt;binary&gt; X&lt;text&gt; X&lt;DOS&gt; X&lt;Windows&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004720Z" changeid="explorer">
        <seg>=item binmode IDENTIFICADOR_ARCHIVO, CAPA
X&lt;binmode&gt; X&lt;binary&gt; X&lt;text&gt; X&lt;DOS&gt; X&lt;Windows&gt; X&lt;binario&gt; X&lt;texto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most well known of these is C&lt;%ENV&gt; which contains environment
variables.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T234425Z" changeid="explorer">
        <seg>El más conocido es C&lt;%ENV&gt;, que contiene variables de entorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {$b cmp $a} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {$b cmp $a} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make split()'s unused captures to be undef, not ''</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hacer que las capturas no utilizadas de split() sean indefinidas, no ''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a  A string with arbitrary binary data, will be null padded.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a  Una cadena con datos binarios arbitrarios, serán rellenados con nulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(?:(?s-i)more.*than).*million/i</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232513Z" changeid="explorer">
        <seg>/(?:(?s-i)más.*que).*millones/i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As C&lt;\c&gt; is skipped at this step, C&lt;@&gt; of C&lt;\c@&gt; in RE is possibly
treated as an array symbol (for example C&lt;@foo&gt;),
even though the same text in C&lt;qq//&gt; gives interpolation of C&lt;\c@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como C&lt;\c&gt; es omitido en este paso, C&lt;@&gt; de C&lt;\c@&gt; en RE es posiblemente tratado como un símbolo de array (por ejemplo C&lt;@foo&gt;), incluso aunque el mismo texto en C&lt;qq//&gt; sí da la interpolación de C&lt;\c@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/x2p&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014733Z" changeid="explorer">
        <seg>=item * F&lt;t/x2p&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To view
the differences between the 5.7.1 release and the 5.7.2 release,
see L&lt;perl572delta&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215121Z" changeid="explorer">
        <seg>(Para ver las diferencias entre la versión 5.7.1 y la versión 5.7.2, vea L&lt;perl572delta&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;charnames&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005445Z" changeid="explorer">
        <seg>=item C&lt;charnames&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are Perl's functions (including things that look like
functions, like some keywords and named operators)
arranged by category.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí están las funciones Perl (incluyen cosas que parecen funciones, como algunas palabras clave y operadores con nombre) agrupados por categoría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until the block exits, elements locally deleted
temporarily no longer exist.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hasta que un bloque termine, los elementos locales suprimidos, temporalmente, ya no existen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus arrays and hashes lose their
identity in a LIST--the list</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, los arrays y hashes pierden su identidad en una LISTA: la lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With it, one can write C&lt;\d&gt; with confidence that it will only match
ASCII characters, and should the need arise to match beyond ASCII, you
can use C&lt;\p{Digit}&gt;, or C&lt;\p{Word}&gt; for C&lt;\w&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T212240Z" changeid="explorer">
        <seg>Con él, se puede escribir C&lt;\d&gt; con la confianza de que sólo coincidirá con caracteres ASCII, y en caso de necesidad, para que coincida más allá del ASCII, puede usar C&lt;\p{Digit}&gt;, o C&lt;\p{Word}&gt; en lugar de C&lt;\w&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pvec($vector);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>pvec($vector);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called in
scalar context, returns only the key (not the value) in a hash, or the index
in an array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se le llama en contexto escalar, sólo devuelve la clave (no el valor) del hash, o el índice del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.manning.com/cross</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003622Z" changeid="explorer">
        <seg>http://www.manning.com/cross</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX &quot;:sys_wait_h&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use POSIX &quot;:sys_wait_h&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item readlink EXPR
X&lt;readlink&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194433Z" changeid="explorer">
        <seg>=item readlink EXPR
X&lt;readlink&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$db-&gt;filter_fetch_key  ( sub { s/\0$//    } );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190130Z" changeid="zipf">
        <seg>$db-&gt;filter_fetch_key  ( sub { s/\0$//    } );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -MCPAN -e shell</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235036Z" changeid="explorer">
        <seg>perl -MCPAN -e shell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Text::Tabs;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225533Z" changeid="explorer">
        <seg>use Text::Tabs;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;unpack&gt;, an internal stack of integer arguments unpacked so far is
used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para C&lt;unpack&gt;, se usa una pila interna de argumentos enteros desempaquetados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13575</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13575</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\e                  escape            (ESC)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T040151Z" changeid="explorer">
        <seg>\e		escape					(ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unsupported in
                   lookbehind.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T044819Z" changeid="explorer">
        <seg>No soportado en
                   búsquedas de coincidencias previas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SUBNAME or BLOCK is omitted, C&lt;sort&gt;s in standard string comparison
order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si NOMBRE_SUB O BLOQUE se omite, se ordena siguiendo una comparación estándar de cadenas de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Operators which expect a string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234101Z" changeid="explorer">
        <seg>=item Operadores que consumen una cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first block or so of the
file is examined for odd characters such as strange control codes or
characters with the high bit set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer bloque (aprox.) del archivo, es examinado para buscar caracteres extraños como códigos de control o caracteres con el bit alto puesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments should
be integers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los argumentos deben ser números enteros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override the width by putting
a number here, or get the width from the next argument (with C&lt;*&gt;)
or from a specified argument (e.g., with C&lt;*2$&gt;):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede reemplazar el ancho al anteponer un número, u obteniendo la anchura del siguiente argumento (con C&lt;*&gt;) o de un argumento determinado (por ejemplo, con C&lt;*2$&gt;):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first argument of the
list will be interpreted as the C&lt;printf&gt; format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T010430Z" changeid="explorer">
        <seg>El primer argumento de la lista será interpretado como el formato para C&lt;printf&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true for success, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero en caso de éxito, o falso en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configurable error handling can be very useful to your users.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023646Z" changeid="explorer">
        <seg>Una gestión configurable de errores puede ser muy útil para los usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Cwd&gt; upgraded to version 3.12</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025738Z" changeid="explorer">
        <seg>C&lt;Cwd&gt; actualizado a la versión 3.12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of Perl 5.10.1 there is a new interface for plugging and using method
resolution orders other than the default (linear depth first search).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T113750Z" changeid="explorer">
        <seg>A partir de Perl 5.10.1 existe una nueva interfaz para la conexión y orden del método de resolución aparte del predeterminado (buscar primero en profundidad lineal).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Boolean logic</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Lógica Booleana</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} until $line  eq &quot;.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} until $linea  eq &quot;.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @{ $AoA[0] }, &quot;wilma&quot;, &quot;betty&quot;;   # explicit deref</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030453Z" changeid="explorer">
        <seg>push @{ $AoA[0] }, &quot;wilma&quot;, &quot;betty&quot;;   # desreferencia explícita</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that C&lt;$(&gt;, C&lt;$)&gt;, and
C&lt;$|&gt; are not interpolated because they look like end-of-string tests.)
Perl will not recompile the pattern unless an interpolated
variable that it contains changes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T203815Z" changeid="explorer">
        <seg>(Tenga en cuenta que C&lt;$(&gt;, C&lt;$)&gt;, y C&lt;$|&gt; no son interpolados porque tienen la apariencia de test de final-de-cadena). Perl no recompilará el patrón a menos que cambie una variable que vaya a ser interpolada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VALUE is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite VALOR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation tweaks</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ajustes en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the GNU project includes Perl in its distributions, there's no
such thing as &quot;GNU Perl&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200421Z" changeid="explorer">
        <seg>Aunque el proyecto GNU incluye Perl en sus distribuciones, no existe &quot;GNU Perl&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>11 blksize  preferred block size for file system I/O</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>11 blksize  tamaño preferido del bloque de E/S para el sistema de archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AUTHOR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>AUTOR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hours = $1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$horas = $1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is the same as this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es lo mismo que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are run first in the test
suite and if any of them fail, something is I&lt;really&gt; broken.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014604Z" changeid="explorer">
        <seg>Son las primeras que se ejecutan del conjunto de pruebas; si no se supera alguna de estas pruebas, significa que hay un problema grave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = ('cc', '-E', $bar);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = ('cc', '-E', $bar);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/hex&gt; and L&lt;perlfunc/oct&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215248Z" changeid="explorer">
        <seg>Vea L&lt;perlfunc/hex&gt; y L&lt;perlfunc/oct&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function semop(2) for semaphore operations
such as signalling and waiting.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC semop(2) para operaciones de semáforo como señalización y espera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello, world&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233532Z" changeid="zipf">
        <seg>print &quot;Hola a todos&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words,
the C&lt;foreach&gt; loop index variable is an implicit alias for each item
in the list that you're looping over.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, la variable índice del bucle C&lt;foreach&gt; es implícitamente un alias de cada elemento de la lista sobre la que está iterando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1: 'oo', pos=4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1: 'oo', pos=4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $perm = (stat $fh)[2] &amp; 07777;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $permisos = (stat $fh)[2] &amp; 07777;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>enhanced debugger and interactive Perl environment,
with integrated editor support</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001430Z" changeid="explorer">
        <seg>depurador mejorado y entorno Perl interactivo, compatible con un editor integrado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub foo { defined &amp;$bar ? &amp;$bar(@_) : die &quot;No bar&quot;; }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043804Z" changeid="explorer">
        <seg>sub foo { defined &amp;$bar ? &amp;$bar(@_) : die &quot;No bar&quot;; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also useful when writing C&lt;lex&gt;-like scanners, when you have
several patterns that you want to match against consequent substrings
of your string; see the previous reference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045340Z" changeid="explorer">
        <seg>También es útil cuando se escriben escáneres C&lt;lex&gt;, cuando tiene varios patrones que desea hacer coincidir contra consiguientes subcadenas de su cadena; vea la referencia anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Jarkko Hietaniemi &lt;jhi@iki.fi&gt;
Bryan Logan &lt;bryanlog@us.ibm.com&gt;
David Larson &lt;larson1@us.ibm.com&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T134610Z" changeid="explorer">
        <seg>Jarkko Hietaniemi &lt;jhi@iki.fi&gt;
Bryan Logan &lt;bryanlog@us.ibm.com&gt;
David Larson &lt;larson1@us.ibm.com&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However,
you may distribute this Package in aggregate with other (possibly
commercial) programs as part of a larger (possibly commercial) software
distribution provided that you do not advertise this Package as a
product of your own.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, usted puede distribuir este Paquete en conjunto con otros programas (posiblemente comerciales) como parte de una mayor (posiblemente comercial) distribución de software siempre y cuando no haga publicidad de este Paquete como si fuera un producto suyo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(F) You passed a buffer of the wrong size to one of msgctl(), semctl()
or shmctl().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110307T000724Z" changeid="explorer">
        <seg>(F) You passed a buffer of the wrong size to one of msgctl(), semctl()
or shmctl().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This
can happen if the group is optional, or in a different branch of an
alternation.)
You can omit the C&lt;&quot;g&quot;&gt;, and write C&lt;&quot;\1&quot;&gt;, etc, but there are some issues with
this form, described below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T001820Z" changeid="explorer">
        <seg>(Esto puede ocurrir si el grupo es opcional, o en una rama diferente de una alternancia.) Puede omitir la C&lt;&quot;g&quot;&gt;, y escribir C&lt;&quot;\1&quot;&gt;, etc, pero hay algunos problemas con este formato, como se describe más abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mentioning the ternary operator in
this error message makes it easier to diagnose syntax errors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051244Z" changeid="explorer">
        <seg>Al mencionar el operador ternario en este mensaje de error hace que sea más fácil diagnosticar errores de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line-noise lowercase line-noise lowercase line-noise lowercase</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205637Z" changeid="explorer">
        <seg>línea-ruido minúsculas línea-ruido minúsculas línea-ruido minúsculas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the file descriptor for a filehandle, or undefined if the
filehandle is not open.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010246Z" changeid="explorer">
        <seg>Devuelve el descriptor de archivo para un identificador de archivo, o indefinido si el identificador de archivo no está abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;W4&quot;,65,66,67,68);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;W4&quot;,65,66,67,68);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those systems that implement a proprietary shadow password
facility are unlikely to be supported.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T162417Z" changeid="explorer">
        <seg>Los sistemas que implementen un sistema de contraseñas shadow propietario es impropable que sean soportados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Network socket support is disabled for BeOS R5 net server.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Soporte para socket está desactivado para BeOS R5 net server.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220321Z" changeid="explorer">
        <seg>Vea también:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>78/75813 subtests failed, 99.90% okay.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005055Z" changeid="explorer">
        <seg>78/75813 subtests fallaron, 99.90% bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;open&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;open&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nice place to ask questions is the PerlMonks site,
http://www.perlmonks.org/ , or the Perl Beginners mailing list
http://lists.perl.org/showlist.cgi?name=beginners .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230504Z" changeid="explorer">
        <seg>Un buen lugar para hacer preguntas es el sitio de PerlMonks, http://www.perlmonks.org/ , o la lista de correo para principiantes, http://lists.perl.org/showlist.cgi?name=beginners .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,10, 2) = 2   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,10, 2) = 2   ==    2097152 00000000000000000000010000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What was Ponie?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T225913Z" changeid="explorer">
        <seg>=head2 ¿Qué era Ponie?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop&gt; for more details on unary operators and the comma operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop&gt; para más detalles en operadores unarios y el operador coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\x{}, \x00  character whose ordinal is the given hexadecimal number</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043557Z" changeid="explorer">
        <seg>\x{}, \x00	carácter cuyo ordinal es el número hex indicado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170025Z" changeid="explorer">
        <seg>$wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 About Compiler Versions of Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003014Z" changeid="explorer">
        <seg>=head2 Sobre las versiones del compilador de Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the
C&lt;Time::Local&gt; module (for converting seconds, minutes, hours, and such back to
the integer value returned by time()), and the L&lt;POSIX&gt; module's strftime(3)
and mktime(3) functions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000345Z" changeid="explorer">
        <seg>Vea también el módulo C&lt;Time::Local&gt; (para convertir los segundos, minutos, horas, etc, de nuevo al valor entero devuelto por time()), y las funciones strftime(3) y mktime(3) del módulo L&lt;POSIX&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Unpacking Perl Distribution on VM/ESA</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101357Z" changeid="explorer">
        <seg>=head2 Desempaquetando distribuciones Perl en VM/ESA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>seek(FILE, $curpos, 0);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>seek(FILE, $curpos, 0);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash    Hash      hash keys identical (every key is found in both hashes)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hash        Hash       claves hash identicas (cada clave está en ambos hash)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item More complex regular expressions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233428Z" changeid="zipf">
        <seg>=item Expresiones regulares más complejas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if warnings are enabled, a warning of the
C&lt;printf&gt; warning class is issued on an unsupported conversion flag.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182318Z" changeid="explorer">
        <seg>Sin embargo, si las advertencias están habilitadas, una advertencia de la clase C&lt;printf&gt; es emitida cuando no esté soportada una bandera de conversión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tidies a pod file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014842Z" changeid="explorer">
        <seg>Ordena un archivo pod.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$abbr[$mon] $mday&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$abbr[$mes] $mdia&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of using C&lt;given()&gt;, you can use a C&lt;foreach()&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En lugar de usar C&lt;given()&gt;, puede usar un bucle C&lt;foreach()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could just make a direct assignment
if you knew where you wanted to put it:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacer una asignación directa si sabe dónde quiere ponerlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>document the coderef-in-@INC feature</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>documentar la característica &quot;referencia a código&quot; en @INC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special case, specifying a PATTERN of space (S&lt;C&lt;' '&gt;&gt;) will split on
white space just as C&lt;split&gt; with no arguments does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como caso especial, especificando un PATRÓN de un espacio (S&lt;C&lt;' '&gt;&gt;) dividirá en espacios en blanco al igual que lo hace C&lt;split&gt; sin argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;$*&gt; Variable Will Be Removed
(it was deprecated a long time ago)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014735Z" changeid="explorer">
        <seg>La variable C&lt;$*&gt; será eliminada
(que estaba en desuso desde hace mucho tiempo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>accompany the distribution with the machine-readable source of the
Package with your modifications.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>acompañar a la distribución con el código fuente, legible por la máquina, del Paquete con sus modificaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The copy of the Unicode Character Database included in Perl 5.8 has
been updated to 4.0.0 from 3.2.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170728Z" changeid="explorer">
        <seg>La copia de la base de datos de caracteres Unicode incluidos en Perl 5.8 ha sido actualizado desde la 3.2.0 a la 4.0.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upgraded from version 2.64 to 3.17.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003451Z" changeid="explorer">
        <seg>Actualizado desde la versión 2.64 a la 3.17.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = @foo;                # $foo gets 3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = @foo;                # $foo vale 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5133delta	Perl changes in version 5.13.3</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141427Z" changeid="explorer">
        <seg>perl5133delta	Cambios en la versión 5.13.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 4   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 4   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: Any files opened at the time of the dump will I&lt;not&gt;
be open any more when the program is reincarnated, with possible
resulting confusion by Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;ATENCIÓN&gt;: Cualquier archivo abierto en el momento del volcado I&lt;no&gt; será abierto mas que cuando el programa sea reencarnado, con una muy posible confusión por parte de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copy the miniperl executable from the native build done earlier to
replace the cross compiled miniperl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Copie el ejecutable miniperl desde la construcción nativa hecha antes, para reemplazar el miniperl compilado de forma cruzada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can--but shouldn't--omit the mode in these forms when that mode
is C&lt;&lt; &lt; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T002813Z" changeid="explorer">
        <seg>Puede -pero no debe- omitir el modo en estos formatos cuando ese modo sea C&lt;&lt; &lt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;syslog()&gt; can now use numeric constants for facility names and priorities,
in addition to strings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T104808Z" changeid="explorer">
        <seg>C&lt;syslog()&gt; ahora puede utilizar constantes numéricas para los nombres de las facilidades y las prioridades, además de cadenas normales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(($a % 2) ? ($a += 10) : $a) += 2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054118Z" changeid="explorer">
        <seg>(($a % 2) ? ($a += 10) : $a) += 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># alter $@ on nefarious repugnancy only</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># altera $@ solo en una infame repugnancia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The granularity for such extension or truncation is one or more
bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La granularidad para dicha extensión o truncamiento es de uno o más bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is the Unicode character or character sequence given by I&lt;name&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204210Z" changeid="explorer">
        <seg>El resulado es un carácter o secuencias de caracteres Unicode indicado por I&lt;nombre&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CORE::require() and CORE::do() were always parsed as require() and do()
when they were overridden.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035116Z" changeid="explorer">
        <seg>CORE::require() y CORE::do() eran siempre interpretadas como require() y do() cuando eran sobreescritas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you call it again after this, it will assume you are processing another
@ARGV list, and if you haven't set @ARGV, will read input from STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si lo llama de nuevo, después, asumirá que está procesando otra lista @ARGV, y si no ha configurado @ARGV, leerá la entrada desde STDIN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 4) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 4) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Smaller fixes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044948Z" changeid="explorer">
        <seg>=head2 Correcciones menores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this port does support dynamic loading but it's not had much testing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101900Z" changeid="explorer">
        <seg>esta adaptación tiene soporte para carga dinámica, pero no ha sido muy testado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most systems the epoch is 00:00:00 UTC, January 1, 1970;
a prominent exception being Mac OS Classic which uses 00:00:00, January 1,
1904 in the current local time zone for its epoch.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de los sistemas el I&lt;epoch&gt; son las 00:00:00 UTC, del 1 de enero de 1970; una prominente excepción es el Mac OS Classic que utiliza las 00:00:00, del 1 de enero de 1904 en la actual zona horaria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.apress.com/book/view/159059097X</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003508Z" changeid="explorer">
        <seg>http://www.apress.com/book/view/159059097X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SUBNAME is specified, it gives the name of a subroutine
that returns an integer less than, equal to, or greater than C&lt;0&gt;,
depending on how the elements of the list are to be ordered.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se ha especificado NOMBRE_SUB, da el nombre de la subrutina que devuelve un entero menor que, igual que, o mayor que C&lt;0&gt;, dependiendo de cómo los elementos de la lista tienen que ser ordenados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Test::Harness&gt; upgraded to version 2.56 (was 2.48)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035806Z" changeid="explorer">
        <seg>C&lt;Test::Harness&gt; actualizado a la versión 2.56 (era 2.48)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the answer to
&quot;Where can I buy a commercial version of perl?&quot; for more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200531Z" changeid="explorer">
        <seg>Vea la respuesta a la pregunta &quot;¿Dónde puedo adquirir una versión comercial de Perl?&quot; para obtener más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most systems, this will set the file's access and
modification times to the current time (i.e., equivalent to the example
above) and will work even on files you don't own provided you have write
permission:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de los sistemas, esto hará que los tiempos de acceso y modificación del archivo se establezcan a la hora actual (es decir, equivalente al ejemplo anterior) y funcionará incluso en archivos de los cuales usted no tenga permisos de escritura:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; &gt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; &gt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>means to use the current locale's rules (see L&lt;perllocale&gt;) when pattern
matching.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220401Z" changeid="explorer">
        <seg>significa que hay que usar las reglas regionales actuales (vea L&lt;perllocale&gt;) en la coincidencia de patrones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/&quot;I/O Operators&quot;&gt; for more discussion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220212Z" changeid="explorer">
        <seg>Vea L&lt;/&quot;Operadores E/S&quot;&gt; para más discusiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When your module encounters an error it should do one or more of:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023140Z" changeid="explorer">
        <seg>Cuando el módulo se encuentre con un error debe hacer uno o más de:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%+.6d&gt;', 1;     # prints &quot;&lt;+000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%+.6d&gt;', 1;     # imprime &quot;&lt;+000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$db-&gt;filter_store_key  ( sub { $_ = pack (&quot;i&quot;, $_) } );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190156Z" changeid="zipf">
        <seg>$db-&gt;filter_store_key  ( sub { $_ = pack (&quot;i&quot;, $_) } );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like C&lt;print&gt;, but implicitly appends a newline.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Igual que C&lt;print&gt;, pero implícitamente añade un carácter de nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;%32W*&quot;,&lt;&gt;) % 65535;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unpack(&quot;%32W*&quot;,&lt;&gt;) % 65535;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Callbacks</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114219Z" changeid="explorer">
        <seg>=head1 Retrollamadas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right	= += -= *= etc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>derecha	= += -= *= etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The author of Perl has never felt the
need to use this form of C&lt;goto&gt; (in Perl, that is--C is another matter).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El autor de Perl nunca ha sentido la necesidad de usar esta forma de C&lt;goto&gt; (en Perl, desde luego. C es otra historia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To find out whether a given string is a valid non-zero number, it's
sometimes enough to test it against both numeric 0 and also lexical
&quot;0&quot; (although this will cause noises if warnings are on).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para saber si una cadena dada es un número válido distinto de cero, a veces es suficiente con compararlo con el 0 numérico y también con el &quot;0&quot; léxico (aunque esto provocará ruido si los avisos están activados).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Sys::Syslog&gt; upgraded to version 0.13</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035043Z" changeid="explorer">
        <seg>C&lt;Sys::Syslog&gt; actualizado a la versión 0.13</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$count = $string =~ /\d+/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cuenta = $cadena =~ /\d+/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checks if the numbered capturing group has matched something.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213234Z" changeid="explorer">
        <seg>Comprueba si el grupo de captura indicado por el número, ha coincidido con algo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;8 - 4&gt; is evaluated first making the
expression C&lt;4 - 2 == 2&gt; and not C&lt;8 - 2 == 6&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;8 - 4&gt; es evaluada primero dejando la expresión C&lt;4 - 2 == 2&gt; y no C&lt;8 - 2 == 6&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ENFMT stands for</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El ENFMT significa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to write loops that terminate when a null list
is returned:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto hace que sea fácil escribir bucles que terminan cuando se devuelve una lista vacía:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Core Changes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Cambios principales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last if eof();          # needed if we're reading from a terminal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last if eof();          # necesario si estamos leyendo de una terminal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with the sequence C&lt;1100&gt; repeating again and again.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232514Z" changeid="explorer">
        <seg>donde la secuencia C&lt;1100&gt; se repite una y otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Ksh</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225453Z" changeid="explorer">
        <seg>=item Ksh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system(@args) == 0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system(@args) == 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print PASSWD &quot;${who}::0:0:Superuser:/:/bin/perl\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print PASSWD &quot;${quien}::0:0:Superusuario:/:/bin/perl\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function allows you to distinguish C&lt;undef&gt; from
other values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función le permite distinguir C&lt;undef&gt; de otros valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hashes are unordered collections of scalar 
values indexed by their associated string key.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los hashes son colecciones no ordenadas de valores escalares indexadas por sus claves asociadas, que son cadenas de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strange though this may seem, this is the basis for the whole
module import/export system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por extraño que pueda parecer, esta es la base para todo el sistema de importación/exportación en los módulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a number of &quot;magic&quot; scalars with names that look like
punctuation or line noise.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224830Z" changeid="explorer">
        <seg>Hay varios escalares &quot;mágicos&quot; con nombres que recuerdan conjuntos de signos de puntuación (o &quot;ruido de señal&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The metacharacters are</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113327Z" changeid="explorer">
        <seg>Los metacaracteres son</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($zippy) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232631Z" changeid="explorer">
        <seg>if ($zippy) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This quoting\ Business\ HERE\ ISN\'T\ QUITE\ done\ yet\, is it?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T233222Z" changeid="explorer">
        <seg>Este trabajo\ de\ Escapado\ AÚN\ NO\ SE\ HA\ terminado\, ¿no?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:-)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T114150Z" changeid="zipf">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;h2xs|h2xs&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234533Z" changeid="explorer">
        <seg>=item L&lt;h2xs|h2xs&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The internal dump output has been improved, so that non-printable characters
such as newline and backspace are output in C&lt;\x&gt; notation, rather than
octal.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T102859Z" changeid="explorer">
        <seg>La salida del comando interno dump se ha mejorado, de modo que los caracteres no imprimibles, como el nueva línea y la tecla de retroceso se emiten en notación C&lt;\x&gt;, en lugar de octal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rand +(10) * 20;	# rand (10 * 20)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>rand +(10) * 20;	# rand (10 * 20)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11371</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11371</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item goto LABEL
X&lt;goto&gt; X&lt;jump&gt; X&lt;jmp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173857Z" changeid="explorer">
        <seg>=item goto ETIQUETA
X&lt;goto&gt; X&lt;jump&gt; X&lt;jmp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)&gt; matches exactly
at these positions, so we want to have each C&lt;\Y|&gt; in the place of the
more complicated version.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001748Z" changeid="explorer">
        <seg>Note que C&lt;(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)&gt; coincide exactamente con esas posiciones, así que lo que queremos es usar C&lt;\Y|&gt; en lugar de una versión más complicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when world writable?) at lib/ftmp-security.t line 100</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when world writable?) at lib/ftmp-security.t line 100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11375</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11375</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extraneous &quot;?&quot; from C&lt;self_url()&gt; removed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T024721Z" changeid="explorer">
        <seg>Un extraño &quot;?&quot; devuelto por C&lt;self_url()&gt;, eliminado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New &quot;Illegal declaration of anonymous subroutine&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001745Z" changeid="explorer">
        <seg>=head2 Nuevo &quot;I&lt;Illegal declaration of anonymous subroutine&gt;&quot; (Declaración ilegal de una subrutina anónima)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>map!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225450Z" changeid="explorer">
        <seg>map!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Verbose modifier C&lt;v&gt; added for C&lt;-DXv&gt; and C&lt;-Dsv&gt;, see L&lt;perlrun&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001903Z" changeid="explorer">
        <seg>El modificador de detalle C&lt;v&gt; añadido para C&lt;-DXv&gt; y C&lt;-Dsv&gt;, vea L&lt;perlrun&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Various minor bug fixes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Varios errores menores arreglados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T010646Z" changeid="explorer">
        <seg>if ($.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If Perl is new (and thus scary) to them,
find something that Perl can do to solve one of their problems.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232146Z" changeid="explorer">
        <seg>Si nunca han utilizado Perl y se sienten inseguros, busque alguna tarea en la que Perl les pueda ayudar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arranges to have a SIGALRM delivered to this process after the
specified number of wallclock seconds has elapsed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ordena mandar una señal SIGALRM al proceso actual después de que haya pasado el número de segundos especificados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means you usually want to use positive not negative signals.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Eso significa que desea utilizar, generalmente, señales positivas, y no negativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$val = oct($val) if $val =~ /^0/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$val = oct($val) if $val =~ /^0/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, &quot;..&quot; returns a boolean value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, &quot;..&quot; devuelve un valor booleano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several examples below that illustrate these perils.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T190805Z" changeid="explorer">
        <seg>Hay varios ejemplos a continuación que ilustran estos peligros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#whatever = -1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#loquesea = -1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%e    a floating-point number, in scientific notation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%e    un número en punto flotante, en notación científica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct mro_alg {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T113944Z" changeid="explorer">
        <seg>struct mro_alg {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(or regen_uconfig64 if you're editing uconfig64.sh)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223547Z" changeid="explorer">
        <seg>(o regen_uconfig64 si está editando uconfig64.sh)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may not be used to go into any construct that
requires initialization, such as a subroutine or a C&lt;foreach&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede ser usado en ninguna construcción que requiera inicialización, como una subrutina o un bucle C&lt;foreach&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many Unicode tests are skipped when
they really should be fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003230Z" changeid="explorer">
        <seg>Muchas pruebas de Unicode se omiten cuando en realidad deberían ser arregladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item On ASCII platforms</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174511Z" changeid="explorer">
        <seg>=item En plataformas ASCII</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, &quot;&lt;&quot;, &quot;input.txt&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000954Z" changeid="explorer">
        <seg>open(my $fh, &quot;&lt;&quot;, &quot;input.txt&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item goto &amp;NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item goto &amp;NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, use of C&lt;$[&gt; is deprecated.)
So in general you can assume that
X&lt;$[&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T001436Z" changeid="explorer">
        <seg>(En otras palabras, el uso de C&lt;$[&gt; es obsoleto). Por ello, en general, puede asumir que X&lt;$[&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default {
            print &quot;I don't like anything&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T235535Z" changeid="explorer">
        <seg>default {
            print &quot;No me gusta nada&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An C&lt;our&gt; declaration declares a global variable that will be visible
across its entire lexical scope, even across package boundaries.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una declaración C&lt;our&gt; declara una variable global que será visible en todo su ámbito léxico, incluso a través de las fronteras del paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 New or Changed Diagnostics</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Diagnósticos nuevos y cambiados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>. 'more '/eg;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054303Z" changeid="explorer">
        <seg>. 'más '/eg;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substr($name, 4) = 'dy';         # $name is now 'freddy'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>substr($nombre, 4) = 'ito';       # $nombre es ahora 'pedrito'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>w  A BER compressed integer (not an ASN.1 BER, see perlpacktut for</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>w  Un entero comprimido en BER (no en ASN.1 BER, ver perlpacktut para los</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may need to worry about the networking
configuration files discussed in the last bullet below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101337Z" changeid="explorer">
        <seg>Es posible que tenga que preocuparse de los archivos de configuración de red, discutido en el último punto de más abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The module can implement its
C&lt;import&gt; method any way it likes, though most modules just choose to
derive their C&lt;import&gt; method via inheritance from the C&lt;Exporter&gt; class that
is defined in the C&lt;Exporter&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo puede implementar su propio método C&lt;import&gt; de la forma que desee, aunque la mayoría de los módulos sólo eligen derivar su método C&lt;import&gt; vía herencia desde la clase C&lt;Exporter&gt; que se define en el módulo C&lt;Exporter&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 @INC reorganization</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T232856Z" changeid="explorer">
        <seg>=head2 Reorganización de @INC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Shift Operators
X&lt;shift operator&gt; X&lt;operator, shift&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;
X&lt;&lt;&lt; &gt;&gt; &gt;&gt;&gt; X&lt;right shift&gt; X&lt;left shift&gt; X&lt;bitwise shift&gt;
X&lt;shl&gt; X&lt;shr&gt; X&lt;shift, right&gt; X&lt;shift, left&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234557Z" changeid="explorer">
        <seg>=head2 Operadores de desplazamiento
X&lt;shift operator&gt; X&lt;operator, shift&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;
X&lt;&lt;&lt; &gt;&gt; &gt;&gt;&gt; X&lt;right shift&gt; X&lt;left shift&gt; X&lt;bitwise shift&gt;
X&lt;shl&gt; X&lt;shr&gt; X&lt;shift, right&gt; X&lt;shift, left&gt; X&lt;operador de desplazamiento&gt; X&lt;operador, desplazamiento&gt; X&lt;desplazamiento derecho&gt; X&lt;desplazamiento izquierdo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl functions affected
by this are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las funciones Perl afectadas por esto son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;goto(&quot;NE&quot;).&quot;XT&quot;&gt; is equivalent to C&lt;goto NEXT&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165135Z" changeid="explorer">
        <seg>C&lt;goto(&quot;NE&quot;).&quot;XT&quot;&gt; es equivalente a C&lt;goto NEXT&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of
the guiding mottos for Perl development is &quot;there's more than one way
to do it&quot; (TMTOWTDI, sometimes pronounced &quot;tim toady&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230330Z" changeid="explorer">
        <seg>Uno de los lemas que dirigen el desarrollo de Perl es &quot;se puede hacer de varias maneras&quot;, que es la traducción de &quot;there's more than one way
to do it&quot; (o TMTOWTDI, pronunciado &quot;tim toady&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Socket&gt; upgraded to version 1.78</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034611Z" changeid="explorer">
        <seg>C&lt;Socket&gt; actualizado a la versión 1.78</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(a.)+/             matches a string in which every odd-numbered letter
                        is a (eg &quot;abacadaf&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055800Z" changeid="explorer">
        <seg>/(a.)+/             cadena en la que cada letra impar es a
                        (ej. &quot;abacadaf&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014921Z" changeid="explorer">
        <seg>Ahora arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each semop structure can be generated with
C&lt;pack(&quot;s!3&quot;, $semnum, $semop, $semflag)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada estructura semop se puede generar con C&lt;pack(&quot;s!3&quot;, $semnum, $semop, $semflag)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?&lt;NAME_PAT&gt;....)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T203508Z" changeid="explorer">
        <seg>(?&lt;NOMBRE_PAT&gt;....)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with Perl 5.14, C&lt;shift&gt; can take a scalar EXPR, which must hold a
reference to an unblessed array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181155Z" changeid="explorer">
        <seg>A partir de Perl 5.14, C&lt;shift&gt; puede tomar una EXPR escalar, que debe contener la referencia a un hash o un array no bendecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, C&lt;undef&gt; is returned only once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una vez más, C&lt;undef&gt; sólo se devuelve una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;formline&gt; always returns true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;formline&gt; siempre devuelve verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11362</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11362</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#ARRAY];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#ARRAY];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The discrepancy in the return values in list context is
considered a bug by some, and will probably be fixed in a future
release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T160529Z" changeid="explorer">
        <seg>La discrepancia en los valores de retorno en el contexto de lista es considerado un error por parte de algunos, y probablemente será corregido en futuras versiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each
hash or array has its own internal iterator, accessed by C&lt;each&gt;, C&lt;keys&gt;,
and C&lt;values&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada hash o array tiene su iterador interno, accedido por C&lt;each&gt; , C&lt;keys&gt;, y C&lt;values&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>const char *name;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T113954Z" changeid="explorer">
        <seg>const char *nombre;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hash or array element can be true only if it's defined and defined only if
it exists, but the reverse doesn't necessarily hold true.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T233950Z" changeid="explorer">
        <seg>Un elemento de un hash o de un array puede ser verdadero sólo si está definido, y está definido solo si ya existe, pero lo inverso no es necesariamente cierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List assignment in scalar context returns the number of elements
produced by the expression on the right side of the assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lista de asignación en contexto escalar devuelve el número de elementos producidos por la expresión en el lado derecho de la asignación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Win32</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015440Z" changeid="explorer">
        <seg>Win32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is better than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es mejor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use the C&lt;keys&gt;, C&lt;values&gt;, C&lt;each&gt; builtin functions on arrays
(previously you could only use them on hashes).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230041Z" changeid="explorer">
        <seg>Ahora puede usar las funciones incorporadas C&lt;keys&gt;, C&lt;values&gt;, C&lt;each&gt; con arrays (anteriormente sólo se podía utilizar con los hashes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the counting for relative recursion differs from that of
relative backreferences, in that with recursion unclosed groups B&lt;are&gt;
included.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T212817Z" changeid="explorer">
        <seg>Tenga en cuenta que el recuento de la recursión relativa difiere de la de contra-referencias relativas, en que con recursión, los grupos no cerrados B&lt;están&gt; incluidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called with a parameter, C&lt;srand&gt; uses that for the seed;
otherwise it (semi-)randomly chooses a seed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182633Z" changeid="explorer">
        <seg>Cuando se llama con un parámetro, C&lt;srand&gt; la usa para la semilla; de lo contrario elige pseudo-aleatoriamente una semilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (%tied_hash) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003658Z" changeid="explorer">
        <seg>if (%tied_hash) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class implementing a scalar should have the following methods:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una clase que implementa un escalar debe tener los siguientes métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getservbyport PORT,PROTO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getservbyport PUERTO,PROTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only hexadecimal digits are valid following C&lt;\x&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110522T175653Z" changeid="explorer">
        <seg>Solo están permitidos dígitos hexadecimales si van a continuación de C&lt;\x&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close $in or die &quot;$in: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T225729Z" changeid="zipf">
        <seg>close $entrada or die &quot;$entrada: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perljp		Perl for Japanese (in EUC-JP)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000829Z" changeid="explorer">
        <seg>perljp		Perl para japonés (en EUC-JP)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named groups count in
absolute and relative numbering, and so can also be referred to by those
numbers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T141607Z" changeid="explorer">
        <seg>Los grupos con nombre se numeran de forma absoluta y relativa, por lo que también se puede hacer referencia a ellos con esos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the semaphore id, or
the undefined value on error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013635Z" changeid="explorer">
        <seg>Devuelve el id del semáforo, o el valor indefinido en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**=    +=    *=    &amp;=    &lt;&lt;=    &amp;&amp;=
           -=    /=    |=    &gt;&gt;=    ||=
           .=    %=    ^=           //=
                 x=</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054133Z" changeid="explorer">
        <seg>**=    +=    *=    &amp;=    &lt;&lt;=    &amp;&amp;=
           -=    /=    |=    &gt;&gt;=    ||=
           .=    %=    ^=           //=
                 x=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endprotoent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endprotoent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which lasts until the end of that BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>que durará hasta el final de ese BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0  &quot;homer&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032555Z" changeid="explorer">
        <seg>0  &quot;homer&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.9.3 and the 5.9.4
development releases.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T234748Z" changeid="explorer">
        <seg>Este documento describe las diferencias entre las versiones de desarrollo 5.9.3 y la 5.9.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces the output 'h:i :t:h:e:r:e!'.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce la salida 'h:o:l:a :p:o:r :a:q:u:i!'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can run scripts from the previous major release, Perl 4
(March 1991), but has significant differences.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004319Z" changeid="explorer">
        <seg>Permite ejecutar scripts de la versión principal anterior, Perl 4 (lanzada en marzo de 1991), pero incluye diferencias importantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (DEFINE)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195728Z" changeid="explorer">
        <seg>=item (DEFINE)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 111631</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 111631</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	-&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	-&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in short:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T225811Z" changeid="zipf">
        <seg>Se incluye a continuación un resumen:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checksumming the compressed output of one or more
rapidly changing operating system status programs is the usual method.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El método usual es la suma de control de la salida comprimida de uno o más programas, rápidamente cambiantes, de estado del sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, 1.23 times ten to the
99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, 1.23 por diez elevado a 99 puede ser &quot;1.23e99&quot; o &quot;1.23e099&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taken together, these features go a long way towards
making Perl's regular expressions more readable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En conjunto, estas características hacen un gran labor para conseguir que las expresiones regulares de Perl sean más legibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scopes where C&lt;use integer;&gt; is in force, nearly all the operators listed
above will force their argument(s) into integer format, and return an integer
result.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234026Z" changeid="explorer">
        <seg>En ámbitos en los que C&lt;use integer;&gt; está activo, casi todos los operadores indicados arriba forzarán la conversión de sus argumentos a formato de entero, y devolverán un resultado entero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This always forces interpretation of the
LIST as a multivalued list, even if there is only a single scalar in
the list.)  Example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto siempre fuerza la interpretación de la LISTA como una lista multievaluada, incluso si sólo hay un único escalar en la lista). Ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;Changes&gt; file for an explanation of how to view exhaustive details
on what changed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T232641Z" changeid="explorer">
        <seg>El archivo F&lt;Changes&gt; (Cambios) para obtener más información exhaustiva sobre lo que ha cambiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3: got AB</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170303Z" changeid="explorer">
        <seg>3: tenemos AB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the delimiter chosen is a single quote, no interpolation is
done on either the PATTERN or the REPLACEMENT.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el delimitador elegido es una comilla simple, no se realiza ninguna interpolación, ni en el PATRÓN ni en el REEMPLAZO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They work much like quotes in the standard Unix shells:
double-quoted string literals are subject to backslash and variable
substitution; single-quoted strings are not (except for C&lt;\'&gt; and
C&lt;\\&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T001506Z" changeid="explorer">
        <seg>Funcionan de forma muy parecida a las comillas en las líneas de comandos Unix: literales de cadena entre comillas dobles están sujetos a la barra invertida y la sustitución de variables; cadenas entre comillas simples no lo están (a excepción de C&lt;\'&gt; y C&lt;\\&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/((.)(.)(.)(.)(.)(.)(.)(.)(.))\10/  # \10 is a backreference</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191509Z" changeid="explorer">
        <seg>/((.)(.)(.)(.)(.)(.)(.)(.)(.))\10/  # \10 es una contrareferencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of the automatic
conversion of scalars, operations that return scalars don't need
to care (and in fact, cannot care) whether their caller is looking
for a string, a number, or a reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que la conversión de escalares es automática, las operaciones que los devuelven no necesitan tener en cuenta (y, de hecho, no pueden hacerlo), si quien ha hecho la petición está esperando una cadena, un número o una referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In older versions of Perl, programmers
would insert curly brackets to force interpretation as a filename glob:
C&lt;&lt; &lt;${foo}&gt; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En versiones anteriores de Perl, los programadores insertaban llaves para forzar la interpretación como una expansión de nombre de archivo: C&lt;&lt; &lt;$foo{}&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shift(@a)           splice(@a,0,1)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shift(@a)           splice(@a,0,1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the C&lt;my&gt; variable may be C&lt;undef&gt;, any
previously assigned value, or possibly anything else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de la variable C&lt;my&gt; puede ser C&lt;undef&gt;, cualquier valor anteriormente asignado, o posiblemente, cualquier otra cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't open $FOO: $!&quot; unless open(FOO);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo abrir $FOO: $!&quot; unless open(FOO);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Care should be taken not
to cause line number collisions in code you'd like to debug later.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay que tener cuidado para no causar colisiones de números de línea en el código que pretenda depurar más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;while&gt; and C&lt;until&gt; modifiers have the usual &quot;C&lt;while&gt; loop&quot;
semantics (conditional evaluated first), except when applied to a
C&lt;do&gt;-BLOCK (or to the deprecated C&lt;do&gt;-SUBROUTINE statement), in
which case the block executes once before the conditional is
evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T105517Z" changeid="explorer">
        <seg>Los modificadores C&lt;while&gt; y C&lt;until&gt; tienen la usual semántica de los &quot;bucles C&lt;while&gt;&quot; (la condición se evalúa primero), excepto cuando se aplica a un bloque C&lt;do&gt; (o a la obsoleta instrucción de subrutina C&lt;do&gt;), en cuyo caso el bloque se ejecuta una vez antes de que sea evaluada la condición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means that if you want to use variables, you
must use an eval():</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que si quiere usar variables, debe usar eval():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That should probably be written more simply as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto, probablemente, se debe escribir más sencillamente como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wanted to have a $ref_to_AoA variable as a reference to an array,
you'd have to do something like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quería tener una variable $ref_to_AoA como una referencia a un array, tendrá que hacer algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;&quot;Terms and List Operators (Leftward)&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220028Z" changeid="explorer">
        <seg>Vea también L&lt;&quot;Términos y Operadores de listas (por la izquierda)&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;cmp&quot; returns -1, 0, or 1 depending on whether the left
argument is stringwise less than, equal to, or greater than the right
argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;cmp&quot; devuelve -1, 0, o 1 dependiendo de si el argumento de la izquierda es alfanuméricamente menor, igual o mayor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sleep($for_a_while);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sleep($por_un_rato);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub ordinal { unpack(&quot;W&quot;,$_[0]); } # same as ord()</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub ordinal { unpack(&quot;W&quot;,$_[0]); } # lo mismo que ord()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not patch these modules directly!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014457Z" changeid="explorer">
        <seg>No debe aplicar revisiones a estos módulos directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11516</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11516</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/lib/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014716Z" changeid="explorer">
        <seg>=item * F&lt;t/lib/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,30, 1) = 1   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,30, 1) = 1   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This modifier may be specified to be the default by C&lt;use re '/a'&gt;
or C&lt;use re '/aa'&gt;, but see
L&lt;/Which character set modifier is in effect?&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001336Z" changeid="explorer">
        <seg>Este modificador puede ser especificado para que sea el predeterminado usando C&lt;use re '/a'&gt; o C&lt;use re '/aa'&gt;, pero vea L&lt;/¿Qué modificares están activos?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use -Doptimize=-g if you want to run Perl under sdb or gdb, OR
if you want to be able to use the -D command line flags to perl,
which are occasionally useful in debugging perl scripts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214615Z" changeid="explorer">
        <seg>Use -Doptimize=-g si quiere ejecutar Perl bajo sdb o gdb, O si quiere ser capaz de usar la bandera -D en la línea de comandos con perl, que ocasionalmente es útil en la depuración de scripts perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local @{$x}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015157Z" changeid="explorer">
        <seg>local @{$x}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;basename&gt; now strips trailing path separators before processing the name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031318Z" changeid="explorer">
        <seg>C&lt;basename&gt; ahora elimina separadores finales superfluos antes de procesar el nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$db = tie %hash, 'DBM', ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040026Z" changeid="explorer">
        <seg>$db = tie %hash, 'DBM', ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function
implementing the C&lt;\L&gt; escape in double-quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la función interna que implementa el escapado C&lt;\L&gt; en las cadenas entre comillas dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's core time-related functions are now Y2038 compliant.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003213Z" changeid="explorer">
        <seg>Las funciones principales de Perl relacionadas con la hora, ahora cumplen con Y2038.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OUTER: for my $wid (@ary1) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EXTERNO: for my $wid (@array1) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbers don't need quotes around them:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233757Z" changeid="zipf">
        <seg>No es necesario escribir los números entre comillas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>flock($fh, LOCK_UN) or die &quot;Cannot unlock mailbox - $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>flock($fh, LOCK_UN) or die &quot;No puedo desbloquear el buzón - $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item FindBin</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item FindBin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl does, and
this replaces most structured uses of C&lt;goto&gt; in other languages.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl sí, y esto reemplaza a la mayor parte de los usos estructurados de C&lt;goto&gt; en otros lenguajes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print sort @george, 'to', @harry;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print sort @george, 'to', @harry;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;\G&gt; assertion can be used to chain global matches (using
C&lt;m//g&gt;), as described in L&lt;perlop/&quot;Regexp Quote-Like Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La aserción C&lt;\G&gt; puede ser usada para encadenar coincidencias globales (usando C&lt;m//g&gt;), como se describe en L&lt;perlop/&quot;Operadores Regexp Entrecomillados&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.6x&gt;', 1;       # prints &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.6x&gt;', 1;       # imprime &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note:  Many folks tend to overuse C&lt;defined&gt; and are then surprised to
discover that the number C&lt;0&gt; and C&lt;&quot;&quot;&gt; (the zero-length string) are, in fact,
defined values.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T232712Z" changeid="explorer">
        <seg>Nota: mucha gente tiende a sobrevalorar C&lt;defined&gt; y, para su sorpresa, descubren que el número C&lt;0&gt; y C&lt;&quot;&quot;&gt; (la cadena de longitud cero) son, de hecho, valores definidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/oranges?/) {
            say &quot;I don't like oranges.&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234538Z" changeid="explorer">
        <seg>when (/naranjas?/) {
            say &quot;No me gustan las naranjas.&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar value is interpreted as TRUE in the Boolean sense if it is not
the null string or the number 0 (or its string equivalent, &quot;0&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un valor escalar se interpreta como VERDADERO, en el sentido booleano, si no es la cadena nula ni el número 0 (ni su cadena equivalente &quot;0&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%10.6d&gt;', 1;    # prints &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%10.6d&gt;', 1;    # imprime &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;next&gt; command is like the C&lt;continue&gt; statement in C; it starts
the next iteration of the loop:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;next&gt; es como la instrucción C&lt;continue&gt; en C; comienza la siguiente iteración del bucle:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to the &quot;cut group&quot; operator C&lt;::&gt; from Perl 6.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T140949Z" changeid="explorer">
        <seg>Este es similar al operador C&lt;::&gt; &quot;grupo de corte&quot; de Perl 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;$#&gt; has been removed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192207Z" changeid="explorer">
        <seg>=head2 C&lt;$#&gt; se ha eliminado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this
isn't the length of the array; it's the subscript of the last element,
which is a different value since there is ordinarily a 0th element.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, esto no es la longitud del array, sino el subíndice del último elemento, que es un valor distinto ya que, ordinariamente, hay un elemento número 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>map  { [ $_, uc( (/\d+\s*(\S+)/)[0]) ] } @data;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>map  { [ $_, uc( (/\d+\s*(\S+)/)[0]) ] } @data;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlreref		Perl regular expressions quick reference</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000331Z" changeid="explorer">
        <seg>perlreref		Referencia rápida de expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the &quot;.&quot; metacharacter
matches any character except &quot;\n&quot; (unless you use C&lt;/s&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T223004Z" changeid="explorer">
        <seg>Por último, el metacarácter &quot;.&quot; coincide con cualquier carácter excepto &quot;\n&quot; (a menos que utilice C&lt;/s&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>follow_skip =&gt; 2,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225447Z" changeid="explorer">
        <seg>follow_skip =&gt; 2,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;Higher-Order Perl&gt;: http://hop.perl.plover.com/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003707Z" changeid="explorer">
        <seg>I&lt;Higher-Order Perl&gt;: http://hop.perl.plover.com/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo . &quot; XXX '&quot; . (join $&quot;, @arr) . &quot;'&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054409Z" changeid="explorer">
        <seg>$foo . &quot; XXX '&quot; . (join $&quot;, @arr) . &quot;'&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See either
the GNU General Public License or the Artistic License for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220617Z" changeid="explorer">
        <seg>Vea, o la Licencia Pública General GNU o la Licencia Artística, para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0 dev      device number of filesystem</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0 dev      número de dispositivo del sistema de archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a time synchronization problem, the
NFS server and local machine will have different times.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay un problema de sincronización de tiempos, el servidor NFS y el equipo local tendrán tiempos diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIST is omitted, C&lt;unlink&gt; uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LISTA se omite, C&lt;unlink&gt; utiliza C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The undefined version is the value that indicates that there is
no real value for something, such as when there was an error, or
at end of file, or when you refer to an uninitialized variable or
element of an array or hash.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004138Z" changeid="explorer">
        <seg>La versión indefinida es el valor que indica que no existe ningún valor real para algo, como cuando hubo un error, se alcanzó el fin de archivo, o cuando se hace referencia a una variable o un elemento de array o hash no inicializados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;abs&gt;, C&lt;atan2&gt;, C&lt;cos&gt;, C&lt;exp&gt;, C&lt;hex&gt;, C&lt;int&gt;, C&lt;log&gt;, C&lt;oct&gt;, C&lt;rand&gt;,
C&lt;sin&gt;, C&lt;sqrt&gt;, C&lt;srand&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200927Z" changeid="explorer">
        <seg>C&lt;abs&gt;, C&lt;atan2&gt;, C&lt;cos&gt;, C&lt;exp&gt;, C&lt;hex&gt;, C&lt;int&gt;, C&lt;log&gt;, C&lt;oct&gt;, C&lt;rand&gt;,
C&lt;sin&gt;, C&lt;sqrt&gt;, C&lt;srand&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is an undefined scalar variable (or array or hash element), a
new filehandle is autovivified, meaning that the variable is assigned a
reference to a newly allocated anonymous filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T001306Z" changeid="explorer">
        <seg>Si IDENTIFICADOR_FICHERO es una variable escalar indefinida (o array o elemento hash), un nuevo identificador de archivo es autovivificado, significando que a la variable es asignada una referencia a un nuevo, anónimo y reservado identificador de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is supported by its users.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200018Z" changeid="explorer">
        <seg>El soporte de Perl lo ofrecen sus usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item parsing regular expressions
X&lt;regexp, parse&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010512Z" changeid="explorer">
        <seg>=item analizando expresiones regulares
X&lt;regexp, parse&gt; X&lt;regexp, análisis&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;podtidy&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014837Z" changeid="explorer">
        <seg>=item * F&lt;podtidy&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each
regexp tries to match where the previous one leaves off.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada regexp intenta coincidir donde la anterior lo dejó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;SVs_TEMP&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005949Z" changeid="explorer">
        <seg>=item C&lt;SVs_TEMP&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item log</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item log</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($user = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($usuario = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if an initialized scalar variable is used instead the
result is different: C&lt;my $fh='zzz'; open($fh, ...)&gt; is equivalent
to C&lt;open( *{'zzz'}, ...)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T235528Z" changeid="explorer">
        <seg>Tenga en cuenta que si se usa una variable escalar ya inicializada, el resultado es diferente: C&lt;my $fh='zzz'; open($fh, ...)&gt; es equivalente a C&lt;open( *{'zzz'}, ...)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval '$x';      # CASE 3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval '$x';      # CASO 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=cut</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=cut</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&lt;&lt;'EOF'&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item C&lt;&lt;&lt;'EOF'&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following
scans a list of files (C&lt;@files&gt;) for a list of words (C&lt;@words&gt;), and prints
out the names of those files that contain a match:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo siguiente examina una lista de archivos (C&lt;@archivos&gt;) por una lista de palabras (C&lt;@palabras&gt;), e imprime los nombres de los archivos que contienen una coincidencia:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the operators which need an argument in the integer format treat the
argument as in modular arithmetic, e.g., C&lt;mod 2**32&gt; on a 32-bit
architecture.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T233201Z" changeid="explorer">
        <seg>Todos los operadores que necesitan un argumento con formato de entero tratan al argumento como en la aritmética modular (p. ej., C&lt;mod 2**32&gt; en una arquitectura de 32 bits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for encoding text strings to binary strings is as simple as decoding:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235243Z" changeid="explorer">
        <seg>La sintaxis para codificar cadenas de texto en cadenas binarias es tan sencilla como la sintaxis de descodificación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,23, 1) = 1   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,23, 1) = 1   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = $ok ? @b : @c;  # get an array</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053849Z" changeid="explorer">
        <seg>@a = $ok ? @b : @c;  # obtiene un array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print v102.111.111;       # prints &quot;foo&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print v102.111.111;       # imprime &quot;foo&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to write:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto le permite escribir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;pos&gt; directly accesses the location used by the regexp engine to
store the offset, so assigning to C&lt;pos&gt; will change that offset, and
so will also influence the C&lt;\G&gt; zero-width assertion in regular
expressions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175948Z" changeid="explorer">
        <seg>C&lt;pos&gt; accede directamente a la ubicación utilizada por el motor de expresiones regulares para almacenar el desplazamiento, por lo que asignar a C&lt;pos&gt; cambiará ese desplazamiento, por lo que también influirá en la aserción de ancho cero C&lt;\G&gt; en las expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other functions do not, except accidentally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otras funciones no, excepto accidentalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(?&lt;NAME&gt;(?&amp;NAME_PAT))(?&lt;ADDR&gt;(?&amp;ADDRESS_PAT))</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T203501Z" changeid="explorer">
        <seg>/(?&lt;NOMBRE&gt;(?&amp;NOMBRE_PAT))(?&lt;DIR&gt;(?&amp;DIRECCIÓN_PAT))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful to check that a child process is still
alive (even if only as a zombie) and hasn't changed its UID.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para comprobar que un proceso hijo aún está vivo (aunque sólo sea como un zombie) y no ha cambiado su UID.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of Perl
5.10, it even has a case/switch statement (spelled C&lt;given&gt;/C&lt;when&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225105Z" changeid="explorer">
        <seg>En Perl 5.10, incluso ofrece una instrucción case/switch (llamada C&lt;given&gt;/C&lt;when&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removes the elements designated by OFFSET and LENGTH from an array, and
replaces them with the elements of LIST, if any.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elimina los elementos designados por DESPLAZAMIENTO y LONGITUD de un array, y los sustituye por los elementos de LISTA, si los hubiere.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsyn/&quot;Smart matching in
detail&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215202Z" changeid="explorer">
        <seg>Vea L&lt;perlsyn/&quot;Coincidencia inteligente, en detalle&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>l  A signed long (32-bit) value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>l  Un valor de un largo con signo (32 bit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;ptargrep&gt; is a utility to apply pattern matching to the contents of files 
in a tar archive.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235007Z" changeid="explorer">
        <seg>F&lt;ptargrep&gt; es una utilidad que aplica detección de patrones al contenido de un archivo de almacenamiento tar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will optimize down to C&lt;'foo'&gt;, so C&lt;'bar'&gt; will never be considered (even
though the rules say to use a smart match on C&lt;'foo'&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215943Z" changeid="explorer">
        <seg>Esto quedará optimizado en C&lt;'foo'&gt;, así que C&lt;'bar'&gt; nunca será considerado (incluso aunque las reglas digan que hay que usar coincidencia inteligente en C&lt;'foo'&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next if /^\s*#/;  # skip comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next if /^\s*#/;  # salta los comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head4 Which character set modifier is in effect?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001332Z" changeid="explorer">
        <seg>=head4 ¿Qué modificares están activos?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print if /$arg/o;	# compile only once (no longer needed!)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025103Z" changeid="explorer">
        <seg>print if /$arg/o;	# compilar solo una vez (¡ya no es necesario!)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;/&gt; is
equivalent to C&lt;\/&gt; inside a regular expression, this does not
matter unless the delimiter happens to be character special to the
RE engine, such as in C&lt;s*foo*bar*&gt;, C&lt;m[foo]&gt;, or C&lt;?foo?&gt;; or an
alphanumeric char, as in:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dado que C&lt;/&gt; es equivalente a C&lt;\/&gt; dentro de una expresión regular, esto no importará a menos que el delimitador pase a ser un carácter especial para el motor de RE, como en C&lt;s*foo*bar*&gt;, C&lt;m[foo]&gt;, o C&lt;?foo?&gt;; o un carácter alfanumérico, como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; =&gt; &gt;&gt; operator is helpful in documenting the correspondence
between keys and values in hashes, and other paired elements in lists.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador C&lt;&lt; =&gt; &gt;&gt;  es útil para documentar la correspondencia entre claves y valores de hashes, y otros elementos vinculados en listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is supported, it
usually encodes the disk quota.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está soportada, usualmente codifica la cuota de disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perlthanks|perlthanks&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232004Z" changeid="explorer">
        <seg>=item L&lt;perlthanks|perlthanks&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intent is to propagate
bug fixes out to stable releases more rapidly and make upgrading stable
releases less of an upheaval.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La intención es propagar la corrección de errores a versiones estables con mayor rapidez y hacer esas actualizaciones menos problemáticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To signal the semaphore, replace C&lt;-1&gt; with C&lt;1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para señalizar el el semáforo, reemplace C&lt;-1&gt; con C&lt;1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not an integer&quot;       unless /^[+-]?\d+$/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es un entero&quot;      unless /^[+-]?\d+$/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregation of this Package with a commercial distribution is always
permitted provided that the use of this Package is embedded; that is,
when no overt attempt is made to make this Package's interfaces visible
to the end user of the commercial distribution.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La agregación de este Paquete con una distribución comercial siempre está permitida siempre que el uso de este Paquete esté integrado; es decir, cuando no se haga un evidente intento de hacer las interfaces del Paquete visibles para el usuario final de la distribución comercial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, if any element of LIST is NOT an
lvalue, any attempt to modify that element will fail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recíprocamente, si cualquier elemento de LISTA NO es un I&lt;lvalue&gt;, cualquier intento de modificar este elemento fallará (provocará un error).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unstable CPAN modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030228Z" changeid="explorer">
        <seg>Módulos inestables de CPAN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use feature &quot;switch&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use feature &quot;switch&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12180</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12180</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (101 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (101 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$$x++;          # CASE 6</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$$x++;          # CASO 6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line \s+ (\d+)   \s*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>line \s+ (\d+)   \s*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?{print &quot;hello&quot;}) # print hello whenever this
                          #    branch is tried</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231824Z" changeid="explorer">
        <seg>(?{print &quot;hola&quot;})  # imprime hola cuando esta
                          #    rama es probada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Other incompatible changes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005235Z" changeid="explorer">
        <seg>=head2 Otros cambios incompatibles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the initial value specified isn't part of a magical increment
sequence (that is, a non-empty string matching C&lt;/^[a-zA-Z]*[0-9]*\z/&gt;),
only the initial value will be returned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224515Z" changeid="explorer">
        <seg>Si el valor inicial especificado no es parte de una secuencia mágica de incremento (es decir, una cadena no vacía coincidente con C&lt;/^[a-zA-Z]*[0-9]*\z/&gt;), sólo se devolverá el valor inicial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 2) = 1   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 2) = 1   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They I&lt;are&gt; reserved with respect to labels and filehandles,
however, which don't have an initial special character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003407Z" changeid="explorer">
        <seg>Sí I&lt;están&gt; reservadas, sin embargo, para las etiquetas e identificadores de archivo, ya que éstos no tienen un carácter especial al comienzo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>j   A Perl internal signed integer value (IV).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>j   Un valor Perl interno entero con signo (IV).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;require $class&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;require $clase&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/(\$\w+)/$1/eeg;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/(\$\w+)/$1/eeg;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the VERSION argument is present between Module and LIST, then the
C&lt;use&gt; will call the VERSION method in class Module with the given
version as an argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el argumento VERSIÓN está presente entre el Módulo y la LISTA, entonces C&lt;use&gt; llamará al método VERSIÓN en la clase Módulo con la versión dada como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlreftut&gt;, L&lt;perlref&gt;, L&lt;perldsc&gt;, and L&lt;perllol&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001331Z" changeid="explorer">
        <seg>Se describe en L&lt;perlreftut&gt;, L&lt;perlref&gt;, L&lt;perldsc&gt; y L&lt;perllol&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$'&gt; returns everything
after the matched string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$'&gt; devuelve todo lo posterior a la cadena coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New &quot;Newline in left-justified string for %s&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002143Z" changeid="explorer">
        <seg>=head2 Nuevo &quot;I&lt;Newline in left-justified string for %s&gt;&quot; (Avance de línea en cadena justificada a la izquierda para %s)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
defined version is just a string of length zero, such as C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La versión definida es sólo una cadena de longitud cero, tal como C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically it would be the first 
declaration in a file included by C&lt;require&gt; or C&lt;use&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente será la primera declaración en un archivo incluido por medio de un C&lt;require&gt; o C&lt;use&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exists &amp;sub();  # Error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exists &amp;sub();  # Error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perlpod&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031941Z" changeid="explorer">
        <seg>=item L&lt;perlpod&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@ary) { s/foo/bar/ }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@array) { s/foo/bar/ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eight (the high bit) is set on each byte except the last.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192159Z" changeid="explorer">
        <seg>octavo (el bit más alto) es puesto en cada byte excepto el último.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is actually a change introduced in perl 5.12.0, but it was missed from
that release's perldelta.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230155Z" changeid="explorer">
        <seg>Esto es realmente un cambio introducido en Perl 5.12.0, pero no se incluyó en el perldelta del lanzamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sentence =~ s{$substring}{big bad wolf};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012552Z" changeid="explorer">
        <seg>$instruccion =~ s{$subcadena}{gran lobo malo};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say() is a new built-in, only available when C&lt;use feature 'say'&gt; is in
effect, that is similar to print(), but that implicitly appends a newline
to the printed string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T213443Z" changeid="explorer">
        <seg>say() es una nueva función integrada; sólo está disponible cuando C&lt;use feature 'say'&gt; está en vigor, que es similar a print(), pero que, implícitamente, añade un carácter de nueva línea a la cadena a ser impresa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current process group for the specified PID.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el actual grupo del proceso especificado por el PID.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 1) = 1   ==          2 01000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 1) = 1   ==          2 01000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Test::More</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015323Z" changeid="explorer">
        <seg>=item Test::More</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;eval BLOCK&gt; does I&lt;not&gt; count as a loop, so the loop control statements
C&lt;next&gt;, C&lt;last&gt;, or C&lt;redo&gt; cannot be used to leave or restart the block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012040Z" changeid="explorer">
        <seg>C&lt;eval BLOQUE&gt; I&lt;no&gt; cuenta como un bucle, así que las instrucciones de control de bucle C&lt;next&gt;, C&lt;last&gt;, o C&lt;redo&gt; no pueden ser usadas para dejar o reiniciar el bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can see whether your Perl was built with PerlIO by running C&lt;perl -V&gt;
and looking for the C&lt;useperlio=&gt; line.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005238Z" changeid="explorer">
        <seg>Puede ver cuándo su Perl se ha compilado con PerlIO ejecutando C&lt;perl -V&gt; y buscando por la línea C&lt;useperlio=&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The status value of the command is
returned in C&lt;$?&gt; (see L&lt;perlvar&gt; for the interpretation of C&lt;$?&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220221Z" changeid="explorer">
        <seg>El valor de estado del comando se devuelve en C&lt;$?&gt; (Vea L&lt;perlvar&gt; para la interpretación del valor de C&lt;$?&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hash{&quot;abc&quot;} = &quot;def&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190141Z" changeid="zipf">
        <seg>$hash{&quot;abc&quot;} = &quot;def&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make LDLOADLIBS=&quot;-lnet&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make LDLOADLIBS=&quot;-lnet&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reference to a subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una referencia a una subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's easy to grow to a rather large data space this
way, so use with care.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esta manera, es fácil que el espacio ocupado por los datos crezca a un gran tamaño, así que tenga cuidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that works, good.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si esto funciona, bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TIEHANDLE classname, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TIEHANDLE clase, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the mechanisms mentioned above, these
affect operations besides regular expressions pattern matching, and so
give more consistent results with other operators, including using
C&lt;\U&gt;, C&lt;\l&gt;, etc. in substitution replacements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T235808Z" changeid="explorer">
        <seg>A diferencia de los mecanismos mencionados anteriormente, estos afectan a las operaciones de coincidencia de las expresiones regulares, y así obtener resultados más consistentes con otros operadores, incluyendo el uso de C&lt;\U&gt;, C&lt;\l&gt;, etc, en la parte de la sustitución en los reemplazos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># ...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BUILD
         -  Non-threaded Case
         -  Threaded Case
         -  Testing
         -  Installing the built perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054848Z" changeid="explorer">
        <seg>COMPILACIÓN
         -  Caso de no enhebrado
         -  Caso de enhebrado
         -  Pruebas
         -  Instalando el perl compilado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Various Copy-On-Write techniques will be investigated in hopes
of speeding up Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T005212Z" changeid="explorer">
        <seg>Varias técnicas Copy-On-Write serán investigadas con la esperanza de acelerar Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item when BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T025104Z" changeid="explorer">
        <seg>=item when BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setpgrp PID,PGRP
X&lt;setpgrp&gt; X&lt;group&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200451Z" changeid="explorer">
        <seg>=item setpgrp PID,PGRP
X&lt;setpgrp&gt; X&lt;group&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forces EXPR to be interpreted in scalar context and returns the value
of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fuerza EXPR a ser interpretada en contexto escalar y devuelve el valor de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(On some machines,
unfortunately, the elapsed time may be up to one second less or more
than you specified because of how seconds are counted, and process
scheduling may delay the delivery of the signal even further.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En algunas máquinas, desafortunadamente, el tiempo transcurrido puede ser hasta un segundo más o menos del especificado debido a cómo los segundos son contados, y la planificación de procesos pueden retrasar la entrega de la señal incluso más).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|        Alternation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042541Z" changeid="explorer">
        <seg>|	Alternativas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Administration</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234303Z" changeid="explorer">
        <seg>=head2 Administración</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Pre-requisites</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030029Z" changeid="explorer">
        <seg>=head2 Pre-requisitos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item log EXPR
X&lt;log&gt; X&lt;logarithm&gt; X&lt;e&gt; X&lt;ln&gt; X&lt;base&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191239Z" changeid="explorer">
        <seg>=item log EXPR
X&lt;log&gt; X&lt;logarithm&gt; X&lt;e&gt; X&lt;ln&gt; X&lt;base&gt; X&lt;logaritmo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># and, in case someone appended while we were waiting...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># y, en caso de que alguien haya añadido algo mientras esperábamos...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The range operator is useful for writing
C&lt;foreach (1..10)&gt; loops and for doing slice operations on arrays.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador rango es útil para escribir bucles C&lt;foreach (1..10)&gt; y para hacer operaciones de troceado en los arrays.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a list consisting of all the values of the named hash, or the values
of an array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una lista consistente de todas las claves del hash indicado, o los índices de un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the second form, the code within the BLOCK is parsed only once--at the
same time the code surrounding the C&lt;eval&gt; itself was parsed--and executed
within the context of the current Perl program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la segunda forma, el código dentro del BLOQUE es interpretado sólo una vez -al mismo tiempo que el código que rodea al mismo C&lt;eval&gt; es interpretado- y ejecutado dentro del contexto del actual programa Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It behaves just as C&lt;import&gt; does with VERSION, an omitted or empty LIST, 
or no unimport method being found.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se comporta igual que C&lt;import&gt; lo hace con VERSIÓN, con una lista vacía o no, o ningún método unimport será encontrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>''	 q{}	      Literal		  no</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>''	 q{}	      Literal		  no</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># if the open fails, output is discarded</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># si open falla, la salida es descartada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;ab&quot; =~ /a(.*)b/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;ab&quot; =~ /a(.*)b/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes the layout of the Perl source tree.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T013225Z" changeid="explorer">
        <seg>En este documento se describe el contenido del árbol de código fuente de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item keys HASH
X&lt;keys&gt; X&lt;key&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174124Z" changeid="explorer">
        <seg>=item keys HASH
X&lt;keys&gt; X&lt;key&gt; X&lt;clave&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two of
these directories contain modules that live in the core, and two contain
modules that can also be released separately on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014339Z" changeid="explorer">
        <seg>Dos de estos directorios contienen módulos integrados en el núcleo y los otros dos contienen módulos que además se publican en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Unicode::UCD</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014848Z" changeid="explorer">
        <seg>=item Unicode::UCD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A line-oriented form of quoting is based on the shell &quot;here-document&quot;
syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un formato de entrecomillado orientado a líneas basado en la sintaxis shell &quot;here-document&quot; (este-documento, documento incrustado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $utf8 = chr(192); utf8::upgrade($utf8);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235827Z" changeid="explorer">
        <seg>my $utf8 = chr(192); utf8::upgrade($utf8);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No implicit conversion to C&lt;&quot;&quot;&gt; is done (as was the case in perl
5.10.0).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T222122Z" changeid="explorer">
        <seg>No se realiza conversión implícita a C&lt;&quot;&quot;&gt; (como era en el caso de Perl 5.10.0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore perl 5.8.1 introduced a &quot;backdoor&quot; to restore the pre-5.8.0
(pre-5.7.3, really) signal behaviour.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T154707Z" changeid="explorer">
        <seg>Por lo tanto, perl 5.8.1 introdujo una &quot;puerta trasera&quot; para restaurar el pre-5.8.0 (pre-5.7.3, en realidad) comportamiento de las señales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Storable&gt; upgraded to version 2.15</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034626Z" changeid="explorer">
        <seg>C&lt;Storable&gt; actualizado a la versión 2.15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @transformed = map { ... } @input;  # syntax error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @transformado = map { ... } @entrada;  # error de sintaxis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator precedence and associativity work in Perl more or less like
they do in mathematics.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Precedencia de operadores y asociatividad funciona en Perl más o menos como se hace en matemáticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (@animals &lt; 5) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234142Z" changeid="zipf">
        <seg>if (@animales &lt; 5) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13684</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13684</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has a low-precedence counterpart, C&lt;err&gt;, which has the same precedence
and associativity as C&lt;or&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143135Z" changeid="explorer">
        <seg>Tiene un homólogo de baja prioridad, C&lt;err&gt;, que tiene la misma prioridad y asociatividad que C&lt;or&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The test t/uni/tr_7jis.t is known to report failure under 'make test'
or the test harness with certain releases of IRIX (at least IRIX 6.5
and MIPSpro Compilers Version 7.3.1.1m), but if run manually the test
fully passes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T004206Z" changeid="explorer">
        <seg>La prueba t/uni/tr_7jis.t se sabe que da un informe de fallo bajo 'make test' o la prueba se cuelga con determinadas versiones de IRIX (por lo menos la IRIX 6.5 y compiladores MIPSpro versión 7.3.1.1m), pero si se ejecuta manualmente la prueba pasa de forma completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Encode;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235005Z" changeid="explorer">
        <seg>use Encode;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use a non-arrowed form for chained subscripts after a list
slice, like in:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035240Z" changeid="explorer">
        <seg>Ahora puede utilizar una forma de no-flecha para los subíndices encadenados después de una porción de una lista, como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IndigoPerl: Windows</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225435Z" changeid="explorer">
        <seg>IndigoPerl: Windows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>assigns the entire list value to array @foo, but</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>asigna la lista completa al array @foo, pero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be pedantic, the comparison is actually C&lt;int(EXPR) == int(EXPR)&gt;,
but that is only an issue if you use a floating point expression; when
implicitly using C&lt;$.&gt; as described in the previous paragraph, the
comparison is C&lt;int(EXPR) == int($.)&gt; which is only an issue when C&lt;$.&gt;
is set to a floating point value and you are not reading from a file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ser pedante, la comparación es en realidad C&lt;int(EXPR) == int(EXPR)&gt; , pero esto sólo es un problema si utiliza una expresión de punto flotante; cuando, implícitamente, está usando C&lt;$.&gt; como se describe en el párrafo anterior, la comparación es C&lt;int(EXPR) == int($.)&gt; que sólo es un problema cuando C$.&gt; se establece en un valor de punto flotante y usted no está leyendo de un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 DIAGNOSTICS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 DIAGNÓSTICO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; site namefmt 1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T134633Z" changeid="explorer">
        <seg>&gt; site namefmt 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;redo&gt; inside such a block will effectively
turn it into a looping construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto C&lt;redo&gt; dentro de un bloque lo convertirá de forma efectiva en una construcción de bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
may be addressed in a future version of perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223613Z" changeid="explorer">
        <seg>Esto puede ser cambiado en una futura versión de perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub process {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub procesa {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan
Gray.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235540Z" changeid="explorer">
        <seg>Son: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan
Gray.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
unimplemented, raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no está implementada, lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bar = pack('s@4l', 12, 34);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$bar = pack('s@4l', 12, 34);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not really a function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No es realmente una función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>n  An unsigned short (16-bit) in &quot;network&quot; (big-endian) order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>n  Un corto sin signo (16 bit) en orden &quot;red&quot; (big-endian).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Interpolation E =&gt; 'eval';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225531Z" changeid="explorer">
        <seg>use Interpolation E =&gt; 'eval';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a += ($a % 2) ? 10 : 2;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054128Z" changeid="explorer">
        <seg>$a += ($a % 2) ? 10 : 2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unsupported private C API functions are now declared &quot;static&quot; to prevent
leakage to Perl's public API.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T191123Z" changeid="explorer">
        <seg>Funciones privadas C de la API, no soportadas, están ahora declaradas como &quot;estáticas&quot; para evitar la fuga hacia la API pública de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the starting delimiter is an opening punctuation
(that is C&lt;(&gt;, C&lt;[&gt;, C&lt;{&gt;, or C&lt;&lt; &lt; &gt;&gt;), the ending delimiter is the
corresponding closing punctuation (that is C&lt;)&gt;, C&lt;]&gt;, C&lt;}&gt;, or C&lt;&lt; &gt; &gt;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el delimitador inicial es un carácter de puntuación (uno como C&lt;(&gt;, C&lt;[&gt;, C&lt;{&gt;, o C&lt;&lt; &lt; &gt;&gt;), el delimitador final es el correspondiente carácter de puntuación, de cierre (uno como C&lt;)&gt;, C&lt;]&gt;, C&lt;}&gt;, o C&lt;&lt; &gt; &gt;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In scalar context, returns the number of keys or indices.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En contexto escalar, devuelve el número de claves o índices).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$class = 'Foo::Bar';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$clase = 'Foo::Bar';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.8.3 release and
the 5.8.4 release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014806Z" changeid="explorer">
        <seg>Este documento describe las diferencias entre la versión 5.8.3 y la versión 5.8.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keep your documentation near the code it documents (&quot;inline&quot;
documentation).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024632Z" changeid="explorer">
        <seg>Mantenga la documentación cerca del código que documenta (documentación &quot;en línea&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./Configure -des -Dprefix=$HOME/localperl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T221902Z" changeid="explorer">
        <seg>./Configure -des -Dprefix=$HOME/localperl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>range operator (creates a list of numbers)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235419Z" changeid="zipf">
        <seg>operador de intervalo (crea una lista de números)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Internals and C Language Interface</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000458Z" changeid="explorer">
        <seg>=head2 Componentes e interfaz con el lenguaje C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head4 /a</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T211538Z" changeid="explorer">
        <seg>=head4 /a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's easier to use a hash like this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021536Z" changeid="explorer">
        <seg>Es más fácil utilizar un hash de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head4 /d</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000352Z" changeid="explorer">
        <seg>=head4 /d</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(S&lt;Plan 9&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014900Z" changeid="explorer">
        <seg>(S&lt;Plan 9&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo, 45,  2) = 3;      # 'PerlPerlPer'  . &quot;\x0c&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052419Z" changeid="explorer">
        <seg>vec($foo, 45,  2) = 3;      # 'PerlPerlPer'  . &quot;\x0c&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also a more insistent form of close because it also
disables the file descriptor in any forked copies in other
processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También es una forma más insistente de cerrar, ya que también desactiva el descriptor de archivo en cualquier copia bifurcada en otros procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$re = qr/$pattern/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$re = qr/$patron/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is a B&lt;free-form&gt; language, you can format and indent it however
you like.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl es un lenguaje de B&lt;estructura libre&gt;, puede formatearlo y sangrarlo como quiera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string you supply will be cut off at 16 bytes,
this is a limitation imposed by Linux.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T053803Z" changeid="explorer">
        <seg>La cadena que suministre será recortada a los 16 bytes, que es una limitación impuesta por Linux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if( $array[$i] =~ /Perl/ ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225554Z" changeid="explorer">
        <seg>if( $array[$i] =~ /Perl/ ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The support for assertions, introduced in perl 5.9.0, has been improved.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T195838Z" changeid="explorer">
        <seg>El soporte para aserciones, introducida en Perl 5.9.0, se ha mejorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Caching</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114951Z" changeid="explorer">
        <seg>=head1 Cacheado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$oct = reverse join('', $vec-&gt;Chunk_List_Read(3));</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225515Z" changeid="explorer">
        <seg>$oct = reverse join('', $vec-&gt;Chunk_List_Read(3));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple comment in the code giving credit to the FAQ would
be courteous but is not required.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232625Z" changeid="explorer">
        <seg>Le agradeceremos que incluya en su código una mención a estos documentos de preguntas más frecuentes, pero no le exigimos que lo haga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the repeat count is C&lt;*&gt;, the offset is relative to the start of the
packed string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el número de repeticiones es C&lt;*&gt;, el desplazamiento es relativo al inicio de la cadena empaquetada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack('S&gt;L&gt;', 42, 4711);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack('S&gt;L&gt;', 42, 4711);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now linenumbers can go all the way to
4294967296, or 2**32.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T233040Z" changeid="explorer">
        <seg>Ahora, los números de línea puede ir hasta 4294967296, o 2**32.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://padre.perlide.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>http://padre.perlide.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head4 /u</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T165925Z" changeid="explorer">
        <seg>=head4 /u</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl does its own C&lt;sprintf&gt; formatting: it emulates the C
function sprintf(3), but doesn't use it except for floating-point
numbers, and even then only standard modifiers are allowed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl hace su propio formateo C&lt;sprintf&gt;: emula la función del C sprintf(3), pero no la usa, excepto para los números en coma flotante, y aún entonces sólo se admiten modificadores estándares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first operand
is to use smart matching, then both operands will do so; if it is
not, then the second argument will not be either.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T214808Z" changeid="explorer">
        <seg>Si el primer operando utiliza coincidencia inteligente, entonces se aplicará a ambos operandos; si no es así, entonces, ni el segundo argumento lo usará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default floating point numbers substituted inside strings use the
dot (&quot;.&quot;)  as the decimal separator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma predeterminada los números en punto flotante sustituidos dentro de cadenas usan el punto (&quot;.&quot;) como separador decimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head4 /l</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T164253Z" changeid="explorer">
        <seg>=head4 /l</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;MANIFEST&gt; file in the root of the source tree contains a list of every
file in the Perl core, as well as a brief description of each file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T015004Z" changeid="explorer">
        <seg>El archivo F&lt;MANIFEST&gt; del directorio raíz del árbol de código fuente contiene una lista de todos los archivos incluidos en el núcleo de Perl, así como una breve descripción de cada archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$y_hi ] ]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053111Z" changeid="explorer">
        <seg>$y_hi ] ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's why it's good to use references sometimes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T004451Z" changeid="explorer">
        <seg>Es por eso que es bueno, en algunas situaciones, utilizar referencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cwd upgraded to version 3.01 (as part of the new PathTools distribution)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cwd actualizado a la versión 3.01 (como parte de la nueva distribución PathTools)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.13.0 represents eight days of development since Perl 5.12.0 and
contains 3,766 lines of changes across 151 files from 29 authors and
committers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T053058Z" changeid="explorer">
        <seg>Perl 5.13.0 representa ocho días de desarrollo desde Perl 5.12.0, y contiene 3.766 líneas de cambios a través de 151 archivos de 29 autores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specify Perl version requirements with C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014117Z" changeid="explorer">
        <seg>Especifique los requisitos de la versión de Perl con C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar or list context propagates down to the right operand if it
is evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los contextos escalar o lista se propagan hacia el operando de la derecha si es evaluado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\S                  non-whitespace character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230229Z" changeid="zipf">
        <seg>\S                  un carácter que no sea un espacio en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But from time to time, Perl's
notions differ substantially from what the author honestly meant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero de vez en cuando, las nociones de Perl difieren sustancialmente de lo que el autor, honestamente, quería decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's probably
best to spend a full day learning all this, but the basics can be learned in
minutes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T233235Z" changeid="explorer">
        <seg>Probablemente lo mejor sea dedicar un día entero a esta tarea, pero para aprender los conceptos básicos bastan unos pocos minutos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es equivalente a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can test whether it conforms to CPAN by 
using</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025454Z" changeid="explorer">
        <seg>Se puede comprobar si se ajusta a CPAN utilizando</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If @foo exists, Perl takes a good guess about C&lt;[bar]&gt;,
and is almost always right.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si @foo existe, Perl tiene una buena pista acerca de C&lt;[bar]&gt;, y casi siempre acierta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 UTF-8 cache optimisation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005602Z" changeid="explorer">
        <seg>=head2 Optimización del caché UTF-8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you call a subroutine by a tainted name, and if it defers to an
AUTOLOAD function, then $AUTOLOAD will be (correctly) tainted.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T000200Z" changeid="explorer">
        <seg>Si llama a una subrutina con un nombre contaminado, y ella remite a una función AUTOLOAD, entonces $AUTOLOAD quedará (correctamente) contaminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that, use C&lt;scalar @array&gt; and C&lt;scalar keys
%hash&gt;, respectively.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ello, utilice C&lt;scalar @array&gt; y C&lt;scalar keys %hash&gt;, respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setpwent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setpwent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But as you might well imagine, this can get pretty rough on the reader.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032705Z" changeid="explorer">
        <seg>Pero como se podrá imaginar, esto puede ser bastante duro para el lector.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When evaluated as a string it is treated as C&lt;''&gt;, but as a number, it
is treated as 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando es evaluado como cadena es tratado como C&lt;''&gt;, pero como número es tratado como 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub tan { sin($_[0]) / cos($_[0])  }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub tan { sin($_[0]) / cos($_[0])  }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlplan9		Perl notes for Plan 9</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlplan9		Notas para Plan 9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://notepad-plus.sourceforge.net/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>http://notepad-plus.sourceforge.net/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, a single string
consisting of all output is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, se devuelve una sola cadena consistente en toda la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for this mechanism is almost the same as for
most C preprocessors: it matches the regular expression</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223630Z" changeid="explorer">
        <seg>La sintaxis de este mecanismo es el mismo que para la mayoría de preprocesadores de C: coincide con la expresión regular</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, C&lt;$a // $b&gt;
is similar to C&lt;defined($a) || $b&gt; (except that it returns the value of C&lt;$a&gt;
rather than the value of C&lt;defined($a)&gt;) and yields the same result as
C&lt;defined($a) ? $a : $b&gt; (except that the ternary-operator form can be
used as a lvalue, while C&lt;$a // $b&gt; cannot).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T184904Z" changeid="explorer">
        <seg>Por lo tanto, C&lt;$a // $b&gt; es similar a C&lt;defined($a) || $b&gt; (excepto que devuelve el valor de C&lt;$a&gt; en lugar del valor de C&lt;defined($a)&gt;) y es equivalente exactamente a C&lt;defined($a) ? $a : $b&gt; (excepto que el operador ternario puede ser usado como ivalor, mientras que C&lt;$a // $b&gt;, no).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&lt; (?&gt;pattern) &gt;&gt;
X&lt;backtrack&gt; X&lt;backtracking&gt; X&lt;atomic&gt; X&lt;possessive&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T204232Z" changeid="explorer">
        <seg>=item C&lt;&lt; (?&gt;patrón) &gt;&gt;
X&lt;backtrack&gt; X&lt;backtracking&gt; X&lt;retroceso&gt; X&lt;retrocediendo&gt; X&lt;atómico&gt; X&lt;posesivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwnam NAME
X&lt;getpwnam&gt; X&lt;getgrnam&gt; X&lt;gethostbyname&gt; X&lt;getnetbyname&gt; X&lt;getprotobyname&gt;
X&lt;getpwuid&gt; X&lt;getgrgid&gt; X&lt;getservbyname&gt; X&lt;gethostbyaddr&gt; X&lt;getnetbyaddr&gt;
X&lt;getprotobynumber&gt; X&lt;getservbyport&gt; X&lt;getpwent&gt; X&lt;getgrent&gt; X&lt;gethostent&gt;
X&lt;getnetent&gt; X&lt;getprotoent&gt; X&lt;getservent&gt; X&lt;setpwent&gt; X&lt;setgrent&gt; X&lt;sethostent&gt;
X&lt;setnetent&gt; X&lt;setprotoent&gt; X&lt;setservent&gt; X&lt;endpwent&gt; X&lt;endgrent&gt; X&lt;endhostent&gt;
X&lt;endnetent&gt; X&lt;endprotoent&gt; X&lt;endservent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173713Z" changeid="explorer">
        <seg>=item getpwnam NOMBRE
X&lt;getpwnam&gt; X&lt;getgrnam&gt; X&lt;gethostbyname&gt; X&lt;getnetbyname&gt; X&lt;getprotobyname&gt;
X&lt;getpwuid&gt; X&lt;getgrgid&gt; X&lt;getservbyname&gt; X&lt;gethostbyaddr&gt; X&lt;getnetbyaddr&gt;
X&lt;getprotobynumber&gt; X&lt;getservbyport&gt; X&lt;getpwent&gt; X&lt;getgrent&gt; X&lt;gethostent&gt;
X&lt;getnetent&gt; X&lt;getprotoent&gt; X&lt;getservent&gt; X&lt;setpwent&gt; X&lt;setgrent&gt; X&lt;sethostent&gt;
X&lt;setnetent&gt; X&lt;setprotoent&gt; X&lt;setservent&gt; X&lt;endpwent&gt; X&lt;endgrent&gt; X&lt;endhostent&gt;
X&lt;endnetent&gt; X&lt;endprotoent&gt; X&lt;endservent&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Win32</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005748Z" changeid="explorer">
        <seg>=item Win32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict 'subs';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use strict 'subs';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;+&quot; has no effect whatsoever, even on strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unario &quot;+&quot; no tiene efecto alguno, incluso en cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length of an array is a scalar value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La longitud de un array es un valor escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When each filter is called by Perl, a local copy of C&lt;$_&gt; will contain
the key or value to be filtered.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T153446Z" changeid="zipf">
        <seg>Cuando Perl llama a uno de estos filtros, una copia local de C&lt;$_&gt; contendrá la clave o el valor que se va a filtrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.oreilly.com/catalog/9780596527242</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003410Z" changeid="explorer">
        <seg>http://www.oreilly.com/catalog/9780596527242</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, &quot;native&quot; floats have a most fundamental
restriction: they may represent only those numbers which have a relatively
&quot;short&quot; representation when converted to a binary fraction.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232503Z" changeid="explorer">
        <seg>En cambio, existe una restricción intrínseca para los números de punto flotante &quot;nativos&quot;: solo se pueden representar los números que tengan una representación relativamente &quot;corta&quot; al convertirse en una fracción binaria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;S{min,max}&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050022Z" changeid="explorer">
        <seg>=item C&lt;S{min,max}&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While short identifiers like C&lt;$gotit&gt; are probably ok, use underscores to
separate words in longer identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras identificadores cortos como C&lt;$leenombre&gt; están bien, use guiones bajos para separar palabras en los identificadores más largos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It might do two totally different things.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacer dos cosas totalmente diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to regenerate uconfig.h.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para regenerar uconfig.h.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in the shell, if SIGNAL is negative, it kills process groups instead
of processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia del shell, si SEÑAL es negativo, mata el grupo de procesos en lugar de a los procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting from C&lt;%ENV&gt; modifies the environment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Borrando de C&lt;%ENV&gt; modifica el entorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maintenance versions are stable, and
have an even number as the minor release (i.e. perl5.10.x, where 10 is the
minor release).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T225610Z" changeid="explorer">
        <seg>Las versiones de mantenimiento son estables; en estas versiones se utiliza un número par como número de versión secundaria (p.ej., perl5.10.x, donde 10 es el número de versión secundaria).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not implemented.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014829Z" changeid="explorer">
        <seg>No implementado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596005030/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003259Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596005030/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But that isn't going to match; at least, not the way you're hoping.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170054Z" changeid="explorer">
        <seg>Pero eso no va a coincidir, al menos, no de la forma en que lo está esperando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Install DBM Filters</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T131924Z" changeid="zipf">
        <seg># Instalar filtros DBM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;attrs&gt; upgraded to version 1.02</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T024012Z" changeid="explorer">
        <seg>C&lt;attrs&gt; actualizado a la versión 1.02</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar&gt;
for more details on the C&lt;%+&gt; and C&lt;%-&gt; hashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T201230Z" changeid="explorer">
        <seg>Vea C&lt;perlvar&gt; para más detalles sobre los hash C&lt;%+&gt; y C&lt;%-&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bareword argument to chdir() is now recognized as a file handle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T235028Z" changeid="explorer">
        <seg>Una palabra sencilla como argumento a chdir() ahora es reconocida como un identificador de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See http://www.perl.com/CPAN (without a slash at the end) for
how this process works.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230021Z" changeid="explorer">
        <seg>Visite http://www.perl.com/CPAN (sin barra diagonal al final) para ver cómo funciona este proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map always returns a list, which can be
assigned to a hash such that the elements
become key/value pairs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171913Z" changeid="explorer">
        <seg>Map siempre devuelve una lista, que puede ser asignada a un hash de tal manera que los elementos serán parejas de claves y valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that reversing an array to itself (as in C&lt;@a = reverse @a&gt;) will
preserve non-existent elements whenever possible, i.e., for non magical
arrays or tied arrays with C&lt;EXISTS&gt; and C&lt;DELETE&gt; methods.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que invertir un array en sí mismo (como en C&lt;@a = reverse @a&gt;) preservará elementos inexistentes cuando le sea posible, es decir, para arrays no mágicos o arrays enlazados con métodos C&lt;EXISTS&gt; y C&lt;DELETE&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @ints, pos $bits while($bits =~ /1/g);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225602Z" changeid="explorer">
        <seg>push @ints, pos $bits while($bits =~ /1/g);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlrequick 	Perl regular expressions quick start</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000204Z" changeid="explorer">
        <seg>perlrequick 	Guía rápida de las expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;check*&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014809Z" changeid="explorer">
        <seg>=item * F&lt;check*&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being parsimonious on filehandles is also useful (besides being
parsimonious) for example when something is dependent on file
descriptors, like for example locking using flock().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011240Z" changeid="explorer">
        <seg>Ser parco en identificadores de archivo también es útil (además de ser parsimoniosos), por ejemplo cuando algo depende de descriptores de archivo, como por ejemplo, el uso del bloqueo flock().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Perl Debugger Pocket Reference&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003249Z" changeid="explorer">
        <seg>=item I&lt;Perl Debugger Pocket Reference&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#AoA ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052830Z" changeid="explorer">
        <seg>$#AoA ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hash randomisation mentioned in L&lt;/Incompatible Changes&gt; is definitely
problematic: it will wake dormant bugs and shake out bad assumptions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T002021Z" changeid="explorer">
        <seg>La asignación al azar de hash mencionado en L&lt;/Cambios Incompatibles&gt; es definitivamente un problema: despertará errores latentes y sacudirá a las malas suposiciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add more great circle routines: C&lt;great_circle_waypoint&gt; and
C&lt;great_circle_destination&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033853Z" changeid="explorer">
        <seg>Añade más rutinas para cálculos de arcos esféricos: C&lt;great_circle_waypoint&gt; y C&lt;great_circle_destination&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| die &quot;can't open UTF-8 encoded filename: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>|| die &quot;no puedo abrir archivo codificado en UTF-8: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 OpenBSD vuelca el núcleo desde getprotobyname_r y getservbyname_r con ithreads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {$b &lt;=&gt; $a} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {$b &lt;=&gt; $a} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, evaluating a filehandle in angle brackets yields
the next line from that file (the newline, if any, included), or
C&lt;undef&gt; at end-of-file or on error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013908Z" changeid="explorer">
        <seg>En contexto escalar, la evaluación de un identificador de archivo entre ángulos retorna la siguiente línea de ese archivo (con el carácter de salto de línea, en su caso, incluido), o C&lt;undef&gt; al final del archivo o en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With format C&lt;h&gt;, the
first character of the pair determines the least-significant nybble of the
output character; with format C&lt;H&gt;, it determines the most-significant
nybble.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con el formato C&lt;h&gt;, el primer carácter del par determina el nible menos significativo de la salida de caracteres; con el formato C&lt;H&gt;, determina el nible más significativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 1) = 1   ==         64 00000010000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 1) = 1   ==         64 00000010000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond that, he has other preferences that aren't so strong:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aparte de eso, él tiene otras preferencias que no son tan estrictas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$no_caps_here    function scope my() or local() variables</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$sin_mayusculas     Ámbito de función, variables my() o local()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * Module tests</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014537Z" changeid="explorer">
        <seg>=item * Pruebas de módulos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just understand what you're getting yourself into.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo entienda lo que te está metiendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Titlecase words in the last 30 characters only</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031228Z" changeid="explorer">
        <seg># Solo palabras con capitulares en los últimos 30 caracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a summary of the possible predicates:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T194502Z" changeid="explorer">
        <seg>He aquí un resumen de los predicados posibles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider writing a module or object class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere escribir un módulo o una clase de objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, that environment variable is not getting
populated by a combination of C&lt;Config&gt; entries and C&lt;ExtUtil::MakeMaker&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la actualidad, esta variable de entorno no está siendo publicitada por una combinación de entradas en C&lt;Config&gt; y C&lt;ExtUtil::MakeMaker&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;ptar&gt; is a pure perl implementation of C&lt;tar&gt;, that comes with
C&lt;Archive::Tar&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013322Z" changeid="explorer">
        <seg>C&lt;ptar&gt; es una implementación en puro perl de C&lt;tar&gt;, que viene incluido con C&lt;Archive::Tar&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the source number is outside of the limits representable in the target form,
a representation of the closest limit is used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232706Z" changeid="explorer">
        <seg>Si el número de origen está fuera de los límites representables en la forma de destino, se usa una representación del límite más cercano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;identifier&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;identifier&gt; X&lt;identificador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nicholas Clark changed the string buffer allocation so that it is now rounded
up to the next multiple of 4 (or 8 on platforms with 64 bit pointers).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T052041Z" changeid="explorer">
        <seg>Nicholas Clark cambió la asignación del búfer de cadena de texto por lo que ahora es redondeado al siguiente múltiplo de 4 (u 8 en las plataformas con punteros de 64 bits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This doesn't work if you explicitly specify a loop variable,
as in C&lt;for $item (@array)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto no funciona si explícitamente especifica una variable de bucle, como en C&lt;for $item (@array)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The former is what the Perl debugger uses, while the latter generates
parsable Perl code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032133Z" changeid="explorer">
        <seg>El primero es el que el depurador de Perl utiliza, mientras que el segundo genera código Perl interpretable de forma directa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The range operator (in list context) makes use of the magical
auto-increment algorithm if the operands are strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador rango (en contexto de lista) hace uso del algoritmo auto-incremental mágico, si los operandos son cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item utime LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item utime LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub newopen {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub nuevoopen {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8.2 introduced a bugfix
which accidentally broke the compilation of Perl extensions written in C++</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5.8.2 introdujo una corrección de errores que rompió accidentalmente la compilación de las extensiones Perl escritas en C++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is something like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resultado es algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11475</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11475</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = $a + 2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a = $a + 2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>view perl perldgux</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>view perl perldgux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a library that provides an API, you can make any component
of it available as just another Perl function or variable using a Perl
extension written in C or C++ and dynamically linked into your main
perl interpreter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230905Z" changeid="explorer">
        <seg>Si tiene una biblioteca que proporciona una API, puede hacer que cualquier componente de la misma esté disponible como cualquier otra función o variable de Perl mediante una extensión programada en C o C++, y vinculada dinámicamente al intérprete perl principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>c  Do not reset search position on a failed match when /g is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T232929Z" changeid="explorer">
        <seg>c	No reinicia la posición de búsqueda en una coincidencia fallida cuando /g esta activa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, whenever Perl writes to
a DBM database it always writes the key and value as strings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T160112Z" changeid="zipf">
        <seg>de manera predeterminada, cuando Perl escribe en una base de datos DBM, siempre escribe la clave y el valor como cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the total
number of characters removed from all its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número total de caracteres eliminados de todos sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create a symlink for libperl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crear un enlace simbólico para libperl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;mkdir()&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T191857Z" changeid="explorer">
        <seg>=head2 C&lt;mkdir()&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These take much longer on MPE/iX than on a Unix
system, because of a slow forking, mostly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto tarda mucho más en MPE/iX que en un sistema Unix, debido, sobre todo, a un sistema lento de C&lt;fork&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[^()]+</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195914Z" changeid="explorer">
        <seg>[^()]+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Parameter passing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021525Z" changeid="explorer">
        <seg>=item Paso de parámetros</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice this is unlikely unless your code
contains a very complex nesting of anonymous subs, evals and lexicals.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010533Z" changeid="explorer">
        <seg>En la práctica esto es poco probable a menos que el código contenga un agrupamiento muy complejo de subs anónimas, evals y léxicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the most common values are C&lt;O_RDONLY&gt; for opening the file in
read-only mode, C&lt;O_WRONLY&gt; for opening the file in write-only mode,
and C&lt;O_RDWR&gt; for opening the file in read-write mode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos de los valores más comunes son C&lt;O_RDONLY&gt; para abrir el archivo en modo de sólo lectura, C&lt;O_WRONLY&gt; para abrir el archivo en modo de sólo escritura, y C&lt;O_RDWR&gt; para abrir el archivo en modo lectura-escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (crypt($word, $pwd) ne $pwd) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (crypt($palabra, $pwd) ne $pwd) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upgraded from version 1.00 to 1.01.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003356Z" changeid="explorer">
        <seg>Actualizado desde la versión 1.00 a la 1.01.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11485</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11485</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$y_lo, $y_hi) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053108Z" changeid="explorer">
        <seg>$y_lo, $y_hi) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New &quot;Use of freed value in iteration&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003155Z" changeid="explorer">
        <seg>=head2 Nuevo &quot;I&lt;Use of freed value in iteration&gt;&quot; (Uso de un valor liberado en la iteración)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A
reference to the subroutine itself is passed in as C&lt;$_[0]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una referencia a la propia subrutina es pasada en C&lt;$_[0]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, it's usually correct for ambiguous cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Afortunadamente, por lo general es correcta para los casos ambiguos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11490</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11490</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;Native&gt; here means &quot;a format supported by the C compiler which was used
to build perl&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232440Z" changeid="explorer">
        <seg>Aquí I&lt;nativo&gt; significa &quot;formato admitido por el compilador de C que se usó para compilar perl&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 B::C</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015526Z" changeid="explorer">
        <seg>=head2 B::C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, if the string starts
with a plus or minus, a string starting with the opposite sign is
returned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T184320Z" changeid="explorer">
        <seg>De otra manera, si el string comienza con un signo más o un menos, se devuelve un string que comience con el signo opuesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar in spirit to C&lt;(?{0})&gt; but more efficient.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195844Z" changeid="explorer">
        <seg>Similar en espíritu a C&lt;(?{0})&gt; pero más eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has been fixed, along with several
other bugs, notably in bounds checking.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044545Z" changeid="explorer">
        <seg>Esto se ha corregido, junto con otros errores, sobre todo en la comprobación de los límites.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Original    Result    Warns?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204034Z" changeid="explorer">
        <seg>Original    Resultado    ¿Advertencia?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's available when C&lt;use feature
'switch'&gt; is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T193847Z" changeid="explorer">
        <seg>Está disponible cuando C&lt;use feature 'switch'&gt; está en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be consistent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sea coherente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subtest of the C&lt;ext/Sys/Syslog/t/syslog.t&gt; test fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una subprueba del test C&lt;ext/Sys/Syslog/t/syslog.t&gt; falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($string = &lt;&lt;'END');</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($cadena = &lt;&lt;'END');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,20, 1) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,20, 1) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlfaq6&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045829Z" changeid="explorer">
        <seg>L&lt;perlfaq6&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a second
C&lt;my&gt; declaration, which will bind the name to a fresh variable, a
second C&lt;our&gt; declaration in the same package, in the same scope, is
merely redundant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de una segunda declaración de C&lt;my&gt;, que unirá el nombre a una nueva variable, una segunda declaración de C&lt;our&gt; en el mismo paquete, en el mismo ámbito, es simplemente redundante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11423</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11423</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $i = @$deck;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225556Z" changeid="explorer">
        <seg>my $i = @$deck;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly for the C&lt;:encoding&gt; pragma: in that
case pretty much any characters can be read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, para el pragma C&lt;:encoding&gt;: en este caso casi todos los caracteres se pueden leer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 What are the Perl newsgroups on Usenet?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230344Z" changeid="explorer">
        <seg>=head2 ¿Qué son los grupos de noticias de Perl en Usenet?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then C&lt;$a&gt; and C&lt;$b&gt; are C&lt;$main::a&gt; and C&lt;$main::b&gt; (or C&lt;$::a&gt; and C&lt;$::b&gt;),
but if you're in the C&lt;FooPack&gt; package, it's the same as typing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>entonces C&lt;$a&gt; y C&lt;$b&gt; son C&lt;$main::a&gt; y C&lt;$main::b&gt; (o C&lt;$::a&gt; y C&lt;$::b&gt;), pero si está en el paquete C&lt;FooPack&gt;, es lo mismo que escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlop - Perl operators and precedence</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlop - Operadores de Perl y precedencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:bytes&gt;, C&lt;:crlf&gt;, C&lt;:utf8&gt;, and any other directives of the
form C&lt;:...&gt;, are called I/O I&lt;layers&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;:bytes&gt;, C&lt;:crlf&gt;, C&lt;:utf8&gt;, y cualquier otra directiva de la forma C&lt;:...&gt;, se llaman I&lt;capas&gt; I/O.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perldata&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171936Z" changeid="explorer">
        <seg>Ver L&lt;perldata&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(x)(?&lt;foo&gt;y)(z)/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T213806Z" changeid="explorer">
        <seg>/(x)(?&lt;foo&gt;y)(z)/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a simple example being:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230912Z" changeid="explorer">
        <seg>He aquí un ejemplo sencillo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The most popular books</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T002950Z" changeid="explorer">
        <seg>=head2 Los libros más populares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lower-level loops are I&lt;interrupted&gt; (that is, the loop is
broken) when Perl detects that a repeated expression matched a
zero-length substring.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231527Z" changeid="explorer">
        <seg>Los bucles de bajo nivel son I&lt;interrumpidos&gt; (es decir, el bucle es roto) cuando Perl detecta que una repetida expresión coincide con una subcadena de longitud cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Note&gt; that this pattern does not behave the same way as the equivalent
PCRE or Python construct of the same form.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T190650Z" changeid="explorer">
        <seg>B&lt;Note&gt; que este patrón no se comporta del mismo modo que la misma construcción equivalente en PCRE o Python.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common case is that the option is an
integer, in which case the result is a packed integer, which you can decode
using C&lt;unpack&gt; with the C&lt;i&gt; (or C&lt;I&gt;) format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un caso común es que la opción sea un entero, en cuyo caso el resultado es un entero empaquetado, que podrá decodificar usando C&lt;unpack&gt; con el formato C&lt;i&gt; (o C&lt;I&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value of an actual array in scalar context is the
length of the array; the following assigns the value 3 to $foo:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el valor actual de un array en contexto escalar es la longitud del array; lo siguiente asigna el valor 3 a $foo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's how to use C&lt;m//gc&gt; with C&lt;\G&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025859Z" changeid="explorer">
        <seg>Aquí está cómo se usa C&lt;m//gc&gt; con C&lt;\G&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,10, 1) = 1   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,10, 1) = 1   ==       1024 00000000001000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do either of those, you have to use the C&lt;$SIG{__WARN__}&gt; facility, or
turn off warnings inside the BLOCK or EXPR using S&lt;C&lt;no warnings 'all'&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para hacer cualquiera de estas dos cosas debe usar C&lt;$SIG{__WARN__}&gt;, o desactivar los avisos dentro del BLOQUE o EXPR usando S&lt;C&lt;no warnings 'all'&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;stdin&gt; X&lt;stdout&gt; X&lt;sterr&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;stdin&gt; X&lt;stdout&gt; X&lt;sterr&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;VSTRING&gt; is returned if the reference points
to a L&lt;version string|perldata/&quot;Version Strings&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;VSTRING&gt; se devuelve si la referencia apunta a una L&lt;version string|perldata/&quot;Cadenas de versión&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ary = glob($pattern);  # expand filenames</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ary = glob($patron);  # expandir los nombres de los archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort find_records(@key);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort busca_registros(@claves);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, devuelve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;DynaLoader&gt; upgraded but unfortunately we're not able to increment its version number :-(</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030633Z" changeid="explorer">
        <seg>C&lt;DynaLoader&gt; actualizado, pero, desafortunadamente, no somos capaces de aumentar su número de versión :-(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because there are I&lt;many&gt; other lowercase Greek characters than
just those, to match lowercase Greek characters in a regular expression,
you would use the pattern C&lt;/(?:(?=\p{Greek})\p{Lower})+/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224851Z" changeid="explorer">
        <seg>Sin embargo, porque existen I&lt;muchos&gt; otros caracteres griegos en minúscula que estos, para buscar por caracteres griegos en minúscula en una expresión regular, se utiliza el patrón C&lt;/(?:(?=\p{Greek})\p{Lower})+/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also embed newlines directly in your strings, i.e., they can end
on a different line than they begin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede incrustar directamente caracteres de nueva línea dentro de sus cadenas, es decir, que puede terminar en una línea diferente de cuando empezaron.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl571delta	Perl changes in version 5.7.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl571delta	Cambios en la versión 5.7.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The I&lt;sequence-item&gt; must not
have a repeat count.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La I&lt;secuencia-item&gt; no debe tener un contador de repeticiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In short, Perl 4 is the past, Perl 5 is the present, and Perl 6 is the
future.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T225638Z" changeid="explorer">
        <seg>Se puede resumir de la siguiente manera: Perl 4 es el pasado, Perl 5 es el presente y Perl 6 es el futuro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the ones
we've already seen include C&lt;print&gt;, C&lt;sort&gt; and C&lt;reverse&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225213Z" changeid="explorer">
        <seg>Ya hemos visto algunas funciones, como C&lt;print&gt;, C&lt;sort&gt; y C&lt;reverse&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fix pure-perl version of C&lt;refaddr&gt; to avoid blessing an un-blessed reference</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032938Z" changeid="explorer">
        <seg>Arreglada la versión en puro perl de C&lt;refaddr&gt; para evitar la bendición de una referencia no bendecida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11459</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11459</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as C&lt;$!&gt; is the value
of C's C&lt;errno&gt;, which can be set by any system call, this means that the value
of the exit code used by C&lt;die&gt; can be non-predictable, so should not be relied
upon, other than to be non-zero.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171410Z" changeid="explorer">
        <seg>Sin embargo, como C&lt;$!&gt; es el valor de C de C&lt;errno&gt;, que se puede establecer por cualquier llamada al sistema, esto significa que el valor del código de salida utilizada por C&lt;die&gt; puede ser no-previsible, por lo que no debe confiarse en él, aparte de ser distinto de cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are upgrading from an earlier release such as 5.6.1, first read
the L&lt;perl58delta&gt;, which describes differences between 5.6.0 and
5.8.0, and the L&lt;perl581delta&gt; and L&lt;perl582delta&gt;, which describe differences
between 5.8.0, 5.8.1 and 5.8.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está actualizando desde una versión anterior como la 5.6.1, primero lea L&lt;perl58delta&gt;, que describe las diferencias entre 5.6.0 y 5.8.0, y L&lt;perl581delta&gt; y L&lt;perl582delta&gt;, que describe las diferencias entre 5.8.0, 5.8.1 y 5.8.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#b&gt;',  12;   # prints &quot;&lt;0b1100&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#b&gt;',  12;   # imprime &quot;&lt;0b1100&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, &quot;extra&quot; nybbles are ignored during
unpacking.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, los nibles &quot;extra&quot; son ignorados durante el desempaquetado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?adlupimsx-imsx)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T051621Z" changeid="explorer">
        <seg>=item C&lt;(?adlupimsx-imsx)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function and method names seem to work best as all lowercase.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Funciones y nombres de métodos parece que funcionan mejor con minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lt  less than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lt  menor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that write is I&lt;not&gt; the opposite of C&lt;read&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que write I&lt;no&gt; es lo contrario de C&lt;read&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is available starting from perl 5.10.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232901Z" changeid="explorer">
        <seg>Está disponible a partir de perl 5.10.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you cannot read from the DATA
filehandle in a BEGIN block: the BEGIN block is executed as soon
as it is seen (during compilation), at which point the corresponding
__DATA__ (or __END__) token has not yet been seen.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003523Z" changeid="explorer">
        <seg>Tenga en cuenta que no puede leer desde el identificador de archivo de datos en un bloque BEGIN: el bloque BEGIN se ejecutará tan pronto como sea visto (durante la compilación), momento en que el correspondiente símbolo __DATA__ (o __END__) aún no se ha visto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%map = ('red',0x00f,'blue',0x0f0,'green',0xf00);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%map = ('rojo',0x00f,'azul',0x0f0,'verde',0xf00);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of a subroutine call, rather than a subroutine name, as an argument
to exists() is an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar una llamada de subrutina en lugar del nombre de una subrutina como argumento a exists() es un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BUILDING PERL ON DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 COMPILANDO PERL EN DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/$^F&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/$^F&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.thomer.com/thomer/vi/vi.html</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://www.thomer.com/thomer/vi/vi.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the FILEHANDLE is an EXPR, then the expression
is evaluated and the resulting string is used to look up the name of
the FILEHANDLE at run time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013621Z" changeid="explorer">
        <seg>Si el IDENTIFICADOR_ARCHIVO es una EXPR, entonces la expresión se evalúa y la cadena resultante se utiliza para buscar el nombre del IDENTIFICADOR_ARCHIVO en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;Carp&gt; for details of C&lt;croak()&gt;, C&lt;carp()&gt; and other useful
routines.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215929Z" changeid="explorer">
        <seg>Vea L&lt;Carp&gt; para más detalles sobre C&lt;croak()&gt;, C&lt;carp()&gt; y otras rutinas útiles.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item m//</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item m//</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in any of the shells, single quotes do not
hide variable names in the command from interpretation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de cualquiera de los shell, las comillas simples no impiden que los nombres de variables sean interpretadas, en el comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a few platform-specific directories which contain C code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014311Z" changeid="explorer">
        <seg>Hay algunos directorios específicos de la plataforma que contienen código C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special literals __FILE__, __LINE__, and __PACKAGE__
represent the current filename, line number, and package name at that
point in your program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los literales especiales __FILE__, __LINE__ y __PACKAGE__ representan el nombre del archivo actual, número de línea, y el nombre del paquete en ese punto de su programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Implicit strictures</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T001311Z" changeid="explorer">
        <seg>=head2 Restricciones implícitas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Barewords
X&lt;bareword&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035547Z" changeid="explorer">
        <seg>=head3 Palabras sueltas
X&lt;bareword&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This modifier means to use the &quot;Default&quot; native rules of the platform
except when there is cause to use Unicode rules instead, as follows:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000607Z" changeid="explorer">
        <seg>Este modificador significa usar las reglas nativas &quot;Predeterminadas&quot; (I&lt;Default&gt;) de la plataforma, excepto cuando hay razones para utilizar las reglas Unicode, de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.*s&gt;', -1, &quot;string&quot;;   # prints &quot;&lt;string&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.*s&gt;', -1, &quot;cadena&quot;;   # imprime &quot;&lt;cadena&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the system call fails, C&lt;syscall&gt; returns C&lt;-1&gt; and sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la llamada al sistema falla, C&lt;syscall&gt; devuelve C&lt;-1&gt; y establece C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR
is not specified, C&lt;$_&gt; will be used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR no se especifica, se comprobará C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... and run the script as C&lt;/path/to/script.pl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230208Z" changeid="zipf">
        <seg>... y ejecutar el script como C&lt;/ruta/script.pl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anywhere else it's $&lt;I&lt;digit&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En cualquier otro lugar, es $&lt;I&lt;dígito&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$Price = '$100';	# not interpolated</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$Precio = '$100';                 # no interpolado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TELL this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TELL este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the LENGTH is greater than the
data available in the SCALAR after the OFFSET, only as much data as is
available will be written.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LONGITUD es mayor que los datos disponibles en ESCALAR después del DESPLAZAMIENTO, sólo se escribirán los datos que estén disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2455607.7959375</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>2455607.7959375</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These look like</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002646Z" changeid="explorer">
        <seg>Aparecen así</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful when the structure you're
unpacking has encoded the sizes or repeat counts for some of its fields
within the structure itself as separate fields.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil cuando la estructura que está desempaquetando tiene codificados los tamaños o recuentos de repetición para algunos de sus campos dentro de la propia estructura como campos separados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run a Perl program from the Unix command line:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224637Z" changeid="explorer">
        <seg>Para ejecutar un programa Perl desde la línea de comandos de Unix, use el siguiente comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.8 has a sort pragma for
limited control of the sort.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>v5,8 tiene un pragma para sort, para un control limitado de la ordenación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setservent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setservent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make test</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make test</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/Net/servent....................FAILED at test 0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214826Z" changeid="explorer">
        <seg>lib/Net/servent....................FAILED at test 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;next&gt;, just double the braces:
X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T041156Z" changeid="explorer">
        <seg>Para C&lt;next&gt;, solamente doble las llaves:
X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the -g operator is often equivalent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># el operador -g es, a menudo, equivalente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi/i;          # Matches</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162257Z" changeid="explorer">
        <seg>&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi/i;          # Coincide</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $bar;    # still prints 30</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $bar;    # sigue pintando 30</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to C&lt;print FILEHANDLE sprintf(FORMAT, LIST)&gt;, except that C&lt;$\&gt;
(the output record separator) is not appended.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011541Z" changeid="explorer">
        <seg>Equivalente a C&lt;print IDENTIFICADOR_ARCHIVO sprintf(FORMATO, LISTA)&gt;, excepto que C&lt;$\&gt; (el separador de registro a la salida) no es añadida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that just because a hash is initialized in that order doesn't
mean that it comes out in that order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que sólo porque un hash se inicializa en ese orden no quiere decir que salga en ese orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;http://juerd.nl/site.plp/perlcheat&gt; - home of the Perl Cheat Sheet</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224435Z" changeid="explorer">
        <seg>L&lt;http://juerd.nl/site.plp/perlcheat&gt; - Página de la hoja resumen de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each version of Perl comes with the documentation that was current at
the time of release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003744Z" changeid="explorer">
        <seg>Cada versión de Perl incluye documentación actualizada en el momento del lanzamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12288</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12288</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlriscos		Perl notes for RISC OS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlriscos		Notas para RISC OS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned value is a
normalized version of the original pattern.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto es una versión normalizada del patrón original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complete regular expression matches this time, and you get
the expected output of &quot;table follows foo.&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T152022Z" changeid="explorer">
        <seg>La expresión regular completa coincide en este momento, y consigue el resultado esperado de &quot;espinacas sigue a come&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following standard quantifiers are recognized:
X&lt;metacharacter&gt; X&lt;quantifier&gt; X&lt;*&gt; X&lt;+&gt; X&lt;?&gt; X&lt;{n}&gt; X&lt;{n,}&gt; X&lt;{n,m}&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110214T002353Z" changeid="explorer">
        <seg>Se reconocen los siguientes cuantificadores estándares:
X&lt;metacharacter&gt; X&lt;quantifier&gt; X&lt;*&gt; X&lt;+&gt; X&lt;?&gt; X&lt;{n}&gt; X&lt;{n,}&gt; X&lt;{n,m}&gt; X&lt;metacarácter&gt; X&lt;cuantificador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlunitut - Perl Unicode Tutorial</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T233046Z" changeid="explorer">
        <seg>perlunitut - Tutorial de Unicode en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New probes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T201245Z" changeid="explorer">
        <seg>=head2 Nuevas pruebas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The quoted part ends on the
first C&lt;&quot;&gt; and C&lt;/&gt;, and the rest happens to be a syntax error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La parte entrecomillada termina en la primera C&lt;&quot;&gt; y C&lt;/&gt;, y el resto pasa a ser un error de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>qw(foo bar baz)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>qw(foo bar baz)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>longsize='4';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>longsize='4';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>means that no fee is charged for the item
itself, though there may be fees involved in handling the item.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>significa que no se cobra cuota por el propio elemento, aunque puede haber cargos involucrados en el manejo del elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldebguts 	Perl debugging guts and tips</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000504Z" changeid="explorer">
        <seg>perldebguts 	Componentes y consejos para la depuración</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the most common reason to learn this is to unravel labyrinthine
regular expressions, because the initial steps of parsing are the
same for all quoting operators, they are all discussed together.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque la razón más común para aprender esto es desentrañar laberínticas expresiones regulares, ya que los pasos iniciales del análisis son los mismos para todos los operadores de entrecomillado, todos ellos son explicados en conjunto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gmtime EXPR
X&lt;gmtime&gt; X&lt;UTC&gt; X&lt;Greenwich&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173836Z" changeid="explorer">
        <seg>=item gmtime EXPR
X&lt;gmtime&gt; X&lt;UTC&gt; X&lt;Greenwich&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might find these links useful:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232548Z" changeid="explorer">
        <seg>Es posible que estos vínculos le resulten de utilidad:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item our EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item our EXPR : ATRIBUTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, usually.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bueno, normalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>line.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$^N&gt; can be used in
extended patterns (see below), for example to assign a submatch to a
variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$^N&gt; puede ser usado en patrones extendidos (ver abajo), por ejemplo para asignar una sub coincidencia a una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stable CPAN modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030216Z" changeid="explorer">
        <seg>Módulos estables de CPAN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;foo;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;foo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreword by Damian Conway</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003138Z" changeid="explorer">
        <seg>prólogo de Damian Conway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%n    special: *stores* the number of characters output so far</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%n    especial: *almacena* el número de caracteres mostrados hasta ahora</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;@&gt;, C&lt;x&gt;, and C&lt;X&gt;, where it is equivalent to C&lt;0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;@&gt;, C&lt;x&gt; y C&lt;X&gt;, donde es equivalente a C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = $b || $c;		# better written this way</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a = $b || $c;		# mejor escrito de esta manera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And some of those digits look like some of the 10
ASCII digits, but mean a different number, so a human could easily think
a number is a different quantity than it really is.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T172804Z" changeid="explorer">
        <seg>Y algunas de esas cifras se parecen a algunos de los 10 dígitos ASCII, pero significan un número diferente, por lo que un ser humano podría pensar en un número con una cantidad diferente de lo que realmente es.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (my $paragraph = &lt;&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025710Z" changeid="explorer">
        <seg>while (my $parrafo = &lt;&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.slickedit.com/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://www.slickedit.com/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl, a sequence of statements that defines a scope is called a block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013249Z" changeid="explorer">
        <seg>En Perl, una secuencia de instrucciones que define un ámbito se llama un bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^/&gt; / if (/^$/ ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^/&gt; / if (/^$/ ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item foreach</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232638Z" changeid="explorer">
        <seg>=item foreach</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ITER: {
           foreach $prefix (@INC) {
               $realfilename = &quot;$prefix/$filename&quot;;
               if (-f $realfilename) {
                   $INC{$filename} = $realfilename;
                   $result = do $realfilename;
                   last ITER;
               }
           }
           die &quot;Can't find $filename in \@INC&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051104Z" changeid="explorer">
        <seg>ITER: {
           foreach $prefix (@INC) {
               $nombre_archivo_real = &quot;$prefijo/$archivo&quot;;
               if (-f $nombre_archivo_real) {
                   $INC{$archivo} = $nombre_archivo_real;
                   $resultado = do $nombre_archivo_real;
                   last ITER;
               }
           }
           die &quot;No encuentro el $archivo en \@INC&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;-&quot; performs arithmetic negation if the operand is numeric,
including any string that looks like a number.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T184158Z" changeid="explorer">
        <seg>Unario &quot;-&quot; lleva a cabo la negación aritmética si el operando es numérico, incluyendo cualquier string que se parezca a un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of specialized
languages that come to mind include prolog and matlab.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231047Z" changeid="explorer">
        <seg>Algunos ejemplos de lenguajes especializados son prolog y matlab.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$i = -9 + 8 * pos $vec;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>$i = -9 + 8 * pos $vec;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach( 0 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>foreach( 0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlclib		Internal replacements for standard C library functions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000512Z" changeid="explorer">
        <seg>perlclib		Sustitutos internos de la biblioteca de C estándar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some examples that you should be able to type into your command
shell:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay algunos ejemplos que será capaz de escribir en la línea de comandos del shell:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contrary to
its appearance, C&lt;#[ \t]*&gt; I&lt;is not&gt; the correct subexpression to match
the comment delimiter, because it may &quot;give up&quot; some whitespace if
the remainder of the pattern can be made to match that way.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T220556Z" changeid="explorer">
        <seg>Contrariamente a lo que parece, C&lt;#[ \t]*&gt; I&lt;no es&gt; la subexpresión correcta para coincidir con el delimitador del comentario, porque puede &quot;dejar aparte&quot; algún espacio en blanco si el resto del patrón lo hace coincidir con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %rules = ( '\\' =&gt; '\\\\',
                  'Y|' =&gt; qr/(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)/ );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002048Z" changeid="explorer">
        <seg>my %reglas = ( '\\' =&gt; '\\\\',
                  'Y|' =&gt; qr/(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)/ );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of MRO implementations, see C&lt;S_mro_get_linear_isa_c3()&gt;
and the C&lt;BOOT:&gt; section of F&lt;mro/mro.xs&gt;, and C&lt;S_mro_get_linear_isa_dfs()&gt;
in F&lt;mro.c&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115547Z" changeid="explorer">
        <seg>Para ver ejemplos de las implementaciones de MRO, vea C&lt;S_mro_get_linear_isa_c3()&gt; y la sección C&lt;BOOT:&gt; de F&lt;mro/mro.xs&gt;, y C&lt;S_mro_get_linear_isa_dfs()&gt; en F&lt;mro.c&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12243</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12243</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the sake
of portability it is a good idea always to use it when appropriate,
and never to use it when it isn't appropriate.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152952Z" changeid="explorer">
        <seg>Para una mejor portabilidad es siempre una buena idea usarlo cuando sea apropiado, y nunca usarlo cuando no sea apropiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no need
to pre-declare your variable types, but you have to declare them using
the C&lt;my&gt; keyword the first time you use them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224822Z" changeid="explorer">
        <seg>No es necesario predeclarar los tipos de las variables, pero éstas deben declararse con la palabra clave C&lt;my&gt; la primera vez que se usan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (blessed($ev_err) &amp;&amp; $ev_err-&gt;isa(&quot;Some::Module::Exception&quot;)) {
            # handle Some::Module::Exception</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043853Z" changeid="explorer">
        <seg>if (blessed($ev_err) &amp;&amp; $ev_err-&gt;isa(&quot;Some::Module::Exception&quot;)) {
            # controlador Some::Module::Exception</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/exec&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/exec&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not particularly efficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto no es particularmente eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mnemonic for C&lt;(?^...)&gt;:  A fresh beginning since the usual use of a caret is
to match at the beginning.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T195259Z" changeid="explorer">
        <seg>Mnemotécnico para C&lt;(?^...)&gt;: Un nuevo comienzo, ya que el uso normal de un circunflejo es coincidir con el comienzo del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation typos fixed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Arreglados errores ortográficos en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhpux		Perl notes for HP-UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlhpux		Notas para HP-UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't go through silly contortions to exit a loop at the top or the
bottom, when Perl provides the C&lt;last&gt; operator so you can exit in
the middle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No haga tontas contorsiones para salir de un bucle al inicio o al final, cuando Perl dispone del operador C&lt;last&gt; para que pueda salir desde el interior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = s/abc/def/r;           # $a is 'def123xyz' and
                                # $_ remains 'abc123xyz'.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035130Z" changeid="explorer">
        <seg>$a = s/abc/def/r;		# $a es 'def123xyz' y $_ queda como 'abc123xyz'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $unlinked = unlink 'a', 'b', 'c';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $unlinked = unlink 'a', 'b', 'c';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;http://perlmonks.org/?node_id=216602&gt; - the original PM post</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224429Z" changeid="explorer">
        <seg>L&lt;http://perlmonks.org/?node_id=216602&gt; - Artículo original de PM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This may seem like an
odd thing to you, but you'll use the construct in almost every Perl
script you write.)  The $_ variable is not implicitly localized.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto puede parecer algo extraño para usted, pero usará esta construcción en casi todos los scripts de Perl que escriba). La variable $_ no estará, implícitamente, localizada en el contexto del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes operands that might otherwise be interpreted as operators,
constants, single number v-strings or function calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto incluye operandos que, de lo contrario, podrían interpretarse como operadores, constantes, un solo número o v-cadenas o llamadas a funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlre&gt;, with additional examples in L&lt;perlop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001425Z" changeid="explorer">
        <seg>Se describe en L&lt;perlre&gt;, con ejemplos adicionales en L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wed Nov  1 19:42:39 5576711</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225528Z" changeid="explorer">
        <seg>Wed Nov  1 19:42:39 5576711</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>READ this, scalar, length, offset</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>READ este, escalar, longitud, desplazamiento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As well as these filters for converting other languages, the
L&lt;pl2pm|pl2pm&gt; utility will help you convert old-style Perl 4 libraries to 
new-style Perl5 modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234301Z" changeid="explorer">
        <seg>Además de estos filtros para traducir otros lenguajes, la utilidad L&lt;pl2pm|pl2pm&gt; permite convertir bibliotecas de código Perl 4 antiguo en módulos de Perl 5 modernos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl builds and runs on a bewildering number of platforms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225352Z" changeid="explorer">
        <seg>Perl se puede compilar y ejecutar en una gran variedad de plataformas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stick with that, and you
should be safe.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siga con eso, y estará seguro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\w??/&lt;$&amp;&gt;/g;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050115Z" changeid="explorer">
        <seg>s/\w??/&lt;$&amp;&gt;/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;, C&lt;msgsnd&gt;, C&lt;semctl&gt;, C&lt;semget&gt;, C&lt;semop&gt;,
C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;, C&lt;shmwrite&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202300Z" changeid="explorer">
        <seg>C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;, C&lt;msgsnd&gt;, C&lt;semctl&gt;, C&lt;semget&gt;, C&lt;semop&gt;,
C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;, C&lt;shmwrite&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12 blcks  strftime!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>12 blcks  strftime!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is another way to protect your filenames from
interpretation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235758Z" changeid="explorer">
        <seg>Esta es otra manera de proteger los nombres de archivo de su interpretación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use the C&lt;x&gt; operator to repeat a C&lt;qw//&gt; list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045542Z" changeid="explorer">
        <seg>Ahora puede usar el operador C&lt;x&gt; para repetir una lista C&lt;qw//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13358</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13358</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>White space can separate pack codes from each other, but modifiers and
repeat counts must follow immediately.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco puede separar los códigos de empaquetado, pero los modificadores y los contadores de repetición deben seguir de inmediato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do { my $_ = EXPR; ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do { my $_ = EXPR; ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the pattern was used as follows</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T185534Z" changeid="explorer">
        <seg>Si el patrón se utilizó de esta manera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># print out history file offsets</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># imprime los desplazamientos en el archivo histórico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
particular, as C&lt;@_&gt; contains aliases to the caller's arguments, Perl does
not take a copy of C&lt;@_&gt;, so C&lt;@DB::args&gt; will contain modifications the
subroutine makes to C&lt;@_&gt; or its contents, not the original values at call
time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, como C&lt;@_&gt; contiene los alias de los argumentos de la función llamante, Perl no tiene una copia de C&lt;@_&gt;, así que C&lt;@DB::args&gt; contendrá modificaciones que la subrutina hace a C&lt;@_&gt; o de sus contenidos, no los valores originales a la hora de ser llamada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Give examples of use in your documentation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013950Z" changeid="explorer">
        <seg>Dé ejemplos de uso en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every
piece of advice given here is the result of previous mistakes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013140Z" changeid="explorer">
        <seg>Cada consejo que aquí se da es el resultado de errores anteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>forces arguments to integer format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234046Z" changeid="explorer">
        <seg>Fuerzan la conversión de los argumentos al formato de entero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| die &quot;can't access /dev/tty: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T024850Z" changeid="explorer">
        <seg>|| die &quot;no puedo acceder a /dev/tty: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;{$key})  { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;{$clave})  { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry has his reasons for each of these things, but he doesn't claim that
everyone else's mind works the same as his does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Larry tiene sus razones para cada una de estas ideas, pero el no aspira que la mente de los demás trabaje de la misma forma que la suya.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For alignment commands, a C&lt;count&gt; of 0 is equivalent to a C&lt;count&gt; of 1;
both are no-ops.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012049Z" changeid="explorer">
        <seg>Para los comandos de alineación, un C&lt;contador&gt; de 0 es equivalente a un C&lt;contador&gt; de 1; ambos son instrucciones no efectivas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recursively create a directory structure, look at
the C&lt;mkpath&gt; function of the L&lt;File::Path&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para, recursivamente, crear una estructura de directorios, mire la función C&lt;mkpath&gt; del módulo L&lt;File::Path&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>N  An unsigned long (32-bit) in &quot;network&quot; (big-endian) order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>N  Un largo sin signo (32 bit) en orden &quot;red&quot; (big-endian).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this code works
in the same way on big-endian or little-endian machines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que este código funciona de la misma manera en máquinas big-endian que little-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $key (sort { $hash{$b} &lt;=&gt; $hash{$a} } keys %hash) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $key (sort { $hash{$b} &lt;=&gt; $hash{$a} } keys %hash) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Johan Vromans</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003230Z" changeid="explorer">
        <seg>Johan Vromans</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given ($fruit) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234910Z" changeid="explorer">
        <seg>given ($fruta) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5113delta	Perl changes in version 5.11.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5113delta	Cambios en la versión 5.11.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joins the separate strings of LIST into a single string with fields
separated by the value of EXPR, and returns that new string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Une las cadenas separados de LISTA en una única cadena con campos separados por el valor de EXPR y devuelve la nueva cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When choosing a new salt create a random two character string whose
characters come from the set C&lt;[./0-9A-Za-z]&gt; (like C&lt;join '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando escoja un nuevo salto cree un string de dos caracteres elegidos aleatoriamente del conjunto C&lt;[./0-9A-Za-z]&gt; (como por ejemplo C&lt;join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/Math/Trig......................exp: OVERFLOW</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214819Z" changeid="explorer">
        <seg>lib/Math/Trig......................exp: OVERFLOW</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens because</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015314Z" changeid="explorer">
        <seg>Esto sucede porque</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perldiag&gt; for explanations of all Perl's diagnostics.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001609Z" changeid="explorer">
        <seg>Encontrará en L&lt;perldiag&gt; las descripciones de todos los diagnósticos de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, all the characters that are decimal digits
somewhere in the world will match C&lt;\d&gt;; this is hundreds, not 10,
possible matches.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T172653Z" changeid="explorer">
        <seg>Del mismo modo, todos los caracteres que son dígitos decimales en algún lugar del mundo coincidirán con C&lt;\d&gt;,lo que significa que son cientos, no 10, de posibles coincidencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;&lt; $ref-&gt;{&quot;A&quot;} &gt;&gt; and C&lt;&lt; $ref-&gt;{&quot;A&quot;}-&gt;{&quot;B&quot;} &gt;&gt; will spring
into existence due to the existence test for the $key element above.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así. C&lt;&lt; $ref-&gt;{&quot;A&quot;} &gt;&gt; y C&lt;&lt; $ref-&gt;{&quot;A&quot;}-&gt;{&quot;B&quot;} &gt;&gt; aparecerán en la existencia debido al actual test por el elemento $clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implements the ioctl(2) function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Implementa la función ioctl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;failed to execute: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001924Z" changeid="explorer">
        <seg>print &quot;error al ejecutar: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(To do runtime compilation only once,
use C&lt;/$variable/o&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para hacer la compilación en tiempo de ejecución sólo una vez, utilice C&lt;/$variable/o&gt;.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmod		Perl modules: how they work</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000431Z" changeid="explorer">
        <seg>perlmod		Funcionamiento de un módulo Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;pod2usage&gt; is a special case of F&lt;podselect&gt;, a utility to extract
named sections from documents written in POD.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233437Z" changeid="explorer">
        <seg>F&lt;pod2usage&gt; es un caso especial de F&lt;podselect&gt;, una utilidad que permite extraer secciones con nombre de documentos escritos en formato POD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl572delta	Perl changes in version 5.7.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl572delta	Cambios en la versión 5.7.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;&lt;&quot;, $file)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235343Z" changeid="explorer">
        <seg>open(FOO, &quot;&lt;&quot;, $archivo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># timed out</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># fin de temporización</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a,$b,$c,$d) = unpack('W4',$addr[0]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a,$b,$c,$d) = unpack('W4',$addr[0]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13326</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13326</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 - that is, each element smart-matches the element of same index in the</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042940Z" changeid="explorer">
        <seg>2 - es decir, cada elemento coincide inteligentemente con cada elemento del mismo índice.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the arguments get executed via the system shell, results are
subject to its quirks and capabilities.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando los argumentos son ejecutados vía el shell del sistema, los resultados están sujetos a sus peculiaridades y capacidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>t	       intepret integer as C type &quot;ptrdiff_t&quot; on Perl 5.14 or later</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182117Z" changeid="explorer">
        <seg>t           interpreta un entero como &quot;ptrdiff_t&quot; del C en Perl 5.14 o superior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let it be stressed that I&lt;whatever falls between C&lt;\Q&gt; and C&lt;\E&gt;&gt;
is interpolated in the usual way.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay que hacer hincapié en que I&lt;lo que caiga dentro de C&lt;\Q&gt; y C&lt;\E&gt;&gt; es interpolado de la forma normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/qr_gc.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010026Z" changeid="explorer">
        <seg>=item t/op/qr_gc.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that capture groups matched inside of recursion are not accessible
after the recursion returns, so the extra layer of capturing groups is
necessary.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213524Z" changeid="explorer">
        <seg>Tenga en cuenta que los grupos de captura encontrados en el interior de la recursión no son accesibles después del regreso de la recursión, por lo que  es necesaria una capa extra de grupos de captura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The C&lt;overloading&gt; pragma</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T194219Z" changeid="explorer">
        <seg>=head2 El pragma C&lt;overloading&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(?'char'.)\g1/                 # ... mix and match
         and print &quot;'$1' is the first doubled character\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191429Z" changeid="explorer">
        <seg>/(?'char'.)\g1/                 # ... mezcla y busca
         and print &quot;'$1' es el primer carácter repetido\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either of these
circumstances triggered tainting code that contained a pointer bug.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000106Z" changeid="explorer">
        <seg>Cualquiera de estas circunstancias provocaba código contaminado que contenía un error de puntero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a podified version of what used to be on the above-mentioned web page,
podified by Jarkko Hietaniemi 2001-Jan-01.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es una versión I&lt;podificada&gt; de lo que solía estar en la anterior página web anteriormente mencionada, I&lt;podificada&gt; por Jarkko Hietaniemi 2001-enero-01.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ints = $vector-&gt;Index_List_Read();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>@ints = $vector-&gt;Index_List_Read();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!/usr/local/bin/perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#!/usr/local/bin/perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will place into $count the number of digit groups found in $string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pondrá en $cuenta el número de grupos de dígitos que se encuentren en $cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub match {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub coincidencia {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Long doubles are available only if your system supports long</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Los dobles-largos están disponibles solo si su sistema soporta valores largos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a *= 3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a *= 3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item MirOS BSD</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005656Z" changeid="explorer">
        <seg>=item MirOS BSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;NEW PARAGRAPH&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025722Z" changeid="explorer">
        <seg>say &quot;NUEVO PÁRRAFO&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $min + int rand(1 + $max - $min);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225521Z" changeid="explorer">
        <seg>return $min + int rand(1 + $max - $min);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$pwd = (getpwuid($&lt;))[1];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$pwd = (getpwuid($&lt;))[1];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 SYNOPSIS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T154324Z" changeid="zipf">
        <seg>=head1 SINOPSIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
particular, all the modifiers execpt C&lt;/o&gt; are further explained in
L&lt;perlre/Modifiers&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T225801Z" changeid="explorer">
        <seg>En particular, todos los modificadores, excepto C&lt;/o&gt; se explican en L&lt;perlre/Modificadores&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'aaabaaab' =~ /a+b?(*SKIP)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T012823Z" changeid="explorer">
        <seg>'aaabaaab' =~ /a+b?(*SKIP)(?{print &quot;$&amp;\n&quot;; $contador++})(*FAIL)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To support the bootstrapping process, F&lt;miniperl&gt; no longer builds with
UTF-8 support in the regexp engine.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T191208Z" changeid="explorer">
        <seg>Para mejorar el proceso de arranque, F&lt;miniperl&gt; ya no se compila con soporte UTF-8 en el motor de expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp; 127),  ($?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp; 127),  ($?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
can be used to go almost anywhere else within the dynamic scope,
including out of subroutines, but it's usually better to use some other
construct such as C&lt;last&gt; or C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser utilizada para ir a casi cualquier sitio que esté dentro del ámbito dinámico, incluyendo fuera de las subrutinas, pero es normalmente mucho mejor otras construcciones como C&lt;last&gt; o C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment is a little bit special in that it uses its left argument
to determine the context for the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La asignación es un poco especial en el sentido de que utiliza su argumento de la izquierda para determinar el contexto del argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El redondeo en las aplicaciones financieras puede tener consecuencias graves, y el método de redondeo utilizado debe ser descrito con precisión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,19, 1) = 1   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,19, 1) = 1   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($a) {}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($a) {}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any positive
flags (except C&lt;&quot;d&quot;&gt;) may follow the caret, so</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T194356Z" changeid="explorer">
        <seg>Cualquier bandera positiva (excepto C&lt;&quot;d&quot;&gt;) pueden seguir al circunflejo, por lo que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may be useful in a my() or local().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto puede ser útil en un my() o local().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the repeat count is C&lt;0&gt;, it's relative to the current position.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el número de repeticiones es C&lt;0&gt;, es relativa a la posición actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict   qw(subs vars refs);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use strict   qw(subs vars refs);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Content-Length: $byte_count&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235404Z" changeid="explorer">
        <seg>&quot;Content-Length: $numero_bytes&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in this release, using a string
eval when C&lt;autodie&gt; is in effect can cause the autodie behaviour to leak
into the surrounding scope.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110921T145353Z" changeid="explorer">
        <seg>Tenga en cuenta que en esta versión, usando una cadena C&lt;eval&gt;uada cuando C&lt;autodie&gt; está activo puede causar que el comportamiento de autodie se fugue del ámbito actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators are exempt from the &quot;looks like a function rule&quot; described
above.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152255Z" changeid="explorer">
        <seg>Estos operadores están exentos de la regla &quot;se parece a una función&quot; descrita anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produce the output 'h:i: :t:h:e:r:e:!:' and 'hi:there:', respectively,
both with an empty trailing field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce la salida 'h:o:l:a: :a:q:u:i:!:' y 'hola:aqui:', respectivamente, ambos con un campo vacío final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(VOS)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015050Z" changeid="explorer">
        <seg>(VOS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reference is a scalar value and can refer to any other Perl data
type.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224949Z" changeid="explorer">
        <seg>Una referencia es un valor escalar que puede apuntar a cualquier tipo de datos de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\f          form feed             (FF)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043342Z" changeid="explorer">
        <seg>\f		avance de página	(FF)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @abbr = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my @abbr = qw( Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to get at a slice (part of a row) in a multidimensional
array, you're going to have to do some fancy subscripting.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194532Z" changeid="explorer">
        <seg>Si desea obtener una porción (parte de una fila) en una matriz multidimensional, va a tener que hacer algunos juegos malabares con los subíndices.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldiag		Perl diagnostic messages</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldiag		Mensajes de diagnóstico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;got $a\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;tengo $a\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used to go almost anywhere
else within the dynamic scope, including out of subroutines, but it's
usually better to use some other construct such as C&lt;last&gt; or C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser utilizada para ir a casi cualquier sitio que esté dentro del ámbito dinámico, incluyendo fuera de las subrutinas, pero es usualmente mucho mejor usar otras construcciones como C&lt;last&gt; o C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item die LIST
X&lt;die&gt; X&lt;throw&gt; X&lt;exception&gt; X&lt;raise&gt; X&lt;$@&gt; X&lt;abort&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170630Z" changeid="explorer">
        <seg>=item die LISTA
X&lt;die&gt; X&lt;throw&gt; X&lt;exception&gt; X&lt;raise&gt; X&lt;$@&gt; X&lt;abort&gt; X&lt;excepción&gt; X&lt;levantar&gt; X&lt;abortar&gt; X&lt;descartar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The suffix is no longer stripped if it is identical to the remaining characters
in the name, again for consistency with the shell utility.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031500Z" changeid="explorer">
        <seg>El sufijo ya no es eliminado si es idéntico al resto de los caracteres en el nombre, una vez más para mantener la coherencia con la utilidad del shell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Juerd Waalboer &lt;#####@juerd.nl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235553Z" changeid="explorer">
        <seg>Juerd Waalboer &lt;#####@juerd.nl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, they always return
$timeleft equal to the supplied $timeout.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no, siempre devuelven $tiempo_restante igual a $tiempo_espera indicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Bugs reports about microperl without fixes/patches are equivalent
to wishlist requests - they won't be discarded, but they likely won't get
worked on either, unless they chance to coincide with someone's personal itch)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223220Z" changeid="explorer">
        <seg>(Informes de errores acerca de microperl sin correcciones/parches son equivalentes a las peticiones - no van a ser desechados, pero probablemente no se trabajará en ellos, a menos que coincida oportunamente con una comezón personal de algún voluntario)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Threading</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Multihilos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -Dcc='cc -64' -Duse64bitint</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002544Z" changeid="explorer">
        <seg>sh Configure -Dcc='cc -64' -Duse64bitint</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Threads Will Be Removed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014657Z" changeid="explorer">
        <seg>I&lt;Threads&gt; serán eliminados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $input = &quot;10110110&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225515Z" changeid="explorer">
        <seg>my $input = &quot;10110110&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item MIME::Base64</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item MIME::Base64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;roffitall|roffitall&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232010Z" changeid="explorer">
        <seg>=item L&lt;roffitall|roffitall&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item times
X&lt;times&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T205940Z" changeid="explorer">
        <seg>=item times
X&lt;times&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if these
conditions are met, be warned that unlinking a directory can inflict
damage on your filesystem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso si se cumplen estas condiciones, se advierte que desvincular un directorio puede causar daños a su sistema de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (values %hash)      { s/foo/bar/g }   # modifies %hash values</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (values %hash)      { s/foo/bar/g }   # modifica los valores de %hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return print reverse sort num values %array;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return print reverse sort num values %array;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that programmers need new habits.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T233213Z" changeid="explorer">
        <seg>Esto significa que los programadores deben adquirir nuevas costumbres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It extends the recommendations found in 
L&lt;perlstyle&gt; , which should be considered required reading
before reading this document.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T012827Z" changeid="explorer">
        <seg>Extiende las recomendaciones que se encuentran en L&lt;perlstyle&gt;, que debe ser considerado de lectura obligatoria antes de leer este documento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, returns the number of fields found.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el número de campos que se han encontrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that argument processing varies depending on the
number of arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que el tratamiento de los argumentos varía en función del número de argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also insert hooks into the import facility by putting Perl code
directly into the @INC array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011357Z" changeid="explorer">
        <seg>También puede insertar enganches en la facilidad C&lt;import&gt; poniendo código Perl directamente en el array @INC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VMS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015434Z" changeid="explorer">
        <seg>VMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$year = sprintf(&quot;%02d&quot;, $year % 100);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$anno = sprintf(&quot;%02d&quot;, $anno % 100);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local *Here::blue = \$There::green;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local *Aqui::azul = \$Ahi::verde;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the character represented by that NUMBER in the character set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el carácter representado por NÚMERO en el conjunto de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsource		Guide to the Perl source tree</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T140945Z" changeid="explorer">
        <seg>perlsource		Guía al árbol de código fuente de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $color  = substr $s, 4, 5;      # black</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $color  = substr $s, 8, 5;      # negro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right	**</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>derecha	**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Closures, eval and lexicals</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010336Z" changeid="explorer">
        <seg>=head2 Clausuras, eval y léxicas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to fields allowed in pack(), you may prefix a field with
a %&lt;number&gt; to indicate that
you want a &lt;number&gt;-bit checksum of the items instead of the items
themselves.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de los campos permitidos en pack(), puede usar un prefijo de un campo con un %&lt;número&gt; para indicar que desea una suma de control a nivel de bit de los elementos en lugar de los propios elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Encoding</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234637Z" changeid="explorer">
        <seg>=head3 Codificación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is not scheduled for release yet, and Perl 5 will still be supported
for quite awhile after its release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230112Z" changeid="explorer">
        <seg>El lanzamiento de Perl 6 aún no está programado, pero recuerde que Perl 5 seguirá vivo mucho tiempo después de que esto ocurra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode has many more characters than that,
so you need a method to make these accessible.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004647Z" changeid="explorer">
        <seg>En Unicode hay muchos más caracteres, por lo que necesitamos una forma de hacerlos accesibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that some system calls I&lt;can&gt; legitimately return C&lt;-1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015747Z" changeid="explorer">
        <seg>Tenga en cuenta que algunas llamadas al sistema I&lt;pueden&gt; legalmente devolver C&lt;-1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Package the module using &quot;make dist&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014312Z" changeid="explorer">
        <seg>Empaquete el módulo con &quot;make dist&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a new warning, produced in situations like the following one:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035932Z" changeid="explorer">
        <seg>Esta es una nueva advertencia, que se produce en situaciones como la siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\H        [3]  Not horizontal whitespace</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224952Z" changeid="explorer">
        <seg>\H        [3]  No espacio en blanco horizontal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open FILEHANDLE,EXPR
X&lt;open&gt; X&lt;pipe&gt; X&lt;file, open&gt; X&lt;fopen&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011006Z" changeid="explorer">
        <seg>=item open IDENTIFICADOR_ARCHIVO,EXPR
X&lt;open&gt; X&lt;pipe&gt; X&lt;file, open&gt; X&lt;fopen&gt; X&lt;archivo, open&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also means that if you want real
whitespace or C&lt;#&gt; characters in the pattern (outside a character
class, where they are unaffected by C&lt;/x&gt;), then you'll either have to
escape them (using backslashes or C&lt;\Q...\E&gt;) or encode them using octal,
hex, or C&lt;\N{}&gt; escapes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto también significa que si quiere un espacio en blanco real o caracteres C&lt;#&gt; en el patrón (excepto en una clase de caracteres, donde no les afecta C&lt;/x&gt;), entonces tendrá que escaparlos (usando barras invertidas o C&lt;\Q...\E&gt;) o codificarlas usando octal, hex, o secuencias de escape C&lt;\N{}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following is a list of expected failures with
the patch number of the fix where that is known:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001538Z" changeid="explorer">
        <seg>La siguiente es una lista de los errores esperados con el número de revisión de la corrección en el que se conocen:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A zero-width negative look-behind assertion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212712Z" changeid="explorer">
        <seg>Una aserción antecedente negativa de ancho cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Math::BigInt</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Math::BigInt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval qq[\n#line 2001 &quot;&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval qq[\n#line 2001 &quot;&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl should build cleanly on Stratus VOS once more.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110015Z" changeid="explorer">
        <seg>Perl debe compilarse limpiamente en Stratus VOS, una vez más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.perl.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110223T234902Z" changeid="explorer">
        <seg>http://www.perl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means that if you don't use binmode() on
these systems, C&lt;\cM\cJ&gt; sequences on disk will be converted to C&lt;\n&gt; on
input, and any C&lt;\n&gt; in your program will be converted back to C&lt;\cM\cJ&gt; on
output.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022914Z" changeid="explorer">
        <seg>Esto significa que, si no usa binmode() en estos sistemas, las secuencias C&lt;\cM\cJ&gt; en disco serán convertidas a C&lt;\n&gt; en la entrada y cualquier C&lt;\n&gt; en tu programa será convertido de nuevo en C&lt;\cM\cJ&gt; en la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this file is found, it will be loaded in
place of any potentially existing file ending in a F&lt;.pm&gt; extension.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T235506Z" changeid="explorer">
        <seg>Si se encuentra este archivo, se cargará en lugar de cualquier archivo existente que termine en la extensión F&lt;. pm&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@utmp2 = unpack($utmp_template, $utmp);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@utmp2 = unpack($utmp_template, $utmp);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Basset hounds got long ears&quot; if length $ear &gt;= 10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El perro de caza Basset tiene largas orejas&quot; if length $oreja &gt;= 10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\k&lt;name&gt;  [5]  Named backreference</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T224625Z" changeid="explorer">
        <seg>\k&lt;name&gt;  [5]  Contrareferencia nominal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%X    like %x, but using upper-case letters</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%X    como %x, pero usando mayúsculas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.8.0 release and
the 5.8.1 release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005434Z" changeid="explorer">
        <seg>Este documento describe las diferencias entre la versión 5.8.0 y la versión 5.8.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlfunc/pos&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045830Z" changeid="explorer">
        <seg>L&lt;perlfunc/pos&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defined(my $tcp = getprotobyname(&quot;tcp&quot;))</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>defined(my $tcp = getprotobyname(&quot;tcp&quot;))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item libnet</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item libnet</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will transliterate any A to X.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>transliterará cualquier A a X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;(*ACCEPT)&gt; is inside of capturing groups then the groups are
marked as ended at the point at which the C&lt;(*ACCEPT)&gt; was encountered.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T144516Z" changeid="explorer">
        <seg>Si el C&lt;(*ACCEPT)&gt; se encuentra dentro de grupos de captura entonces los grupos son marcados para terminar en el lugar en que se encontró el C&lt;(*ACCEPT)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the match runs, the first part of the regular expression (C&lt;\b(foo)&gt;)
finds a possible match right at the beginning of the string, and loads up
$1 with &quot;Foo&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T150904Z" changeid="explorer">
        <seg>Cuando la coincidencia se ejecuta, la primera parte de la expresión regular (C&lt;\b(come)&gt;) encuentra una posible coincidencia al principio de la cadena, y carga $1 con &quot;Come&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function tells the thingy referenced by REF that it is now an object
in the CLASSNAME package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función dice que la cosa referenciada por REF es ahora un objeto del paquete NOMBRECLASE (I&lt;bless&gt; es bendición en inglés, que se podría traducir mejor por bautizar, en el sentido de 'dar un nombre' al objeto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the
cost of a little more overhead, you can do this by using the /m modifier
on the pattern match operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A costa de una ligera sobrecarga, puede hacer esto usando el modificador /m en el patrón del operador de coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = chown $uid, $gid, 'foo', 'bar';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$num = chown $uid, $gid, 'foo', 'bar';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used on a hash element, it tells you whether the value is defined,
not whether the key exists in the hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa con un elemento de un hash, le indica si el valor está definido, no si la clave existe en el hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perl590delta&gt;, L&lt;perl591delta&gt;, L&lt;perl592delta&gt;
and L&lt;perl593delta&gt; for the differences between 5.8.0 and 5.9.3.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T234825Z" changeid="explorer">
        <seg>Vea L&lt;perl590delta&gt;, L&lt;perl591delta&gt;, L&lt;perl592delta&gt; y L&lt;perl593delta&gt; para consultar las diferencias entre 5.8.0 y 5.9.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most other
approaches are doomed to failure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225848Z" changeid="explorer">
        <seg>La probabilidad de éxito de las demás opciones es escasa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the constants is also more portable
than relying on 0, 1, and 2.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de las constantes también es más portátil que confiar en 0, 1 y 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are scripts which will check the source things like ANSI C violations,
POD encoding issues, etc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014816Z" changeid="explorer">
        <seg>Scripts que detectarán en el código fuente cosas como infracciones de ANSI C, problemas de codificación de POD, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open mailbox: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir el buzón: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Platform-Specific</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000837Z" changeid="explorer">
        <seg>=head2 Información específica de plataformas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[[:...:]] [2]  Match a character according to the rules of the POSIX
                   character class &quot;...&quot; within the outer bracketed
                   character class.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T044233Z" changeid="explorer">
        <seg>[[:...:]] [2]  Busca un carácter de acuerdo a las reglas de la clase
                    carácter POSIX &quot;...&quot; dentro de la clase carácter
                    más exterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;chr(65)&gt; is C&lt;&quot;A&quot;&gt; in either ASCII or Unicode, and
chr(0x263a) is a Unicode smiley face.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;chr(65)&gt; es C&lt;&quot;A&quot;&gt; tanto en ASCII como en Unicode, y chr(0x263a) es una cara sonriente en Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of
characters is no longer known, because characters only exist in text strings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235318Z" changeid="explorer">
        <seg>Ya no se sabe cuál es el número de caracteres, puesto que los caracteres solo existen en las cadenas de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not consider C&lt;getlogin&gt; for authentication: it is not as
secure as C&lt;getpwuid&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No considere usar C&lt;getlogin&gt; para autenticación: no es tan seguro como C&lt;getpwuid&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shadow password
files are supported only if your vendor has implemented them in the
intuitive fashion that calling the regular C library routines gets the
shadow versions if you're running under privilege or if there exists
the shadow(3) functions as found in System V (this includes Solaris
and Linux).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T162357Z" changeid="explorer">
        <seg>Archivos de contraseñas shadow sólo están soportados si el proveedor los ha implementado con la intuitiva moda de que llamando a las rutinas regulares de la biblioteca C se obtienen las versiones shadow si está corriendo con bajos privilegios o si existe la función shadow(3) tal como se encuentra en System V (esto incluye Solaris y Linux).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is called synonymously its ordinal, code position, or code point.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232335Z" changeid="explorer">
        <seg>Esto se conoce, de forma similar, como su valor ordinal, posición del código, o punto de código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns a list of lines
(however you've defined lines with C&lt;$/&gt; or C&lt;$INPUT_RECORD_SEPARATOR&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, devuelve una lista de líneas (según haya definido lo que son líneas con C&lt;$/&gt; o C&lt;$INPUT_RECORD_SEPARATOR&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To decode, you have to
know what encoding was used during the encoding phase.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234732Z" changeid="explorer">
        <seg>Para descodificar necesita saber la codificación que se utilizó al codificar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlinterp		Overview of the Perl intepreter source and how it works</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141027Z" changeid="explorer">
        <seg>perlinterp		Visión general al código fuente del intérprete Perl, y cómo funciona</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;roffitall&gt; utility is not installed on your system but lives in
the F&lt;pod/&gt; directory of your Perl source kit; it converts all the
documentation from the distribution to F&lt;*roff&gt; format, and produces a
typeset PostScript or text file of the whole lot.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234130Z" changeid="explorer">
        <seg>La utilidad C&lt;roffitall&gt; no se instala en el sistema, pero puede encontrarla en el directorio F&lt;pod/&gt; del kit de código fuente de Perl. Esta utilidad convierte toda la documentación de la distribución al formato F&lt;*roff&gt; y a partir de esto genera código fuente PostScript o un archivo de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that functions such as C&lt;keys&gt; and C&lt;values&gt; may return huge lists
when used on large DBM files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que las funciones como C&lt;keys&gt; y C&lt;values&gt; pueden devolver largas listas cuando se usan con archivos DBM grandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our $x; our $x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014305Z" changeid="explorer">
        <seg>our $x; our $x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is usually 32766 on the most common platforms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Éste es, normalmente, 32766, en la mayoría de las plataformas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider giving away your code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere compartir su código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>, =&gt;             {3,7} repeat in range      /o cmpl pat.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224249Z" changeid="explorer">
        <seg>, =&gt;             {3,7} repeticiones             /o compilar patrón</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar  =&gt;  {
                     description =&gt; &quot;single item&quot;,
                     sigil =&gt; '$',
                    },</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T214332Z" changeid="explorer">
        <seg>scalar  =&gt;  {
                     descripcion =&gt; &quot;un solo valor&quot;,
                     sigilo =&gt; '$',
                    },</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is usually
something to be avoided when writing clear code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto suele ser algo que debe ser evitado cuando se está escribiendo código claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[2]-&gt;[2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[2]-&gt;[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you think this</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002347Z" changeid="explorer">
        <seg>Si piensa que esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!/usr/bin/env perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232546Z" changeid="explorer">
        <seg>#!/usr/bin/env perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This now correctly produces the run-time error C&lt;Can't use string as a
SCALAR ref while &quot;strict refs&quot; in use&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T034854Z" changeid="explorer">
        <seg>Esto ahora produce correctamente el error en tiempo de ejecución C&lt;Can't use string as a SCALAR ref while &quot;strict refs&quot; in use&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
should give a few percent speed increase, and eliminates almost all of
the speed penalty caused by the introduction of &quot;safe signals&quot; in
5.8.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T053131Z" changeid="explorer">
        <seg>Esto debería dar un pequeño porcentaje de aumento de velocidad, y elimina casi la totalidad de la pérdida de velocidad causada por la introducción de las &quot;señales de seguridad&quot; en la 5.8.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that alternatives are not necessarily greedy.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T223542Z" changeid="explorer">
        <seg>Esto significa que las alternativas no son necesariamente codiciosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;xsubpp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234610Z" changeid="explorer">
        <seg>=item L&lt;xsubpp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?^aluimsx:pattern)&gt;
X&lt;(?^:)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T194152Z" changeid="explorer">
        <seg>=item C&lt;(?^aluimsx:patrón)&gt;
X&lt;(?^:)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only operators with lower precedence are the logical operators
&quot;and&quot;, &quot;or&quot;, and &quot;not&quot;, which may be used to evaluate calls to list
operators without the need for extra parentheses:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los únicos operadores con menor prioridad son los operadores lógicos &quot;and&quot;, &quot;or&quot;, y &quot;no&quot;, que pueden ser utilizados para evaluar las llamadas a los operadores de lista sin necesidad de paréntesis adicionales:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item my EXPR : ATTRS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item my EXPR : ATRIBUTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'foo{bar}baz'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'foo{bar}baz'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(($mode &amp; 0777) == 04000);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234251Z" changeid="explorer">
        <seg>(($mode &amp; 0777) == 04000);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.20_01.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025631Z" changeid="explorer">
        <seg>1.20_01.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -d:DProf program.pl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T005740Z" changeid="explorer">
        <seg>perl -d:DProf programa.pl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Earlier versions of mod_perl 2.x
do not work with the randomised hashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T012149Z" changeid="explorer">
        <seg>Las versiones anteriores de mod_perl 2.x no funcionan con la función de aleatorización de los hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$isdst&gt; is true if the specified time occurs during Daylight Saving
Time, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$isdst&gt; es verdadero si el tiempo especificado se produce durante el horario de verano; en caso contrario, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-10206-7 [1st edition July 2007]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003402Z" changeid="explorer">
        <seg>ISBN 978-0-596-10206-7 [1ª edición - Julio de 2007]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8 atime    last access time in seconds since the epoch</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>8 atime    tiempo último acceso, en segundos, desde el epoch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Switch and Smart Match operator</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T193805Z" changeid="explorer">
        <seg>=head2 El operador Switch y el emparejamiento inteligente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $animals[0];              # prints &quot;camel&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121207Z" changeid="zipf">
        <seg>print $animales[0];  # imprime &quot;camello&quot; en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>APIs obsoleted in Perl 5.8.0, like sv_2pv, sv_catpvn, sv_catsv,
sv_setsv, are again available.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T001631Z" changeid="explorer">
        <seg>API obsoleta en Perl 5.8.0, como sv_2pv, sv_catpvn, sv_catsv, sv_setsv, están de nuevo disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;$,&gt; flexibility</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003247Z" changeid="explorer">
        <seg>=head2 Flexibilidad de C&lt;$,&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596001735</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003540Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596001735</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On error, C&lt;select&gt; behaves like select(2): it returns
-1 and sets C&lt;$!&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de error, C&lt;select&gt; se comporta como select(2): devuelve -1 y actualiza C&lt;$!&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Math::BigRat</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014829Z" changeid="explorer">
        <seg>=item Math::BigRat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Module auxiliary files</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T034638Z" changeid="explorer">
        <seg>=head2 Archivos auxiliares de los módulos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is written in pod format hence there are punctuation
characters in odd places.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento está escrito en formato pod, por lo que hay caracteres de puntuación en lugares extraños.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;INSTALL&gt;, L&lt;perlport&gt;, L&lt;perlebcdic&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T064852Z" changeid="explorer">
        <seg>L&lt;INSTALL&gt;, L&lt;perlport&gt;, L&lt;perlebcdic&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I18N::LangTags</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item I18N::LangTags</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002333Z" changeid="explorer">
        <seg>Use</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># File types.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Tipos de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, this is
a big win except in pathological cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, esto es un gran ahorro, salvo en casos patológicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($X, $Y, $POINTS) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($X, $Y, $PUNTOS) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the syntax for a
block and an anonymous hash reference constructor look the same unless
there's something in the braces that give Perl a hint.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, la sintaxis de un bloque y un constructor de referencia a un hash anónimo tienen el mismo aspecto a menos que haya algo dentro de las llaves que le den una pista a Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (R1) (R2) ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T194856Z" changeid="explorer">
        <seg>=item (R1) (R2) ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When large amounts of client code will use the software (and
should be insulated from changes in its implementation)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020144Z" changeid="explorer">
        <seg>Cuando grandes cantidades de código del cliente utilizará el software (y debe estar aislado de los cambios en su implementación)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chomp VARIABLE
X&lt;chomp&gt; X&lt;INPUT_RECORD_SEPARATOR&gt; X&lt;$/&gt; X&lt;newline&gt; X&lt;eol&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170108Z" changeid="explorer">
        <seg>=item chomp VARIABLE
X&lt;chomp&gt; X&lt;INPUT_RECORD_SEPARATOR&gt; X&lt;$/&gt; X&lt;newline&gt; X&lt;eol&gt; X&lt;nueva línea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prior to 5.14, there were no explicit modifiers, but C&lt;/l&gt; was implied
for regexes compiled within the scope of C&lt;use locale&gt;, and C&lt;/d&gt; was
implied otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T000323Z" changeid="explorer">
        <seg>Antes de 5.14, no existían modificadores explícitos, pero C&lt;/l&gt; estaba implícito para las expresiones regulares compiladas en el ámbito de C&lt;use locale&gt;, y C&lt;/d&gt; era el implícito en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The importance of these tests is proportional to the alleged stability of a 
module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030501Z" changeid="explorer">
        <seg>La importancia de estas pruebas es proporcional a la supuesta estabilidad de un módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$output = `cmd 2&gt;&amp;1`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$salida = `comando 2&gt;&amp;1`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $byte_count = length $binary;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234635Z" changeid="explorer">
        <seg>my $numero_bytes = length $binario;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...           +     one or more          /s . includes \n</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224238Z" changeid="explorer">
        <seg>...           +     uno o varios             /s . incluye \n</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=   assignment</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=   asignación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a number of issues with regard to case-insensitive matching
in Unicode rules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003845Z" changeid="explorer">
        <seg>Hay una serie de cuestiones con respecto a las coincidencias con las mayúsculas y minúsculas en las reglas Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item glob EXPR
X&lt;glob&gt; X&lt;wildcard&gt; X&lt;filename, expansion&gt; X&lt;expand&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173832Z" changeid="explorer">
        <seg>=item glob EXPR
X&lt;glob&gt; X&lt;wildcard&gt; X&lt;filename, expansion&gt; X&lt;expand&gt; X&lt;archivo, expansión&gt; X&lt;comodín&gt; X&lt;expandir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use IO::File;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use IO::File;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simply quote all non-&quot;word&quot; characters:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Escape sencillamente todos los caracteres que no formen parte de una palabra:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;ptar&gt; is a tar-like program, written in pure Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234924Z" changeid="explorer">
        <seg>F&lt;ptar&gt; es un programa tar escrito en código Perl puro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 chdir FOO</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T111915Z" changeid="explorer">
        <seg>=head2 chdir FOO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing subroutines is easy:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233231Z" changeid="zipf">
        <seg>Es fácil escribir subrutinas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used in scalar context, the return value generally indicates the
success of the operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa en contexto escalar, el valor devuelto, por lo general, indica el éxito de la operación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you really mean for such values
to terminate the loop, they should be tested for explicitly:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si realmente quiere mirar por esos valores para terminar el bucle, deben hacerse la prueba de forma explícita:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This release is known not to build on Windows 95.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014956Z" changeid="explorer">
        <seg>Esta publicación se sabe que no se compila en Windows 95.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldata		Perl data structures</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000253Z" changeid="explorer">
        <seg>perldata		Estructuras de datos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can browse and search
the Perl 5 bugs at http://bugs.perl.org/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede navegar y buscar en el web de los errores de Perl 5 en http://bugs.perl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So
this expression:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que esta expresión:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%6s&gt;&quot;, &quot;a&quot;;      # prints &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014559Z" changeid="explorer">
        <seg>printf &quot;&lt;%6s&gt;&quot;, &quot;a&quot;;      # imprime &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some syntax errors involving unrecognized filetest operators are now handled
correctly by the parser.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004058Z" changeid="explorer">
        <seg>Algunos errores de sintaxis involucrados en no reconocer operadores de test de archivo son ahora manejados correctamente por el analizador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LD_LIBRARY_PATH=`pwd` ./perl -Ilib lib/Net/servent.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T215017Z" changeid="explorer">
        <seg>LD_LIBRARY_PATH=`pwd` ./perl -Ilib lib/Net/servent.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(OUTPUT, '|sort &gt;foo')  # pipe to sort</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(OUTPUT, '|sort &gt;foo')  # tubería a sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Builtin types include:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tipos integrados incluyen:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Changed &quot;A thread exited while %d threads were running&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001649Z" changeid="explorer">
        <seg>=head2 Caambiada &quot;I&lt;A thread exited while %d threads were running&gt;&quot; (Un hilo de ejecución terminó mientras %d hilos se estaban ejecutando)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or if you try to do</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T225721Z" changeid="explorer">
        <seg>O si trata de hacer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlop		Perl operators and precedence</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlop		Operadores y precedencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># run-time warnings enabled after here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># advertencias en ejecución activas desde aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Programming Pearls&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003725Z" changeid="explorer">
        <seg>=item I&lt;Programming Pearls&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, C&lt;require&gt; demands that a library file be included if it
hasn't already been included.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario, C&lt;require&gt; demanda que un archivo de biblioteca sea incluido si no se hubiera incluido ya.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map  ( lc($_), 1 ),   @array  # evaluates to (1, @array)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map  ( lc($_), 1 ),   @array  # evalúa a (1, @array)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other boolean contexts, C&lt;&lt; &lt;filehandle&gt; &gt;&gt; without an
explicit C&lt;defined&gt; test or comparison elicits a warning if the
C&lt;use warnings&gt; pragma or the B&lt;-w&gt;
command-line switch (the C&lt;$^W&gt; variable) is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013938Z" changeid="explorer">
        <seg>En otros contextos booleanos, C&lt;&lt; &lt;identificador-de-archivo&gt; &gt;&gt; sin un explícito C&lt;defined&gt; o comparación, provoca una advertencia si el pragma C&lt;use warnings&gt; o la opción B&lt;-w&gt; en la línea de comandos (la variable C&lt;$^W&gt;) está en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;//&gt; matching operator is documented in L&lt;perlop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225408Z" changeid="explorer">
        <seg>El operador de detección de coincidencias C&lt;//&gt; se describe en L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, C&lt;&quot;$foo\Qbaz$bar&quot;&gt;
is converted to C&lt;$foo . (quotemeta(&quot;baz&quot; . $bar))&gt; internally.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054350Z" changeid="explorer">
        <seg>Así, C&lt;&quot;$foo\Qbaz$bar&quot;&gt; es convertida internamente a C&lt;$foo . (quotemeta(&quot;baz&quot; . $bar))&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub fhbits {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub fhbits {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sentence =~ s{\Q$substring\E}{big bad wolf};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012614Z" changeid="explorer">
        <seg>$instruccion =~ s{\Q$subcadena\E}{gran lobo malo};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rewinddir DIRHANDLE
X&lt;rewinddir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020805Z" changeid="explorer">
        <seg>=item rewinddir IDENTIFICADOR_DIR
X&lt;rewinddir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These have been
fixed by Dave Mitchell and Yves Orton.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T050232Z" changeid="explorer">
        <seg>Esto ha sido solventado por Dave Mitchell e Yves Orton.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's one that avoids the
problem you get into if you explicitly test for end-of-file on
an interactive file descriptor causing your program to appear to
hang.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay una que evita el problema, al comprobar explícitamente, por el fin de archivo en un descriptor de archivo interactivo, que parezca que su programa se haya quedado colgado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the constructor from the C&lt;IO::Handle&gt; package (or one of its
subclasses, such as C&lt;IO::File&gt; or C&lt;IO::Socket&gt;), you can generate anonymous
filehandles that have the scope of the variables used to hold them, then
automatically (but silently) close once their reference counts become
zero, typically at scope exit:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T000105Z" changeid="explorer">
        <seg>Utilizando el constructor del paquete C&lt;IO::Handle&gt; (o una de sus subclases, como C&lt;IO::File&gt; o C&lt;IO::Socket&gt;), puede generar identificadores de archivo anónimos que tienen el ámbito de cualquiera de las variables que contengan referencias a ellos, y entonces, automáticamente (pero silenciosamente), son cerrados cuando el contador de referencias llegue a cero, normalmente a la salida del ámbito actual:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$y = 'ABC445';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050402Z" changeid="explorer">
        <seg>$y = 'ABC445';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the `#' on the previous line must be the first char on line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># el `#' en la línea anterior debe ser el primer carácter de la línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your bug report, along with the output
of C&lt;perl -V&gt;, will be sent off to perlbug@perl.org to be analysed by
the Perl porting team.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052839Z" changeid="explorer">
        <seg>Su informe de error, junto con la salida de C&lt;perl -V&gt;, serán enviados a perlbug@perl.org para ser analizado por el equipo de adaptación de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If multiple distinct capture groups have the same name then the
$+{NAME} will refer to the leftmost defined group in the match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T201353Z" changeid="explorer">
        <seg>Si múltiples grupos de captura tienen el mismo nombre, entonces $+{NOMBRE} se referirá al grupo definido más a la izquierda, dentro de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within each repetition of a group, positioning with
C&lt;@&gt; starts over at 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dentro de cada repetición de un grupo, posicionarse con C&lt;@&gt; comienza de nuevo en 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Variable names
X&lt;variable, name&gt; X&lt;variable name&gt; X&lt;data type&gt; X&lt;type&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Nombres de variable
X&lt;variable, name&gt; X&lt;variable name&gt; X&lt;data type&gt; X&lt;type&gt;
X&lt;variable, nombre&gt; X&lt;nombre variable&gt; X&lt;tipo dato&gt; X&lt;tipo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For others, it serves as a convenient, high-level replacement for most of
what they'd program in low-level languages like C or C++.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230835Z" changeid="explorer">
        <seg>Para otros, es un cómodo sustituto de alto nivel para la mayor parte de los programas que desarrollarían en lenguajes de bajo nivel como C o C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>follow =&gt; 1,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225447Z" changeid="explorer">
        <seg>follow =&gt; 1,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opens a filehandle to an anonymous temporary file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020614Z" changeid="explorer">
        <seg>abre un identificador de archivo a un archivo anónimo temporal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some internal code cleanup</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alguna limpieza interna de código</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hex() and oct() functions make these conversions
for you.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las funciones hex() y oct() hacen estas conversiones por usted.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is a bareword, the require assumes a &quot;F&lt;.pm&gt;&quot; extension and
replaces &quot;F&lt;::&gt;&quot; with &quot;F&lt;/&gt;&quot; in the filename for you,
to make it easy to load standard modules.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es una simple palabra, el require asume una extensión &quot;F&lt;.pm&gt;&quot; y le reemplaza &quot;F&lt;::&gt;&quot; con &quot;F&lt;/&gt;&quot; en el nombre del archivo, para que sea fácil cargar módulos estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The digest of the password is stored,
not the password itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El I&lt;digest&gt; de una contraseña se almacena, no la propia contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># 0         1          2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># 0         1         2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the typical &quot;match a double-quoted
string&quot; problem can be most efficiently performed when written as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, el problema típico de &quot;coincidir con una cadena doblemente entrecomillada&quot; puede ser más eficientemente realizada cuando se escribe como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># ...		# code for each line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ...		# código por cada línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcn		Perl for Simplified Chinese (in EUC-CN)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000826Z" changeid="explorer">
        <seg>perlcn		Perl para chino simplificado (en EUC-CN)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Unicode::UCD&gt; upgraded to version 0.24</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041113Z" changeid="explorer">
        <seg>C&lt;Unicode::UCD&gt; actualizado a la versión 0.24</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;threads&gt; upgraded to version 1.07</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040324Z" changeid="explorer">
        <seg>C&lt;threads&gt; actualizado a la versión 1.07</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A little forethought may save you a vast
amount of effort later on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014523Z" changeid="explorer">
        <seg>Un poco de previsión puede ahorrar una gran cantidad de esfuerzo más adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most systems, you are not allowed to change the ownership of the
file unless you're the superuser, although you should be able to change
the group to any of your secondary groups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de los sistemas, no se le permite cambiar la propiedad del archivo a menos que sea el superusuario, aunque sí pueda cambiar el grupo a cualquiera de sus grupos secundarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.gnu.org/software/emacs/windows/ntemacs.html</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://www.gnu.org/software/emacs/windows/ntemacs.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value gives the name of the
filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020926Z" changeid="explorer">
        <seg>IDENTIFICADOR_ARCHIVO puede ser una expresión cuyo valor da el nombre del identificador de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which uses C&lt;&lt; (?&gt;...) &gt;&gt; matches exactly when the one above does (verifying
this yourself would be a productive exercise), but finishes in a fourth
the time when used on a similar string with 1000000 C&lt;a&gt;s.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T214833Z" changeid="explorer">
        <seg>que hace que C&lt;&lt; (?&gt;...) &gt;&gt; coincida exactamente con la cadena anterior (verificar esto por uno mismo puede ser un ejercicio muy productivo), pero termina en la cuarta parte de tiempo cuando se usa en una cadena similar con 1.000.000 de C&lt;a&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while($vec =~ /[^\0]+/g ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225602Z" changeid="explorer">
        <seg>while($vec =~ /[^\0]+/g ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default the format for
a file is the one having the same name as the filehandle, but the
format for the current output channel (see the C&lt;select&gt; function) may be set
explicitly by assigning the name of the format to the C&lt;$~&gt; variable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013545Z" changeid="explorer">
        <seg>Por defecto el formato de un archivo es el que tiene el mismo nombre que el identificador de archivo, pero el formato para el canal de salida (vea la función C&lt;select&gt;) se puede establecer de forma explícita mediante la asignación del nombre del formato a la variable C&lt;$~&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,13, 2) = 1   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,13, 2) = 1   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item m?PATTERN?msixpodualgc
X&lt;?&gt; X&lt;operator, match-once&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030217Z" changeid="explorer">
        <seg>=item m?PATRÓN?msixpodualgc
X&lt;?&gt; X&lt;operator, match-once&gt; X&lt;operador, coincide una vez&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getppid
X&lt;getppid&gt; X&lt;parent&gt; X&lt;pid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173550Z" changeid="explorer">
        <seg>=item getppid
X&lt;getppid&gt; X&lt;parent&gt; X&lt;pid&gt; X&lt;padre&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluation of EXPR may be in list, scalar, or void
context, depending on how the return value will be used, and the context
may vary from one execution to the next (see C&lt;wantarray&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evaluación de EXPR puede estar en contextos lista, escalar, o contexto vacío, dependiendo de cómo el valor de retorno será utilizado, y el contexto puede variar de una ejecución a la siguiente (ver C&lt;wantarray&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;characters&gt;: depending on the status of the filehandle,
either (8-bit) bytes or characters are read.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011701Z" changeid="explorer">
        <seg>Note los I&lt;caracteres&gt;: dependiendo del estado del identificador de archivo, son leídos bytes (8-bit) o caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the limits
for Perl numbers stored as native integers would typically be -2**31..2**32-1,
with appropriate modifications in the case of 64-bit integers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232606Z" changeid="explorer">
        <seg>Así, los límites para números Perl almacenados como enteros nativos serán normalmente -2**31..2**32-1, con las modificaciones correspondientes en el caso de los enteros de 64 bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
differences can be either positive (e.g. extensions for the features
of the particular platform that are not supported in the source
release of perl) or negative (e.g. might be based upon a less current
source release of perl).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225429Z" changeid="explorer">
        <seg>Estas diferencias pueden ser positivas (p. ej., extensiones para las características de una plataforma específica que no se ofrecen en la distribución de código fuente de perl) o negativas (p. ej., la distribución binaria puede estar basada en una distribución de código fuente de perl menos reciente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context,
returns the last element removed, or C&lt;undef&gt; if no elements are
removed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el último elemento eliminado, o C&lt;undef&gt; si no hay elementos eliminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{}[]()^$.|*+?\</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113334Z" changeid="explorer">
        <seg>{}[]()^$.|*+?\</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Delete (most) C comments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Eliminar (la mayoría) comentarios C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Win32: sysopen, sysread, syswrite</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003744Z" changeid="explorer">
        <seg>=head2 Win32: sysopen, sysread, syswrite</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shortsize='2';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shortsize='2';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whatever you choose, be
consistent!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022903Z" changeid="explorer">
        <seg>Lo que elija, ¡debe ser coherente!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other assignment operators work similarly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros operadores de asignación funcionan de manera similar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232617Z" changeid="explorer">
        <seg>Le permitimos y animamos a utilizar este código y los derivados que surjan en sus propios programas, ya sea con fines de diversión o beneficio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl limits barewords (like
identifiers) to about 250 characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl limita las palabras sueltas (como a los identificadores) a cerca de 250 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;readline&gt; encounters an operating system error, C&lt;$!&gt; will be set
with the corresponding error message.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;readline&gt; encuentra un error del sistema operativo, C&lt;$!&gt; será puesto al correspondiente mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># The operators -f, -d, -l, -b, -c, -p, and -S.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Los operadores -f, -d, -l, -b, -c, -p, y -S.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new
behaviour in the absence of a SCALAR method is to return TRUE if in the
middle of an C&lt;each&gt; iteration, and otherwise call FIRSTKEY to check if the
hash is empty (making sure that a subsequent C&lt;each&gt; will also begin by
calling FIRSTKEY).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El nuevo comportamiento en ausencia de un método SCALAR es retornar verdadero si está en medio de una iteración C&lt;each&gt;, y de otra manera, llamar a FIRSTKEY para comprobar si el hash está vacío (asegurarse de que una posterior C&lt;each&gt; también comenzará llamando FIRSTKEY).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subroutine that is not defined
may still be callable: its package may have an C&lt;AUTOLOAD&gt; method that
makes it spring into existence the first time that it is called; see
L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una subrutina que no ha sido definida puede ser ejecutada: su paquete puede tener un método C&lt;AUTOLOAD&gt; que la hace aparecer la primera vez que es llamada; ver L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can process line directives, much like the C preprocessor.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl puede procesar directivas como lo hace el preprocesador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Time-related functions
X&lt;time&gt; X&lt;date&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165224Z" changeid="explorer">
        <seg>=item Funciones relacionadas con el tiempo
X&lt;time&gt; X&lt;date&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all else fails, consult http://perldoc.perl.org/ which has the
complete documentation in HTML and PDF format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230300Z" changeid="explorer">
        <seg>Como último recurso, puede consultar http://perldoc.perl.org/, que incluye toda la documentación en formato HTML y PDF.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function msgsnd to send the message MSG to the
message queue ID.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función msgsnd de System V IPC para enviar el mensaje MSG a la cola de mensajes ID.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the substring
is beyond either end of the string, substr() returns the undefined
value and produces a warning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la subcadena está más allá de cada extremo de la cadena, substr() devuelve el valor indefinido y produce una advertencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlaix		Perl notes for AIX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlaix		Notas para AIX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is,
if the left operand is true, the right operand is not even evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, si el operando izquierdo es verdadero, el operando de la derecha no es ni siquiera evaluado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a comparison such as C&lt;$_ E&lt;lt&gt; 10&gt; or C&lt;$x eq &quot;abc&quot;&gt;
(or of course C&lt;$_ ~~ $c&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042810Z" changeid="explorer">
        <seg>una comparación, como C&lt;$_ E&lt;lt&gt; 10&gt; o C&lt;$x eq &quot;abc&quot;&gt; (o, naturalmente, C&lt;$_ ~~ $c&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matches as C&lt;S{max}|S{max-1}|...|S{min+1}|S{min}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235732Z" changeid="explorer">
        <seg>Coincide con C&lt;S{max}|S{max-1}|...|S{min+1}|S{min}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3: 'pp', pos=7</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3: 'pp', pos=7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/etc/games is no good at canasta line 123.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/etc/games no está bien at canasta line 123.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example of setting a filehandle named C&lt;REMOTE&gt; to be
non-blocking at the system level.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010120Z" changeid="explorer">
        <seg>Aquí hay un ejemplo de poner un identificador de archivo llamado C&lt;REMOTE&gt; a no bloqueante a nivel de sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void      $scalar   whole:   @array        %hash</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224116Z" changeid="explorer">
        <seg>nulo       $escalar  completo: @array        %hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value gives the name of
the actual filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T021100Z" changeid="explorer">
        <seg>IDENTIFICADOR_ARCHIVO puede ser una expresión cuyo valor da el nombre del identificador de archivo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example is checking
if a correct password is given.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un ejemplo es comprobando si se ha dado una contraseña correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;perlperf&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005523Z" changeid="explorer">
        <seg>=item L&lt;perlperf&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you get tired of writing a custom print for your data structures,
you might look at the standard L&lt;Dumpvalue&gt; or L&lt;Data::Dumper&gt; modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032024Z" changeid="explorer">
        <seg>Cuando se canse de escribir una impresión personalizada de las estructuras de datos, podría mirar los módulos estándar L&lt;Dumpvalue&gt; o L&lt;Data::Dumper&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no way for pack() and unpack()
to know where characters are going to or coming from, so they 
handle their output and input as flat sequences of characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No hay forma, para un pack() y unpack(), saber qué caracteres van o vienen, por lo que controlan su salida y entrada como secuencias planas de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the emulation built with lockf(3) doesn't provide shared
locks, and it requires that FILEHANDLE be open with write intent.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010543Z" changeid="explorer">
        <seg>Note que la emulación integrada con lockf(3) no provee de bloqueos compartidos y requiere que el IDENTIFICADOR_ARCHIVO sea abierto con intención de escribir en el.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m	Treat string as multiple lines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>m	Trata la cadena como un conjunto de múltiples líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo{$a,$b,$c}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T014040Z" changeid="explorer">
        <seg>$foo{$a,$b,$c}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print while ($_ = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print while ($_ = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>contains all the elements of @foo followed by all the elements of @bar,
followed by all the elements returned by the subroutine named SomeSub 
called in list context, followed by the key/value pairs of %glarch.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>contiene todos los elementos de @foo seguido por todos los elementos de @bar, seguido de todos los elementos devueltos por la subrutina llamada AlgunaSub llamada en contexto lista, seguido de los pares clave/valor de %glarch.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the I&lt;gethost*()&gt; functions, if the C&lt;h_errno&gt; variable is supported in
C, it will be returned to you via C&lt;$?&gt; if the function call fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las funciones I&lt;gethost*()&gt;, si la variable C&lt;h_errno&gt; está soportada en C, será devuelta vía C&lt;$?&gt; si la llamada a la función falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say $+ {b};   # *Also* prints '12'.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T125445Z" changeid="explorer">
        <seg>say $+ {b};   # *También* imprime '12'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;vmsish&gt; upgraded to version 1.02</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041145Z" changeid="explorer">
        <seg>C&lt;vmsish&gt; actualizado a la versión 1.02</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;END&gt; routines and destructors
can change the exit status by modifying C&lt;$?&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T161057Z" changeid="explorer">
        <seg>Las rutinas C&lt;END&gt; y los destructores pueden cambiar el estado de salida modificando C&lt;$?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes the currently selected filehandle if the argument is
omitted.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005559Z" changeid="explorer">
        <seg>Cierra el identificador de archivo actualmente seleccionado si se omite el argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current position of the C&lt;readdir&gt; routines on DIRHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T021120Z" changeid="explorer">
        <seg>Devuelve la posición actual de la rutina C&lt;readdir&gt; sobre IDENTIFICADOR_DIR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrecharclass/POSIX Character Classes&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220446Z" changeid="explorer">
        <seg>Vea L&lt;perlrecharclass/Clases carácter POSIX&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$flags = fcntl(REMOTE, F_GETFL, 0)
                or die &quot;Can't get flags for the socket: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044442Z" changeid="explorer">
        <seg>$flags = fcntl(REMOTE, F_GETFL, 0)
                or die &quot;No puedo obtener los flags para el socket: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless the C&lt;/r&gt; option is used,
the string specified must be a scalar variable, an array element, a
hash element, or an assignment to one of those; that is, some sort of
scalar lvalue.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031118Z" changeid="explorer">
        <seg>A menos que se use la opción C&lt;/r&gt;, la cadena especificada debe ser una variable escalar, un elemento de un array, un elemento hash, o una asignación a una de estas; es decir, algún tipo de I&lt;ivalor&gt; escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this code has the same effect as the
Unix touch(1) command when the files I&lt;already exist&gt; and belong to
the user running the program:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, este código tiene el mismo efecto que el comando touch(1) de Unix cuando los archivos &lt;realmente existen&gt; y pertenecen al usuario que ejecuta el programa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some case insensitive matches between UTF-8 encoded data and 8 bit regexps,
and vice versa, could give malformed character warnings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T050210Z" changeid="explorer">
        <seg>Algunas coincidencias insensibles al tamaño de caja de los caracteres, entre datos codificados en UTF-8 y expresiones regulares de 8 bits, y viceversa, podría dar advertencias sobre caracteres incorrectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get the correct function definitions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para obtener las correctas definiciones de la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># exactly the same</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># exactamente lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is always safe to use the two-argument form of C&lt;open&gt; if
the filename argument is a known literal.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T002918Z" changeid="explorer">
        <seg>Siempre es más seguro utilizar el formato de dos argumentos de C&lt;open&gt; si el argumento con el nombre de archivo es un literal bien visible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,13, 1) = 1   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,13, 1) = 1   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	, =&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	, =&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that
zero-length look-ahead/look-behind assertions will not backtrack to make
the tail match, since they are in &quot;logical&quot; context: only
whether they match is considered relevant.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T211840Z" changeid="explorer">
        <seg>Tenga en cuenta también que las aserciones de longitud cero antecedentes/consecuentes no darán marcha atrás para retrasar la coincidencia, ya que ellas están en un contexto &quot;lógico&quot;: sólo cuando coinciden son considerados relevantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The build procedure is completely standard:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procedimiento de construcción es completamente estándar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlsyn/&quot;Switch statements&quot;&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225108Z" changeid="explorer">
        <seg>Consulte &quot;Instrucciones switch&quot; en L&lt;perlsyn&gt; para obtener información detallada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proper
way to handle such calls is to assign C&lt;$!=0&gt; before the call, then
check the value of C&lt;$!&gt; if C&lt;syscall&gt; returns C&lt;-1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015821Z" changeid="explorer">
        <seg>La forma correcta de manejar llamadas de ese tipo es el de asignar C&lt;$!=0&gt; antes de la llamada, y comprobar el valor de C&lt;$!&gt; si C&lt;syscall&gt; devuelve C&lt;-1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: One should not attempt to mix buffered I/O (like C&lt;read&gt;
or &lt;FH&gt;) with C&lt;select&gt;, except as permitted by POSIX, and even
then only on POSIX systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;AVISO&gt; : No debe tratar de mezclar el E/S con buferes (como C&lt;read&gt; o &lt;FH&gt;) con C&lt;select&gt;, excepto lo autorizado por POSIX, e incluso entonces sólo en sistemas POSIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're just looking for software, first use Google
( http://www.google.com ), Google's Usenet search interface
( http://groups.google.com ), and CPAN Search ( http://search.cpan.org ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230653Z" changeid="explorer">
        <seg>Si sólo busca software, empiece por Google ( http://www.google.com ), la interfaz de búsqueda de Usenet disponible en Google ( http://groups.google.com ) y CPAN Search ( http://search.cpan.org ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlform&gt; for other examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlform&gt; para otros ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>z	       intepret integer as C type &quot;size_t&quot; on Perl 5.14 or later</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182155Z" changeid="explorer">
        <seg>z           interpreta un entero como &quot;size_t&quot; del C en Perl 5.14 o superior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Query or change configuration of Perl modules that use Module::Build-based
configuration files for features and config data.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234316Z" changeid="explorer">
        <seg>Permite consultar o modificar la configuración de módulos Perl que usan archivos de configuración basados en Module::Build para características y datos de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item umask EXPR
X&lt;umask&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210108Z" changeid="explorer">
        <seg>=item umask EXPR
X&lt;umask&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Configuration improvements</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003708Z" changeid="explorer">
        <seg>=head2 Mejoras en la configuración</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item format
X&lt;format&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173404Z" changeid="explorer">
        <seg>=item format
X&lt;format&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;lcfirst&gt; and C&lt;ucfirst&gt; could corrupt the string for certain cases where
the length UTF-8 encoding of the string in lower case, upper case or title
case differed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T050422Z" changeid="explorer">
        <seg>C&lt;lcfirst&gt; y C&lt;ucfirst&gt; podrían corromper la cadena de caracteres en ciertos casos donde la longitud de la codificación UTF-8 de la cadena en minúsculas, mayúsculas o capitulares, puede diferir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ByteLoader</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015045Z" changeid="explorer">
        <seg>=item ByteLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The metaconfig system has its own git repository.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014912Z" changeid="explorer">
        <seg>El sistema metaconfig tiene su propio repositorio git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$debugging = 0 unless defined $debugging;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$debugging = 0 unless defined $debugging;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tests C&lt;lib/Net/Ping/t/450_service.t&gt; and C&lt;lib/Net/Ping/t/510_ping_udp.t&gt;
fail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los test C&lt;lib/Net/Ping/t/450_service.t&gt; y C&lt;lib/Net/Ping/t/510_ping_udp.t&gt; fallan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the embedded C&lt;#&gt; is interpreted as a literal C&lt;#&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que el C&lt;#&gt; incrustado se interpreta como un C&lt;#&gt; literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
changes to the directory specified by C&lt;$ENV{HOME}&gt;, if set; if not,
changes to the directory specified by C&lt;$ENV{LOGDIR}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, cambia al directorio especificado por C&lt;$ENV{HOME}&gt;, si está puesto; si no, cambia al directorio especificado por C&lt;$ENV{LOGDIR}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is 
omitted, it stats C&lt;$_&gt; (not C&lt;_&gt;!).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015054Z" changeid="explorer">
        <seg>Si EXPR se omite, se hace el stat de C&lt;$_&gt; (¡no de C&lt;_&gt;!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number 0, the strings C&lt;'0'&gt; and C&lt;''&gt;, the empty list C&lt;()&gt;, and
C&lt;undef&gt; are all false in a boolean context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número 0, las cadenas C&lt;'0'&gt; y C&lt;''&gt;, la cadena vacía C&lt;()&gt; y C&lt;undef&gt; son todos falsos en contexto booleano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hardly what
you had in mind unless you were aware of this feature of Perl 5.8.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T144011Z" changeid="explorer">
        <seg>Difícilmente se acordaría de ello a menos que fuera consciente de esta característica de Perl 5.8.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#foo];	# slice last 5 items</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#foo];	# trocea los últimos 5 elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After configuration is done correctly give &quot;make&quot; to compile.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Después de la configuración haya terminado, se puede hacer un &quot;make&quot; para compilar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m m ^ a \s* b mmx;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>m m ^ a \s* b mmx;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use 5.006_001;  # ditto; preferred for backwards compatibility</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use 5.006_001;  # ídem; preferido para mantener la compatibilidad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any element of LIST is an lvalue, you can modify it by modifying
VAR inside the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si cualquier elemento de LISTA es un I&lt;lvalue&gt; (un valor que puede ponerse en el lado izquierdo de una expresión de asignación), puede modificarlo, modificando VAR dentro del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>W  An unsigned char value (can be greater than 255).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>W  Un valor de un carácter sin signo (puede ser mayor de 255).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now F&lt;malloc.h&gt; is not used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T183144Z" changeid="explorer">
        <seg>Ahora ya no se utiliza F&lt;malloc.h&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>d	Delete found but unreplaced characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>d	Elimina los caracteres que se encuentren pero que no hayan sido reemplazados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map { +&quot;\L$_&quot; =&gt; 1  } @array  # perl guesses BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map { +&quot;\L$_&quot; =&gt; 1  } @array  # perl lee bien el BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE
before locking or unlocking it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010527Z" changeid="explorer">
        <seg>Para evitar la posibilidad de descoordinación, Perl ahora vacía el IDENTIFICADOR_ARCHIVO antes de bloquearlo o desbloquearlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@data) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>for (@data) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item -X EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># now process $_</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ahora, procesa $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (--$i) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225556Z" changeid="explorer">
        <seg>while (--$i) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perliol&gt; for detailed info on PerlIO.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perliol&gt; para información detallada sobre PerlIO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with 5.9.4, they'll be always loaded if
they exist.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T235806Z" changeid="explorer">
        <seg>A partir de 5.9.4, siempre serán cargados, si existen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, each execution of C&lt;m//g&gt; finds the next match,
returning true if it matches, and false if there is no further match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, cada ejecución de C&lt;m//g&gt; encuentra la siguiente coincidencia, devolviendo verdadero si coincide, y falso si no hay ninguna coincidencia más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by James Lee</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003330Z" changeid="explorer">
        <seg>James Lee</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you really want to 
write these, include them as sub-documents such as C&lt;My::Module::Tutorial&gt; or
C&lt;My::Module::FAQ&gt; and provide a link in the SEE ALSO section of the
main documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215955Z" changeid="explorer">
        <seg>Si realmente quieres escribirlos, inclúyalos como sub-documentos, tales como C&lt;My::Module::Tutorial&gt; o C&lt;My::Module::FAQ&gt; y proporcione un enlace en la sección VEA TAMBIÉN de la documentación principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map { (&quot;\L$_&quot; =&gt; 1) } @array  # this also works</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map { (&quot;\L$_&quot; =&gt; 1) } @array  # esto también funciona</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;BEGIN&gt; forces the C&lt;require&gt; and C&lt;import&gt; to happen at compile time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;BEGIN&gt; fuerza a ejecutar a C&lt;require&gt; e C&lt;import&gt; en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These new warnings are now emitted when a dirhandle is used but is
either closed or not really a dirhandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040917Z" changeid="explorer">
        <seg>Estas nuevas advertencias son ahora emitidas cuando un identificador de directorio que es usado ya está cerrado o no es realmente un identificador de directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exec LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exec LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $1 while /(p)/gc; print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $1 while /(p)/gc; print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ARRAY[++$#ARRAY] = $value;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ARRAY[++$#ARRAY] = $valor;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Leading whitespace is ignored in all three cases.)
The following will handle decimal, binary, octal, and hex in standard
Perl notation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco que le rodea es ignorado en los tres casos). Lo que le sigue se interpretará como un decimal, binario, octal y hexadecimal en la notación estándar de Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pragma/warnings             333    1   0.30%  215</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pragma/warnings             333    1   0.30%  215</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 13452</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 13452</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must ensure your strings don't exceed this
limit after any necessary interpolations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debe asegurarse de que sus cadenas de texto no superan ese límite después de cualquier necesaria interpolación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FETCH this,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FETCH este,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = &quot;0644&quot;; chmod oct($mode), &quot;foo&quot;; # this is better</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = &quot;0644&quot;; chmod oct($modo), &quot;foo&quot;; # este es mejor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this is not true of lists, which return
the last value, like the C comma operator, nor of built-in functions,
which return whatever they feel like returning.)  The following is
always true:
X&lt;array, length&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T213527Z" changeid="explorer">
        <seg>(Note que esto no es cierto para las listas, que devuelven el último valor, como el operador coma de C, y tampoco para las funciones integradas, que devuelven lo que les parezca mejor devolver). Lo siguiente es siempre verdadero:
X&lt;array, length&gt; X&lt;array, longitud&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful with sockets when you want to tell the other
side you're done writing but not done reading, or vice versa.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil con sockets cuando desee decirle al otro lado que ha terminado de escribir, pero no ha terminado la lectura, o viceversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getgrent();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$name  = getgrent();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;The price is $Price.\n&quot;;	# interpolated</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El precio es $Precio.\n&quot;;  # interpolado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return print(reverse(sort num (values(%array))));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return print(reverse(sort num (values(%array))));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@many =  glob &quot;{apple,tomato,cherry}={green,yellow,red}&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@muchos =  glob &quot;{manzana,tomate,cereza}={verde,amarilla,roja}&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/do&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlfunc/do&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These routines are the same as their counterparts in the
system C library.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas rutinas son las mismas que sus homólogas en la biblioteca del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Term::ANSIcolor</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015321Z" changeid="explorer">
        <seg>=item Term::ANSIcolor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In those cases the value of EXPR is used directly as a boolean.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estos casos el valor de EXPR es usado directamente como un booleano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Perl doesn't look
ahead for the closing C&lt;}&gt; it has to take a guess at which it's dealing with
based on what it finds just after the C&lt;{&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que Perl no mira por adelantado por el cierre C&lt;}&gt;, tiene que hacer una conjetura por la que tiene que lidiar en base a lo que encuentra justo después de la &lt;C{&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wh.space</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224242Z" changeid="explorer">
        <seg>espacios en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative, overloaded constants (see L&lt;overload&gt;) provide a simple
way to extend the functionality of the RE engine, by substituting one
pattern for another.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001237Z" changeid="explorer">
        <seg>Como alternativa, las constantes sobrecargadas (vea L&lt;overload&gt;) proporcionan una manera sencilla de extender la funcionalidad del motor de RE, mediante la sustitución de un patrón por otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please only use this address for security issues in the Perl core, not
for modules independently distributed on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052919Z" changeid="explorer">
        <seg>Por favor, utilice sólo esta dirección para problemas de seguridad en el núcleo de Perl, no para los módulos distribuidos de forma independiente en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's why it's common practice to include
alternatives in parentheses: to minimize confusion about where they
start and end.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T223445Z" changeid="explorer">
        <seg>Es por eso que es una práctica común incluir las alternativas entre paréntesis: para minimizar la confusión acerca de dónde empiezan y terminan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;~~&gt; will now refuse to work on objects that do not overload it (in order
to avoid relying on the object's underlying structure).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T185000Z" changeid="explorer">
        <seg>C&lt;~~&gt; rechazará funcionar en objetos que no lo sobrecarguen (para no depender de la estructura subyacente del objeto)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closing a pipe also waits for the process executing
on the pipe to exit--in case you wish to look at the output of the pipe
afterwards--and implicitly puts the exit status value of that command into
C&lt;$?&gt; and C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El proceso de cierre de una tubería también espera por el proceso de ejecución en la tubería antes de salir -en caso de que desee ver después la salida de la tubería- e, implícitamente, pone el valor de estado de salida de ese comando en C&lt;$?&gt; y C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Test::Simple&gt; upgraded to version 0.62 (was 0.54)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035914Z" changeid="explorer">
        <seg>C&lt;Test::Simple&gt; actualizado a la versión 0.62 (era 0.54)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Calling CORE::require()</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035007Z" changeid="explorer">
        <seg>=head2 Llamando a CORE::require()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@fruits) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234500Z" changeid="explorer">
        <seg>foreach (@frutas) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Can do.\n&quot; if -r $a || -w _ || -x _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Puedo hacerlo.\n&quot; if -r $a || -w _ || -x _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># expand tabs to 8-column spacing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># expandir tabuladores a un espaciado de 8 columnas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;-T&gt; and C&lt;-B&gt; switches work as follows.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las opciones C&lt;-T&gt; y C&lt;-B&gt; funcionan como sigue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When presented with something that might have several different
interpretations, Perl uses the B&lt;DWIM&gt; (that's &quot;Do What I Mean&quot;)
principle to pick the most probable interpretation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se le presenta algo que podría tener varias interpretaciones diferentes, Perl utiliza el B&lt;DWIM&gt; (&quot;I&lt;Do What I Mean&gt;&quot;, es decir, &quot;hacer lo que quiero decir&quot;) para escoger la interpretación más probable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upgraded from version 1.04 to 1.05.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003504Z" changeid="explorer">
        <seg>Actualizado desde la versión 1.04 a la 1.05.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;continue&gt; block, if any, is I&lt;not&gt; executed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bloque C&lt;continue&gt;, si está, no es ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it does not change
semantics, details of this step are not documented and are subject
to change without notice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ya que no cambia la semántica, los detalles de este paso no están documentados y están sujetas a cambios sin previo aviso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Formats</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Formatos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Parsing of C&lt;-f _&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T191557Z" changeid="explorer">
        <seg>=head2 Análisis de C&lt;-f _&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when ([qw(foo bar)] &amp;&amp; /baz/) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T214944Z" changeid="explorer">
        <seg>when ([qw(foo bar)] &amp;&amp; /baz/) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Parallel tests</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T001337Z" changeid="explorer">
        <seg>=head2 Pruebas en paralelo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An exception to this is that you may assign to C&lt;undef&gt; in a list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T004414Z" changeid="explorer">
        <seg>Una excepción a esto es que puede asignar C&lt;undef&gt; en una lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in the example above, the final
C&lt;print $y&gt; would cause a compile-time error and prevent you from
running the program.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225058Z" changeid="explorer">
        <seg>Así, en el ejemplo anterior, la última instrucción C&lt;print $y&gt; provocará una error en tiempo de compilación que impedirá la ejecución del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash entries are returned in an apparently random order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las entradas de un hash son devueltas en un aparente orden aleatorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Using Perl modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230900Z" changeid="zipf">
        <seg>=head2 Utilización de módulos de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/Warning on \1 Instead of $1&gt; below for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T191239Z" changeid="explorer">
        <seg>Vea L&lt;/Advertencia de \1 en lugar de $1&gt; abajo para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SALT used
to create the digest is visible as part of the digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El SALTO usado para crear el I&lt;digest&gt; es visible como parte del I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For different
quoting constructs, Perl performs different numbers of passes, from
one to four, but these passes are always performed in the same order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para diferentes construcciones de entrecomillado, Perl realiza diferentes números de pases, de uno a cuatro, pero estos pases se realizan siempre en el mismo orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The sheet</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 La hoja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$fruit_color{&quot;apple&quot;};           # gives &quot;red&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025842Z" changeid="explorer">
        <seg>$color_fruta{&quot;manzana&quot;};         # devuelve &quot;rojo&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, change &quot;.&quot; to match any character
whatsoever, even a newline, which normally it would not match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, cambia &quot;.&quot; para que coincida con cualquier carácter, incluso el de nueva línea, que normalmente no coincidiría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;The animal is $animal\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T231001Z" changeid="zipf">
        <seg>print &quot;El animal es $animal\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 More Unicode Fixes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035552Z" changeid="explorer">
        <seg>=head2 Más correcciones Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function implementing the C&lt;qx/EXPR/&gt;
operator, but you can use it directly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es la función interna que implementa el operador C&lt;qx/EXPR/&gt;, pero puede usarla directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = (($foo,$bar) = (3,2,1));       # set $x to 3, not 2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035738Z" changeid="explorer">
        <seg>$x = (($foo,$bar) = (3,2,1));       # pone $x a 3, no 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array   CodeRef   sub truth for each elt[1] !grep { !$b-&gt;($_) } @$a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Array       RefCódigo  sub verdad por cada elemento[1]  !grep { !$b-&gt;($_) } @$a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next LINE if /^#/;	# discard comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next LINEA if /^#/;	# descartar los comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This isn't a particularly good seed, so many old
programs supply their own seed value (often C&lt;time ^ $$&gt; or C&lt;time ^
($$ + ($$ &lt;&lt; 15))&gt;), but that isn't necessary any more.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto no es una buena semilla, por lo que demasiados viejos programas tienen sus propias semillas (a menudo C&lt;time ^ $$&gt; o C&lt;time ^ ($$ + ($$ &lt;&lt; 15))&gt;), pero esto ya no es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The way C&lt;study&gt; works is this: a linked list of every
character in the string to be searched is made, so we know, for
example, where all the C&lt;'k'&gt; characters are.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(La forma en que C&lt;study&gt; funciona es la siguiente: se crea una lista enlazada de todos los caracteres en la cadena que se deben buscar, así sabremos, por ejemplo, donde están todos los caracteres C&lt;'k'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = chmod 0755, &quot;foo&quot;, &quot;bar&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = chmod 0755, &quot;foo&quot;, &quot;bar&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are suspected to be compiler errors (at least the shuffle.t
failure is known from some IRIX 6 setups) and math library errors
(the Trig.t failure), but since IRIX 5 is long since end-of-lifed,
further fixes for the IRIX are unlikely.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T002215Z" changeid="explorer">
        <seg>Son sospechosos de ser errores del compilador (por lo menos, del error de shuffle.t se sabe de algunos IRIX seis configuraciones) y los errores de la biblioteca matemática (el error de Trig.t), pero como IRIX 5 está desde hace mucho tiempo al final de su vida, son poco probables los arreglos de errores para el IRIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
used to report whether memory for that aggregate had ever been
allocated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T154228Z" changeid="explorer">
        <seg>Se usó para informar si la memoria para los datos agregados había sido reservada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use C&lt;no&gt; followed by a version number to specify that you
want to use a version of perl older than the specified one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200138Z" changeid="explorer">
        <seg>Ahora puede utilizar C&lt;no&gt; seguido por un número de versión para especificar que desea utilizar una versión de Perl más vieja que la especificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5111delta	Perl changes in version 5.11.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5111delta	Cambios en la versión 5.11.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;f&quot;)[$num &amp; 15];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224417Z" changeid="explorer">
        <seg>&quot;f&quot;)[$numero &amp; 15];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $oops = substr $name, 7;      # returns undef, with warning</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $oops = substr $nombre, 7;     # devuelve undef, con advertencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a, $b, $c) = (1, 2, 3);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a, $b, $c) = (1, 2, 3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other layers that would affect the binary nature of the stream are
I&lt;also&gt; disabled.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-- otras capas que pudieran afectar la naturaleza binaria del flujo son I&lt;también&gt; desactivadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at foo bar line 200.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at foo bar line 200.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then any bareword that would NOT be interpreted as a subroutine call
produces a compile-time error instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>entonces cualquier palabra suelta que NO pueda ser interpretada como una llamada de subrutina, produce en su lugar un error en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effect the &quot;o&quot;
modifier has is not propagated, being restricted to those patterns
explicitly using it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T024649Z" changeid="explorer">
        <seg>El efecto del modificador &quot;o&quot; no es propagado, se limita a los patrones que lo utilicen de forma explícita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::String           treat string sequences like numbers</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035338Z" changeid="explorer">
        <seg>Math::String			trata secuencias de cadenas como números</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>admin($_)   when [ qw/Alice Bob/ ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>admin($_)  when [ qw/Alice Bob/ ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context it evaluates
its left argument, throws that value away, then evaluates its right
argument and returns that value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar evalúa su argumento de la izquierda, descarta este valor, y luego evalúa su argumento de la derecha y devuelve este valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @{$ref-&gt;[$x][$y]}{$key1, $key2, @morekeys};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @{$ref-&gt;[$x][$y]}{$clave1, $clave2, @masclaves};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FETCHSIZE this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FETCHSIZE este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 2   ==          2 01000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because patterns are processed as double-quoted strings, the following
also work:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043258Z" changeid="explorer">
        <seg>Dado que los patrones son procesados como cadenas doblemente entrecomilladas, lo que sigue también funciona:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>next LINE if (1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>next LINEA if (1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cost = &lt;&lt;\VISTA;   # Same thing!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T032852Z" changeid="explorer">
        <seg>$cost = &lt;&lt;\VISTA;   # ¡Lo mismo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;local&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;local&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>end (before \n) /m line based ^$</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224233Z" changeid="explorer">
        <seg>cadena (antes \n)    /m basado en líneas ^$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a close-on-exec flag on files, that flag is set
on all newly opened file descriptors whose C&lt;fileno&gt;s are I&lt;higher&gt; than 
the current value of $^F (by default 2 for C&lt;STDERR&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En los sistemas que soportan las banderas cerrado-en-ejecución en los archivos, esas banderas se encuentran en todos los nuevos descriptores de archivos abiertos cuyo C&lt;fileno&gt; sean más I&lt;altos&gt; que el valor actual de $^F (por defecto 2 para C&lt;STDERR&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the argument before the ? is true, the
argument before the : is returned, otherwise the argument after the :
is returned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053827Z" changeid="explorer">
        <seg>Si el argumento anterior al ? es verdadero, se devuelve el argumento anterior al &quot;:&quot;; de lo contrario se devuelve el argumento posterior a &quot;:&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stat($filename);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>stat($nombre_de_archivo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;{&gt; starts both hash references and blocks, so C&lt;map { ...&gt; could be either
the start of map BLOCK LIST or map EXPR, LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;{&gt; comienza tanto una referencia a hash como bloques, por lo que C&lt;map { ...&gt; podría ser tanto el comienzo de map BLOQUE LISTA o map EXPR, LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the
Perl Mongers website ( http://www.pm.org/ ) for more information about
joining, starting, or requesting services for a Perl user group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231400Z" changeid="explorer">
        <seg>Visite el sitio web de Perl Mongers ( http://www.pm.org/ ) para obtener más información sobre servicios relacionados con los grupos de usuarios de Perl: cómo unirse a un grupo, cómo iniciar un grupo o cómo solicitar servicios para un grupo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line, it must also be used on the command line</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212505Z" changeid="explorer">
        <seg>línea, también debe estar en la línea de comandos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When under C&lt;use filetest 'access'&gt; the above-mentioned filetests
test whether the permission can(not) be granted using the
access(2) family of system calls.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152829Z" changeid="explorer">
        <seg>Cuando esté bajo C&lt;use filetest 'access'&gt;, las comprobaciones de archivo mencionadas antes comprobarán cuándo los permisos pueden (o no) ser concedidos usando la familia de llamadas del sistema access(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $success = 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $exito = 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item binmode FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004731Z" changeid="explorer">
        <seg>=item binmode IDENTIFICADOR_ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc&gt; for an example of socketpair use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc&gt; para un ejemplo de uso de socketpair.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlglossary - Perl Glossary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlglossary	- Glosario Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?{ code })&gt;
X&lt;(?{})&gt; X&lt;regex, code in&gt; X&lt;regexp, code in&gt; X&lt;regular expression, code in&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T215243Z" changeid="explorer">
        <seg>=item C&lt;(?{ código })&gt;
X&lt;(?{})&gt; X&lt;regex, código interior&gt; X&lt;regexp, código interior&gt; X&lt;expresión regular, código interior&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So for example, C&lt;~&quot;\x{3B1}&quot;&gt; is C&lt;&quot;\x{FFFF_FC4E}&quot;&gt; on
32-bit machines and C&lt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&gt; on 64-bit machines.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224251Z" changeid="explorer">
        <seg>Así, por ejemplo, C&lt;~&quot;\x{3B1}&quot;&gt; es C&lt;&quot;\x{FFFF_FC4E}&quot;&gt; en máquinas de 32 bits y C&lt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&gt; en máquinas de 64 bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If BITS is 16 or more, bytes of the input string are grouped into chunks
of size BITS/8, and each group is converted to a number as with
pack()/unpack() with big-endian formats C&lt;n&gt;/C&lt;N&gt; (and analogously
for BITS==64).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si BITS es de 16 o más, los bytes de la cadena de entrada se agrupan en bloques de tamaño BITS/8, y cada grupo es convertido a un número como con pack()/unpack() con formatos big-endian C&lt;n&gt;/C&lt;N&gt; (Y, análogamente para BITS==64).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backtracking is often optimized
internally, but the general principle outlined here is valid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T145348Z" changeid="explorer">
        <seg>La vuelta atrás es a menudo optimizada internamente, pero estos principios generales siguen siendo válidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no string is specified via the C&lt;=~&gt; or C&lt;!~&gt; operator, the C&lt;$_&gt;
variable is searched and modified.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se especifica una cadena a través de los operadores C&lt;=~&gt; o C&lt;!~&gt;, se utiliza la variable C&lt;$_&gt; para la búsqueda y la modificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's
cleaner because it's less noisy.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más limpio porque es menos ruidoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also shift operations internally use
signed integers rather than the default unsigned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234051Z" changeid="explorer">
        <seg>Además, las operaciones de desplazamiento usan internamente enteros con signo en lugar de los enteros sin signo predeterminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%+d&gt;',  12;   # prints &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%+d&gt;',  12;   # imprime &quot;&lt;+12&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns like C&lt;ioctl&gt;:
the undefined value for error, &quot;C&lt;0 but true&gt;&quot; for zero, or the actual
return value otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve lo mismo que C&lt;ioctl&gt;: el valor indefinido para error, C&lt;&quot;0 but true&quot;&gt; para el cero, o el valor de retorno real, en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 while foo();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 while foo();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;$hash{&quot;$foo/$bar&quot;}&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;$hash{&quot;$foo/$bar&quot;}&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;ptar&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013226Z" changeid="explorer">
        <seg>=head2 C&lt;ptar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.003 release (as
documented in I&lt;Programming Perl&gt;, second edition--the Camel Book) and
this one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe las diferencias entre la versión 5.003 (como se documenta en I&lt;Programming Perl&gt;, segunda edición - el libro del Dromedario) y ésta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You will not be required to justify it to the Copyright Holder, but
only to the computing community at large as a market that must bear the
fee.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(No se requerirá la justificación al Titular del Copyright, pero sólo a la comunidad informática en general como un mercado que debe tener la tasa).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a C&lt;&lt; while (&lt;&gt;) &gt;&gt; loop, C&lt;eof&gt; or C&lt;eof(ARGV)&gt; can be used to
detect the end of each file, whereas C&lt;eof()&gt; will detect the end 
of the very last file only.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T233203Z" changeid="explorer">
        <seg>En un bucle C&lt;&lt; while (&lt;&gt;) &gt;&gt;, C&lt;eof&gt; o C&lt;eof(ARGV)&gt; pueden usarse para detectar el fin de un archivo, mientras que C&lt;eof()&gt; sólo detectará el final del último archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is now known to build also in Hitachi HI-UXMPP.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T183225Z" changeid="explorer">
        <seg>Se sabe que Perl se compila también ahora en Hitachi HI-UXMPP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &lt;EXPR&gt; &gt;&gt;
operator is discussed in more detail in L&lt;perlop/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador C&lt;&lt; &lt;EXPR&gt; &gt;&gt; se discute con más detalle en L&lt;perlop/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 1   ==          1 10000000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La versión definida es simplemente una cadena de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$vec = '';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>$vec = '';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that code points
above 255 are treated as Unicode no matter what locale is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T165315Z" changeid="explorer">
        <seg>Esto significa que los puntos de código por encima de 255 se consideran como Unicode sin importar qué configuración regional esté en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Platform Specific Problems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Problemas en plataformas específicas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This unary
operator takes one argument, either a filename, a filehandle, or a dirhandle, 
and tests the associated file to see if something is true about it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004452Z" changeid="explorer">
        <seg>Este operador unario toma un argumento, bien sea un nombre de archivo o un identificador de archivo o de directorio, y comprueba si el archivo asociado para ver si algo sobre él es cierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -e &quot;print &lt;Ctrl-x&gt;&quot;Hello world\n&lt;Ctrl-x&gt;&quot;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225505Z" changeid="explorer">
        <seg>perl -e &quot;print &lt;Ctrl-x&gt;&quot;Hello world\n&lt;Ctrl-x&gt;&quot;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>setsockopt($socket, IPPROTO_TCP, TCP_NODELAY, 1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>setsockopt($socket, IPPROTO_TCP, TCP_NODELAY, 1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three forms: C&lt;goto&gt;-LABEL, C&lt;goto&gt;-EXPR, and
C&lt;goto&gt;-&amp;NAME.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existen tres formas: C&lt;goto&gt;-ETIQUETA, C&lt;goto&gt;-EXPR y C&lt;goto&gt;-&amp;NOMBRE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * http://perltraining.com.au/whyperl.html</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232551Z" changeid="explorer">
        <seg>=item * http://perltraining.com.au/whyperl.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, just because an operator lets you assume default arguments
doesn't mean that you have to make use of the defaults.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma similar, sólo porque un operador le permite asumir argumentos por defecto no significa que usted tenga que hacer uso de esos valores por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 sort() enhancements</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014028Z" changeid="explorer">
        <seg>=head2 Mejoras en sort()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is corrected in perl5.8.6.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212231Z" changeid="explorer">
        <seg>Esto se ha corregido en perl5.8.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until a release of these compilers is made, support for compiling Perl with
these compiler experimental.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hasta que una liberación de estos compiladores sea hecha, el soporte para la compilación de Perl con estas herramientas es experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello $_!\n&quot; foreach qw(world Dolly nurse);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Hola $_!\n&quot; foreach qw(mundo Dolly enfermera);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?+     Match 0 or 1 time and give nothing back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>?+     Coincide 0 o 1 veces y no devuelve nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># to the variable name, and then evaluated</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># al nombre de la variable, y entonces, evaluada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only resets variables or searches in the current package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo se restablecen variables o búsquedas en el paquete actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CPAN is a free service and is not affiliated with O'Reilly Media.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230209Z" changeid="explorer">
        <seg>CPAN es un servicio gratuito y no está afiliado a O'Reilly Media.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the books we've listed appear almost ancient in internet
scale, but we've included those books because they still describe the
current way of doing things.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003819Z" changeid="explorer">
        <seg>En la escala temporal de Internet, algunos de los libros de la lista parecen anticuados, pero los hemos incluido porque su contenido sigue siendo válido en la actualidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getc</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Attribute::Handlers&gt; upgraded to version 0.78_02</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T024000Z" changeid="explorer">
        <seg>C&lt;Attribute::Handlers&gt; actualizado a la versión 0.78_02</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| warn &quot;close failed: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T001001Z" changeid="explorer">
        <seg>|| warn &quot;close falló: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsyn - Perl syntax</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsyn - Sintaxis de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the terminating identifier is on the last line of the program, you
must be sure there is a newline after it; otherwise, Perl will give the
warning B&lt;Can't find string terminator &quot;END&quot; anywhere before EOF...&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el identificador de final está en la última línea del programa, debe asegurarse de que hay un carácter de nueva línea después de él; de lo contrario, Perl dará la advertencia B&lt;Can't find string terminator &quot;END&quot; anywhere before EOF...&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\n                  newline           (NL)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T190003Z" changeid="explorer">
        <seg>\n		nueva línea				(NL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A backreference matches whatever
actually matched the subpattern in the string being examined, not
the rules for that subpattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T224410Z" changeid="explorer">
        <seg>Una contrareferencia coincide con lo que en realidad coincidía con el subpatrón en la cadena examinada, no con las reglas de ese subpatrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This used to be a syntax error; a C&lt;&lt; -&gt; &gt;&gt; was required.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035308Z" changeid="explorer">
        <seg>Esto solía ser un error de sintaxis; se requería un C&lt;&lt; -&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filtering is achieved by modifying
the contents of C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110819T095732Z" changeid="zipf">
        <seg>El filtrado se realiza modificando el contenido de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Installing the built perl on UTS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Instalando la compilación de perl en UTS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or by using the C&lt;-E&gt; command-line switch in one-liners.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T000653Z" changeid="explorer">
        <seg>o mediante el uso de la opción de la línea de comandos C&lt;-E&gt; en los programas Perl de una-línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;&gt; symbol will return C&lt;undef&gt; for end-of-file only once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El símbolo &lt;&gt; devolverá C&lt;undef&gt; para el fin-de-archivo solo una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$Config{byteorder}\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$Config{byteorder}\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All functions that are capable of creating filehandles (open(),
opendir(), pipe(), socketpair(), sysopen(), socket(), and accept())
automatically create an anonymous filehandle if the handle passed to
them is an uninitialized scalar variable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T003811Z" changeid="explorer">
        <seg>Todas las funciones que son capaces de crear identificadores de archivo (open(), opendir(), pipe(), socketpair(), sysopen(), socket(), y accept()) crea automáticamente un identificador de archivo anónimo si el identificador que se les pasa es una variable escalar sin inicializar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>localtime( mktime( 0, 0, 0, 18, 11, 87 ) );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225522Z" changeid="explorer">
        <seg>localtime( mktime( 0, 0, 0, 18, 11, 87 ) );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're new to Perl, you should start by running C&lt;perldoc perlintro&gt;,
which is a general intro for beginners and provides some background to help
you navigate the rest of Perl's extensive documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000121Z" changeid="explorer">
        <seg>Si nunca ha programado en Perl, debe empezar por ejecutar C&lt;perldoc perlintro&gt; para leer una introducción general para principiantes y aprender a orientarse por la amplia documentación de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It bypasses buffered IO, so
mixing this with reads (other than C&lt;sysread())&gt;, C&lt;print&gt;, C&lt;write&gt;,
C&lt;seek&gt;, C&lt;tell&gt;, or C&lt;eof&gt; may cause confusion because the perlio and
stdio layers usually buffer data.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T023353Z" changeid="explorer">
        <seg>Omite E/S con búfer, por lo que mezclar esto con otros tipos de lecturas (distintas de C&lt;sysread()&gt;) como C&lt;print&gt;, C&lt;write&gt;, C&lt;seek&gt;, C&lt;tell&gt;, o C&lt;eof&gt; puede causar confusión porque las capas perlio y stdio, por lo general, usan búfer de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To see if you are in
this category, issue the command &quot;uname -a&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ver si está en esta categoría, ejecute el comando &quot;uname -a&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Incompatible Changes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Incompatibilidades</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;sendpath&quot; will have internal linkage.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003835Z" changeid="explorer">
        <seg>&quot;sendpath&quot; tendrá un enlazado interno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close OUTPUT                # wait for sort to finish</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close OUTPUT                # esperar que sort termine</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;\g&gt; and C&lt;\k&gt; notations were introduced in Perl 5.10.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T185002Z" changeid="explorer">
        <seg>Las notaciones C&lt;\g&gt; y C&lt;\k&gt; fueron introducidas en Perl 5.10.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; ge &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; ge &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;Operator precedence&gt; means some operators are evaluated before
others.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>I&lt;Precedencia de operadores&gt; significa que algunos operadores son evaluados antes que otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$user_rwx      = ($mode &amp; S_IRWXU) &gt;&gt; 6;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$usuario_rwx    = ($modo &amp; S_IRWXU) &gt;&gt; 6;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not rely
on it in security-sensitive situations.&gt;  As of this writing, a
number of third-party CPAN modules offer random number generators
intended by their authors to be cryptographically secure,
including: L&lt;Math::Random::Secure&gt;, L&lt;Math::Random::MT::Perl&gt;, and
L&lt;Math::TrulyRandom&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181141Z" changeid="explorer">
        <seg>No debe confiar en él en situaciones delicadas de seguridad.&gt; Al escribir estas líneas, una serie de módulos de CPAN de terceros ofrecen generadores de números aleatorios destinados, por sus autores, a ser criptográficamente seguros, incluyendo L&lt;Math::Random::Secure&gt;, L&lt;Math::Random::MT::Perl&gt;, y
L&lt;Math::TrulyRandom&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This might not seem important, but it is
important when you are capturing matched text using parentheses.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T223749Z" changeid="explorer">
        <seg>(Esto puede no parecer importante, pero es importante cuando se está capturando texto usando paréntesis.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*?)(\d+)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233802Z" changeid="explorer">
        <seg>(.*?)(\d+)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($y = 7; $y &lt; 13; $y++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052950Z" changeid="explorer">
        <seg>for ($y = 7; $y &lt; 13; $y++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;System returned %d\n&quot;, $retval;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Sistema devolvió %d\n&quot;, $retval;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, it doesn't think the C&lt;...&gt; is the whatever
because it's expecting an expression instead of a statement:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225845Z" changeid="explorer">
        <seg>En ese caso, Perl no cree que C&lt;...&gt; es el lo-que-sea porque está esperando una expresión en lugar de una instrucción:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a plain text file, try
http://www.cpan.org/misc/lwall-quotes.txt.gz .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232132Z" changeid="explorer">
        <seg>Si prefiere un archivo de texto simple, puede descargarlo desde 
http://www.cpan.org/misc/lwall-quotes.txt.gz .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a match has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the C&lt;$REGERROR&gt;
variable will be set to the name of the most recently executed
C&lt;(*MARK:NAME)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T140722Z" changeid="explorer">
        <seg>Cuando una coincidencia ha fallado, y a menos que otro verbo haya estado involucrado en el fallo de la coincidencia y ha dado su propio nombre para ser usado, la variable C&lt;$REGERROR&gt; será ajustada al nombre de C&lt;(*MARK:NOMBRE)&gt; más recientemente ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by brian d foy</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003353Z" changeid="explorer">
        <seg>brian d foy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $a;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $a;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>10) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those features, and the C&lt;feature&gt; pragma itself, have been contributed by
Robin Houston.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T193718Z" changeid="explorer">
        <seg>Estas características, y el mismo pragma C&lt;feature&gt;, han sido aportados por Robin Houston.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a C&lt;;&gt; inside your block to denote that the C&lt;{ ... }&gt; is
a block and not a hash reference constructor.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede utilizar un C&lt;;&gt; dentro del bloque para indicar que C&lt;{...}&gt; es un bloque y no un constructor de una referencia a un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;a14&quot;,&quot;abcdefg&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;a14&quot;,&quot;abcdefg&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a filehandle has been marked as to have an encoding, unmappable
characters are detected already during input, not later (when the
corrupted data is being used).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T172823Z" changeid="explorer">
        <seg>Si un identificador de archivo se ha marcado para tener una cierta codificación, los caracteres no traducibles son detectados en la entrada, no después (cuando los datos dañados se estén utilizando).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, decimal strings can represent only those numbers which have a
finite decimal expansion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232539Z" changeid="explorer">
        <seg>De manera similar, las cadenas decimales solo pueden representar números que tengan una expansión decimal finita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for most of these is a
pair of parentheses with a question mark as the first thing within
the parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T192152Z" changeid="explorer">
        <seg>La sintaxis, para la mayor parte de estos casos, es un par de paréntesis con un signo de interrogación como primer elemento dentro de los paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*?)(\d*)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233759Z" changeid="explorer">
        <seg>(.*?)(\d*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hash can be initialized using a literal list holding pairs of
items to be interpreted as a key and a value:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un hash puede ser inicializado con una lista literal que contenga pares de elementos que deben interpretarse como una clave y un valor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; lt &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; lt &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behaviour of a smart match depends on what type of thing its arguments
are.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento de una coincidencia inteligente depende del tipo de cosa que sean sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Splits the string EXPR into a list of strings and returns that list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Divide la cadena EXPR en una lista de cadenas y devuelve esa lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$child_pid = open(TO_KID,   &quot;|-&quot;) 	// die &quot;can't fork: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005848Z" changeid="explorer">
        <seg>$child_pid = open(AL_HIJO, &quot;|-&quot;)	// die &quot;no puedo hacer fork: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use C&lt;unless&gt; in place of C&lt;if&gt;,
the sense of the test is reversed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usa C&lt;unless&gt; en lugar de C&lt;if&gt;, el sentido del test se invierte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some contexts allow 2 or even 1 digit, but any usage without exactly
three digits, the first being a zero, may give unintended results.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T210158Z" changeid="explorer">
        <seg>Algunos contextos permiten dos o incluso un dígito, pero cualquier otro uso, sin exactamente tres dígitos, siendo el primero un cero, puede dar resultados inesperados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a known race condition opening scripts in C&lt;suidperl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay una conocida condición de carrera al abrir scripts con C&lt;suidperl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The 
C&lt;&lt; &lt;=&gt; &gt;&gt; and C&lt;cmp&gt; operators are extremely useful in such routines.)
SUBNAME may be a scalar variable name (unsubscripted), in which case
the value provides the name of (or a reference to) the actual
subroutine to use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Los operadores C&lt;&lt; &lt;=&gt; &gt;&gt; y C&lt;cmp&gt; son muy útiles en este tipo de rutinas). NOMBRE_SUB puede ser el nombre de una variable escalar, en cuyo caso el valor provee el nombre de (o la referencia a) la actual subrutina a usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Exceptions in constant folding</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T001110Z" changeid="explorer">
        <seg>=head2 Excepciones en el plegado de constantes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.perl.com/       Perl articles (O'Reilly)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001554Z" changeid="explorer">
        <seg>http://www.perl.com/       artículos sobre Perl (O'Reilly)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./Configure -de [-Dusedevel] [-Doptimize=-g ] 2&gt;&amp;1 | tee Conf.out</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214351Z" changeid="explorer">
        <seg>./Configure -de [-Dusedevel] [-Doptimize=-g ] 2&gt;&amp;1 | tee Conf.out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example at C&lt;readdir&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T174750Z" changeid="explorer">
        <seg>Vea el ejemplo en C&lt;readdir&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the GNU General Public License, see L&lt;perlgpl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215226Z" changeid="explorer">
        <seg>Para la Licencia General Pública GNU, vea L&lt;perlgpl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;my&gt; creates lexically
scoped variables instead.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225042Z" changeid="explorer">
        <seg>En cambio, C&lt;my&gt; crea variables dentro de un ámbito léxico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An OFFSET may be specified to place the read data at some place in the
string other than the beginning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DESPLAZAMIENTO puede ser especificado para colocar los datos leídos en algún otro lugar de la cadena distinto del principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be sure to trim your bug down to a
tiny but sufficient test case.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052826Z" changeid="explorer">
        <seg>Asegúrese de reducir la aparición del error en un programa que sea pequeño, pero suficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;CLONE_SKIP()&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T195024Z" changeid="explorer">
        <seg>=head2 C&lt;CLONE_SKIP()&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this document is intended to be useful to all module authors, it is
particularly aimed at authors who wish to publish their modules on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T012913Z" changeid="explorer">
        <seg>Aunque este documento está destinado a ser útil a todos los autores de módulos, está especialmente dirigido a autores que desean publicar sus módulos en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>comp.lang.perl.tk            Using Tk (and X) from Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230402Z" changeid="explorer">
        <seg>comp.lang.perl.tk            Uso de Tk (y X) en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 F&lt;ext/&gt; reorganisation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152929Z" changeid="explorer">
        <seg>=head2 Reorganización de F&lt;ext/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $some_condition = 1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181646Z" changeid="zipf">
        <seg>my $una_condicion = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item recv SOCKET,SCALAR,LENGTH,FLAGS
X&lt;recv&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194504Z" changeid="explorer">
        <seg>=item recv SOCKET,ESCALAR,LONGITUD,BANDERAS
X&lt;recv&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@stripped = map tr/a-zA-Z/ /csr, @original;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T214547Z" changeid="explorer">
        <seg>@limpiado = map tr/a-zA-Z/ /csr, @original;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, the use of C&lt;(*PRUNE)&gt; can be
replaced with a C&lt;&lt; (?&gt;pattern) &gt;&gt; with no functional difference; however,
C&lt;(*PRUNE)&gt; can be used to handle cases that cannot be expressed using a
C&lt;&lt; (?&gt;pattern) &gt;&gt; alone.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T010808Z" changeid="explorer">
        <seg>En algunos casos, el uso de C&lt;(*PRUNE)&gt; puede ser reemplazado con un C&lt;&lt; (?&gt;patrón) &gt;&gt; sin ninguna diferencia funcional; sin embargo, C&lt;(*PRUNE)&gt; puede ser usado para manejar casos que no pueden ser expresados usando un único C&lt;&lt; (?&gt;patrón) &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Hacking toolks and documentation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014758Z" changeid="explorer">
        <seg>=head2 Herramientas y documentación para «hackear»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the main point isn't whether the user typed B&lt;-v&gt; or not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>porque el objetivo principal no es si el usuario escribió B&lt;-v&gt; o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This change was done
mainly for faster startup times.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T190621Z" changeid="explorer">
        <seg>Este cambio se llevó a cabo principalmente por obtener tiempos de arranque más rápidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 ENVIRONMENT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 ENTORNO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>veryCompact =&gt; 1,  # if you want a bigger dump</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032253Z" changeid="explorer">
        <seg>veryCompact =&gt; 1,  # si quiere un volcado mayor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Z  A null-terminated (ASCIZ) string, will be null padded.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Z  Una cadena terminada en cero (ASCIZ), será rellenada con nulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you have can't handle C&lt;readline&gt; errors that way with the
C&lt;ARGV&gt; filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011746Z" changeid="explorer">
        <seg>Note que no puede manejar errores de C&lt;readline&gt; de esta manera con el identificador de archivo C&lt;ARGV&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort +find_records(@key);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort +busca_registros(@claves);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gentler messing with C&lt;Carp::&gt; internals</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041349Z" changeid="explorer">
        <seg>Ahora funciona caballerosamente con las funciones internas de C&lt;Carp::&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in slurp mode (C&lt;$/ = undef&gt;) or fixed-length record mode (C&lt;$/&gt; is
a reference to an integer or the like; see L&lt;perlvar&gt;) chomp() won't
remove anything.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T153713Z" changeid="explorer">
        <seg>En modo chupón (C&lt;$/ = undef&gt;) o en modo registros de longitud fija (C&lt;$/&gt; es una referencia a un entero o algo parecido; ver L&lt;perlvar&gt;) chomp() no elimina nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&quot;&quot;&gt;, C&lt;``&gt;, C&lt;qq//&gt;, C&lt;qx//&gt;, C&lt;&lt; &lt;file*glob&gt; &gt;&gt;, C&lt;&lt;&lt;&quot;EOF&quot;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item C&lt;&quot;&quot;&gt;, C&lt;``&gt;, C&lt;qq//&gt;, C&lt;qx//&gt;, C&lt;&lt; &lt;file*glob&gt; &gt;&gt;, C&lt;&lt;&lt;&quot;EOF&quot;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;\t elt $i is [ @{$AoA[$i]} ],&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031809Z" changeid="explorer">
        <seg>say &quot;\t elt $i is [ @{$AoA[$i]} ],&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 4) = 4   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 4) = 4   ==    4194304 00000000000000000000001000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $logmessage = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T212840Z" changeid="zipf">
        <seg>my $mensaje_registro = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Linchi Shea</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003503Z" changeid="explorer">
        <seg>Linchi Shea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $e;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $e;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many good books on Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230703Z" changeid="explorer">
        <seg>Se han publicado muchos libros buenos sobre Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>../lib/Math/Trig.t            255 65280    29   12  41.38%  24-29</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055023Z" changeid="explorer">
        <seg>../lib/Math/Trig.t            255 65280    29   12  41.38%  24-29</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will allow the user to specify an argument of the form C&lt;&quot;rsh cat file |&quot;&gt;,
but will not work on a filename that happens to have a trailing space, while</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>permitirá al usuario especificar un argumento de la forma C&lt;&quot;rsh cat archivo |&quot;&gt;, pero no funcionará en un nombre de archivo que tenga un espacio al final, mientras que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the system call specified as the first element of the list,
passing the remaining elements as arguments to the system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la llamada del sistema especificado en el primer elemento de la lista, pasando el resto de elementos como argumentos para la llamada al sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it will usually not work across file system
boundaries, even though the system I&lt;mv&gt; command sometimes compensates
for this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, normalmente no funcionará a través de los límites del sistema de archivos, a pesar de que el comando del sistema I&lt;mv&gt; a veces lo compense.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item int</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item int</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might notice several familiar Perl concepts in this collection of
ACM columns from Jon Bentley.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003717Z" changeid="explorer">
        <seg>Es posible que encuentre varios conceptos de Perl familiares en esta colección de artículos de la ACM escritos por Jon Bentley.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEEK this, position, whence</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SEEK este, posición, desde_donde</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the advice contained in this document has been gleaned from
extensive conversations with experienced CPAN authors and users.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013052Z" changeid="explorer">
        <seg>Todos los consejos que figuran en este documento ha sido obtenidos de largas conversaciones con autores experimentados CPAN y los usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certain Perl core C APIs like C&lt;Perl_list&gt; are no longer available
without their C&lt;Perl_&gt; prefix.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T001950Z" changeid="explorer">
        <seg>Ciertas API C del núcleo de Perl, como C&lt;Perl_list&gt; ya no están disponibles sin su prefijo C&lt;Perl_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr [\200-\377]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr [\200-\377]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is for clustering, not capturing; it groups subexpressions like
&quot;()&quot;, but doesn't make backreferences as &quot;()&quot; does.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232018Z" changeid="explorer">
        <seg>Este es para agrupación, no captura; agrupa subexpresiones como lo hace &quot;()&quot;, pero no crea contrareferencias como sí lo hace &quot;()&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current major release of Perl is Perl 5, and was first released in
1994.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004315Z" changeid="explorer">
        <seg>La versión principal actual de Perl es Perl 5, y se lanzó en 1994.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value for C&lt;atan2(0,0)&gt; is implementation-defined; consult
your atan2(3) manpage for more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165618Z" changeid="explorer">
        <seg>El valor de retorno para C&lt;atan2(0,0)&gt; depende de la implementación; consulte su página de manual de atan2(3) para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because now an
opcode, a basic unit of Perl execution, is never interrupted but
instead let to run to completion, certain operations that can take a
long time now really do take a long time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T152644Z" changeid="explorer">
        <seg>Porque ahora un código de operación, una unidad básica de ejecución Perl, nunca es interrumpida, sino que va a ejecutarse hasta el final; ciertas operaciones que pueden tomar mucho tiempo ahora realmente se toman un largo tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;eof&gt; X&lt;end-of-file&gt; X&lt;end of file&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;eof&gt; X&lt;end-of-file&gt; X&lt;fin de archivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = tr/0-9//;		# count the digits in $_</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = tr/0-9//;		# cuenta los dígitos en $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getting nothing but bug reports can become a bit demoralising:
we'll see if this changes things.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010903Z" changeid="explorer">
        <seg>No obtener nada más que informes de error puede ser algo desmoralizante: veremos si esto cambia las cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intent of this document is to state the conditions under which a
Package may be copied, such that the Copyright Holder maintains some
semblance of artistic control over the development of the package,
while giving the users of the package the right to use and distribute
the Package in a more-or-less customary fashion, plus the right to make
reasonable modifications.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La intención de este documento es establecer las condiciones en que un Paquete puede ser copiado, de manera que el Titular del Copyright mantiene una apariencia de control artístico sobre el desarrollo del paquete, mientras que dan a los usuarios del paquete el derecho a utilizar y distribuir el Paquete de una manera que sea más o menos habitual, además del derecho a hacer modificaciones razonables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(EXTRACT, &quot;|sort &gt;Tmp$$&quot;)            # $$ is our process id</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(EXTRACT, &quot;|sort &gt;Tmp$$&quot;)            # $$ es nuestro proceso id</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is not present, C&lt;$_&gt; is
checked.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR no está presente, se comprobará C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substr( $string, 13, 4 ) =  &quot;Perl 5.8.0&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225534Z" changeid="explorer">
        <seg>substr( $string, 13, 4 ) =  &quot;Perl 5.8.0&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;vec&gt; may also be assigned to, in which case parentheses are needed
to give the expression the correct precedence as in</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;vec&gt; también puede ser asignado, en cuyo caso los paréntesis son necesarios para dar a la expresión la correcta precedencia, como en</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned is either the empty string for
false, or a sequence number (beginning with 1) for true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto es una cadena vacía para falso, o un número de secuencia (empezando por 1) para verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned value is the
amount of time remaining on the previous timer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto es la cantidad de tiempo restante del temporizador anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc/&quot;Signals&quot;&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc/&quot;Señales&quot;&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also remember that &quot;|&quot; is interpreted as a literal within square brackets,
so if you write C&lt;[fee|fie|foe]&gt; you're really only matching C&lt;[feio|]&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T223910Z" changeid="explorer">
        <seg>También recuerde que &quot;|&quot; es interpretado como un literal cuando está entre corchetes, por lo que si usted escribe C&lt;[fee|fie|foe]&gt; realmente está solo buscando C&lt;[feio|]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, unlike C and Pascal, these are defined in terms of BLOCKs,
not statements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013307Z" changeid="explorer">
        <seg>Note que, a diferencia del C y Pascal, están definidas en términos de BLOQUES, no instrucciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run Perl with the B&lt;-w&gt; switch it can warn you about this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ejecuta Perl con la opción B&lt;-w&gt; le avisará sobre todo esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if all
platforms are using IEEE, there may still be subtle differences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso si todas las plataformas usan IEEE, todavía puede haber diferencias sutiles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The L&lt;crypt|/crypt&gt; function is unsuitable for hashing large quantities
of data, not least of all because you can't get the information
back.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función L&lt;crypt|/crypt&gt; no es apropiada para calcular el hash de grandes volúmenes de información, teniendo en cuenta que no es posible luego volver a obtener la misma información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dec = $vec-&gt;to_Dec();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225513Z" changeid="explorer">
        <seg>$dec = $vec-&gt;to_Dec();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any     CodeRef   scalar sub truth          $b-&gt;($a)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquiera  RefCódigo  escalar sub verdad               $b-&gt;($a)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Earlier versions of the strict pragma did not check the parameters
implicitly passed to its &quot;import&quot; (use) and &quot;unimport&quot; (no) routine.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T174723Z" changeid="explorer">
        <seg>Las versiones anteriores del pragma strict no comprobaban de forma implícita los parámetros pasados a sus rutinas &quot;import&quot; (use) y &quot;unimport&quot; (no).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provides Windows Vista support to C&lt;Win32::GetOSName&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041559Z" changeid="explorer">
        <seg>Proporciona soporte para C&lt;Win32::GetOSName&gt; en Windows Vista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;sort&gt; pragma is now lexically scoped.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192612Z" changeid="explorer">
        <seg>El pragma C&lt;sort&gt; tiene ahora un alcance léxico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 AVAILABILITY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 DISPONIBILIDAD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># force use of mergesort (not portable outside Perl 5.8)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># fuerza el uso del mergesort (no portátil fuera de Perl v5.8)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;   less than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;   menor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final element of a list assignment may be an array or a hash:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El elemento final de una asignación de lista puede ser un array o un hash:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rename OLDNAME,NEWNAME
X&lt;rename&gt; X&lt;move&gt; X&lt;mv&gt; X&lt;ren&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T194556Z" changeid="explorer">
        <seg>=item rename NOMBRE_VIEJO,NOMBRE_NUEVO
X&lt;rename&gt; X&lt;move&gt; X&lt;mv&gt; X&lt;ren&gt; X&lt;mover&gt; X&lt;renombra&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?^:pattern)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002553Z" changeid="explorer">
        <seg>(?^:patrón)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can refer to this document in Pod via &quot;L&lt;perlartistic&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacer referencia a este documento en Pod a través de &quot;L&lt;perlartistic&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$$r = 503;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T050829Z" changeid="explorer">
        <seg>$$r = 503;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Unicode&gt; is a character set with room for lots of characters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234301Z" changeid="explorer">
        <seg>B&lt;Unicode&gt; es un juego de caracteres en el que caben muchos caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until that is done, those modules should be
in F&lt;cpan/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014518Z" changeid="explorer">
        <seg>Mientras no se determine, estos módulos deben estar en F&lt;cpan/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $i;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>my $i;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&gt;&quot; returns true if the left argument is numerically greater
than the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&gt;&quot; devuelve verdadero si el argumento de la izquierda es numéricamente mayor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some might argue that one should go at these this way:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110220T235859Z" changeid="explorer">
        <seg>Some might argue that one should go at these this way:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 5, 1) = 1   ==         32 00000100000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 5, 1) = 1   ==         32 00000100000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Benchmark</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015220Z" changeid="explorer">
        <seg>=item Benchmark</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To encode,
you have to supply the target encoding, for example C&lt;iso-8859-1&gt; or C&lt;UTF-8&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234657Z" changeid="explorer">
        <seg>Al codificar debe especificar la codificación de destino (por ejemplo, C&lt;iso-8859-1&gt; o C&lt;UTF-8&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this filehandle must be a real filehandle (strictly a typeglob
or reference to a typeglob, whether blessed or unblessed); tied filehandles 
will be ignored and processing will stop there.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011735Z" changeid="explorer">
        <seg>Tenga en cuenta que este identificador de archivo debe ser un identificador de archivo real (en sentido estricto un C&lt;typeglob&gt; o una referencia a un C&lt;typeglob&gt;, bendecido o no); identificadores de archivo enlazados serán ignorados y el procesado terminará ahí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature has been fixed and
is also documented better.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T011257Z" changeid="explorer">
        <seg>Esta característica se ha fijado y está también mejor documentada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until
then, the use of sysopen(), sysread() and syswrite() is not supported
for &quot;text&quot; mode operations.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T002310Z" changeid="explorer">
        <seg>Hasta entonces, el uso de sysopen(), sysread() y syswrite() no está soportado para las operaciones en modo &quot;texto&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may mail your bug reports (be sure to include full configuration
information as output by the myconfig program in the perl source
tree, or by C&lt;perl -V&gt;) to perlbug@perl.org .  If you've succeeded
in compiling perl, the L&lt;perlbug&gt; script in the F&lt;utils/&gt; subdirectory
can be used to help mail in a bug report.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T142205Z" changeid="explorer">
        <seg>Puede enviar sus informes de errores (asegúrese de incluir la información de configuración completa, como la salida del programa myconfig, en el árbol de código fuente Perl, o con C&lt;perl -V&gt;) a perlbug@perl.org. Si ha tenido éxito compilando Perl, el script L&lt;perlbug&gt; en el subdirectorio F&lt;utils/&gt; se puede utilizar para enviar por correo electrónico un informe de los errores encontrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also cheaper not to capture
characters if you don't need to.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232244Z" changeid="explorer">
        <seg>También, es más barato no capturar caracteres si no son necesarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that it's more efficient and concise, keeps track of the current
filename for error messages, searches the C&lt;@INC&gt; directories, and updates
C&lt;%INC&gt; if the file is found.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T154620Z" changeid="explorer">
        <seg>excepto que es más eficiente y conciso, mantiene el nombre del archivo en los mensajes de error, busca en los directorios C&lt;@INC&gt; y actualiza C&lt;%INC&gt; si el archivo es encontrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being able
to use C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt; on floating-point values can be useful,
but also dangerous if you don't know exactly what you're doing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El ser capaz de usar C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt; en valores de punto flotante puede ser útil, pero también peligroso si no sabe exactamente lo que está haciendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules not available from CPAN</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030243Z" changeid="explorer">
        <seg>Módulos no disponibles en CPAN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item vec EXPR,OFFSET,BITS
X&lt;vec&gt; X&lt;bit&gt; X&lt;bit vector&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210839Z" changeid="explorer">
        <seg>=item vec EXPR,DESPLAZAMIENTO,BITS
X&lt;vec&gt; X&lt;bit&gt; X&lt;bit vector&gt; X&lt;vectores de bit&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The size specifier C&lt;V&gt; has no effect for Perl code, but is supported for
compatibility with XS code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La especificación de tamaño C&lt;V&gt; no tiene ningún efecto en el código Perl, pero se admite para la compatibilidad con el código XS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do {{</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do {{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Install all perl files:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Instalar todos los archivos de perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first section of this document provides an itemized checklist; 
subsequent sections provide a more detailed discussion of the items on 
the list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013236Z" changeid="explorer">
        <seg>La primera sección de este documento ofrece una lista detallada; las secciones siguientes proporcionan una descripción más detallada de los elementos de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Win32, VMS, S&lt;RISC OS&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014927Z" changeid="explorer">
        <seg>(Win32, VMS, S&lt;RISC OS&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En lugar de esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\d                  a digit (0-9)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230233Z" changeid="zipf">
        <seg>\d                  un dígito (0-9)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;use strict &quot;refs&quot;&gt; was ignoring taking a hard reference in an argument
to defined(), as in :</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T034824Z" changeid="explorer">
        <seg>C&lt;use strict &quot;refs&quot;&gt; hace caso omiso de una referencia dura en un argumento para defined(), como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it's expecting the beginning of a new statement, if the compiler
encounters a line that begins with an equal sign and a word, like this</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013603Z" changeid="explorer">
        <seg>Mientras que él espera el comienzo de una nueva instrucción, si el compilador encuentra una línea que comienza con un signo de igual y una palabra, como esta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>E.g., C&lt;$obj-E&lt;gt&gt;as_string()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ej., C&lt;$obj-E&lt;gt&gt;como_cadena()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a
hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Liga un archivo dbm(3), ndbm(3), sdbm(3), gdbm(3), o Berkeley DB a un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation typo fix</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Corrección de error tipográfico en la documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware, however, that in many
system users are able to change this information and therefore it
cannot be trusted and therefore the $gcos is tainted (see
L&lt;perlsec&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T162224Z" changeid="explorer">
        <seg>Tenga cuidado, sin embargo, que en muchos sistemas los usuarios son capaces de cambiar esta información y por eso no puede confiarse y por eso el $gcos es considerado como contaminado (ver L&lt;perlsec&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec ('foo')   or print STDERR &quot;couldn't exec foo: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec ('foo')   or print STDERR &quot;no puedo exec foo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Array Interpolation
X&lt;array, interpolation&gt; X&lt;interpolation, array&gt; X&lt;$&quot;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T145856Z" changeid="explorer">
        <seg>=head3 Interpolación de Array
X&lt;array, interpolation&gt; X&lt;interpolation, array&gt; X&lt;$&quot;&gt; X&lt;array, interpolación&gt; X&lt;interpolación, array&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Known Problems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Problemas conocidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item break</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item break</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are the
meanings of the fields:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí están los significados de los campos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(To be compatible with .Net regular expressions, C&lt;\g{I&lt;name&gt;}&gt; may
also be written as C&lt;\k{I&lt;name&gt;}&gt;, C&lt;\kE&lt;lt&gt;I&lt;name&gt;E&lt;gt&gt;&gt; or C&lt;\k'I&lt;name&gt;'&gt;.)
I&lt;name&gt; must not begin with a number, nor contain hyphens.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T141315Z" changeid="explorer">
        <seg>(Para ser compatible con las expresiones regulares .Net, C&lt;\g{I&lt;nombre&gt;}&gt; también se puede escribir como C&lt;\k{I&lt;nombre&gt;}&gt;, C&lt;\kE&lt;lt&gt;I&lt;nombre&gt;E&lt;gt&gt;&gt; o C&lt;\k'I&lt;nombre&gt;'&gt;.) I&lt;nombre&gt; no debe comenzar con un número, ni contener guiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the reverse, see L&lt;/chr&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215524Z" changeid="explorer">
        <seg>Para lo contrario, vea L&lt;/chr&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-M  Script start time minus file modification time, in days.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-M  Tiempo de arranque del script menos el tiempo de modificación del archivo, en días.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item hash</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114142Z" changeid="explorer">
        <seg>=item hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Win32, VMS, S&lt;RISC OS&gt;, VOS, VM/ESA)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015002Z" changeid="explorer">
        <seg>(Win32, VMS, S&lt;RISC OS&gt;, VOS, VM/ESA)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or later, and only with a C99 compiler (unportable)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181650Z" changeid="explorer">
        <seg>o superior, y solo con un compilador C99 (no portable)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently EXPR with the value C&lt;0&gt; is
also special-cased as C&lt;1&gt; (this was undocumented before Perl 5.8.0
and is subject to change in future versions of Perl).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Actualmente EXPR con el valor de C&lt;0&gt; es también un caso especial como el de C&lt;1&gt; (no estaba documentado esto antes de Perl 5.8.0
y está sujeto a cambios en futuras versiones de Perl).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pos SCALAR
X&lt;pos&gt; X&lt;match, position&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192708Z" changeid="explorer">
        <seg>=item pos ESCALAR
X&lt;pos&gt; X&lt;match, position&gt; X&lt;coincidencia, posición&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 More bugs</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Más errores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME
X&lt;function&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200823Z" changeid="explorer">
        <seg>=head1 NOMBRE
X&lt;function&gt; X&lt;función&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POP this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>POP este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike some other regular expression languages, there
are no backslashed symbols that aren't alphanumeric.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de algunos otros lenguajes de expresiones regulares, no hay símbolos escapados que no sean alfanuméricos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo =  150  | '105';	# yields 255</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo =  150  | '105';	# produce 255</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may, however, wish to treat a
string as a multi-line buffer, such that the &quot;^&quot; will match after any
newline within the string (except if the newline is the last character in
the string), and &quot;$&quot; will match before any newline.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110307T000852Z" changeid="explorer">
        <seg>Puede, sin embargo, desear tratar a la cadena como un búfer de varias líneas, de modo que &quot;^&quot; coincidirá después de cualquier carácter nueva línea dentro de la cadena (excepto si el nueva línea es el último carácter en la cadena), y &quot;$&quot; coincidirá delante de cualquier carácter nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} keys %hash;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225610Z" changeid="explorer">
        <seg>} keys %hash;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$url = URI::URL-&gt;new( &quot;http://example.com/&quot; ); die if $url eq &quot;xXx&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$url = URI::URL-&gt;new( &quot;http://ejemplo.com/&quot; ); die if $url eq &quot;xXx&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($pattern = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($patron = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;Yada Yada Operator&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T002956Z" changeid="explorer">
        <seg>Vea L&lt;perlop/&quot;Operador Blablablá&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Changed &quot;Invalid range &quot;%s&quot; in transliteration operator&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001923Z" changeid="explorer">
        <seg>=head2 Cambiado &quot;I&lt;Invalid range &quot;%s&quot; in transliteration operator&gt;&quot; (Rango &quot;%s&quot; inválido en el operador de transliteración)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Scalar value constructors
X&lt;scalar, literal&gt; X&lt;scalar, constant&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035340Z" changeid="explorer">
        <seg>=head2 Constructores de valores escalares
X&lt;scalar, literal&gt; X&lt;scalar, constant&gt; X&lt;escalar, literal&gt; X&lt;escalar, constante&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fork
X&lt;fork&gt; X&lt;child&gt; X&lt;parent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173401Z" changeid="explorer">
        <seg>=item fork
X&lt;fork&gt; X&lt;child&gt; X&lt;parent&gt; X&lt;hijo&gt; X&lt;padre&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can force Perl to skip the
test and never recompile by adding a C&lt;/o&gt; (which stands for &quot;once&quot;)
after the trailing delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T204003Z" changeid="explorer">
        <seg>Puede forzar a Perl para saltar el test y nunca volver a recompilar, mediante la adición de un C&lt;/o&gt; (que significa &quot;una vez&quot;) después del delimitador final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/usr/bin/uname &quot;$@&quot; | sed -e 's/^telcoUTS/uts/'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214113Z" changeid="explorer">
        <seg>/usr/bin/uname &quot;$@&quot; | sed -e 's/^telcoUTS/uts/'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>, =&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000529Z" changeid="explorer">
        <seg>, =&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, it returns a list of the
substrings matched by any capturing parentheses in the regular
expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, devuelve una lista de las subcadenas coincidentes con los paréntesis de captura de la expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a tiny change to this pattern</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T214439Z" changeid="explorer">
        <seg>Sin embargo, con un pequeño cambio en este patrón</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example if you have C&lt;qr/$a$b/&gt;, and C&lt;$a&gt;
contained C&lt;&quot;\g1&quot;&gt;, and C&lt;$b&gt; contained C&lt;&quot;37&quot;&gt;, you would get C&lt;/\g137/&gt; which
is probably not what you intended.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T184932Z" changeid="explorer">
        <seg>Por ejemplo, si tiene C&lt;qr/$a$b/&gt;, y C&lt;$a&gt; conteniendo C&lt;&quot;\g1&quot;&gt; y C&lt;$b&gt; conteniendo C&lt;&quot;37&quot;&gt;, obtendrá C&lt;\g137/&gt;, que, probablemente, no será lo que pretendía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's important you make sure to use the C&lt;[ ]&gt; array reference
constructor.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T025935Z" changeid="explorer">
        <seg>Es importante que esté seguro de que está utilizando el constructor de referencia a array C&lt;[]&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item values HASH
X&lt;values&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210806Z" changeid="explorer">
        <seg>=item values HASH
X&lt;values&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Look-around assertions are zero-width patterns which match a specific
pattern without including it in C&lt;$&amp;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T200546Z" changeid="explorer">
        <seg>Las aserciones cercanas (I&lt;Look-around assertions&gt;) son patrones de ancho cero que coinciden con un patrón específico sin incluirlo en C&lt;$&amp;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One example is templating systems, another is date and
time modules, and there are many more.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031244Z" changeid="explorer">
        <seg>Un ejemplo es el sistema de plantillas, otro son los módulos de fecha y hora, y hay muchos más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.1e&gt;', 10; # prints &quot;&lt;1.0e+01&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.1e&gt;', 10; # imprime &quot;&lt;1.0e+01&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use charnames ':full';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010100Z" changeid="explorer">
        <seg>use charnames ':full';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>subroutines can now be overridden, autoloaded, and prototyped</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001209Z" changeid="explorer">
        <seg>subrutinas que se pueden reemplazar, cargar automáticamente y prototipar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ( $code-&gt;(@_[@idx]) ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>while ( $code-&gt;(@_[@idx]) ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On VOS, time values are 32-bit quantities.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T212143Z" changeid="explorer">
        <seg>En VOS, los valores de tiempos son cantidades de 32 bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print reverse;                              # No output, list context</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print reverse;                              # No hay salida, contexto lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$vec = Bit::Vector-&gt;new_Dec(33, 3735928559);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225514Z" changeid="explorer">
        <seg>$vec = Bit::Vector-&gt;new_Dec(33, 3735928559);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opens the file whose filename is given by FILENAME, and associates it with
FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T020207Z" changeid="explorer">
        <seg>Abre el archivo cuyo nombre viene dado por ARCHIVO, y lo asocia con IDENTIFICADOR_ARCHIVO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raises an exception otherwise.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso contrario, se levanta una excepción).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also
means that recipients of the item may redistribute it under the same
conditions they received it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También significa que los destinatarios del elemento pueden redistribuirlo bajo las mismas condiciones que lo recibieron.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Intermediate Perl&gt; (the &quot;Alpaca Book&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003133Z" changeid="explorer">
        <seg>=item I&lt;Intermediate Perl&gt; (el &quot;Libro de la Alpaca&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># /r with map</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T214552Z" changeid="explorer">
        <seg># /r con map</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on formats, see L&lt;perlform&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215917Z" changeid="explorer">
        <seg>Para más información sobre formatos, vea L&lt;perlform&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11794</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11794</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather, it
matched something that happened to be zero characters long.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Más bien, ha coincidido con algo que parece tener cero caracteres de longitud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}} until $x++ &gt; $z;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>}} until $x++ &gt; $z;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then that text and all remaining text up through and including a line
beginning with C&lt;=cut&gt; will be ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entonces este texto y el siguiente hasta incluir una línea que comience por C&lt;=cut&gt; será ignorada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== 200) { print; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== 200) { print; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;cpan&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235024Z" changeid="explorer">
        <seg>=item L&lt;cpan&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eval</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eval</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Nagle's algorithm is turned &quot;, $nodelay ? &quot;off\n&quot; : &quot;on\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050138Z" changeid="explorer">
        <seg>print &quot;El algoritmo de Nagle está puesto a &quot;, $nodelay ? &quot;off\n&quot; : &quot;on\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this function actually
reads a character and then C&lt;ungetc&gt;s it, so isn't useful in an
interactive context.)  Do not read from a terminal file (or call
C&lt;eof(FILEHANDLE)&gt; on it) after end-of-file is reached.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005935Z" changeid="explorer">
        <seg>(Note que esta función realmente lee un carácter y luego hace un C&lt;ungetc&gt;, así que no es útil en un contexto interactivo). No lea de un archivo del que se ha llegado al final (o vuelva a llamar a C&lt;eof(IDENTIFICADOR_ARCHIVO)&gt; sobre él) después de haber alcanzado un fin-de-archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, C&lt;(0|0x)\d*\s\g1\d*&gt; will
match &quot;0x1234 0x4321&quot;, but not &quot;0x1234 01234&quot;, because subpattern
1 matched &quot;0x&quot;, even though the rule C&lt;0|0x&gt; could potentially match
the leading 0 in the second number.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T224658Z" changeid="explorer">
        <seg>Por lo tanto, C&lt;(0|0x)\d*\s\g1\d*&gt; coincidirá con &quot;0x1234 0x4321&quot;, pero no con &quot;0x1234 01234&quot;, debido a que el subpatrón primero coincidió con &quot;0x&quot;, incluso aunque la regla C&lt;0|0x&gt; podría coincidir con el 0 a la izquierda en el segundo número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus it can be used to
increment a loop variable, even when the loop has been continued via
the C&lt;next&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013420Z" changeid="explorer">
        <seg>Así, puede ser usada para incrementar una variable de bucle, incluso cuando el ciclo ha sido parado por medio de la instrucción C&lt;next&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get a list of anonymous hashes each with only one entry apiece.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para obtener una lista de hashes anónimos, cada uno con sólo una entrada cada uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for fixed-length data or records</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152202Z" changeid="explorer">
        <seg>=item Funciones para registros o datos de longitud fija</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl uses an internal type called a I&lt;typeglob&gt; to hold an entire
symbol table entry.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl utiliza un tipo interno que se llama I&lt;typeglob&gt; para mantener una entrada entera en la tabla de símbolos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hmm... here's the simple way:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194940Z" changeid="explorer">
        <seg>Hmm ... aquí está la forma más sencilla:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose an appropriate name</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013450Z" changeid="explorer">
        <seg>Elija un nombre apropiado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On many operating systems, the native text file
representation matches the internal representation, but on some
platforms the external representation of C&lt;\n&gt; is made up of more than
one character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En muchos sistemas operativos, la representación nativa de un archivo texto coincide con su representación interna, pero en algunas plataformas la representación externa de C&lt;\n&gt; se realiza con más de un carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item \G assertion</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Aserción \G</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>distribute a Standard Version of the executables and library files,
together with instructions (in the manual page or equivalent) on where
to get the Standard Version.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>distribuir una Versión Estándar de los ejecutables y archivos de biblioteca, junto con instrucciones (en página de manual o equivalente) sobre dónde obtener la Versión Estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 FreeBSD core dumps from readdir_r with ithreads</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 FreeBSD vuelca el núcleo desde readdir_r con ithreads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of these variables incurs no global performance penalty, unlike
their punctuation char equivalents, however at the trade-off that you
have to tell perl when you want to use them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de estas variables no incurre en penalización en el rendimiento global, a diferencia de sus equivalentes de caracteres de puntuación, pero sin embargo, tiene que decirle a perl cuándo desea utilizarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current nonsensical behaviour is always to return false,
regardless of whether the hash is empty or has elements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T002544Z" changeid="explorer">
        <seg>El comportamiento sin sentido actual siempre devolvía falso, independientemente de si el hash está vacío o si tiene elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getsockopt SOCKET,LEVEL,OPTNAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getsockopt SOCKET,NIVEL,OPCIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#ints ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225601Z" changeid="explorer">
        <seg>$#ints ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl 'SEEK_CUR';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl 'SEEK_CUR';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>../ext/List/Util/t/shuffle.t    0   139    ??</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055019Z" changeid="explorer">
        <seg>../ext/List/Util/t/shuffle.t    0   139    ??</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you really want to continue
using the 5.005 threads but not to see the deprecation warnings, use:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011407Z" changeid="explorer">
        <seg>Si realmente desea seguir utilizando los I&lt;threads&gt; 5.005 pero no quiere ver la advertencia de obsolescencia, utilice:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>split(/([,-])/, &quot;1-10,20&quot;, 3);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>split(/([,-])/, &quot;1-10,20&quot;, 3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in a
destructor of one object you cannot assume that objects of any other
class are still available, unless you hold a reference to them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135939Z" changeid="explorer">
        <seg>Por ejemplo, en un destructor de un objeto no puede asumir que los objetos de cualquier otra clase todavía están disponibles, a menos que mantenga una referencia a ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to Johan Vromans from Squirrel Consultancy.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235434Z" changeid="explorer">
        <seg>Deseo expresar mi agradecimiento a las siguientes personas: Johan Vromans de Squirrel Consultancy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a &quot;hints&quot; file for vmesa that specifies the correct values
for most things.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T101816Z" changeid="explorer">
        <seg>Hay un archivo &quot;hints&quot; (sugerencias) para vmesa que especifica los valores correctos para la mayoría de las cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\N{U+I&lt;hexadecimal number&gt;}&gt; means the Unicode character whose Unicode code
point is I&lt;hexadecimal number&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204356Z" changeid="explorer">
        <seg>C&lt;\N{U+I&lt;número hexadecimal&gt;}&gt; equivale al carácter Unicode cuyo código punto Unicode sea I&lt;número hexadecimal&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Defined\n&quot;   if defined $hash{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Definido\n&quot;  if defined $hash{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl doesn't officially have a no-op operator, but the bare constants
C&lt;0&gt; and C&lt;1&gt; are special-cased to not produce a warning in a void
context, so you can for example safely do</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl, oficialmente, no tiene un operador de no-operación, pero las constantes simples C&lt;0&gt; y C&lt;1&gt; son un caso especial, que no producen una advertencia en un contexto vacío, por lo que puede, por ejemplo, hacer de forma segura</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Nicholas Clark, Dave Mitchell)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112030Z" changeid="explorer">
        <seg>(Nicholas Clark, Dave Mitchell)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will use miniperl to complete the rest of the build.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto utilizará miniperl para completar el resto de la construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are introduced by a keyword which
the extension recognizes, and the syntax following the keyword is
defined entirely by the extension.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T212048Z" changeid="explorer">
        <seg>Son presentadas por una palabra clave que la extensión reconoce, y la sintaxis que le sigue se define enteramente por la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/g&gt; option is not used, C&lt;m//&gt; in list context returns a
list consisting of the subexpressions matched by the parentheses in the
pattern, i.e., (C&lt;$1&gt;, C&lt;$2&gt;, C&lt;$3&gt;...).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la opción C&lt;/g&gt; no se utiliza, C&lt;m//&gt; en contexto lista devuelve una lista compuesta de las subexpresiones coincidentes por los paréntesis en el patrón, es decir, (C&lt;$1&gt;, C&lt;$2&gt;, C&lt;$3&gt;...).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;NDBM_File&gt; upgraded to version 1.06</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033916Z" changeid="explorer">
        <seg>C&lt;NDBM_File&gt; actualizado a la versión 1.06</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\N{omega}&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;\N{omega}&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The usual C-style backslash rules apply for making
characters such as newline, tab, etc., as well as some more exotic
forms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las reglas normales de la barra invertida en el estilo del C se aplican para la creación de caracteres como el salto de línea, tabuladores, etc, así como algunas formas más exóticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 + 1, &quot;\n&quot;;    # Obviously not what you meant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 + 1, &quot;\n&quot;;    # Obviamente no es lo que quería decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is B&lt;not&gt; locking: exclusiveness means here that
if the file already exists, sysopen() fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto B&lt;no&gt; es bloquear: la exclusividad significa aquí que si el archivo ya existe, sysopen() falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If, however, the
variable has been used in only string contexts since it was set, and
has a value that is not the empty string and matches the pattern
C&lt;/^[a-zA-Z]*[0-9]*\z/&gt;, the increment is done as a string, preserving each
character within its range, with carry:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T010220Z" changeid="explorer">
        <seg>Sin embargo, si la variable se ha utilizado sólo en contextos de cadena desde que se creó, y tiene un valor que no es la cadena vacía y coincide con el patrón C&lt;/^[a-zA-Z]*[0-9]*\z/&gt;, el incremento se realiza como una cadena, conservando cada carácter dentro de su rango, conllevando a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tick        =&gt; q(&quot;),</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032210Z" changeid="explorer">
        <seg>tick        =&gt; q(&quot;),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 4) = 4   ==         64 00000010000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 4) = 4   ==         64 00000010000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;$&gt; or C&lt;@&gt; trigger interpolation, you'll need to use something
like C&lt;/\Quser\E\@\Qhost/&gt; to match them literally.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222652Z" changeid="explorer">
        <seg>Debido a que C&lt;$&gt; o C&lt;@&gt; disparan la interpolación, tendrá que usar algo como C&lt;/\Quser\E\@\Qhost/&gt; para coincidir con ellos literalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within any delimiters for such a
construct, allowed spaces are not affected by C&lt;/x&gt;, and depend on the
construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una construcción como esta, con cualquier tipo de delimitadores, los espacios permitidos no se verán afectados por C&lt;/x&gt;, y depende de la propia construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my (@length_content) = unpack &quot;(V/a)*&quot;, $binary;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234610Z" changeid="explorer">
        <seg>my (@contenido_longitud) = unpack &quot;(V/a)*&quot;, $binario;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If such scripts or library files are aggregated with this
Package via the so-called &quot;undump&quot; or &quot;unexec&quot; methods of producing a
binary executable image, then distribution of such an image shall
neither be construed as a distribution of this Package nor shall it
fall under the restrictions of Paragraphs 3 and 4, provided that you do
not represent such an executable image as a Standard Version of this
Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los scripts o archivos de biblioteca son agregados con este Paquete a través de los métodos &quot;undump&quot; o &quot;unexec&quot; para la producción de una imagen ejecutable binaria, entonces, la distribución de esta imagen no se interpretará como una distribución de este Paquete, ni caerá bajo las restricciones de los párrafos 3 y 4, siempre y cuando usted no intente representar que es una imagen ejecutable de una Versión Estándar de este Paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl was originally a language optimized for scanning arbitrary
text files, extracting information from those text files, and printing
reports based on that information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141536Z" changeid="explorer">
        <seg>Perl era un lenguaje optimizado para procesar archivos de texto, a fin de extraer información y utilizarla para generar informes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9 mtime    last modify time in seconds since the epoch</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>9 mtime    tiempo última modificación, en segundos desde el epoch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both C&lt;-T&gt; and C&lt;-B&gt; return true on an empty
file, or a file at EOF when testing a filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004626Z" changeid="explorer">
        <seg>Ambos, C&lt;-T&gt; y C&lt;-B&gt;, devuelven verdadero en un archivo vacío o en un archivo en el EOF (marca de fin de archivo) cuando se analiza un identificador de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CODE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CODE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Darwin&quot; =&gt; &quot;Charles&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;Darwin&quot; =&gt; &quot;Charles&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item last</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item last</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl582delta - what is new for perl v5.8.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl582delta - Qué hay de nuevo en perl v5.8.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %h = (&quot;FOO&quot;, 23);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my %h = (&quot;FOO&quot;, 23);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,18, 1) = 1   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,18, 1) = 1   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of the elementary pieces of regular expressions which were described
before (such as C&lt;ab&gt; or C&lt;\Z&gt;) could match at most one substring
at the given position of the input string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T233459Z" changeid="explorer">
        <seg>Cada una de las piezas elementales de las expresiones regulares que se ha descrito anteriormente (por ejemplo, C&lt;ab&gt; o C&lt;\Z&gt;) podría coincidir como mucho con una subcadena en la posición indicada de la cadena de entrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;-T&gt;
or C&lt;-B&gt; is used on a filehandle, the current IO buffer is examined
rather than the first block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004603Z" changeid="explorer">
        <seg>Si C&lt;-T&gt; o C&lt;-B&gt; se usan con un identificador de archivo, la memoria intermedia actual de IO es examinada en vez del primer bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has been corrected.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015445Z" changeid="explorer">
        <seg>Esto ha sido corregido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of running C&lt;make test&gt;, set C&lt;TEST_JOBS&gt; in
your environment to the number of tests to run in parallel, and run
C&lt;make test_harness&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T002128Z" changeid="explorer">
        <seg>En lugar de ejecutar C&lt;make test&gt;, ponga en su entorno la variable C&lt;TEST_JOBS&gt; al número de pruebas que se deben ejecutar en paralelo, y ejecute C&lt;make test_harness&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: If the filehandle is marked C&lt;:utf8&gt;, Unicode characters
encoded in UTF-8 are written instead of bytes, and the LENGTH, OFFSET, and
return value of syswrite() are in (UTF8-encoded Unicode) characters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T023512Z" changeid="explorer">
        <seg>B&lt;ADVERTENCIA&gt;: Si el identificador de archivo está marcado como C&lt;:utf8&gt;, caracteres Unicode codificados en UTF-8 son escritos en lugar de bytes, y la LONGITUD, DESPLAZAMIENTO y el valor de retorno de syswrite() estarán basados en caracteres (Unicode codificados en UTF-8).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any part of LIST is an array, C&lt;foreach&gt; will get very confused if
you add or remove elements within the loop body, for example with
C&lt;splice&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si cualquier parte de la LISTA es un array, C&lt;foreach&gt; quedará confundido si añade o quita elementos dentro del cuerpo del bucle, por ejemplo, al usar C&lt;splice&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;-E&gt; is equivalent to B&lt;-e&gt;, but it implicitly enables all
optional features (like C&lt;use feature &quot;:5.10&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200614Z" changeid="explorer">
        <seg>B&lt;-E&gt; es equivalente a B&lt;-e&gt;, pero implícitamente activa todas las características opcionales (igual que C&lt;use feature &quot;:5.10&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This prohibition interacts with backtracking (see L&lt;&quot;Backtracking&quot;&gt;),
and so the I&lt;second best&gt; match is chosen if the I&lt;best&gt; match is of
zero length.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T232503Z" changeid="explorer">
        <seg>Esta prohibición se relaciona con dar la marcha atrás (vea L&lt;&quot;Marcha atrás&quot;&gt;), por lo que la I&lt;segunda mejor&gt; coincidencia es elegida si la I&lt;mejor&gt; coincidencia es de longitud cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Selected Bug Fixes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Arreglo de determinados errores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item precision, or maximum width
X&lt;precision&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201218Z" changeid="explorer">
        <seg>=item precisión, o ancho máximo
X&lt;precision&gt; X&lt;precisión&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a (relatively expensive) work-around to compare
whether two floating-point numbers are equal to a particular number of
decimal places.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un (relativamente caro) ejemplo en torno a cómo comprobar si dos números de punto flotante son iguales en un determinado número de decimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array represents a list of values:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T231513Z" changeid="zipf">
        <seg>Un array representa una lista de valores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/&quot;Switch statements&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013110Z" changeid="explorer">
        <seg>Ver también L&lt;/&quot;Instrucciones Switch&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;The square of $answer is &quot;, $answer * $answer, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T001501Z" changeid="zipf">
        <seg>print &quot;El cuadrado de $respuesta es &quot;, $respuesta * $respuesta, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But that doesn't help you.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225814Z" changeid="explorer">
        <seg>Pero esto no le servirá de nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl operations which take a numeric argument treat that argument in one
of four different ways: they may force it to one of the integer/floating/
string formats, or they may behave differently depending on the format of
the operand.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232914Z" changeid="explorer">
        <seg>En Perl, las operaciones que consumen un argumento numérico tratan al argumento de una de cuatro maneras posibles: pueden forzar la conversión a uno de los formatos de entero/número de punto flotante/cadena, o pueden comportarse de una manera diferente en función del formato del operando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $foo eq $bar</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># $foo eq $bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Perl has many other internal
optimizations, but none would be triggered in the above example if
we did not use qr() operator.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Perl tiene otras muchas optimizaciones internas, pero ninguna será activada en el ejemplo anterior si no usamos el operador qr()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -le '$a = &quot;NaN&quot;; print &quot;No NaN support here&quot; if $a == $a'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl -le '$a = &quot;NaN&quot;; print &quot;No tiene soporte NaN&quot; if $a == $a'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value gives the name of the
actual filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T021047Z" changeid="explorer">
        <seg>IDENTIFICADOR_ARCHIVO puede ser una expresión cuyo valor da el nombre del identificador de archivo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or gripe(), next LINE;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or gripe(), next LINEA;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider changing your whole
world view.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere cambiar su punto de vista vital.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&amp;&quot; returns its operands ANDed together bit by bit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&amp;&quot; devuelve la operación AND, bit a bit, de sus operandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is
complicated by the need to cross compile.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es complicado, por la necesidad de hacer una compilación cruzada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consult the documentation that came with the module for
subscription information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230933Z" changeid="explorer">
        <seg>Consulte la documentación del módulo para averiguar qué tiene que hacer para suscribirse a su lista de correo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NAME needn't be the name of a subroutine; it can be a scalar variable
containing a code reference or a block that evaluates to a code
reference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T235749Z" changeid="explorer">
        <seg>NOMBRE no necesita ser el nombre de una subrutina; puede ser una variable escalar que contenga una referencia a un código o un bloque que evalúa a una referencia de código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some systems (in general, DOS- and Windows-based systems) binmode()
is necessary when you're not working with a text file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004916Z" changeid="explorer">
        <seg>En algunos sistemas (en general, sistemas basados en DOS y Windows) binmode() es necesario cuando no esté trabajando con un archivo de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A negative subscript retrieves its 
value from the end.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un subíndice negativo devuelve un valor a partir del final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support
symbolic links, raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En los sistemas que no admiten los enlaces simbólicos, produce una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPERATOR PRECEDENCE     =          =        perl.plover.com</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224159Z" changeid="explorer">
        <seg>PRIORIDAD OPERADORES      =          =           perl.plover.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%G    like %g, but with an upper-case &quot;E&quot; (if applicable)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%G    como %g, pero con una letra letra &quot;E&quot; mayúscula (si es aplicable)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while(readdir $dh) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while(readdir $dh) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item (R)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T194753Z" changeid="explorer">
        <seg>=item (R)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As
this could cause problems when C&lt;goto&gt; jumps were involved, this change
has been backed out.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044341Z" changeid="explorer">
        <seg>Ya que esto podría causar problemas cuando intervenían saltos C&lt;goto&gt;, este cambio ha sido deshecho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@pats = qw{</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233747Z" changeid="explorer">
        <seg>@patrones = qw{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a
zero-width pattern similar to C&lt;(*SKIP)&gt;, except that when backtracked
into on failure it causes the match to fail outright.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T141917Z" changeid="explorer">
        <seg>Es un patrón de ancho cero similar a C&lt;(*SKIP)&gt;, excepto que cuando ocurre la vuelta atrás a causa de un fallo hace que la coincidencia falle completamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalars, arrays and hashes are documented more fully in L&lt;perldata&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224945Z" changeid="explorer">
        <seg>Encontrará información detallada sobre los escalares, arrays y hashes en L&lt;perldata&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't just have to match on fixed strings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T234751Z" changeid="zipf">
        <seg>No tiene que limitarse a detectar coincidencias en cadenas fijas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local ${$x}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015153Z" changeid="explorer">
        <seg>local ${$x}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, returns the
total number of elements so generated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el número total de elementos generados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the normal array index looping, C&lt;for&gt; can lend itself
to many other interesting applications.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de recorrer los índices de los arrays, C&lt;for&gt; puede prestarse a otras interesantes aplicaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;STDIN&gt;) { print; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;STDIN&gt;) { print; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// die &quot;Can't open pipeline to lpr: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T234307Z" changeid="explorer">
        <seg>// die &quot;No puedo entubar hacia lpr: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Hello, world&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T233540Z" changeid="zipf">
        <seg>&quot;Hola a todos&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a beginning Perl programmer, your most common use of OO Perl will be
in using third-party modules, which are documented below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225546Z" changeid="explorer">
        <seg>La aplicación que suelen hacer los programadores principiantes de la programación orientada a objetos en Perl es la utilización de módulos de terceros, que se describe a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code will build up an ASCII string saying C&lt;'PerlPerlPerl'&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El código siguiente construirá una cadena ASCII diciendo C&lt;'PerlPerlPerl'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version control system used for the development of the perl
interpreter has been switched from Perforce to git.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190159Z" changeid="explorer">
        <seg>El sistema de control de versiones usado para el desarrollo del intérprete perl se ha cambiado de Perforce a git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($coderef, $filename) = @_;  # $coderef is \&amp;my_sub</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($coderef, $archivo) = @_;  # $coderef is \&amp;mi_sub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some functions appear in more
than one place.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas funciones aparecen en más de un lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>write;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>write;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 2) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 2) = 1   ==         16 00001000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, this sorts the LIST and returns the sorted list value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, ordena la LISTA y devuelve los valores de la lista ordenados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (EXPR) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (EXPR) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;/\w+(?=\t)/&gt;
matches a word followed by a tab, without including the tab in C&lt;$&amp;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T205945Z" changeid="explorer">
        <seg>Por ejemplo, C&lt;/\w+(?=\t)/&gt; coincide con una palabra seguida por un tabulador, sin incluir el tabulador en C&lt;$&amp;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596006396</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003459Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596006396</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose mnemonic identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elija identificadores mnemónicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a bunch of anything</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025510Z" changeid="explorer">
        <seg># un montón de nada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the case where some patterns want to be
case-sensitive and some do not:  The case-insensitive ones merely need to
include C&lt;(?i)&gt; at the front of the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T192334Z" changeid="explorer">
        <seg>Considere el caso de que algunos patrones quieren ser sensibles a las mayúsculas y otros no: para el caso de los patrones insensibles sólo necesita incluir C&lt;(?i)&gt; por delante del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/^\s*(.*?)\s*$/$1/;	# trim whitespace in $_, expensively</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/^\s*(.*?)\s*$/$1/;	# recorta el espacio en blanco en $_, de forma onerosa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perllexwarn 	Perl warnings and their control</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000312Z" changeid="explorer">
        <seg>perllexwarn 	Advertencias y control de advertencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The term &quot;native&quot; does not mean quite as much when we talk about native
integers, as it does when native floating point numbers are involved.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232445Z" changeid="explorer">
        <seg>En el caso de los enteros nativos, el término &quot;nativo&quot; no tiene las mismas implicaciones que para los números de punto flotante nativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item print FILEHANDLE LIST
X&lt;print&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011410Z" changeid="explorer">
        <seg>=item print IDENTIFICADOR_ARCHIVO LISTA
X&lt;print&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to cross-post
to alt.sources, please make sure it follows their posting standards,
including setting the Followup-To header line to NOT include alt.sources;
see their FAQ ( http://www.faqs.org/faqs/alt-sources-intro/ ) for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230646Z" changeid="explorer">
        <seg>Si desea publicarlo además en alt.sources, asegúrese de cumplir sus normas de publicación, como la de establecer una línea de encabezado de seguimiento que NO incluya alt.sources; consulte la sección de preguntas más frecuentes ( http://www.faqs.org/faqs/alt-sources-intro/ ) para obtener información detallada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File::Find could become confused when navigating to a relative
directory whose name collided with a logical name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000750Z" changeid="explorer">
        <seg>File::Find podría confundirse cuando se navega a un directorio de forma relativa cuyo nombre coincide con un nombre lógico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's safer because if code gets added
between the inner and outer loops later on, the new code won't be
accidentally executed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más seguro porque si se añade nuevo código entre los bucles interno y externo, ese nuevo código no será ejecutado accidentalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;le&quot; returns true if the left argument is stringwise less than
or equal to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;le&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente menor o igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># do something here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># hacer algo aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl(1).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl(1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you stick 10,000 things in a hash, but evaluating
%HASH in scalar context reveals C&lt;&quot;1/16&quot;&gt;, which means only one out
of sixteen buckets has been touched, and presumably contains all
10,000 of your items.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, supóngase que se insertan 10.000 valores en un hash, pero al evaluar el %HASH en contexto escalar nos devuelve C&lt;&quot;1/16&quot;&gt;, lo cual significa que sólo una de cada dieciséis unidades ha sido tocada, y que probablemente contiene los 10.000 elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of kill when a I&lt;PROCESS&gt; number is zero or negative depends on
the operating system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento de kill cuando el I&lt;PROCESO&gt; es el número cero o negativo depende del sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any letters between C&lt;?&gt; and C&lt;:&gt; act as flags modifiers as with
C&lt;(?adluimsx-imsx)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T194254Z" changeid="explorer">
        <seg>Cualquier letra entre C&lt;?&gt; y C&lt;:&gt; actúa como modificadores de banderas con C&lt;(?adluimsx-imsx)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the use of $ instead of \ in the last example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note el uso de $ en lugar de \ en el último ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl v5.14.0 required--this is only v5.12.3, stopped at /tmp/a line 1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031738Z" changeid="explorer">
        <seg>Perl v5.14.0 required--this is only v5.12.3, stopped at /tmp/a line 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://archive.develooper.com/perl-mvs@perl.org/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220630Z" changeid="explorer">
        <seg>http://archive.develooper.com/perl-mvs@perl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perltw		Perl for Traditional Chinese (in Big5)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000833Z" changeid="explorer">
        <seg>perltw		Perl para chino tradicional (en Big5)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names
that do not start with a letter, underscore, digit or a caret (i.e.
a control character) are limited to one character, e.g.,  C&lt;$%&gt; or
C&lt;$$&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres que no empiecen ni por letra, ni subrayado, ni dígito, ni acento circunflejo (es decir, un carácter de control) están limitados a un solo carácter, como por ejemplo C&lt;$%&gt; o C&lt;$$&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following are recognized:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo siguiente es reconocido como correcto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the expression is
omitted, one-match searches (C&lt;?pattern?&gt;) are reset to match again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la expresión se omite, las búsquedas de una sola coincidencia (C&lt;?pattern?&gt;) son reinicializadas para que vuelvan a hacer el trabajo de coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise it's a list
operator or unary operator, and precedence does matter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario es un operador de lista u operador unario, y la precedencia sí importa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The character following C&lt;\c&gt; is mapped to some other character as shown in the
table:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204442Z" changeid="explorer">
        <seg>El carácter que siga a C&lt;\c&gt; es mapeado a algún otro carácter, tal como se muestra en esta tabla:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o equivalentemente,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check L&lt;perlop&gt; for more
detail.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225250Z" changeid="explorer">
        <seg>Consulte L&lt;perlop&gt; para obtener más información)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called in list context, returns a 2-element list consisting of the key
and value for the next element of a hash, or the index and value for the
next element of an array, so that you can iterate over it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se le llama en contexto lista, devuelve una lista de dos elementos consistentes en la clave y el valor del siguiente elementos del hash, o el índice y valor del siguiente elemento del array, así que de esta manera puede iterar por el.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns false if the context is
looking for a scalar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve falso si el contexto está buscando por un escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Stratus VOS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005705Z" changeid="explorer">
        <seg>=item Stratus VOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To break the loop, the following
match after a zero-length match is prohibited to have a length of zero.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T232317Z" changeid="explorer">
        <seg>Para romper el bucle, la siguiente coincidencia después de una coincidencia de longitud cero se prohíbe que tenga una longitud cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf(&quot;%#02x &quot;, $_) for unpack(&quot;W*&quot;, pack L=&gt;0x12345678);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf(&quot;%#02x &quot;, $_) for unpack(&quot;W*&quot;, pack L=&gt;0x12345678);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (EXPR) BLOQUE elsif (EXPR) BLOQUE ... else BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052945Z" changeid="explorer">
        <seg>$n ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item our EXPR
X&lt;our&gt; X&lt;global&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191937Z" changeid="explorer">
        <seg>=item our EXPR
X&lt;our&gt; X&lt;global&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/grep&gt; for an array composed of those items of
the original list for which the BLOCK or EXPR evaluates to true.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215413Z" changeid="explorer">
        <seg>Vea también L&lt;/grep&gt; para un array compuesto por los elementos de la lista original en que el BLOQUE o EXPR se evalúa como verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@hash{keys %hash}) { s/foo/bar/g }   # same</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@hash{keys %hash}) { s/foo/bar/g }   # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your system has a strange pointer size--meaning a pointer is neither as
big as an int nor as big as a long--it may not be possible to pack or
unpack pointers in big- or little-endian byte order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su sistema tiene un tamaño de puntero extraño -lo que significa que un puntero no es ni tan grande como un int, ni tan grande como un long- quizás no pueda ser posible empaquetar o desempaquetar punteros en orden big-endian o little-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &lt;&gt; &gt;&gt; operator is most often seen in a C&lt;while&gt; loop:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T003055Z" changeid="zipf">
        <seg>El operador C&lt;&lt; &lt;&gt; &gt;&gt; se suele utilizar en un bucle C&lt;while&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$bin = $vec-&gt;to_Bin();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225516Z" changeid="explorer">
        <seg>$bin = $vec-&gt;to_Bin();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>20 ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>20 ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All systems use the virtual C&lt;&quot;\n&quot;&gt; to represent a line terminator,
called a &quot;newline&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todos los sistemas usan el carácter virtual C&lt;&quot;\n&quot;&gt; para representar un terminador de línea, llamado un &quot;nueva línea&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/reg_nc_tie.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010036Z" changeid="explorer">
        <seg>=item t/op/reg_nc_tie.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%by_name = reverse %by_address;  # Invert the hash</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%por_nombre = reverse %por_direccion;  # Invierte el hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl
bug database at F&lt;http://bugs.perl.org/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T010205Z" changeid="explorer">
        <seg>Si encuentra algo que piensa que es un error, podría verificar los artículos publicados recientemente en el grupo de noticias comp.lang.perl.misc y en la base de datos de errores de perl en F&lt;http://bugs.perl.org/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has now support for the C&lt;CLONE_SKIP&gt; special subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T195102Z" changeid="explorer">
        <seg>Perl ahora tiene soporte para la subrutina especial C&lt;CLONE_SKIP&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shutdown(Wtr, 0);        # no more reading for writer</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shutdown(Wtr, 0);        # no más lecturas para el escritor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is written in the POD format (see pod/perlpod.pod) which is specially
designed to be readable as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está escrito en formato POD (ver pod/perlpod.pod) que está específicamente diseñado para ser legible de forma sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might like to use C&lt;do&gt; to read in a program configuration
file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar C&lt;do&gt; para leer en un programa un archivo de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support futimes(2), you may pass filehandles among the
files.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013425Z" changeid="explorer">
        <seg>En sistemas que soporten futimes(2), puede pasar identificadores de archivo entre los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Stat returns list value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># stat devuelve una lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $s = undef;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014858Z" changeid="explorer">
        <seg>my $s = undef;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;u&gt;, where it is equivalent to 1 (or 45, which here is equivalent).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;u&gt;, donde es equivalente a 1 (o 45, que aquí es equivalente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A missing pattern always
matches.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213032Z" changeid="explorer">
        <seg>Un patrón no presente siempre coincide.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq		Perl frequently asked questions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000228Z" changeid="explorer">
        <seg>perlfaq		Preguntas más frecuentes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A separate DTrace is now build for miniperl, which means that perl can be
compiled with -Dusedtrace on Solaris again.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230618Z" changeid="explorer">
        <seg>Ahora se construye un DTrace aparte, para miniperl. Esto quiere decir que perl puede ser, de nuevo, compilado con -Dusedtrace en Solaris.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Programming Perl&gt; (the &quot;Camel Book&quot;):</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003001Z" changeid="explorer">
        <seg>=item I&lt;Programming Perl&gt; (el &quot;Libro del Camello&quot;):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@george = qw(gone chased yz Punished Axed);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@george = qw(gone chased yz Punished Axed);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.4g&gt;', 100.01; # prints &quot;&lt;100&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.4g&gt;', 100.01; # imprime &quot;&lt;100&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $aref = undef;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031143Z" changeid="explorer">
        <seg>my $aref = undef;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @nums, ( /=(\d+)/ ? $1 : undef );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051414Z" changeid="explorer">
        <seg>push @numeros, ( /=(\d+)/ ? $1 : undef );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When inside of a
nested pattern, such as recursion, or in a subpattern dynamically generated
via C&lt;(??{})&gt;, only the innermost pattern is ended immediately.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T144327Z" changeid="explorer">
        <seg>Cuando, dentro de un patrón anidado, tales como una recursión, o en un sub-patrón generado de forma dinámica a través de C&lt;(??{})&gt;, sólo el patrón más interno es terminado inmediatamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user could specify a filename of
F&lt;&quot;rsh cat file |&quot;&gt;, or you could change certain filenames as needed:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235218Z" changeid="explorer">
        <seg>Un usuario podría especificar un nombre de archivo como F&lt;&quot;rsh cat archivo |&quot;&gt;, o podría cambiar ciertos nombres de archivo, según lo que necesite:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;setlogmask()&gt; now behaves like its C counterpart.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035224Z" changeid="explorer">
        <seg>C&lt;setlogmask()&gt; ahora se comporta igual que su homólogo en C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subpatterns are numbered based on the left to right order
of their opening parenthesis.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T224257Z" changeid="explorer">
        <seg>Los subpatrones son numerados basados en el orden, de izquierda a derecha, de su paréntesis de apertura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $n = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $n = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$utf8 =~ /$byte|X}/i;	# failed in 5.10.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003901Z" changeid="explorer">
        <seg>$utf8 =~ /$byte|X}/i;	# fallaba en 5.10.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make 2&gt;&amp;1 | tee make.out</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make 2&gt;&amp;1 | tee make.out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Search::Dict: allow transforming lines before comparing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Search::Dict: permite transformar líneas antes de compararlas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $cycle; # 000000</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>print $cycle; # 000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME
X&lt;operator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T232224Z" changeid="explorer">
        <seg>=head1 NOMBRE
X&lt;operator&gt; X&lt;operador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SIGNAL is zero, no signal is sent to the process, but C&lt;kill&gt;
checks whether it's I&lt;possible&gt; to send a signal to it (that
means, to be brief, that the process is owned by the same user, or we are
the super-user).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la SEÑAL es cero, no se envía señal al proceso, pero C&lt;kill&gt; comprueba si I&lt;posible&gt; enviar una señal a la misma (lo que significa, para ser breve, que el proceso es propiedad del mismo usuario, o somos el super-usuario).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$x][20] += func2($x);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$x][20] += func2($x);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect of C&lt;each&gt; is considered highly experimental.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T160256Z" changeid="explorer">
        <seg>Este aspecto de C&lt;each&gt; es considerado altamente experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For how many bytes a string encoded as
UTF-8 would take up, use C&lt;length(Encode::encode_utf8(EXPR))&gt; (you'll have
to C&lt;use Encode&gt; first).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para saber la cantidad de bytes que una cadena codificada como UTF-8 ocupa, utilice C&lt;length(Encode::encode_utf8(EXPR))&gt; (tendrá que poner C&lt;use Encode&gt; primero).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there was no error, C&lt;$@&gt; is guaranteed to be the empty
string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay errores, se garantiza que C&lt;$@&gt; será una cadena vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use 
C&lt;perldoc E&lt;lt&gt;nameE&lt;gt&gt;&gt; to get information on any of the utilities
described in this document.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233350Z" changeid="explorer">
        <seg>Para obtener información sobre cualquiera de las utilidades descritas en este documento, use C&lt;perldoc E&lt;lt&gt;nombreE&lt;gt&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$i++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$i++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@folks[0, -1]  = @folks[-1, 0];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@gente[0, -1]  = @gente[-1, 0];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chop VARIABLE
X&lt;chop&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170152Z" changeid="explorer">
        <seg>=item chop VARIABLE
X&lt;chop&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://indigostar.com/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225435Z" changeid="explorer">
        <seg>http://indigostar.com/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any of the file tests (or either the C&lt;stat&gt; or C&lt;lstat&gt; operator) is given
the special filehandle consisting of a solitary underline, then the stat
structure of the previous file test (or stat operator) is used, saving
a system call.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T004707Z" changeid="explorer">
        <seg>Si a cualquiera de los test de archivo (o los operadores C&lt;stat&gt; o C&lt;lstat&gt;) se les da el identificador de archivo especial consistente en un solitario guión bajo, entonces se usa la estructura stat del archivo del test anterior (u operador stat), ahorrando una llamada del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $mon=9, $mday=18 gives &quot;Oct 18&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># $mes=9, $mdia=18 da &quot;Oct 18&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @sorted    = sort @animals;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T025801Z" changeid="explorer">
        <seg>my @ordenados     = sort @animales;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See examples above under L&lt;Terms and List Operators (Leftward)&gt;.)
X&lt;+&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T190411Z" changeid="explorer">
        <seg>(Ver ejemplos anteriores en L&lt;Términos y Operadores de listas (por la izquierda)&gt;)
X&lt;+&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, many of the guidelines presented in this document
can be extrapolated and applied successfully to a module's internals.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013003Z" changeid="explorer">
        <seg>Sin embargo, muchas de las directrices que se presentan en este documento puede ser extrapoladas y aplicadas con éxito a un módulo de uso particular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item IPC::Open3</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014822Z" changeid="explorer">
        <seg>=item IPC::Open3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NaN is not &quot;&lt;&quot;, &quot;==&quot;, &quot;&gt;&quot;,
&quot;&lt;=&quot; or &quot;&gt;=&quot; anything (even NaN), so those 5 return false.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235141Z" changeid="explorer">
        <seg>NaN no es &quot;&lt;&quot;, &quot;==&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot; o &quot;&gt;=&quot; ni cualquier otra cosa (incluso NaN), así que estos 5 devuelven falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, C&lt;/(?!foo)bar/&gt;
will not do what you want.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T210954Z" changeid="explorer">
        <seg>Si está buscando por un &quot;bar&quot; que no esté precedido por un &quot;foo&quot;, C&lt;/(?!foo)bar/&gt; no hará lo que espera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bit::Vector            manipulate bit vectors fast (uses C)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035352Z" changeid="explorer">
        <seg>Bit::Vector			manipula vectores bit rápidamente (usa C)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Logical And
X&lt;operator, logical, and&gt; X&lt;and&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T002105Z" changeid="explorer">
        <seg>=head2 And lógico
X&lt;operator, logical, and&gt; X&lt;and&gt; X&lt;operador, lógico, and&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl language for MPE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl lenguaje para el MPE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;12&quot; =~ /(?| (?&lt;a&gt; \d+ ) | (?&lt;b&gt; \D+))/x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T125421Z" changeid="explorer">
        <seg>&quot;12&quot; =~ /(?| (?&lt;a&gt; \d+ ) | (?&lt;b&gt; \D+))/x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you evaluate a hash in scalar context, it returns false if the
hash is empty.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se evalúa un hash en contexto escalar, devuelve falso si el hash está vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl community is geared toward supporting the most recent releases,
so you'll have an easier time finding help for those.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200731Z" changeid="explorer">
        <seg>La comunidad Perl tiende a ofrecer soporte para las versiones más recientes, por lo que le costará menos encontrar ayuda para estas versiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;=~&quot; binds a scalar expression to a pattern match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;=~&quot; une una expresión escalar a un patrón de coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the B&lt;-u&gt;
command-line switch in L&lt;perlrun&gt;, which does the same thing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también la opción de línea de comando B&lt;-u&gt; en L&lt;perlrun&gt;, que hace lo mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use bigint;  # easy interface to Math::BigInt</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033259Z" changeid="explorer">
        <seg>use bigint;  # interfaz sencillo para Math::BigInt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( /\b(foo)\s+(\w+)/i ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T151405Z" changeid="explorer">
        <seg>if ( /\b(come)\s+(\w+)/i ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Bitwise operators</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234038Z" changeid="explorer">
        <seg>=item Operadores bit a bit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;tr&gt; does B&lt;not&gt; do regular expression character classes such as
C&lt;\d&gt; or C&lt;\pL&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031943Z" changeid="explorer">
        <seg>Tenga en cuenta que C&lt;tr&gt; B&lt;no&gt; usa expresiones regulares de clases de caracteres, tales como C&lt;\d&gt; o C&lt;\pL&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This proxy constant subroutine is
automatically upgraded to a real typeglob with subroutine if necessary.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T033408Z" changeid="explorer">
        <seg>Este cacheo de la subrutina constante se actualiza automáticamente a un typeglob real con subrutina, si es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Program
                           |
                       Statement
                           |
                           =
                          / \
                         /   \
                        $a   +
                            / \
                          $b   $c</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103854Z" changeid="explorer">
        <seg>Programa
                           |
                      Instrucción
                           |
                           =
                          / \
                         /   \
                        $a   +
                            / \
                          $b   $c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrecharclass/Bracketed Character Classes&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220441Z" changeid="explorer">
        <seg>Vea L&lt;perlrecharclass/Clases carácter encorchetadas&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -Dcc='cc -n32' -Duse64bitint</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002728Z" changeid="explorer">
        <seg>sh Configure -Dcc='cc -n32' -Duse64bitint</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not useful.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014947Z" changeid="explorer">
        <seg>Nada útil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 8   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 8   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check L&lt;perlport&gt; and either the
rename(2) manpage or equivalent system documentation for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compruebe L&lt;perlport&gt; y, o bien la página de manual de rename(2) o documentación equivalente del sistema para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++ $i + $i ++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ++ $i + $i ++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require Dumpvalue;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032200Z" changeid="explorer">
        <seg>require Dumpvalue;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my %fruit_color = (&quot;apple&quot;, &quot;red&quot;, &quot;banana&quot;, &quot;yellow&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234320Z" changeid="zipf">
        <seg>my %color_fruta = (&quot;manzana&quot;, &quot;rojo&quot;, &quot;plátano&quot;, &quot;amarillo&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\l		lowercase next character only</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232442Z" changeid="explorer">
        <seg>\l		siguiente car. en minúscula</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11865</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11865</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item &lt;&lt;EOF
X&lt;here-doc&gt; X&lt;heredoc&gt; X&lt;here-document&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010411Z" changeid="explorer">
        <seg>=item &lt;&lt;EOF
X&lt;here-doc&gt; X&lt;heredoc&gt; X&lt;here-document&gt; X&lt;&lt;&lt; &lt;&lt; &gt;&gt;&gt; X&lt;documento incrustado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item printf FILEHANDLE FORMAT, LIST
X&lt;printf&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011448Z" changeid="explorer">
        <seg>=item printf IDENTIFICADOR_ARCHIVO FORMATO, LISTA
X&lt;printf&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%.20g\n&quot;, 123456789123456789;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%.20g\n&quot;, 123456789123456789;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%.*2$x&gt;&quot;, 1, 6;   # INVALID, but in future will print &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;&lt;%.*2$x&gt;&quot;, 1, 6;   # INVÁLIDO, pero en el futuro imprimirá &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C&lt;ptar&gt;, it comes with
C&lt;Archive::Tar&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013436Z" changeid="explorer">
        <seg>Como C&lt;ptar&gt;, viene con C&lt;Archive::Tar&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Weak references are cheaper</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T033859Z" changeid="explorer">
        <seg>=head2 Referencias débiles son ahora más livianas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;-X&gt; X&lt;filetest&gt; X&lt;operator, filetest&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;-X&gt; X&lt;filetest&gt; X&lt;operator, filetest&gt; X&lt;operador, test archivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[This function has been largely superseded by the C&lt;untie&gt; function.]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[Esta función ha sido largamente supeditada por la función C&lt;untie&gt;].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Together with
undefining C&lt;$/&gt; to input entire files as one record, this can be quite
fast, often faster than specialized programs like fgrep(1).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Junto con la indefinición de C&lt;$/&gt; para la entrada de archivos completos como un único registro, esto puede ser bastante rápido, a menudo más rápido que los programas especializados como fgrep(1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, binmode() should be called after open() but before any I/O
is done on the filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005127Z" changeid="explorer">
        <seg>En general, binmode() debe ser llamada después de open() pero antes de que cualquier I/O se realice sobre el identificador de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is so that you can write loops like:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esa manera puede escribir bucles como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No space before the semicolon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin espacio antes de punto y coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, hashes included as parts of other lists (including
parameters lists and return lists from functions) always flatten out into
key/value pairs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, los hashes incluidos como parte de otras listas (incluidas las listas de parámetros y listas de retorno de funciones) siempre se extienden en pares clave / valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item prototype FUNCTION
X&lt;prototype&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T192801Z" changeid="explorer">
        <seg>=item prototype FUNCIÓN
X&lt;prototype&gt; X&lt;prototipo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11874</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11874</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results are what the C language system call C&lt;tolower()&gt; returns.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174456Z" changeid="explorer">
        <seg>Los resultados son los que devuelve la llamada del sistema en lenguaje C C&lt;tolower()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($child_pid) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005857Z" changeid="explorer">
        <seg>if ($child_pid) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\pP       [3]  Match P, named property.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223744Z" changeid="explorer">
        <seg>\pP	 [3]  Coincide con P, una propiedad nominal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11877</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11877</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replace C&lt;5.8.6&gt; with your respective version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Reemplace C&lt;5.8.6&gt; con su respectiva versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can
be useful but it may be a memory hog.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225344Z" changeid="explorer">
        <seg>Puede resultar útil, pero esta operación consume mucha memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item time</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item time</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting in Perl 5.14, a C&lt;&quot;^&quot;&gt; (caret or circumflex accent) immediately
after the C&lt;&quot;?&quot;&gt; is a shorthand equivalent to C&lt;d-imsx&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T051603Z" changeid="explorer">
        <seg>A partir de Perl 5.14, un C&lt;&quot;^&quot;&gt; (acento circunflejo) inmediatamente después de un C&lt;&quot;?&quot;&gt; es una abreviatura equivalente de C&lt;d-imsx&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queries the option named OPTNAME associated with SOCKET at a given LEVEL.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consulta la opción con nombre OPCIÓN asociada con el SOCKET en un determinado NIVEL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The right argument is a search
pattern, substitution, or transliteration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El argumento de la derecha es un patrón de búsqueda, sustitución o transliteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect of C&lt;pop&gt; is considered highly experimental.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175804Z" changeid="explorer">
        <seg>Este aspecto de C&lt;pop&gt; es considerado altamente experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $dbase, &quot;+&lt;&quot;, &quot;dbase.mine&quot;)      # open for update</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004009Z" changeid="explorer">
        <seg>open(my $dbase, &quot;+&lt;&quot;, &quot;dbase.mine&quot;)      # abrir para actualizar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$file = &lt;blurch*&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$archivo = &lt;loquesea*&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.apress.com/book/view/1590594541</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003655Z" changeid="explorer">
        <seg>http://www.apress.com/book/view/1590594541</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^xyz/) { $xyz = 1; last SWITCH; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^xyz/) { $xyz = 1; last SWITCH; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use Module LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item use Módulo LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used with C&lt;@&gt;, the repeat count represents an offset from the start
of the innermost C&lt;()&gt; group.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se utiliza con C&lt;@&gt;, el número de repeticiones representa un desplazamiento desde el inicio del grupo C&lt;()&gt; más interior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@$deck[$i,$j] = @$deck[$j,$i];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225556Z" changeid="explorer">
        <seg>@$deck[$i,$j] = @$deck[$j,$i];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>info perldgux</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>info perldgux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;3: '&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;3: '&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also do not have to use mpeix/relink after building, so the
recommend sequence is:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También no tiene que utilizar mpeix/relink después de la compilación, por lo que la secuencia recomendada es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir EXPR
X&lt;chdir&gt;
X&lt;cd&gt;
X&lt;directory, change&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chdir EXPR
X&lt;chdir&gt; X&lt;cd&gt; X&lt;directory, change&gt; X&lt;directorio, cambio&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where an argument is
specified by an explicit index, this does not affect the normal
order for the arguments, even when the explicitly specified index
would have been the next argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se especifica un argumento por un índice explícito, esto no afecta el orden normal de los argumentos, incluso cuando el índice especificado explícitamente habría sido el siguiente argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example to illustrate how the bits actually fall in place:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este es un ejemplo para ilustrar cómo los bits están amparados efectivamente en su lugar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Contributed by Gisle Aas.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T195811Z" changeid="explorer">
        <seg>(Escrito por Gisle Aas.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;http://lists.perl.org/showlist.cgi?name=perl-mvs&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T064848Z" changeid="explorer">
        <seg>L&lt;http://lists.perl.org/showlist.cgi?name=perl-mvs&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also behaves similarly, but avoids $_ :</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto también se comporta de forma similar, pero evita $_:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Higher-Order Perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003541Z" changeid="explorer">
        <seg>=item I&lt;Higher-Order Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of -pthread put here -lthread.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>en lugar de -pthread, ponga -lthread.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub substr {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub substr {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11825</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11825</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then C&lt;%hash&gt; will have at least 200 buckets allocated for it--256 of them,
in fact, since it rounds up to the next power of two.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>entonces C&lt;%hash&gt; tendrá al menos 200 alojamientos de memoria reservados para él -- 256 de ellos, de hecho, ya que se redondea a la siguiente potencia de dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dbmclose HASH
X&lt;dbmclose&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170401Z" changeid="explorer">
        <seg>=item dbmclose HASH
X&lt;dbmclose&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting $0 now works.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031530Z" changeid="explorer">
        <seg>Ahora funciona el establecer $0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@days		# ($days[0], $days[1],... $days[n])</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@dias		# ($dias[0], $dias[1],... $dias[n])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} @data;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>} @data;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.9.0 and the 5.9.1
development releases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe las diferencias entre las versiones de desarrollo 5.9.0 y la 5.9.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 4) = 8   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 4) = 8   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BINMODE this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BINMODE este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-   subtraction</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235208Z" changeid="zipf">
        <seg>-   resta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Symbian</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005708Z" changeid="explorer">
        <seg>=item Symbian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str .= &quot;\x{0e0b}&quot;;  # Now $str is in UTF-8 format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001211Z" changeid="explorer">
        <seg>$str .= &quot;\x{0e0b}&quot;;  # Ahora, $str está en formato UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All unqualified dynamic identifiers in this scope will be in the given
namespace, except where overridden by another C&lt;package&gt; declaration or
when they're one of the special identifiers that qualify into C&lt;main::&gt;,
like C&lt;STDOUT&gt;, C&lt;ARGV&gt;, C&lt;ENV&gt;, and the punctuation variables.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T004642Z" changeid="explorer">
        <seg>Todos los identificadores dinámicos no cualificados en este ámbito pertenecerán al espacio de nombres indicado, salvo cuando sea reemplazado por otra declaración C&lt;package&gt; o cuando sean uno de los identificadores especiales que cualifican dentro de C&lt;main::&gt;, al igual que C&lt;STDOUT&gt;, C&lt;ARGV&gt;, C&lt;ENV&gt;, y las variables especiales de caracteres de puntuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = '150' |  105;	# yields 255</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = '150' |  105;	# produce 255</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Diamond inheritance now works.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T174044Z" changeid="explorer">
        <seg>La herencia de diamante ahora funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Breaking out</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Saliendo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlock($mbox);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlock($mbox);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, bugs/features of the compiler
used may lead to breakage of some of the above rules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232852Z" changeid="explorer">
        <seg>En particular, determinados errores o características del compilador usado pueden provocar la infracción de algunas de las normas anteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The root cause is that there is no interface for the implementors of
tied hashes to implement the behaviour of a hash in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T002614Z" changeid="explorer">
        <seg>La causa principal es que no existe una interfaz para los implementadores de los hashes enlazados para implementar el comportamiento de un hash en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($Fld1,$Fld2) = split(/[:\n]/, $_, -1);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234157Z" changeid="explorer">
        <seg>($Fld1,$Fld2) = split(/[:\n]/, $_, -1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to set @ARGV to your own list of files, go right ahead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea establecer @ARGV a su propia lista de archivos, adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The permission (or &quot;mode&quot;)
values you pass C&lt;mkdir&gt; or C&lt;sysopen&gt; are modified by your umask, so
even if you tell C&lt;sysopen&gt; to create a file with permissions C&lt;0777&gt;,
if your umask is C&lt;0022&gt;, then the file will actually be created with
permissions C&lt;0755&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024138Z" changeid="explorer">
        <seg>El valor de permiso (o &quot;modo&quot;) que se pasa a C&lt;mkdir&gt; o C&lt;sysopen&gt; son modificados por su C&lt;umask&gt;, así que incluso si usted le pide a C&lt;sysopen&gt; crear un archivo con permisos C&lt;0777&gt;, y su C&lt;umask&gt; es C&lt;0022&gt;, entonces el archivo realmente es creado con permisos C&lt;0755&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except where otherwise noted, you
should assume that C&lt;use strict&gt; and C&lt;use warnings&gt; statements
appear earlier in the &quot;program&quot;, and that any variables used have
already been declared, even if those declarations have been omitted
to make the example easier to read.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004517Z" changeid="explorer">
        <seg>Salvo si se indica lo contrario, debe suponer que al principio del &quot;programa&quot; se incluyen las instrucciones C&lt;use strict&gt; y C&lt;use warnings&gt;, y que todas las variables han sido declaradas, aunque se omitan las declaraciones para facilitar la lectura del ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Linker Problems in Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003840Z" changeid="explorer">
        <seg>=head2 Problemas de enlazado en Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^-v/)     { $verbose++  }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^-v/)     { $verboso++  }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An C&lt;eval ''&gt; executed within the C&lt;DB&gt; package doesn't see the usual
surrounding lexical scope, but rather the scope of the first non-DB piece
of code that called it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;eval ''&gt; ejecutado dentro del paquete C&lt;DB&gt; no ve el usual ámbito léxico circundante, sino más bien el ámbito de la primera parte del código no-DB que le llamó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HASH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>HASH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stability of these extensions varies widely.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La estabilidad de estas extensiones varía ampliamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Include POD for a given method right above that 
method's subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024715Z" changeid="explorer">
        <seg>Incluya POD para un determinado método justo por encima de la subrutina del método.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted incrementa una variable que es numérica, o que haya sido utilizada en un contexto numérico, se obtiene un incremento normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The following is a comprehensive reference to open(): for a gentler
introduction you may consider L&lt;perlopentut&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Lo siguiente es una referencia general a open(): para una introducción más suave puede considerar L&lt;perlopentut&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exhaustive information on the topic of references can be found in
L&lt;perlreftut&gt;, L&lt;perllol&gt;, L&lt;perlref&gt; and L&lt;perldsc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225034Z" changeid="explorer">
        <seg>Encontrará información detallada sobre las referencias en L&lt;perlreftut&gt;, L&lt;perllol&gt;, L&lt;perlref&gt; y L&lt;perldsc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the modifiers affect only pattern matching, and do not extend
to any replacement done.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163921Z" changeid="explorer">
        <seg>Tenga en cuenta que los modificadores afectan sólo a la coincidencia de patrones, y no se extienden a ningún reemplazo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Building with threads in Irix</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T012147Z" changeid="explorer">
        <seg>=head2 Compilando con hilos en Irix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_[0] = 'bar';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225616Z" changeid="explorer">
        <seg>$_[0] = 'bar';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/porting/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014706Z" changeid="explorer">
        <seg>=item * F&lt;t/porting/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item alarm SECONDS
X&lt;alarm&gt;
X&lt;SIGALRM&gt;
X&lt;timer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165518Z" changeid="explorer">
        <seg>=item alarm SEGUNDOS
X&lt;alarm&gt; X&lt;SIGALRM&gt; X&lt;timer&gt; X&lt;alarma&gt; X&lt;temporizador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has been fixed [RT #53746].</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T004025Z" changeid="explorer">
        <seg>Esto ha sido corregido [RT #53746].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*before* the &quot;make -f Makefile.micro&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>*antes* del &quot;make -f Makefile.micro&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Pro Perl Debugging&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003648Z" changeid="explorer">
        <seg>=item I&lt;Pro Perl Debugging&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print hex '0xAf'; # prints '175'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print hex '0xAf'; # imprime '175'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlink $filename;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T131856Z" changeid="zipf">
        <seg>unlink $archivo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because C&lt;$body&gt; is now a byte string, C&lt;length&gt; will report the
number of bytes, instead of the number of characters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235304Z" changeid="explorer">
        <seg>Como C&lt;$cuerpo_texto&gt; es una cadena de bytes, C&lt;length&gt; devolverá el número de bytes, en lugar del número de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;cpan/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014448Z" changeid="explorer">
        <seg>=item * F&lt;cpan/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIMIT is specified and positive, it represents the maximum number
of fields the EXPR will be split into, though the actual number of
fields returned depends on the number of times PATTERN matches within
EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LÍMITE está especificado y es positivo, representa el máximo número de campos que EXPR será dividido, aunque el número real de campos devueltos depende del número de veces que PATRÓN concuerda en EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 UTF-8</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234426Z" changeid="explorer">
        <seg>=head3 UTF-8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item no MODULE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item no MÓDULO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty&quot;, '-icanon', 'eol', &quot;\001&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty&quot;, '-icanon', 'eol', &quot;\001&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments should be
integers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los argumentos deben ser números enteros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A minor release is one in which a small amount of functionality
has been added or changed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025310Z" changeid="explorer">
        <seg>Una versión menor es aquella en la que una pequeña cantidad de funcionalidad ha sido añadida o cambiada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What gets returned depends on several factors:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174229Z" changeid="explorer">
        <seg>Lo que se devuelve depende de varios factores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the variable is
implicitly local to the loop and regains its former value upon exiting
the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dicho de otra forma, la variable es implícitamente local al bucle y recupera su valor anterior al salir del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substr( $string, 13, 4, &quot;Perl 5.8.0&quot; );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225534Z" changeid="explorer">
        <seg>substr( $string, 13, 4, &quot;Perl 5.8.0&quot; );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub/&quot;Localized deletion of elements of composite types&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub/&quot;Eliminación local de elementos de tipos compuestos&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ein = $rin | $win;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ein = $rin | $win;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only characters C&lt;A-Z&gt; change, to C&lt;a-z&gt;
respectively.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T174555Z" changeid="explorer">
        <seg>Sólo los caracteres C&lt;A-Z&gt; cambian, a C&lt;a-z&gt;, respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require &quot;sys/ioctl.ph&quot;;  # probably in $Config{archlib}/sys/ioctl.ph</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require &quot;sys/ioctl.ph&quot;;  # probablemente en $Config{archlib}/sys/ioctl.ph</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 32  ==         32 00000100000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 32  ==         32 00000100000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str =  &quot;\xDF&quot;;      # $str is not in UTF-8 format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001118Z" changeid="explorer">
        <seg>$str =  &quot;\xDF&quot;;      # $str no está en formato UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can change the way that an object is matched by overloading
the C&lt;~~&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede cambiar la forma en que un objeto es comparado, sobrecargando el operador C&lt;~~&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The major reference book on Perl, written by the creator of Perl, is
I&lt;Programming Perl&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T002956Z" changeid="explorer">
        <seg>El principal libro de referencia sobre Perl, escrito por el creador del lenguaje, es I&lt;Programming Perl&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a character (C&lt;ord&gt;, C&lt;chr&gt;) is the corresponding Unicode code
point.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234545Z" changeid="explorer">
        <seg>El valor de un carácter (C&lt;ord&gt;, C&lt;chr&gt;) es el código de carácter Unicode correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlperf		Perl Performance and Optimization Techniques</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000217Z" changeid="explorer">
        <seg>perlperf		Rendimiento y técnicas de optimización</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\Q		quote non-word characters till \E</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003230Z" changeid="explorer">
        <seg>\Q		escapa los caracteres no alfanuméricos hasta \E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Starting analysis\n&quot; if $verbose;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Empezando análisis\n&quot; if $locuaz;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also triggers an
uninitialized warning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto también desencadena una advertencia de datos no inicializados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;|-&quot;) || exec 'tr', '[a-z]', '[A-Z]';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T233619Z" changeid="explorer">
        <seg>open(FOO, &quot;|-&quot;) || exec 'tr', '[a-z]', '[A-Z]';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The locale used will be the one in
effect at the time of execution of the pattern match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T164929Z" changeid="explorer">
        <seg>La regla regional utilizada será la vigente en el momento de la ejecución de la coincidencia de patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To guarantee this to be
true, add a C&lt;0&gt; to the scalar before using it.)  The C&lt;pack&gt; and C&lt;unpack&gt;
functions may be needed to manipulate the values of structures used by
C&lt;ioctl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para garantizar este último comportamiento, añada un C&lt;0&gt; al escalar antes de usarlo). Las funciones C&lt;pack&gt; y C&lt;unpack&gt; pueden ser necesarias para manipular los valores de las estructuras usadas por C&lt;ioctl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use List::Util 'shuffle';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225556Z" changeid="explorer">
        <seg>use List::Util 'shuffle';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = map +( lc($_) =&gt; 1 ), @array  # this is EXPR and works!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = map +( lc($_) =&gt; 1 ), @array  # esto es EXPR ¡y funciona!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Support for Atari MiNT was removed in Perl 5.11.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T020324Z" changeid="explorer">
        <seg>El soporte para Atari MiNT fue eliminado en Perl 5.11.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a field width obtained through C&lt;*&gt; is negative, it has the same
effect as the C&lt;-&gt; flag: left-justification.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si un ancho de campo obtenidos a través de C&lt;*&gt; es negativo, tiene el mismo efecto que la bandera C&lt;-&gt;: alineación a la izquierda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Correct previous documentation: v-strings are not deprecated</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T011005Z" changeid="explorer">
        <seg>Se corrige documentación anterior: los v-strings no son obsoletos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can be used instead of</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143023Z" changeid="explorer">
        <seg>se puede utilizar en lugar de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when (/^abc/) { $abc = 1; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when (/^abc/) { $abc = 1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.manning.com/conway/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003617Z" changeid="explorer">
        <seg>http://www.manning.com/conway/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;encoding::warnings&gt; is now a lexical pragma.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005225Z" changeid="explorer">
        <seg>C&lt;encoding::warnings&gt; es ahora un pragma léxico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
current value of C&lt;$\&gt; (if any) is printed after the entire LIST has been
printed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T005753Z" changeid="explorer">
        <seg>El valor actual de C&lt;$\&gt; (si lo tiene) es impreso después de que toda la LISTA haya sido impresa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Lexical C&lt;$_&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T214914Z" changeid="explorer">
        <seg>=head2 C&lt;$_&gt; léxico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl should now
build on Haiku.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003800Z" changeid="explorer">
        <seg>Perl ahora debe compilarse en Haiku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add to your standard heading the following line:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234947Z" changeid="explorer">
        <seg>Agregue al encabezado estándar de su programa la línea siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is silently ignored for all other
types.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se ignora silenciosamente todos los demás tipos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are two common cases:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay dos casos comunes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&lt;&lt;&quot; returns the value of its left argument shifted left by the
number of bits specified by the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&lt;&lt;&quot; devuelve el valor de su argumento de la izquierda desplazado por el número de bits especificado por el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$just_a = 1 when /^a/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$solo_a = 1 when /^a/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+                   one or more of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230543Z" changeid="zipf">
        <seg>+                   una o más coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@old = 1 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225557Z" changeid="explorer">
        <seg>@old = 1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with Perl 5.14, C&lt;keys&gt; can take a scalar EXPR, which must contain
a reference to an unblessed hash or array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165225Z" changeid="explorer">
        <seg>A partir de Perl 5.14, C&lt;keys&gt; puede tomar una EXPR escalar, que debe contener la referencia a un hash o un array no bendecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When opening a file, it's seldom a good idea to continue 
if the request failed, so C&lt;open&gt; is frequently used with
C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al abrir un archivo, es difícil que sea una buena idea seguir si la solicitud ha fallado, por lo que C&lt;open&gt; se utiliza con frecuencia con C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that after the match, C&lt;$cnt&gt; returns to the globally
introduced value, because the scopes that restrict C&lt;local&gt; operators
are unwound.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T221657Z" changeid="explorer">
        <seg>Tenga en cuanta que después de la coincidencia, C&lt;$cnt&gt; devuelve el valor introducido globalmente, porque los ámbitos que imponen los operadores C&lt;local&gt; son desarmados en orden inverso al que se creó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right	?:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>derecha	?:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;=  less than or equal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;=  menor o igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true
for success, false on failure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001741Z" changeid="explorer">
        <seg>Devuelve verdadero para éxito, falso en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;Test::Harness&gt; timer is now off by default.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035828Z" changeid="explorer">
        <seg>El temporizador C&lt;Test::Harness&gt; está apagado por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>abc&quot;def</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>abc&quot;def</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item PodParsers</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015248Z" changeid="explorer">
        <seg>=item PodParsers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want either &quot;-&quot; or &quot;]&quot; itself to be a member of a
class, put it at the start of the list (possibly after a &quot;^&quot;), or
escape it with a backslash.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212821Z" changeid="explorer">
        <seg>Si desea que sean los propios &quot;-&quot; o &quot;]&quot; como miembros de una clase, póngalos al principio de la lista (posiblemente después de un &quot;^&quot;), o escápelos con una barra invertida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There can be whitespace between the operator and the quoting
characters, except when C&lt;#&gt; is being used as the quoting character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede haber espacios en blanco entre el operador y los caracteres delimitadores, excepto cuando C&lt;#&gt; se utiliza como carácter delimitador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, you get the name, unless the function was a
lookup by name, in which case you get the other thing, whatever it is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, obtiene el nombre, a menos que la función fuera localizar por nombre, en cuyo caso obtendrá la otra cosa, cualquiera que sea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldbmfilter - Perl DBM Filters</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T223736Z" changeid="explorer">
        <seg>perldbmfilter - Filtros DBM de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if OS returns:      then Perl returns:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>si OS devuelve:    entonces Perl devuelve:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This substitutes the question of &quot;what is chosen?&quot;
by the question of &quot;which matches are better, and which are worse?&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T234426Z" changeid="explorer">
        <seg>Esto sustituye la pregunta &quot;¿qué es elegida?&quot; por la cuestión &quot;¿que coincidencia es mejor, y cuál es peor?&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225554Z" changeid="explorer">
        <seg>last;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcygwin		Perl notes for Cygwin</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlcygwin		Notas para Cygwin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this match would fail:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235734Z" changeid="explorer">
        <seg>Por ejemplo, esta búsqueda podría fallar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, include a C&lt;use v5.10&gt; or later to the current
scope.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T012104Z" changeid="explorer">
        <seg>O de otra forma, incluya un C&lt;use v5.10&gt; o posterior, al ámbito actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Smart matching in detail</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Coincidencia inteligente en detalle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing of C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt;, and interpolation
happens as with C&lt;qq//&gt; constructs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procesamiento de C&lt;\Q&gt;, C&lt;\U&gt;, C&lt;\u&gt;, C&lt;\L&gt;, C&lt;\l&gt;, e interpolación ocurre igual que en las construcciones C&lt;qq//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final semicolon, if any, may be omitted from the value of EXPR or within
the BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El último punto y coma, si lo hay, puede ser omitido del valor de EXPR o dentro de BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Linux</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015340Z" changeid="explorer">
        <seg>Linux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$+[0] * 8;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>$+[0] * 8;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A double-quoted, interpolated string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un doble entrecomillado, la cadena es interpolada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If, on the other hand, you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por otra parte, si se escribe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ilya Zakharevich C&lt;ilya@math.ohio-state.edu&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234140Z" changeid="explorer">
        <seg>Ilya Zakharevich C&lt;ilya@math.ohio-state.edu&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of characters
actually read, C&lt;0&gt; at end of file, or undef if there was an error (in
the latter case C&lt;$!&gt; is also set).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de caracteres actualmente leídos, C&lt;0&gt; al final del archivo, o undef si hubo un error (en este último caso se actualiza el valor de C&lt;$!&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fatal error &quot;DESTROY created new reference to dead object&quot; is now
documented in L&lt;perldiag&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El error fatal &quot;DESTROY creó una nueva referencia al objeto muerto&quot; ya está documentada en L&lt;perldiag&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The inode change time of each file is set
to the current time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El tiempo de cambio de inodo de cada archivo se establece en la hora actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules for this are different for lower-level
loops given by the greedy quantifiers C&lt;*+{}&gt;, and for higher-level
ones like the C&lt;/g&gt; modifier or split() operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231344Z" changeid="explorer">
        <seg>Las reglas para esto son diferentes para los bucles de bajo nivel ofrecidos por los cuantificadores codiciosos C&lt;*+{}&gt;, y para los de más alto nivel como el modificador C&lt;/g&gt; o el operador split().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Favorably in some areas, unfavorably in others.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230624Z" changeid="explorer">
        <seg>Gana en algunos aspectos y pierde en otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It requires some time and patience
to sift through all the content but often you will find the answer you
seek.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231005Z" changeid="explorer">
        <seg>&quot;Vadear&quot; toda esta información requiere tiempo y paciencia, pero normalmente encontrará la respuesta que busca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;homer&quot;, &quot;bart&quot;, &quot;marge&quot;, &quot;maggie&quot;, ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;homer&quot;, &quot;bart&quot;, &quot;marge&quot;, &quot;maggie&quot;, ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Foreach Loops
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T042130Z" changeid="explorer">
        <seg>=head2 Bucles Foreach
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in a typical regular
expression these elementary pieces are combined into more complicated
patterns using combining operators C&lt;ST&gt;, C&lt;S|T&gt;, C&lt;S*&gt; etc.
(in these examples C&lt;S&gt; and C&lt;T&gt; are regular subexpressions).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T233615Z" changeid="explorer">
        <seg>Sin embargo, en una típica expresión regular, estas piezas elementales se combinan en patrones más complicados con los operadores de combinación C&lt;ST&gt;, C&lt;S|T&gt;, C&lt;S*&gt;, etc (en estos ejemplos C&lt;S&gt; y C&lt;T&gt; son subexpresiones regulares).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (my $j = 0; $j &lt; @ary2; $j++) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (my $j = 0; $j &lt; @ary2; $j++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And so on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y así sucesivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;got &lt;$1&gt;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T154801Z" changeid="explorer">
        <seg>print &quot;obtiene &lt;$1&gt;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a real flock(2), locks are inherited across fork()
calls, whereas those that must resort to the more capricious fcntl(2)
function lose their locks, making it seriously harder to write servers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soportan un flock(2) de verdad, los bloqueos se heredan a través de las llamadas fork(), teniendo en cuenta que se recurrirá a la caprichosa función fcntl(2) que pierde sus bloqueos, haciendo difícil escribir servidores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Assign a list of array references to an array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032329Z" changeid="explorer">
        <seg># Asigna una lista de referencias de array a un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has an B&lt;internal format&gt;, an encoding that it uses to encode text strings
so it can store them in memory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234833Z" changeid="explorer">
        <seg>Perl utiliza un B&lt;formato interno&gt;, que es una codificación con la que se codifican las cadenas de texto para almacenarlas en memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsec&gt; for details about both these mechanisms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220524Z" changeid="explorer">
        <seg>Vea L&lt;perlsec&gt; para obtener más detalles sobre estos dos mecanismos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%*1$.*s&gt;&quot;, $a, $b;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;&lt;%*1$.*s&gt;&quot;, $a, $b;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;http://perlmonks.org/?node_id=238031&gt; - Damian Conway's Perl 6 version</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224432Z" changeid="explorer">
        <seg>L&lt;http://perlmonks.org/?node_id=238031&gt; - Versión para Perl 6 de Damian Conway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if /\b(tcl|java|python)\b/i;      # :-)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if /\b(tcl|java|python)\b/i;      # :-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EXTEND this, count</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EXTEND este, contador</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item system LIST
X&lt;system&gt; X&lt;shell&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T204411Z" changeid="explorer">
        <seg>=item system LISTA
X&lt;system&gt; X&lt;shell&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;isa()&gt; checks for
inheritance, while C&lt;DOES()&gt; has been designed to be overridden when
module authors use other types of relations between classes (in addition
to inheritance).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T001023Z" changeid="explorer">
        <seg>C&lt;isa()&gt; controla la herencia, mientras que C&lt;DOES()&gt; ha sido diseñado para ser sobre escrito cuando los autores de módulos utilicen otros tipos de relaciones entre las clases (además de la herencia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item truncate EXPR,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item truncate EXPR,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If MODE is C&lt;&lt; &lt; &gt;&gt; or nothing, the file is opened for input.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T001947Z" changeid="explorer">
        <seg>Si MODO es C&lt;&lt; &lt; &gt;&gt; o nada, el archivo se abre para lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (;;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (;;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, quoting rules for the end-of-string identifier are
unrelated to Perl's quoting rules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033034Z" changeid="explorer">
        <seg>Además, no están relacionadas las reglas de entrecomillado para el identificador del fin-de-cadena con las reglas de entrecomillado de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Available as a
statement after Perl 5.10 and as a statement modifier after 5.14.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T103727Z" changeid="explorer">
        <seg>Disponible como una instrucción después de Perl 5.10 y como un modificador de instrucción después de 5.14.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>('a' x 100)=~/(??{'(.)' x 100})/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T182341Z" changeid="explorer">
        <seg>('a' x 100)=~/(??{'(.)' x 100})/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to sort the list returned by the function call
C&lt;find_records(@key)&gt;, you can use:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201012Z" changeid="explorer">
        <seg>Si quiere ordenar la lista devuelta por la llamada a la función C&lt;find_records(@key)&gt;, puede usar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sysread FILEHANDLE,SCALAR,LENGTH,OFFSET
X&lt;sysread&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012829Z" changeid="explorer">
        <seg>=item sysread IDENTIFICADOR_ARCHIVO,ESCALAR,LONGITUD,DESPLAZAMIENTO
X&lt;sysread&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;warnings&gt; upgraded to version 1.05</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041155Z" changeid="explorer">
        <seg>C&lt;warnings&gt; actualizado a la versión 1.05</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$file is executable NFS file\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$archivo es un archivo NFS ejecutable\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes various features of OpenBSD that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documentos describe varias características de OpenBSD que afectarán a cómo Perl versión 5 (de ahora en adelante sólo Perl) es compilado y/o ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example C&lt;/(?&lt;!bar)foo/&gt;
matches any occurrence of &quot;foo&quot; that does not follow &quot;bar&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212757Z" changeid="explorer">
        <seg>Por ejemplo C&lt;/(?&lt;!bar)foo/&gt; coincide con cualquier ocurrencia de &quot;foo&quot; que no esté seguido por &quot;bar&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-1               undefined value
         0              string &quot;0 but true&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050229Z" changeid="explorer">
        <seg>-1               valor indefinido
         0              cadena &quot;0 but true&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section of the FAQ answers very general, high-level questions
about Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T195833Z" changeid="explorer">
        <seg>En esta sección de las preguntas más frecuentes se proporcionan respuestas a preguntas muy generales sobre Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the C&lt;$/&gt; and C&lt;$\&gt; variables
in L&lt;perlvar&gt; for how to manually set your input and output
line-termination sequences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver las variables C&lt;$/&gt; y C&lt;$\&gt; en L&lt;perlvar&gt; para cómo poner manualmente sus secuencias de fin de línea en su entrada y salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This often resulted in blocking operations terminating prematurely or
returning incorrect results, when Perl was executing under environments
that could generate Windows messages.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001106Z" changeid="explorer">
        <seg>A menudo, esto resultó en el bloqueo de las operaciones, finalizando antes de tiempo, o la devolución de resultados incorrectos, cuando se estaba ejecutando Perl bajo entornos que podrían generar mensajes de Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This isn't supposed to happen.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg> Se supone que esto no debe de ocurrir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows a build to complete with PERL_UNICODE set and a UTF-8 locale.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T191709Z" changeid="explorer">
        <seg>Esto permite tener una compilación con PERL_UNICODE activado y una localización de UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should post source code to whichever group is most appropriate, but
feel free to cross-post to comp.lang.perl.misc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230637Z" changeid="explorer">
        <seg>Debe publicar código fuente en el grupo más apropiado, pero también lo puede publicar en comp.lang.perl.misc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (defined($_ = &lt;STDIN&gt;)) { print; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (defined($_ = &lt;STDIN&gt;)) { print; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A lot of bugs have been fixed since v1.60, the version included in Perl
v5.8.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T173231Z" changeid="explorer">
        <seg>Muchos errores se han corregido desde v1.60, la versión incluida en Perl v5.8.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143344Z" changeid="explorer">
        <seg>Vea L&lt;perlop&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values for LEVEL can also be obtained from
getprotobyname.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores para NIVEL también se pueden obtener de getprotobyname.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta también que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How can I build my own Perl interpreter?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225803Z" changeid="explorer">
        <seg>¿Cómo puedo compilar mi propio intérprete de Perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the integer number of seconds actually slept.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número entero de segundos realmente dormidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pluggable optimizer</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>optimizador conectable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provides a faster implementation of C&lt;expand&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040101Z" changeid="explorer">
        <seg>Proporciona una implementación más rápida de C&lt;expand&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in C&lt;2 + 4 * 5&gt;, the multiplication has higher
precedence so C&lt;4 * 5&gt; is evaluated first yielding C&lt;2 + 20 ==
22&gt; and not C&lt;6 * 5 == 30&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T010118Z" changeid="explorer">
        <seg>Por ejemplo, en C&lt;2 + 4 * 5&gt;, la multiplicación tiene una precedencia mayor por lo que C&lt;4 * 5&gt; es evaluado primero, resultando C&lt;2 + 20 == 22&gt; y no C&lt;6 * 5 == 30&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;eq&quot; returns true if the left argument is stringwise equal to
the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;eq&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So C&lt;my $logmessage = shift;&gt; shifts the first item off the list of
arguments and assigns it to C&lt;$logmessage&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T230343Z" changeid="explorer">
        <seg>Así, C&lt;my $mensaje_registro = shift;&gt; quita el primer elemento de la lista de argumentos y se lo asigna a C&lt;$mensaje_registro&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl
5 interpreter was a complete re-write of the previous perl sources.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004327Z" changeid="explorer">
        <seg>El intérprete de Perl 5 fue una reescritura completa del código fuente de perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use sort '_mergesort';  # note discouraging _</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use sort '_mergesort';  # note el desalentador _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 UTF-8 On Filehandles No Longer Activated By Locale</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T140549Z" changeid="explorer">
        <seg>=head2 UTF-8 en identificadores de archivo ya no son activados por locale</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 1+2+4;      # Prints 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print 1+2+4;	# Imprime 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the position of the first occurrence of SUBSTR in STR at
or after POSITION.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la posición de la primera ocurrencia de SUBSTR en STRING en o después de POSICIÓN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;O_EXCL&gt; may not work
on network filesystems, and has no effect unless the C&lt;O_CREAT&gt; flag
is set as well.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;O_EXCL&gt; quizás no funcione en sistemas de archivos en red, y no tiene ningún efecto a menos que el indicador C&lt;O_CREAT&gt; también esté establecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason that doesn't do what you want is because assigning a
named array like that to a scalar is taking an array in scalar
context, which means just counts the number of elements in @tmp.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030238Z" changeid="explorer">
        <seg>La razón de que no hace lo que usted quiere que haga es porque la asignación de un array con nombre como si fuera un escalar es tomado como si se tomara un escalar de un array en contexto escalar, lo que significa que sólo obtenemos el número de elementos que hay en @tmp.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.MultiEdit.com/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://www.MultiEdit.com/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You
can find the latest releases at http://www.cpan.org/src/README.html .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225349Z" changeid="explorer">
        <seg>Encontrará las versiones más recientes en http://www.cpan.org/src/README.html .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596003135</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003451Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596003135</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;Module::CoreList&gt; is not installed on your system, check out
http://perlpunks.de/corelist .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231210Z" changeid="explorer">
        <seg>Si C&lt;Module::CoreList&gt; no está instalado en su sistema, visite http://perlpunks.de/corelist .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_ISBLK($mode) S_ISCHR($mode) S_ISFIFO($mode) S_ISSOCK($mode)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_ISBLK($modo) S_ISCHR($modo) S_ISFIFO($modo) S_ISSOCK($modo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>split(&quot; &quot;, q/STRING/);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031328Z" changeid="explorer">
        <seg>split(&quot; &quot;, q/CADENA/);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;cpanp&gt; is, like F&lt;cpan&gt;, a command-line interface to the CPAN, using
the C&lt;CPANPLUS&gt; module as a back-end.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235044Z" changeid="explorer">
        <seg>F&lt;cpanp&gt; es otra interfaz de línea de comandos de CPAN (una alternativa a F&lt;cpan&gt;) que usa el módulo C&lt;CPANPLUS&gt; como back-end.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;ge&quot; returns true if the left argument is stringwise greater
than or equal to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;ge&quot; devuelve verdadero si el argumento de la izquierda es alfanuméricamente mayor o igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%h = ( v65 =&gt; 42 );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015102Z" changeid="explorer">
        <seg>%h = ( v65 =&gt; 42 );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;POST_MAX&gt; doesn't cause the client to hang any more</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025245Z" changeid="explorer">
        <seg>C&lt;POST_MAX&gt; ya no provoca que el cliente se quede colgado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	and</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	and</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item while</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232633Z" changeid="explorer">
        <seg>=item while</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HP-UX</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015343Z" changeid="explorer">
        <seg>HP-UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\x&quot;        &quot;\x00&quot;    no</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204116Z" changeid="explorer">
        <seg>&quot;\x&quot;        &quot;\x00&quot;       no</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0b011011            # binary</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0b011011            # binario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The price is $Price.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El precio es $Precio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Time::Seconds;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225526Z" changeid="explorer">
        <seg>use Time::Seconds;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This safer version of L&lt;/chop&gt; removes any trailing string
that corresponds to the current value of C&lt;$/&gt; (also known as
$INPUT_RECORD_SEPARATOR in the C&lt;English&gt; module).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la versión segura de L&lt;/chop&gt;, que quita cualquier string restante que corresponda al valor actual de C&lt;$/&gt; (también conocido como $INPUT_RECORD_SEPARATOR -separador de registros en entrada- en el módulo C&lt;English&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># and UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># y UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code freeze for the next maintenance release (5.8.4) is on March 31st 2004,
with release expected by mid April.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Código congelado para la próxima versión de mantenimiento (5.8.4) será el 31 de marzo de 2004, con el lanzamiento previsto para mediados de abril.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will need to seek() to do the
reading.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Necesitará usar seek() para hacer la lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Arithmetic operators</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T233210Z" changeid="explorer">
        <seg>=item Operadores aritméticos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%  ??</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004948Z" changeid="explorer">
        <seg>%  ??</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 (Reminder) Pseudo-hashes are deprecated (really)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T010441Z" changeid="explorer">
        <seg>=head3 (Recordatorio) Pseudo-hashes están en desuso (de verdad)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># if you're building a development version</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># si está construyendo una versión de desarrollo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section of the FAQ answers questions about where to find
source and documentation for Perl, support, and
related matters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225315Z" changeid="explorer">
        <seg>Esta sección de preguntas más frecuentes indica dónde se puede obtener el código fuente y la documentación de Perl, cómo obtener soporte técnico, y ofrece información sobre otros temas relacionados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.9.0 has experimental support for assertions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142737Z" changeid="explorer">
        <seg>Perl 5.9.0 tiene soporte experimental para las aserciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
always succeeds, and its C&lt;code&gt; is not interpolated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T215614Z" changeid="explorer">
        <seg>Siempre tiene éxito, y el C&lt;código&gt; no es interpolado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;system&gt;'s arguments are executed indirectly by the shell, 
results and return codes are subject to its quirks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando los argumentos de C&lt;system&gt; son ejecutados indirectamente por el shell, los resultados y los códigos de retorno están sujetos a sus caprichos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/my&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/my&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behavior in list context depends on the particular operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T184626Z" changeid="explorer">
        <seg>El comportamiento en contexto de lista depende del propio operador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set C&lt;$Module::errstr&gt; or similar (C&lt;errstr&gt; is a common name used by
DBI and other popular modules; if you choose something else, be sure to
document it clearly).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023307Z" changeid="explorer">
        <seg>poner C&lt;$Module::errstr&gt; o similar (C&lt;errstr&gt; es un nombre común usado por DBI y otros módulos populares; si elije otro, asegúrese de documentarlo claramente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;Connect to %s [%s]\n&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Conectar a %s [%s]\n&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This warning has now been avoided by
Configure weeding out such directories before the compilation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T182757Z" changeid="explorer">
        <seg>Esta advertencia ha sido eliminada para no confundir a Configure de esos directorios antes de la compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CPANPLUS, Inline, and Module::Build will become core modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T005238Z" changeid="explorer">
        <seg>CPANPLUS, Inline, y Module::Build se convertirán en módulos principales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;File::Spec&gt; upgraded to version 3.12</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031809Z" changeid="explorer">
        <seg>C&lt;File::Spec&gt; actualizado a la versión 3.12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you may want to truncate an already-existing file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A veces puede querer truncar un archivo ya existente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$x = '56789';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$x = '56789';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>p	When matching preserve a copy of the matched string so</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>p	Cuando exista una coincidencia preserva una copia de la cadena concordante,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The J.R.R.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005829Z" changeid="explorer">
        <seg>Las citas de J.R.R.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /[fi][fi]/i;    # Doesn't match!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162309Z" changeid="explorer">
        <seg>&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /[fi][fi]/i;    # ¡No coincide!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Scalar::Util &quot;blessed&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Scalar::Util &quot;blessed&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 LIST OF UTILITIES</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233250Z" changeid="explorer">
        <seg>=head1 LISTA DE UTILIDADES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A negative OFFSET specifies writing
that many characters counting backwards from the end of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un DESPLAZAMIENTO negativo especifica escribir tantos caracteres contando desde el final de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Conditional and looping constructs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234706Z" changeid="zipf">
        <seg>=head2 Estructuras condicionales y de bucle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;fcntl&gt; raises an exception if used on a machine that
doesn't implement fcntl(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que C&lt;fcntl&gt; levanta una excepción si se utiliza en una máquina que no implemente fcntl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;O_TRUNC&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;O_TRUNC&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This surprising autovivification in what does not at first--or even
second--glance appear to be an lvalue context may be fixed in a future
release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta sorprendente autovivificación en que al primer vistazo -o incluso al segundo- parece que es un contexto lvalor quizás será arreglado en una futura distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require $class;       # $class is not a bareword</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require $clase;       # $clase no es una palabra suelta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Contributed by Dave Mitchell.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T195335Z" changeid="explorer">
        <seg>(Escrito por Dave Mitchell.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 'Hello, $name\n';     # prints $name\n literally</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T124130Z" changeid="zipf">
        <seg>print 'Hola, $nombre\n';  # imprime $nombre\n literalmente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's used as the default argument to a number of functions in Perl, and
it's set implicitly by certain looping constructs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224838Z" changeid="explorer">
        <seg>Se usa como argumento predeterminado de varias funciones de Perl y su valor se establece implícitamente en determinadas estructuras de bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's used by C&lt;Archive::Tar&gt; (see below).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T201058Z" changeid="explorer">
        <seg>Es utilizado por C&lt;Archive::Tar&gt; (ver más abajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar gethostbyaddr($myaddr, AF_INET),</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>scalar gethostbyaddr($myaddr, AF_INET),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The names I&lt;big-endian&gt; and I&lt;little-endian&gt; are comic references to the
egg-eating habits of the little-endian Lilliputians and the big-endian
Blefuscudians from the classic Jonathan Swift satire, I&lt;Gulliver's Travels&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres I&lt;big-endian&gt; y I&lt;little-endian&gt; son referencias cómicas a los hábitos alimenticios de comer huevos por el extremo pequeño de los Liliputienses y por el extremo grande de los Blefuscudianos de la clásica sátira de Jonathan Swift, I&lt;Los Viajes de Gulliver&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The UTF-8 caching code is now more efficient, and used more often.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005651Z" changeid="explorer">
        <seg>El código de cacheo de UTF-8 es ahora más eficiente, y se utiliza con más frecuencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &quot;&amp;&quot; has lower priority than relational operators, so for example
the brackets are essential in a test like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que &quot;&amp;&quot; tiene una menor prioridad que los operadores relaciones, así que, por ejemplo, los paréntesis son esenciales en una prueba como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Username is $1\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T225258Z" changeid="explorer">
        <seg>print &quot;El nombre de usuario  es $1\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item seekdir DIRHANDLE,POS
X&lt;seekdir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020956Z" changeid="explorer">
        <seg>=item seekdir IDENTIFICADOR_DIR,POS
X&lt;seekdir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some older systems, it may sleep up to a full second less than what
you requested, depending on how it counts seconds.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas antiguos, se puede dormir hasta un segundo meno de lo que ha solicitado, en función de la forma en cómo se cuenten los segundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>untie %hash;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190152Z" changeid="zipf">
        <seg>untie %hash;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@) = (')','');</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225532Z" changeid="explorer">
        <seg>@) = (')','');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All are different from C&lt;[a-z]&gt;, which
specifies a class containing twenty-six characters, even on EBCDIC-based
character sets.)  Also, if you try to use the character
classes C&lt;\w&gt;, C&lt;\W&gt;, C&lt;\s&gt;, C&lt;\S&gt;, C&lt;\d&gt;, or C&lt;\D&gt; as endpoints of
a range, the &quot;-&quot; is understood literally.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T222424Z" changeid="explorer">
        <seg>Todos son diferentes de C&lt;[a-z]&gt;, que especifica una clase que contiene veintiséis caracteres, incluso en los juegos de caracteres basados en EBCDIC.) Además, si intenta utilizar las clases de caracteres C&lt;\w&gt;, C&lt;\W&gt;, C&lt;\s&gt;, C&lt;\S&gt;, C&lt;\d&gt;, o C&lt;\D&gt; como criterios de valoración de una serie, el &quot;-&quot; es tomado de forma literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5112delta	Perl changes in version 5.11.2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5112delta	Cambios en la versión 5.11.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlunicode&gt; for more about Unicode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215516Z" changeid="explorer">
        <seg>Vea L&lt;perlunicode&gt; para más información acerca de Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;More Programming Pearls&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003733Z" changeid="explorer">
        <seg>=item I&lt;More Programming Pearls&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During this search, text between the starting and ending delimiters
is copied to a safe location.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Durante esta búsqueda, el texto entre los delimitadores inicial y final se copia a un lugar seguro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { ... ; die Some::Module::Exception-&gt;new( FOO =&gt; &quot;bar&quot; ) };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { ... ; die Some::Module::Exception-&gt;new( FOO =&gt; &quot;bar&quot; ) };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.mpeix - Perl/iX for HP e3000 MPE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.mpeix - Perl/iX para el HP e3000 MPE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of
bytes actually read, C&lt;0&gt; at end of file, or undef if there was an
error (in the latter case C&lt;$!&gt; is also set).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de bytes realmente leídos, C&lt;0&gt; al final del archivo, o undef si hubo un error (en este último caso, también se establece C&lt;$!&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means it
was never a list to start with.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que nunca será una lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The PLAINTEXT and SALT are turned
into a short string, called a digest, which is returned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T154020Z" changeid="explorer">
        <seg>El TEXTOPLANO y el SALTO se convierten en un pequeño string, llamado I&lt;digest&gt; (compendio, resumen), que es devuelto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Can your module be broken down into a family of
related modules?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014944Z" changeid="explorer">
        <seg>¿Puede su módulo dividirse en una familia de módulos relacionados?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3: '', pos=8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3: '', pos=8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hash randomisation is certain to reveal hidden assumptions about
some particular ordering of hash elements, and outright bugs: it
revealed a few bugs in the Perl core and core modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T140358Z" changeid="explorer">
        <seg>La asignación al azar de un hash sirvió para revelar suposiciones ocultas acerca de alguna ordenación particular de los elementos de un hash, y errores definitivos: reveló un par de errores en el núcleo de Perl y en los módulos básicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport/gmtime&gt; for portability concerns.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport/gmtime&gt; para problemas sobre portabilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item package NAMESPACE VERSION BLOCK
X&lt;package&gt; X&lt;module&gt; X&lt;namespace&gt; X&lt;version&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175349Z" changeid="explorer">
        <seg>=item package ESPACIO_NOMBRES VERSIÓN BLOQUE
X&lt;package&gt; X&lt;module&gt; X&lt;namespace&gt; X&lt;version&gt;
X&lt;paquete&gt; X&lt;módulo&gt; X&lt;espacio de nombres&gt; X&lt;versión&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sequence
number is reset for each range encountered.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de secuencia se reinicia para cada rango encontrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;sysseek(FH, 0, 1)&gt; for that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use C&lt;sysseek(FH, 0, 1)&gt; para eso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The copy will always be a plain string, even if the
input is an object or a tied variable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030916Z" changeid="explorer">
        <seg>La copia siempre será una cadena normal, incluso si la entrada es un objeto o una variable enlazada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;if&gt; upgraded to version 0.05</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032624Z" changeid="explorer">
        <seg>C&lt;if&gt; actualizado a la versión 0.05</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (eof()) {  # check for end of last file
            print &quot;--------------\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044141Z" changeid="explorer">
        <seg>if (eof()) {  # chequea por el final del último archivo
            print &quot;--------------\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the right operand is zero or negative, it returns an empty string
or an empty list, depending on the context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el operando derecho es cero o negativo, devuelve una cadena vacía o una lista vacía, dependiendo del contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such constructs are quite frequently used, because older versions
of Perl had no official C&lt;switch&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013507Z" changeid="explorer">
        <seg>Estas construcciones son muy frecuentes, porque las versiones anteriores de Perl no tenían oficialmente una instrucción C&lt;switch&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item require</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item require</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interprets EXPR as an octal string and returns the corresponding
value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Interpreta EXPR como una cadena en octal y devuelve el valor correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checksum is calculated by
summing numeric values of expanded values (for string fields the sum of
C&lt;ord($char)&gt; is taken; for bit fields the sum of zeroes and ones).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024421Z" changeid="explorer">
        <seg>La suma de comprobación se calcula sumando los valores numéricos de los valores expandidos (para los campos de cadena se toma la suma de C&lt;ord($char)&gt;; para los campos de bits, la suma de ceros y unos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;do&gt;, C&lt;import&gt;, C&lt;no&gt;, C&lt;package&gt;, C&lt;require&gt;, C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;do&gt;, C&lt;import&gt;, C&lt;no&gt;, C&lt;package&gt;, C&lt;require&gt;, C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'\\' =~ q'\\';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'\\' =~ q'\\';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?'NAME'pattern)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212826Z" changeid="explorer">
        <seg>=item C&lt;(?'NOMBRE'patrón)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@new = map { $_-&gt;[0] }
           sort { $b-&gt;[1] &lt;=&gt; $a-&gt;[1]
               ||
           $a-&gt;[2] cmp $b-&gt;[2]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051512Z" changeid="explorer">
        <seg>@nuevo = map { $_-&gt;[0] }
           sort { $b-&gt;[1] &lt;=&gt; $a-&gt;[1]
               ||
           $a-&gt;[2] cmp $b-&gt;[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Amongst other
things, this may have the effect of calling stdio's clearerr(3).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entre otras cosas, esto puede tener el efecto de llamar a los clearerr(3) de stdio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Community
support in places such as Perlmonks ( http://www.perlmonks.com )
and the various Perl mailing lists ( http://lists.perl.org ) means that
you can usually get quick answers to your problems.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232525Z" changeid="explorer">
        <seg>La comunidad ofrece soporte en foros como Perlmonks ( http://www.perlmonks.com )
y las distintas listas de correo de Perl ( http://lists.perl.org ). Generalmente, siempre que plantee algún problema recibirá rápidamente ayuda para solucionarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you may inspect the value of C&lt;${^CHILD_ERROR_NATIVE}&gt;
with the C&lt;W*()&gt; calls from the POSIX module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alternativamente, puede inspeccionar el valor de C&lt;${^CHILD_ERROR_NATIVE}&gt; con las llamadas C&lt;W*()&gt; desde el módulo POSIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tied methods like FETCH etc. may now safely access tied values, i.e.
resulting in a recursive call to FETCH etc.  Remember to break the
recursion, though.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T011450Z" changeid="explorer">
        <seg>Métodos enlazados como FETCH, etc ahora pueden acceder de forma segura a los valores enlazados, es decir, que resulta en una llamada recursiva a FETCH, etc. Recuerde, sin embargo, romper la recursión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of files
successfully changed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de archivos cambiados con éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item PerlBuilder</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>=item PerlBuilder</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 README, INSTALL, release notes, changelogs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024806Z" changeid="explorer">
        <seg>=head2 README, INSTALL, notas de lanzamiento, changelogs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $x;               # prints &quot;foo&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002215Z" changeid="zipf">
        <seg>print $x;               # imprime &quot;foo&quot; en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the other</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>el otro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>utf8::is_utf8() has been added as a quick way to test whether
a scalar is encoded internally in UTF-8 (Unicode).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171503Z" changeid="explorer">
        <seg>utf8::is_utf8() ha sido añadido como una forma rápida de comprobar cuándo un escalar está codificado internamente en UTF-8 (Unicode).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order, these are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En fin, estos son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, you may need
to set C&lt;$|&gt; ($AUTOFLUSH in English) or call the C&lt;autoflush()&gt; method
of C&lt;IO::Handle&gt; on any open handles.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T011952Z" changeid="explorer">
        <seg>Para estar seguro, es posible que necesite el conjunto C&lt;|&gt; ($AUTOFLUSH en English) o llame al método C&lt;autoflush()&gt; de C&lt;IO::Handle&gt; en cualquier controlador abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Unicode::Collate&gt; upgraded to version 0.52</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040945Z" changeid="explorer">
        <seg>C&lt;Unicode::Collate&gt; actualizada a la versión 0.52</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
because named unary operators are higher precedence than ||:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, debido a que los operadores unarios con nombre tienen mayor precedencia que ||:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmod - Perl modules (packages and symbol tables)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053132Z" changeid="explorer">
        <seg>perlmod - Perl modules (packages and symbol tables)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if those
operations succeed and if no error was reported by any PerlIO
layer.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023348Z" changeid="explorer">
        <seg>Devuelve verdadero si las operaciones han tenido éxito y si ningún error fue reportado por alguna capa PerlIO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use v5.14;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234628Z" changeid="explorer">
        <seg>use v5.14;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If more than one value is listed, the list must be placed
in parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se lista más de un valor, esa lista debe ser puesta entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is part of the change to allow the internal use of any code point
(see L&lt;/Core Enhancements&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T140953Z" changeid="explorer">
        <seg>Esto es parte del cambio para permitir el uso interno de cualquier punto de código (vea L&lt;/Mejoras del núcleo&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Gtk and Gtk2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T010340Z" changeid="explorer">
        <seg>=item Gtk y Gtk2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recall that which of C&lt;yes-pattern&gt; or C&lt;no-pattern&gt; actually matches is
already determined.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T000829Z" changeid="explorer">
        <seg>Recordemos que realmente ya están determinadas las coincidencias de C&lt;patrón-sí&gt; o de C&lt;patrón-no&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(IN, &quot;&lt;&quot;, $ARGV[0])</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235538Z" changeid="explorer">
        <seg>open(IN, &quot;&lt;&quot;, $ARGV[0])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For many people, Perl serves as a great replacement for shell scripting.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230827Z" changeid="explorer">
        <seg>Para muchas personas, Perl es un buen sustituto de los scripts de shell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you believe you have an unreported bug, please run the B&lt;perlbug&gt;
program included with your release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted cree que tiene un error no declarado, por favor, ejecute el programa B&lt;perlbug&gt; incluido en su distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define a named capture group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003158Z" changeid="explorer">
        <seg>Define un grupo de captura con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the form of pipe opens taking three or more arguments, if LIST is specified
(extra arguments after the command name) then LIST becomes arguments
to the command invoked if the platform supports it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la forma de tubería tomando tres o más argumentos, si se especifica LISTA (argumentos adicionales después del nombre del comando) entonces LISTA son los argumentos para el comando invocado, si la plataforma lo soporta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can intermix C&lt;m//g&gt; matches with C&lt;m/\G.../g&gt;, where C&lt;\G&gt; is a
zero-width assertion that matches the exact position where the
previous C&lt;m//g&gt;, if any, left off.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T204831Z" changeid="explorer">
        <seg>Puede entremezclar coincidencias C&lt;m//g&gt; con C&lt;m/\G.../g&gt;, donde C&lt;\G&gt; es una aserción de ancho cero que coincide con la posición exacta en que la anterior C&lt;m//g&gt;, si hubo, se detuvo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is nice, but if you forget
your trailing quote, the error will not be reported until Perl finds
another line containing the quote character, which may be much further
on in the script.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es bueno, pero si se le olvida cerrar el entrecomillado, el error no será reportado hasta que Perl encuentre otra línea que contenga el carácter de comillas, que puede estar mucho más allá en el programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,13, 2) = 2   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,13, 2) = 2   ==  134217728 00000000000000000000000000010000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item index STR,SUBSTR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item index STRING,SUBSTR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmroapi&gt; for
more information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T151726Z" changeid="explorer">
        <seg>Vea L&lt;perlmroapi&gt; para obtener más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator has the same precedence and associativity as C&lt;||&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143043Z" changeid="explorer">
        <seg>Este operador tiene la misma prioridad y asociatividad que C&lt;||&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No longer uses C&lt;Sys::Hostname&gt; as it may provide useless values in
unconfigured network environments, so instead uses C&lt;INADDR_LOOPBACK&gt; directly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035159Z" changeid="explorer">
        <seg>Ya no utiliza C&lt;Sys::Hostname&gt; ya que puede proporcionar valores inútiles en entornos de red sin configurar, así que, en vez de eso, utiliza C&lt;INADDR_LOOPBACK&gt; directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BEFORE YOU START WRITING A MODULE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014340Z" changeid="explorer">
        <seg>=head1 ANTES DE COMENZAR A ESCRIBIR UN MÓDULO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One is for generating predictable results generally for
testing or debugging.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183035Z" changeid="explorer">
        <seg>Uno de ellos es para la generación de resultados predecibles, generalmente para pruebas o depuraciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid this warning, make sure to pad
your octal number with C&lt;0&gt;'s: C&lt;&quot;\0128&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T211044Z" changeid="explorer">
        <seg>Para evitar la aparición de esta advertencia, asegúrese de rellenar su número octal con C&lt;0&gt;: C&lt;&quot;\0128&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $file (@ARGV) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $archivo (@ARGV) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Network Programming with Perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003556Z" changeid="explorer">
        <seg>=item I&lt;Network Programming with Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,15, 2) = 1   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,15, 2) = 1   == 1073741824 00000000000000000000000000000010</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PAT{min,max}+       (?&gt;PAT{min,max})</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232354Z" changeid="explorer">
        <seg>PAT{min,max}+       (?&gt;PAT{min,max})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They're also supported as operators in their own
right.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T182510Z" changeid="zipf">
        <seg>Son también operadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PRINT this, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>PRINT este, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\c@      chr(0)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034617Z" changeid="explorer">
        <seg>\c@      chr(0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redeclaration of &quot;sendpath&quot; with a different storage class specifier:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003819Z" changeid="explorer">
        <seg>Redeclaración de &quot;sendpath&quot; con un especificador de clase de almacenamiento especifico:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the next character from the input file attached to FILEHANDLE,
or the undefined value at end of file or if there was an error (in
the latter case C&lt;$!&gt; is set).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010724Z" changeid="explorer">
        <seg>Devuelve el siguiente carácter desde el archivo de entrada asociado a IDENTIFICADOR_ARCHIVO, o el valor indefinido al final del archivo, o si ocurrió un error (en este último caso, se actualiza C&lt;$!&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@chars = split //, $string;                  # // is not magic in split</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231001Z" changeid="explorer">
        <seg>@chars = split //, $string;                  # // no es mágico en split</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lib/Net/servent failure seems to be a bug in the test
program.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T002308Z" changeid="explorer">
        <seg>El error en lib/Net/servent parece que es un error en el programa de pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_ISREG($mode) S_ISDIR($mode) S_ISLNK($mode)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_ISREG($modo) S_ISDIR($modo) S_ISLNK($modo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Sys::Syslog&gt; has been changed to protect people from poor quality third
party code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044755Z" changeid="explorer">
        <seg>C&lt;Sys::Syslog&gt; ha sido cambiado para proteger a los usuarios de la pobre calidad del código de terceros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New &quot;Possible precedence problem on bitwise %c operator&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T002336Z" changeid="explorer">
        <seg>=head2 Nuevo &quot;I&lt;Possible precedence problem on bitwise %c operator&gt;&quot; (Posible problema de precedencia en el operador de bit %c)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>when EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getprotobynumber NUMBER</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getprotobynumber NÚMERO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;-|&quot;, &quot;cat -n '$file'&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T233650Z" changeid="explorer">
        <seg>open(FOO, &quot;-|&quot;, &quot;cat -n '$archivo'&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%010.6x&gt;', 1;   # prints &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%010.6x&gt;', 1;   # imprime &quot;&lt;    000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no real file descriptor at the OS
level, as can happen with filehandles connected to memory objects via
C&lt;open&gt; with a reference for the third argument, -1 is returned.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010334Z" changeid="explorer">
        <seg>Si no hay un descriptor de archivo real al nivel del sistema operativo, como puede suceder con identificadores de archivo relacionados con objetos de memoria a través de C&lt;open&gt; con una referencia para el tercer argumento, se devuelve -1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the integer operation provides scalar context for the &lt;&gt;
operator, which responds by reading one line from STDIN and passing it
back to the integer operation, which will then find the integer value
of that line and return that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>la operación int establece un contexto escalar para el operador &lt;&gt;, que responde leyendo una línea de STDIN y enviándola de vuelta a la operación int, la cual entonces busca el valor entero de esa línea y lo devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can always put another block inside of it
(for C&lt;next&gt;) or around it (for C&lt;last&gt;) to do that sort of thing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre puede poner otro bloque dentro de él  (para C&lt;next&gt;) o alrededor de él (para C&lt;last&gt;) para hacer esta suerte de cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>white wine</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vino blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PerlIO::via layers can now have an optional UTF8 method to
indicate whether the layer wants to &quot;auto-:utf8&quot; the stream.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171423Z" changeid="explorer">
        <seg>Las capas PerlIO::via pueden tener ahora un método UTF8 opcional para indicar cuándo la capa requiere que el flujo active &quot;:utf8&quot; de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pos</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item pos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item pop</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item pop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: Use of lexical (C&lt;my&gt;) variables in these blocks is
broken.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T223350Z" changeid="explorer">
        <seg>B&lt;AVISO&gt;: El uso de variables léxicas (C&lt;my&gt;) en estos bloques está
roto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} while $x++ &lt;= $z;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} while $x++ &lt;= $z;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T190203Z" changeid="explorer">
        <seg>my $parentesis = qr/(\((?:[^()]++|(?-1))*+\))/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>xX         Make x and X act as alignment commands.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>xX         Hace x y X actuar como comandos de alineamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>normal tomato</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tomate normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That is, all characters not matching
C&lt;/[A-Za-z_0-9]/&gt; will be preceded by a backslash in the
returned string, regardless of any locale settings.)
This is the internal function implementing
the C&lt;\Q&gt; escape in double-quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Es decir, todos los caracteres que no se ajusten a C&lt;/[A-Za-z_0-9]/&gt; serán precedidos por una barra invertida en la cadena devuelta, con independencia de cualquier configuración regional). Esta es la función interna que implementa el escapado de C&lt;\Q&gt; en las cadenas con doble entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;\$$x++&quot;;  # CASE 5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;\$$x++&quot;;  # CASO 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore C&lt;-&gt; in C&lt;tr'''&gt; and C&lt;y'''&gt; is treated literally
as a hyphen and no character range is available.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo tanto, C&lt;-&gt; en C&lt;tr'''&gt; y C&lt;y'''&gt; es tratado, literalmente, como un guion, y por lo tanto no está disponible un intervalo de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PerlIO will become The Default.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T013554Z" changeid="explorer">
        <seg>PerlIO se convertirá en el predeterminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since
Perl 5.8.1 the ordering can be different even between different runs of
Perl for security reasons (see L&lt;perlsec/&quot;Algorithmic Complexity
Attacks&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165205Z" changeid="explorer">
        <seg>Desde Perl 5.8.1 la ordenación puede ser diferente incluso entre diferentes ejecuciones de Perl por razones de seguridad (ver L&lt;perlsec/&quot;Ataques por Complejidad Algorítmica&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This sets @ARGV to all plain text files if no @ARGV was given:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto establecerá @ARGV a todos los archivos de texto sin formato si no se indicó nada a @ARGV:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A word that has no other interpretation in the grammar will
be treated as if it were a quoted string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una palabra que no tiene otra interpretación en la gramática será tratada como si fuera una cadena entrecomillada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RedHat users should see https://rhn.redhat.com/errata/RHBA-2003-136.html
and consider upgrading their glibc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los usuarios de RedHat deberían ver la página https://rhn.redhat.com/errata/RHBA-2003-136.html y considerar la actualización de sus glibc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Content-Type: text/plain; charset=UTF-8&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235401Z" changeid="explorer">
        <seg>&quot;Content-Type: text/plain; charset=UTF-8&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| die &quot;open failed: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235432Z" changeid="explorer">
        <seg>|| die &quot;falló el open: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;\b&gt; X&lt;\A&gt; X&lt;\Z&gt; X&lt;\z&gt; X&lt;/m&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;\b&gt; X&lt;\A&gt; X&lt;\Z&gt; X&lt;\z&gt; X&lt;/m&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those loops
that scan for many short constant strings (including the constant
parts of more complex patterns) will benefit most.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los bucles que escanean por muchas cadenas constantes cortas (incluidas las partes constante de patrones más complejos) serán los más beneficiados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use List::Util qw(first);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225554Z" changeid="explorer">
        <seg>use List::Util qw(first);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One more rule is needed to understand how a match is determined for the
whole regular expression: a match at an earlier position is always better
than a match at a later position.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001057Z" changeid="explorer">
        <seg>Una regla más que se necesita para entender cómo se determina una coincidencia por parte de la expresión regular completa: una coincidencia en una posición anterior es siempre mejor que una coincidencia en una posición más tardía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with Perl 5.14, C&lt;each&gt; can take a scalar EXPR, which must hold
reference to an unblessed hash or array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T160223Z" changeid="explorer">
        <seg>A partir de Perl 5.14, C&lt;each&gt; puede tomar una EXPR escalar, que debe contener la referencia a un hash o un array no bendecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item close FILEHANDLE
X&lt;close&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005500Z" changeid="explorer">
        <seg>=item close IDENTIFICADOR_ARCHIVO
X&lt;close&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@info = stat($file) || die;     # oops, scalar sense of stat!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@info = stat($archivo) || die;     # ¡oops, sentido escalar de stat!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item caller</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item caller</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that under Perls older than 5.8.0, Perl uses the standard C library's'
fdopen() to implement the C&lt;=&gt; functionality.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005005Z" changeid="explorer">
        <seg>Tenga en cuenta que si está usando un Perl más viejo que 5.8.0, Perl usa las bibliotecas estándar C de fdopen() para implementar la funcionalidad de C&lt;=&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/my.STRING/foo/is;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s/mi.CADENA/foo/is;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular macros which create temporary
local variables now name these variables more defensively, which should
avoid bugs where names clash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En ciertas macros que crean variables locales temporales se nombra ahora estas variables de forma más defensiva, que deberían evitar errores con la coincidencia de nombres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;/etc/games is no good&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;/etc/games no está bien&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item podlators</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015242Z" changeid="explorer">
        <seg>=item podlators</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { $x };    # CASE 4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { $x };    # CASO 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl589delta	Perl changes in version 5.8.9</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl589delta	Cambios en la versión 5.8.9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You probably shouldn't rely upon the C&lt;warn()&gt; being podded out forever.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Probablemente no se dará cuenta de que el C&lt;warn()&gt; ha sido comentado para siempre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it is likely that new data types may be later introduced
into the system, and will need to be handled by existing code</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020011Z" changeid="explorer">
        <seg>Cuando es probable que los nuevos tipos de datos pueden ser posteriormente introducidos en el sistema, y tendrán que ser manejados por el código existente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix a bug in the security taint checking of open()</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>arreglado un error en la comprobación de seguridad aceitosa de open()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does not check the full
stack, but only the name of the innermost active recursion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195725Z" changeid="explorer">
        <seg>No comprueba la pila completa, sino sólo el nombre de la recursión activa más interna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-C  Same for inode change time (Unix, may differ for other platforms)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-C  Lo mismo, para el cambio de la fecha del inodo (en Unix, puede diferir en otras plataformas)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;mkpath&gt; now preserves C&lt;errno&gt; when C&lt;mkdir&gt; fails</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031757Z" changeid="explorer">
        <seg>C&lt;mkpath&gt; ahora preserva C&lt;errno&gt; cuando C&lt;mkdir&gt; falla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use a here-document to assign an array, one line per element,
you might use an approach like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para usar un documento embebido para asignar a un array, una línea por elemento, puede usar un enfoque como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(?s-i:more.*than).*million/i</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T232421Z" changeid="explorer">
        <seg>/(?s-i:más.*que).*millones/i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@days[3,4,5]	# same as ($days[3],$days[4],$days[5])</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@dias[3,4,5]	# igual que ($dias[3],$dias[4],$dias[5])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global matching, and keep the Current position after failed matching.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Coincidencia global, y almacenar la posición actual después de una coincidencia fallida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl
uses the same mechanism to produce C&lt;$1&gt;, C&lt;$2&gt;, etc, so you also pay a
price for each pattern that contains capturing parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T192029Z" changeid="explorer">
        <seg>Perl utiliza el mismo mecanismo para producir C&lt;$1&gt;, C&lt;$2&gt;, etc, por lo que también paga un precio para cada patrón que contenga paréntesis de captura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use parentheses for functions' arguments or omit them
according to your personal taste.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224755Z" changeid="explorer">
        <seg>Puede escribir los argumentos de las funciones entre paréntesis u omitir los paréntesis, si lo prefiere.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Should you instead prefer an exception, do this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182338Z" changeid="explorer">
        <seg>Si en vez de eso, prefiere una excepción, haga lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't know what license to use, dual licensing under the GPL
and Artistic licenses (the same as Perl itself) is a good idea.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031106Z" changeid="explorer">
        <seg>Si no sabe qué licencia usar, es una buena idea el licenciamiento dual bajo la GPL y la licencia Artistic (la misma que Perl).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@part = ();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194659Z" changeid="explorer">
        <seg>@part = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run C&lt;perldoc
perldoc&gt; to learn more things you can do with F&lt;perldoc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000130Z" changeid="explorer">
        <seg>Ejecute C&lt;perldoc perldoc&gt; para ver qué más puede hacer con &lt;perldoc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item system PROGRAM LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item system PROGRAMA LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11993</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11993</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Useless use of integer addition in void context at - line 1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Useless use of integer addition in void context at - line 1.
(Inútil uso de suma de enteros en contexto void en - línea 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chr() on a negative value now gives C&lt;\x{FFFD}&gt;, the Unicode replacement
character, unless when the C&lt;bytes&gt; pragma is in effect, where the low
eight bytes of the value are used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035905Z" changeid="explorer">
        <seg>chr() de un valor negativo ahora da C&lt;\x{FFFD}&gt;, el carácter Unicode de reemplazo, salvo si está activo el pragma C&lt;bytes&gt;, en cuyo caso se utiliza los ocho bits más bajos, del valor indicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Term::ANSIColor</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014845Z" changeid="explorer">
        <seg>=item Term::ANSIcolor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;av_*()&gt; functions, used to manipulate arrays, no longer accept null
C&lt;AV*&gt; parameters.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T041410Z" changeid="explorer">
        <seg>Las funciones C&lt;av_*()&gt;, usadas para manipular array, ya no aceptan parámetros C&lt;AV*&gt; nulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U16 kflags;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114003Z" changeid="explorer">
        <seg>U16 kflags;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As far as I can tell, this is caused by
a bug in the BeOS pipes implementation that occurs when starting other child
processes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001948Z" changeid="explorer">
        <seg>Por lo que puedo decir, es causado por un error en la implementación de las tuberías en BeOS que se produce cuando se inicia otro proceso hijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return int((((localtime(shift || time))[5] + 1999))/100);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225523Z" changeid="explorer">
        <seg>return int((((localtime(shift || time))[5] + 1999))/100);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not confuse this behavior with the behavior of
backslash within a string, although both forms do convey the notion
of protecting the next thing from interpolation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se debe confundir este comportamiento con el comportamiento de una barra diagonal inversa en una cadena, aunque ambas formas transmiten la idea de proteger a lo que sigue de ser interpolado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$number = 0b10110110;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225515Z" changeid="explorer">
        <seg>$number = 0b10110110;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (my $line = &lt;STDIN&gt;) { print $line }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (my $linea = &lt;STDIN&gt;) { print $linea }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current priority for a process, a process group, or a user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la prioridad actual de un proceso, un grupo de procesos o un usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to numeric backreferences, except that
the group is designated by name and not number.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T214643Z" changeid="explorer">
        <seg>Similar a las referencias inversas numéricas, excepto que el grupo es designado por nombre y no por número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl594delta	Perl changes in version 5.9.4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl594delta	Cambios en la versión 5.9.4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item flags</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item banderas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;$hints&gt; and C&lt;$bitmask&gt; values are subject to change
between versions of Perl, and are not meant for external use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores C&lt;$hints&gt; y C&lt;$bitmask&gt; están sujetos a cambios entre versiones de Perl y no se espera que sean utilizados para uso externo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
core, the standard Perl library, the optional modules, and the
documentation you're reading now were all written by volunteers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200042Z" changeid="explorer">
        <seg>El núcleo, la biblioteca Perl estándar, los módulos opcionales y esta documentación han sido desarrollados por voluntarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\S      A non-whitespace character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110220T232247Z" changeid="explorer">
        <seg>[parcial]\S	     Coincide con un carácter que en es espacio en blanco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ternary &quot;?:&quot; is the conditional operator, just as in C.  It works much
like an if-then-else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ternario &quot;?:&quot; es el operador condicional, al igual que en C. Funciona como un if-then-else.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_ISENFMT($mode) S_ISWHT($mode)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_ISENFMT($modo) S_ISWHT($modo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&lt;=&quot; returns true if the left argument is numerically less than
or equal to the right argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&lt;=&quot; devuelve verdadero si el argumento de la izquierda es numéricamente menor o igual que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sq = square(8);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235518Z" changeid="zipf">
        <seg>$sq = cuadrado(8);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FAILED at test 250</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214817Z" changeid="explorer">
        <seg>FAILED at test 250</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 F&lt;MANIFEST&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014957Z" changeid="explorer">
        <seg>=head2 F&lt;MANIFEST&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new operator C&lt;//&gt; (defined-or) has been implemented.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030742Z" changeid="explorer">
        <seg>Se ha implementado un nuevo operador: C&lt;//&gt; (definido-o).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to write conditionals without
curly brackets there are several other ways to do it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere escribir condicionales sin llaves hay varias formas de hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring a subroutine allows a subroutine name to be used as if it were a
list operator from that point forward in the program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Declarar una subrutina permite que su nombre sea usado como si fuera un operador de lista, desde el punto de vista del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Patch, extend or subclass an existing module where possible</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013423Z" changeid="explorer">
        <seg>Parchee, amplíe o derive de un módulo existente siempre que sea posible</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,@#,@#) = @&lt;&lt; == @######### @&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,@#,@#) = @&lt;&lt; == @######### @&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contents</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Contenido</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@a = @b ? @b : @c;		# this works fine, though</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053420Z" changeid="explorer">
        <seg>@a = @b ? @b : @c;		# aunque esto también funciona</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 'STRING'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 'CADENA'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub/&quot;Temporary Values via local()&quot;&gt;
for details, including issues with tied arrays and hashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub/&quot;Valores temporales con local()&quot;&gt; para más detalles, incluidas las cuestiones relativas a arrays y hash enlazadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Tru64: No threaded builds with GNU cc (gcc)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T004328Z" changeid="explorer">
        <seg>=head2 Tru64: No compilación con threaded con el GNU cc (gcc)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, C&lt;localtime()&gt; uses the current time (as returned
by time(3)).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, C&lt;localtime()&gt; utiliza la hora actual (devuelta por time(3)).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is B&lt;&quot;The Artistic License&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es B&lt;&quot;La Licencia Artística&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, $arg) or warn &quot;Can't open $arg: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $fh, $arg) or warn &quot;No puedo abrir $arg: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An illegal user-defined Unicode casemapping was specified.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003128Z" changeid="explorer">
        <seg>Se ha especificado un mapeo Unicode de caja ilegal definido por el usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>break when 'vote';      # My vote cannot be bought</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223457Z" changeid="explorer">
        <seg>break when 'voto';      # Mo voto no puede ser comprado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>named uops              if     ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224219Z" changeid="explorer">
        <seg>ops unarios con nombre  if     ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(-s $file) + 1024  # correct</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T152724Z" changeid="explorer">
        <seg>(-s $archivo) + 1024  # correcto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider how the pattern
above detects no-match on C&lt;((()aaaaaaaaaaaaaaaaaa&gt; in several
seconds, but that each extra letter doubles this time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T214359Z" changeid="explorer">
        <seg>Considere cómo el patrón anterior detecta una no-coincidencia en C&lt;((()aaaaaaaaaaaaaaaaaa&gt; en unos segundos, pero que cada letra adicional duplica ese tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The API</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013456Z" changeid="explorer">
        <seg>=head2 LA API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if layers are specified in the
three-argument form, then default layers stored in ${^OPEN} (see L&lt;perlvar&gt;;
usually set by the B&lt;open&gt; pragma or the switch B&lt;-CioD&gt;) are ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que si las capas se especifican en la forma de tres argumentos, entonces las capas por defecto almacenadas en ${^OPEN} (ver L&lt;perlvar&gt;; normalmente fijados por el pragma B&lt;open&gt; o la opción B&lt;-CioD&gt;) son ignoradas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;podselect|podselect&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233431Z" changeid="explorer">
        <seg>=item L&lt;podselect|podselect&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the absolute value of its argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor absoluto del argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See C&lt;(*SKIP)&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T140740Z" changeid="explorer">
        <seg>Vea C&lt;(*SKIP)&gt; para obtener más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item size</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item tamaño</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the following secret stuff will be
ignored by both the compiler and the translators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que el siguiente material secreto será ignorado tanto por el compilador como por los traductores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is written in the POD format (see perlpod manpage) which is
specially designed to be readable as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está escrito en formato POD (ver la página de manual perlpod) que está específicamente diseñado para ser legible de forma sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;suidperl&gt; has been removed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T235442Z" changeid="explorer">
        <seg>C&lt;suidperl&gt; ha sido eliminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do_something_else;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hacer_algo_despues;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, certain
network operations have their own blocking and timeout mechanisms, and
being able to interrupt them immediately would be nice.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T152715Z" changeid="explorer">
        <seg>Por ejemplo, ciertas operaciones de red tienen sus propios mecanismos de bloqueo de tiempo de espera, y ser capaz de interrumpirles de inmediato estaría bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use v5.10;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234450Z" changeid="explorer">
        <seg>use v5.10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = &quot;I have 2 numbers: 53147&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050441Z" changeid="explorer">
        <seg>$_ = &quot;Tengo 2 números: 53147&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context or if the left
operand is not enclosed in parentheses, it returns a string consisting
of the left operand repeated the number of times specified by the right
operand.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el contexto escalar o si el operando izquierdo no está encerrado entre paréntesis, devuelve una cadena consistente en el operando de la izquierda repetido el número de veces especificado por el operando de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = @foo[0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = @foo[0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;Mastering Regular Expressions&gt; by Jeffrey Friedl, published
by O'Reilly and Associates.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045912Z" changeid="explorer">
        <seg>I&lt;Mastering Regular Expressions&gt; de Jeffrey Friedl, publicado por O'Reilly y Asociados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Non-threaded Perl on DG/UX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Perl sin I&lt;threads&gt; en DG/UX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the EXPR can be arbitrarily complicated as long as the final
operation is a hash or array key lookup or subroutine name:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que EXPR puede ser todo lo arbitrariamente complicada que se quiera con tal de que la operación final sea un escalar de un hash o de un array o el nombre de una subrutina:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at - line 2001.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at - line 2001.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, people can
set their I/O to be by default UTF8-encoded Unicode, not bytes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005011Z" changeid="explorer">
        <seg>También, el personal puede poner su I/O para que sea codificado por defecto en Unicode UTF-8, y no en bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE:&gt; In order to make things easier for programmers with experience
with the Python or PCRE regex engines, the pattern C&lt;&lt; (?PE&lt;lt&gt;NAMEE&lt;gt&gt;pattern) &gt;&gt;
may be used instead of C&lt;&lt; (?&lt;NAME&gt;pattern) &gt;&gt;; however this form does not
support the use of single quotes as a delimiter for the name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T222601Z" changeid="explorer">
        <seg>B&lt;NOTA:&gt; Con el fin de facilitar las cosas a los programadores con experiencia en Python o motores regex PCRE, el patrón C&lt;&lt; (?PE&lt;lt&gt;NOMBREE&lt;gt&gt;patrón) &gt;&gt; puede ser usado en lugar de C&lt;&lt; (?&lt;NOMBRE&gt;patrón) &gt;&gt;; sin embargo, esta forma no soporta el uso de comillas simples como un delimitador para el nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three forms of hooks: subroutine
references, array references, and blessed objects.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011413Z" changeid="explorer">
        <seg>Hay tres formas de enganches: referencias a subrutinas, referencias a arrays y objetos bendecidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^$/                nothing in the string (start and end are adjacent)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T121804Z" changeid="zipf">
        <seg>/^$/                cadena vacía (principio y final contiguos)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to enhance the mechanism of subroutine hooks in @INC by
adding a source filter on top of the filehandle opened and returned by the
hook.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T001445Z" changeid="explorer">
        <seg>Es posible mejorar el mecanismo de enganche de subrutinas en @INC añadiendo un filtro de código fuente por encima del identificador de archivo abierto y devuelto por el enganche.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To omit an element, return an empty list ().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171720Z" changeid="explorer">
        <seg>Para omitir un elemento, devuelva una lista vacía ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If in doubt, spell out the
character sets in full.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de duda, explicite los conjuntos de caracteres completamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;last&gt; cannot be used to exit a block that returns a value such as
C&lt;eval {}&gt;, C&lt;sub {}&gt;, or C&lt;do {}&gt;, and should not be used to exit
a grep() or map() operation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000033Z" changeid="explorer">
        <seg>C&lt;last&gt; no puede usarse para salir de un bloque que devuelve un valor como en C&lt;eval {}&gt;, C&lt;sub {}&gt; o C&lt;do {}&gt;, y no debe ser usado para salir de una operación grep() o map().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Support for building perl with Microsoft's 64-bit compiler has been
improved.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005750Z" changeid="explorer">
        <seg>Se ha mejorado el soporte para la compilación de perl con el compilador de 64 bits de Microsoft.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@idx[$p-1,$q]=@idx[$q,$p-1];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>@idx[$p-1,$q]=@idx[$q,$p-1];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values
for WHENCE are C&lt;0&gt; to set the new position to POSITION; C&lt;1&gt; to set the it
to the current position plus POSITION; and C&lt;2&gt; to set it to EOF plus
POSITION, typically negative.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T020841Z" changeid="explorer">
        <seg>Los valores de DÓNDE son C&lt;0&gt; para establecer la nueva posición a POSICIÓN; C&lt;1&gt; para establecerla a la actual más POSICIÓN; y C&lt;2&gt; para establecerla a EOF más POSICIÓN, normalmente negativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;version is v%vd\n&quot;, $^V;     # Perl's version</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;versión es v%vd\n&quot;, $^V;     # Versión de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>y{}{}	  Transliteration	  no (but see below)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230854Z" changeid="explorer">
        <seg>y{}{}     Transliteración	  no (pero vea abajo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;-&quot; is also taken literally when it is
at the end of the list, just before the closing &quot;]&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212925Z" changeid="explorer">
        <seg>&quot;-&quot; es también tomado literalmente cuando se encuentra al final de la lista, justo antes del &quot;]&quot; final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11549</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11549</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If none of the above apply, for backwards compatibility reasons, the
C&lt;/d&gt; modifier is the one in effect by default.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T235918Z" changeid="explorer">
        <seg>Si no se puede aplicar ninguna de las situaciones anteriores, por razones de compatibilidad, el modificador C&lt;/d&gt; es el que está activo de manera predeterminada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11541</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11541</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;FILE&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T010528Z" changeid="explorer">
        <seg>while (&lt;ARCHIVO&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all pod translators are well-behaved in this regard, and perhaps
the compiler will become pickier.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No todos los traductores pod están bien entrenados a este respecto y quizá el compilador sea más quisquilloso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LOCK_NB is bitwise-or'ed with
LOCK_SH or LOCK_EX, then C&lt;flock&gt; returns immediately rather than blocking
waiting for the lock; check the return status to see if you got it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T234336Z" changeid="explorer">
        <seg>Si LOCK_NB se combina a nivel de bit con 'or' con LOCK_SH o LOCK_EX entonces C&lt;flock&gt; regresa inmediatamente en vez de bloquear esperando por el cerrojo; compruebe el valor de estado devuelto para ver si lo ha conseguido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; binary</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T134630Z" changeid="explorer">
        <seg>&gt; binary</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two
elements of the list must be the I&lt;numeric&gt; uid and gid, in that
order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los primeros dos elementos de la lista deben ser el valor I&lt;numérico&gt; del uid y gid, en este orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although exists() will return false for deleted entries,
deleting array elements never changes indices of existing values; use shift()
or splice() for that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque exists() devolverá falso para entradas eliminadas, eliminar elementos del array nunca cambia los índices de los valores existentes; use en su lugar shift() o splice().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require v5.6.1;     # run time version check</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require v5.6.1;     # comprobación de versión en tiempo de ejecución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now back to the regularly scheduled documentation...&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora volvamos a la documentación normal...&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>...;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you would like to know about a version dependency before you
start running the program, put something like this at its top:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T182443Z" changeid="explorer">
        <seg>Si quiere saber acerca de las dependencias de la versión antes de empezar a ejecutar el programa, poner algo como esto en su parte superior:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following people are known to
have contributed the improvements that became Perl 5.12.3:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T231233Z" changeid="explorer">
        <seg>De las siguientes personas se sabe que han contribuido con mejoras que hicieron posible Perl 5.12.3:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is, however, syntax checked at
compile-time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Será, sin embargo, comprobada la sintaxis en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say $sentences;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025250Z" changeid="explorer">
        <seg>say $sentencias;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;.IX blurfl\n&quot; if /\bblurfl\b/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;.IX blurfl\n&quot; if /\bblurfl\b/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatically calls
C&lt;srand&gt; unless C&lt;srand&gt; has already been called.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Automáticamente llama a C&lt;srand&gt; a menos que C&lt;srand&gt; ya haya sido llamado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to pack() or unpack() a C structure like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, para pack() o unpack() una estructura en C como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a filter has been installed with this method, it will be invoked
every time you read a key from a DBM database.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110812T144614Z" changeid="zipf">
        <seg>Si se ha instalado un filtro con este método, se invocará cada vez que se lea una clave de una base de datos DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print STDOUT &quot;stdout 2\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print STDOUT &quot;stdout 2\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The elements we're getting from the array start with a C&lt;$&gt; because
we're getting just a single value out of the array; you ask for a scalar,
you get a scalar.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224905Z" changeid="explorer">
        <seg>Los nombres de los elementos que obtenemos del array empiezan por C&lt;$&gt; porque reciben valores individuales del array; si se pide un escalar, se obtiene un escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>native floating_point --&gt; decimal string		(*)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T112937Z" changeid="explorer">
        <seg>punto flotante nativo --&gt; cadena decimal (*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data::Dumper: option to sort hashes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Data::Dumper: opción para abreviar hashes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These permission values need to be in octal, and are modified by your
process's current C&lt;umask&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos valores de permisos tiene que estar en octal, y son modificados por el valor de C&lt;umask&gt; de su proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(SunOS, Solaris, HP-UX)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015010Z" changeid="explorer">
        <seg>(SunOS, Solaris, HP-UX)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take care when using patterns that include C&lt;\G&gt; in an alternation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado al utilizar patrones que incluyan C&lt;\G&gt; en una alternativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it much easier for tools such as
web browsers to wrap it, but might confuse any automatic tools which perform
detailed parsing of Carp output.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T102813Z" changeid="explorer">
        <seg>Esto hace que sea mucho más fácil para las herramientas como los navegadores web para ajustar la presentación, pero podría confundir a cualquier herramienta automática que llevase a cabo un análisis detallado de la salida de Carp.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's reasonably easy to
understand, and almost everything that applies here will also be applicable
later on with the fancier data structures.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T025846Z" changeid="explorer">
        <seg>Es razonablemente fácil de entender, y casi todo lo que se aplica aquí también se aplicará más tarde con las estructuras de datos más elaborados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will also probe for C&lt;futimes&gt; (and use it
internally if available), and whether C&lt;sprintf&gt; correctly returns the
length of the formatted string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T034616Z" changeid="explorer">
        <seg>También probará por C&lt;futimes&gt; (y lo usará internamente si está disponible), y también por si C&lt;sprintf&gt; devuelve correctamente la longitud de la cadena formateada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On EBCDIC systems, the first example would be</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas EBCDIC, el primer ejemplo sería</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $db;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190145Z" changeid="zipf">
        <seg>undef $db;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the right argument is an expression rather than a search pattern,
substitution, or transliteration, it is interpreted as a search pattern at run
time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el argumento derecho es una expresión en lugar de un patrón de búsqueda, sustitución o transliteración, se interpreta como un patrón de búsqueda en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BEGIN { require Module; Module-&gt;import( LIST ); }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BEGIN { require Módulo; Módulo-&gt;import( LISTA ); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>h  A hex string (low nybble first).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>h  Una cadena hexadecimal (primero el nibble bajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in paragraph
mode (C&lt;$/ = &quot;&quot;&gt;), it removes all trailing newlines from the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En modo párrafo (C&lt;$/ = &quot;&quot;&gt;), elimina todos los caracteres de nueva línea del string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item s///</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item s///</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional expression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T193501Z" changeid="explorer">
        <seg>Expresión condicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sethostent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sethostent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11594</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11594</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &quot;Environment access&quot; in
the F&lt;INSTALL&gt; file for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215140Z" changeid="explorer">
        <seg>Vea &quot;Acceso al entorno&quot; en el fichero F&lt;INSTALL&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or xor           |     alternation      \s == whitespace
                   \b    word boundary    \w == word characters
                   \z    string end       \d == digits</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224306Z" changeid="explorer">
        <seg>or xor           |     alternancia              \s == espacio en blanco
                   \b    límite de palabra        \w == caracteres de palabra
                   \z    fin cadena               \d == dígitos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#foo];	# an expensive no-op</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034319Z" changeid="explorer">
        <seg>$#foo];		# una costosa no-operación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In time critical applications it behooves you not to split
into more fields than you really need.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En aplicaciones de tiempo crítico no es conveniente dividir en más campos de los que realmente necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>display_week();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021343Z" changeid="explorer">
        <seg>muestra_semana();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Details in L&lt;/&quot;/x&quot;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162902Z" changeid="explorer">
        <seg>Detalles en L&lt;/&quot;/x&quot;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@z2 = (&quot;01&quot; ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224423Z" changeid="explorer">
        <seg>@z2 = (&quot;01&quot; ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Modules;       /$userinput/     perl.apache.org</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224327Z" changeid="explorer">
        <seg>use Modules;       /$entrada_usuario/     perl.apache.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	&lt; &gt; &lt;= &gt;= lt gt le ge</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	&lt; &gt; &lt;= &gt;= lt gt le ge</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator
overloading allows user-defined behaviors for numbers, such as operations
over arbitrarily large integers, floating points numbers with arbitrary
precision, operations over &quot;exotic&quot; numbers such as modular arithmetic or
p-adic arithmetic, and so on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T112630Z" changeid="explorer">
        <seg>que permite establecer comportamientos definidos por el usuario para números, como operaciones con enteros arbitrariamente grandes, números de punto flotante de precisión arbitraria, operaciones con números &quot;exóticos&quot; (como la aritmética modular o la aritmética de números p-ádicos), etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item System V interprocess communication functions
X&lt;IPC&gt; X&lt;System V&gt; X&lt;semaphore&gt; X&lt;shared memory&gt; X&lt;memory&gt; X&lt;message&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202258Z" changeid="explorer">
        <seg>=item Funciones de comunicación interprocesos System V
X&lt;IPC&gt; X&lt;System V&gt; X&lt;semaphore&gt; X&lt;shared memory&gt; X&lt;memory&gt; X&lt;message&gt; X&lt;semáforo&gt; X&lt;memoria compartida&gt; X&lt;memoria&gt; X&lt;mensaje&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldsc		Perl data structures intro</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldsc		Introducción a las estructuras de datos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But if you try this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero si intenta esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11589</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11589</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$vector = &quot;\xff\x0f\xef\xfe&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>$vector = &quot;\xff\x0f\xef\xfe&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@lines) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach (@lineas) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== != &lt;=&gt; eq ne cmp ~~</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005840Z" changeid="explorer">
        <seg>== != &lt;=&gt; eq ne cmp ~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opendir(my $dh, $some_dir) || die &quot;can't opendir $some_dir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>opendir(my $dh, $algun_dir) || die &quot;no puedo opendir $algun_dir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric literals are specified in any of the following floating point or
integer formats:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los literales numéricos se especifican en cualquiera de los siguientes formatos de punto flotante o entero:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TERM has the highest precedence in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un TÉRMINO tiene la mayor precedencia en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can actually put an array or hash anywhere in the list, but the first one
in the list will soak up all the values, and anything after it will become
undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede poner realmente un array o hash en cualquier lugar de la lista, pero la primera en la lista absorberá todos los demás valores, y cualquier cosa después quedará indefinida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike C&lt;printf&gt;, C&lt;sprintf&gt; does not do what you probably mean when you
pass it an array as your first argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de C&lt;printf&gt;, C&lt;sprintf&gt; no hace lo que probablemente quiere decir cuando se le pasa un array como primer argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl Authors Upload Server.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T032120Z" changeid="explorer">
        <seg>Servidor de subidas para los autores Perl (I&lt;Perl Authors Upload Server&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Text::Tabs&gt; upgraded to version 2005.0824</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040043Z" changeid="explorer">
        <seg>C&lt;Text::Tabs&gt; actualizado a la versión 2005.0824</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlsub/&quot;Private Variables via my()&quot;&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110803T113918Z" changeid="explorer">
        <seg>Ver L&lt;perlsub/&quot;Variables privadas con my()&quot;&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Cygwin 1.5 problems</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003716Z" changeid="explorer">
        <seg>=head2 Problemas en Cygwin 1.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;reverse&gt; to do the
reverse.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilice C&lt;reverse&gt; para hacer lo contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignore them: in IRIX 5.3 there is no way to quieten ld about this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004759Z" changeid="explorer">
        <seg>No haga caso de ellos: en IRIX 5.3 no hay manera de silenciar ld a este respecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does a fork(2) system call to create a new process running the
same program at the same point.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace una llamada del sistema fork(2) para crear un nuevo proceso ejecutando el mismo programa en el mismo punto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no valid digits between the braces, the generated character is
the NULL character (C&lt;\x{00}&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T202627Z" changeid="explorer">
        <seg>Si no hay dígitos válidos entre las llaves, el carácter generado es el carácter NULL (C&lt;\x{00}&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;or&quot; returns the logical disjunction of the two surrounding
expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;or&quot; devuelve la disyunción lógica de las dos expresiones que la rodean.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The routines are derived
(distantly) from Henry Spencer's freely redistributable reimplementation
of the V8 routines.)  See L&lt;Version 8 Regular Expressions&gt; for
details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220436Z" changeid="explorer">
        <seg>(Las rutinas se derivan (lejanamente) de la reimplementación redistribuible de henry Spencer de las rutinas V8). Vea L&lt;Expresiones regulares versión 8&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item y///</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item y///</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($package, $filename, $line, $subroutine, $hasargs,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($paquete, $archivo, $linea, $subritina, $hasargs,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the system is large or likely to become so</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015758Z" changeid="explorer">
        <seg>Cuando el sistema es grande o que pueda llegar a serlo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195910Z" changeid="explorer">
        <seg>Ver abajo para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T220522Z" changeid="explorer">
        <seg>/el (\S+)(?{ $animal = $^N }) (\S+)(?{ $color = $^N })/i;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PAT*+               (?&gt;PAT*)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232337Z" changeid="explorer">
        <seg>PAT*+               (?&gt;PAT*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These modules
have the advantage of not hiding different types of the same name
during the local().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos módulos tienen la ventaja de no ocultar diferentes tipos del mismo nombre durante el local().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%*2$s&gt;&quot;, &quot;a&quot;, 6; # prints &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014617Z" changeid="explorer">
        <seg>printf &quot;&lt;%*2$s&gt;&quot;, &quot;a&quot;, 6; # imprime &quot;&lt;     a&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use strict;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlnewmod		Perl modules: preparing a new module for distribution</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000445Z" changeid="explorer">
        <seg>perlnewmod		Preparar la distribución de un módulo Perl nuevo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc/&quot;SysV IPC&quot;&gt; and the documentation for
C&lt;IPC::SysV&gt; and C&lt;IPC::SysV::Msg&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215430Z" changeid="explorer">
        <seg>Vea también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt; y C&lt;IPC::SysV&gt; y C&lt;IPC::SysV::Msg&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$utmp = pack($utmp_template, @utmp1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$utmp = pack($utmp_template, @utmp1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;-T&quot; is on the #!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212421Z" changeid="explorer">
        <seg>&quot;-T&quot; está en la #!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behaviour is now optional.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170407Z" changeid="explorer">
        <seg>Este comportamiento es ahora opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X FILEHANDLE
X&lt;-r&gt;X&lt;-w&gt;X&lt;-x&gt;X&lt;-o&gt;X&lt;-R&gt;X&lt;-W&gt;X&lt;-X&gt;X&lt;-O&gt;X&lt;-e&gt;X&lt;-z&gt;X&lt;-s&gt;X&lt;-f&gt;X&lt;-d&gt;X&lt;-l&gt;X&lt;-p&gt;
X&lt;-S&gt;X&lt;-b&gt;X&lt;-c&gt;X&lt;-t&gt;X&lt;-u&gt;X&lt;-g&gt;X&lt;-k&gt;X&lt;-T&gt;X&lt;-B&gt;X&lt;-M&gt;X&lt;-A&gt;X&lt;-C&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020006Z" changeid="explorer">
        <seg>=item -X IDENTIFICADOR_ARCHIVO
X&lt;-r&gt;X&lt;-w&gt;X&lt;-x&gt;X&lt;-o&gt;X&lt;-R&gt;X&lt;-W&gt;X&lt;-X&gt;X&lt;-O&gt;X&lt;-e&gt;X&lt;-z&gt;X&lt;-s&gt;X&lt;-f&gt;X&lt;-d&gt;X&lt;-l&gt;X&lt;-p&gt;
X&lt;-S&gt;X&lt;-b&gt;X&lt;-c&gt;X&lt;-t&gt;X&lt;-u&gt;X&lt;-g&gt;X&lt;-k&gt;X&lt;-T&gt;X&lt;-B&gt;X&lt;-M&gt;X&lt;-A&gt;X&lt;-C&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consult the Usenet FAQs for your operating system for
information on where to get such a binary version.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225822Z" changeid="explorer">
        <seg>Consulte las preguntas más frecuentes de Usenet relativas a su sistema operativo para obtener más información acerca de dónde obtener esta versión binaria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = 'abc123xyz';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = 'abc123xyz';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;srand&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;srand&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new
Perl command line option C&lt;-C&gt; and its counterpart environment
variable PERL_UNICODE can now be used to control how Perl and Unicode
interact at interfaces like I/O and for example the command line
arguments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T152334Z" changeid="explorer">
        <seg>La nueva opción de la línea de comandos de Perl C&lt;-C&gt; y su contrapartida en la variable de entorno PERL_UNICODE ahora se pueden utilizar para controlar la forma en que Perl y Unicode interactuan en las interfaces como E/S y, por ejemplo, los argumentos en la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LABEL is omitted, the command
refers to the innermost enclosing loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la ETIQUETA se omite, el comando se refiere al bucle más interior en que se encuentre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>support BeOS better</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>mejor soporte para BeOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are advised to replace use of suidperl with tools such
as sudo ( http://www.courtesan.com/sudo/ )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se recomienda reemplazar el uso de suidperl con herramientas como sudo (http://www.courtesan.com/sudo/)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If more than one value is listed,
the list must be placed in parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se indica más de un valor, esa lista debe ser puesta entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use File::stat;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use File::stat;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last SWITCH;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last SWITCH;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Yuval Kogman)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005315Z" changeid="explorer">
        <seg>(Yuval Kogman)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that it isn't so cumbersome to say, and will actually work.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>excepto que no es tan complicado como hemos dicho, y funciona de forma efectiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f  A single-precision float in native format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>f  Un flotante en simple precisión en formato nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New modules</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Nuevos módulos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And most of all, it must
be something decodable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110405T000840Z" changeid="explorer">
        <seg>También es fundamental que lo que se va a descodificar sea descodificable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item oct</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item oct</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is supplied,
sets the new current default filehandle for output.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012241Z" changeid="explorer">
        <seg>Si se indica un IDENTIFICADOR_ARCHIVO, se establece un nuevo identificador de archivo predeterminado para la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here's one way to count how many times a particular
string occurs in an array:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, aquí hay una manera de contar cuántas veces aparece una cadena particular en un array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%.2f&quot;, 10/3;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225509Z" changeid="explorer">
        <seg>printf &quot;%.2f&quot;, 10/3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>He says (half in jest) that &quot;a script is
what you give the actors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231641Z" changeid="explorer">
        <seg>Dice (medio en broma) que &quot;un script (guión) es lo que se le da a los actores,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= caller($i);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170028Z" changeid="explorer">
        <seg>= caller($i);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is not the same as</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050619Z" changeid="explorer">
        <seg>no es lo mismo que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in doubt, parenthesize.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de duda, coloque paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's all well and good for declaration of a fixed data structure,
but what if you wanted to add new elements on the fly, or build
it up entirely from scratch?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo eso está bien y es bueno para la declaración de una estructura de datos fijos, pero ¿y si quisiera añadir nuevos elementos sobre la marcha, o construirlo desde cero?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.perl.org/       the Perl homepage</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001553Z" changeid="explorer">
        <seg>http://www.perl.org/       página de inicio del lenguaje Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neale Ferguson.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T064901Z" changeid="explorer">
        <seg>Neale Ferguson.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new filename linked to the old filename.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea un nuevo nombre de archivo enlazado con el nombre del archivo antiguo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;abc\Qfoo\tbar$s\Exyz&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222214Z" changeid="explorer">
        <seg>&quot;abc\Qfoo\tbar$s\Exyz&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bar</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print scalar reverse &quot;dlrow ,&quot;, &quot;olleH&quot;;    # Hello, world</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print scalar reverse &quot;odnum ,&quot;, &quot;aloH&quot;;    # Hola, mundo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with the release following soon after, when testing is complete.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>con el consiguiente comunicado poco después, cuando se complete los test.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Modules and Pragmas</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112052Z" changeid="explorer">
        <seg>=head1 Módules y Pragmas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\b Sra )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025605Z" changeid="explorer">
        <seg>\b Sra )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 0-321-49694-9 [2nd edition 2010]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003418Z" changeid="explorer">
        <seg>ISBN 0-321-49694-9 [2ª edición - 2010]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tru64 when using gcc 3 drops the optimisation for F&lt;toke.c&gt; to C&lt;-O2&gt;
because of gigantic memory use with the default C&lt;-O3&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010211Z" changeid="explorer">
        <seg>En Tru64, cuando se utiliza gcc 3 baja la optimización de F&lt;toke.c&gt; a C&lt;-O2&gt; debido al enorme uso de memoria con el valor por defecto C&lt;-O3&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no Perl 6 release scheduled, but it will be available when
it's ready.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200916Z" changeid="explorer">
        <seg>Aún no está prevista una fecha de lanzamiento de Perl 6. La nueva versión estará disponible cuando llegue el momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;$user not in passwd file&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;$usuario no está en archivo de contraseñas&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ext/List/Util/t/p_tainted.t    #26912</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T053451Z" changeid="explorer">
        <seg>ext/List/Util/t/p_tainted.t    #26912</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq9		Networking</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000248Z" changeid="explorer">
        <seg>perlfaq9		Conexión a redes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an expression that specifies an element or slice of a hash, C&lt;delete&gt;
deletes the specified elements from that hash so that exists() on that element
no longer returns true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dada una expresión que especifica un elemento o una porción de un hash, C&lt;delete&gt; elimina los elementos especificados de este hash de tal forma que exists() en ese elemento ya no devuelve verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To match
the actual end of the string and not ignore an optional trailing
newline, use C&lt;\z&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para coincidir con el final actual de la cadena, sin ignorar un posible carácter de fin de línea, use C&lt;\z&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If new flags are
added to Perl, the meaning of the caret's expansion will change to include
the default for those flags, so the test will still work, unchanged.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T195054Z" changeid="explorer">
        <seg>Si las nuevas banderas son agregadas a Perl, el significado de la expansión del circunflejo cambiará para incluir el valor predeterminado para estas banderas, por lo que la prueba seguirá funcionando, sin cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;undef ~~ %hash&gt; is always false (since C&lt;undef&gt; can't be a key in a
hash).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T222019Z" changeid="explorer">
        <seg>C&lt;undef ~~ %hash&gt; siempre es falsa (ya que C&lt;undef&gt; no puede ser una clave en un hash).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/foo $parens \s+ + \s+ bar $parens/x) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T190237Z" changeid="explorer">
        <seg>if (/foo $parentesis \s+ + \s+ bar $parentesis/x) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where do I get it?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225319Z" changeid="explorer">
        <seg>¿Dónde puedo obtener perl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;Artistic&gt; and F&lt;Copying&gt; files for copyright information.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los archivos F&lt;Artistic&gt; y F&lt;Copying&gt; para ver la información sobre derechos de autor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but, because * is higher precedence than named operators:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pero, debido a que * es de mayor precedencia que los operadores con nombre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== 101 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== 101 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>intsize='4';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>intsize='4';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl561delta	Perl changes in version 5.6.1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl561delta	Cambios en la versión 5.6.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of non-leap seconds since whatever time the system
considers to be the epoch, suitable for feeding to C&lt;gmtime&gt; and
C&lt;localtime&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de segundos no bisiestos desde el momento en que el sistema considera que es el I&lt;epoch&gt;, apto para ser alimentado a C&lt;gmtime&gt; y C&lt;localtime&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not wait for Perl 6 to do whatever
you need to do.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230117Z" changeid="explorer">
        <seg>No espere a que salga Perl 6 para hacer lo que tenga que hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As noted earlier in this document, the scalar sense of list assignment
is the number of elements on the right-hand side of the assignment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como se ha señalado anteriormente en este documento, el sentido escalar de una asignación de una lista es el número de elementos en el lado derecho de la asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>redo unless eof();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>redo unless eof();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intent is to squeeze as much possible information about the likely cause
into the limited space of the system exit code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171255Z" changeid="explorer">
        <seg>La intención es comprimir la mayor información posible sobre la causa probable en el limitado espacio del código de salida del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptors, as determined by the value
of $^F.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que apoyan la bandera close-on-exec en archivos, esta bandera se establecerá para los nuevos descriptores de archivo abiertos, según lo determinado por el valor de $^F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gethostent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gethostent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%h = ( 'A' =&gt; 42 );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015104Z" changeid="explorer">
        <seg>%h = ( 'A' =&gt; 42 );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is called when
a tied hash is used in scalar context, such as</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se activa cuando un hash enlazado se utiliza en contexto escalar, como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the
log of another base, use basic algebra:
The base-N log of a number is equal to the natural log of that number
divided by the natural log of N.  For example:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171445Z" changeid="explorer">
        <seg>Para obtener el logaritmo de otra base, use álgebra básica: el logaritmo de base N de un número es igual al logaritmo natural de ese número dividido por el logaritmo natural de N. Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a C&lt;continue&gt; BLOCK, it is always executed just before the
conditional is about to be evaluated again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si existe un BLOQUE C&lt;continue&gt;, siempre es ejecutado justo antes de que la condición sea evaluada de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These may look like functions, but
may also look completely different.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pueden parecerse a funciones, pero también pueden ser complementamente diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $1 if /\G(q)/gc;  print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $1 if /\G(q)/gc;  print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $name = 'fred';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $nombre = 'pedro';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A loop's LABEL is not actually a valid target for
a C&lt;goto&gt;; it's just the name of the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La ETIQUETA de un bucle no es realmente un destino válido para un C&lt;goto&gt;; sólo es el nombre del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item mkdir FILENAME,MASK
X&lt;mkdir&gt; X&lt;md&gt; X&lt;directory, create&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191422Z" changeid="explorer">
        <seg>=item mkdir ARCHIVO,MÁSCARA
X&lt;mkdir&gt; X&lt;md&gt; X&lt;directory, create&gt; X&lt;directorio, crear&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*this = *that;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>*este = *ese;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$int = unpack(&quot;N&quot;, pack(&quot;B32&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225515Z" changeid="explorer">
        <seg>$int = unpack(&quot;N&quot;, pack(&quot;B32&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[]       Bracketed Character class</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042619Z" changeid="explorer">
        <seg>[]	Clase carácter encorchetada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the two-argument (and one-argument) form, one should
replace dash (C&lt;-&gt;) with the command.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003053Z" changeid="explorer">
        <seg>En la forma de dos argumentos (y un argumento), debe sustituir el guión (C&lt;-&gt;) por el comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item wantarray
X&lt;wantarray&gt; X&lt;context&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T211004Z" changeid="explorer">
        <seg>=item wantarray
X&lt;wantarray&gt; X&lt;context&gt; X&lt;contexto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;hv_clear_placeholders&gt; is now part of the perl API</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;hv_clear_placeholders&gt; ahora es parte de la API de perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eof());  # quote body</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eof());  # citar el cuerpo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $r1 = qr/$a/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010125Z" changeid="explorer">
        <seg>my $r1 = qr/$a/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/Math/BigInt/t/bigintpm.........FAILED at test 204</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214805Z" changeid="explorer">
        <seg>lib/Math/BigInt/t/bigintpm.........FAILED at test 204</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We know that these values do I&lt;not&gt; work under
OS/390 &amp; VM/ESA Unix and on the Macintosh; you probably don't want to
use them in new code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sabemos que estos valores I&lt;no&gt; funcionan bajo OS/390 y VM/ESA Unix y en el Macintosh; es probable que no desea utilizarlos en nuevos programas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*)(\d*)    &lt;I have 2 numbers: 53147&gt; &lt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T234041Z" changeid="explorer">
        <seg>(.*)(\d*)    &lt;Tengo 2 números: 53147&gt; &lt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+------+------+</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225610Z" changeid="explorer">
        <seg>+------+------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum depth is compiled into perl, so
changing it requires a custom build.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T183315Z" changeid="explorer">
        <seg>La profundidad máxima está compilada en perl, por lo que su modificación requiere una generación personalizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>struct {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>struct {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>find(</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225447Z" changeid="explorer">
        <seg>find(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@animals[0..2];                 # gives (&quot;camel&quot;, &quot;llama&quot;, &quot;owl&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T213957Z" changeid="explorer">
        <seg>@animales[0..2];           # devuelve (&quot;camello&quot;, &quot;llama&quot;, &quot;búho&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A list of
them is given at the start of L&lt;perlfunc&gt; and you can easily read
about any given function by using C&lt;perldoc -f I&lt;functionname&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225220Z" changeid="explorer">
        <seg>Al principio de L&lt;perlfunc&gt; se incluye una lista completa de funciones. También puede obtener fácilmente información sobre cualquier función mediante el comando C&lt;perldoc -f I&lt;nombre_función&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod&gt; para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The wrapping
defaults to enabled on platforms where we know it works (most AIX
configurations, BSDi, Darwin, DEC OSF/1, FreeBSD, HP/UX, GNU Linux, OpenBSD,
Solaris, VMS and most Win32 compilers) and defaults to disabled on other
platforms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T103453Z" changeid="explorer">
        <seg>La envoltura por defecto está activa en plataformas en las que sabemos que funciona (la mayoría de las configuraciones de AIX, BSDi, Darwin, DEC OSF/1, FreeBSD, HP/UX, GNU Linux, OpenBSD, Solaris, VMS y la mayor parte de los compiladores Win32) y por defecto queda desactivado en otras plataformas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Too much to list here;  see L&lt;http://search.cpan.org/dist/ExtUtils-MakeMaker/Changes&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T031212Z" changeid="explorer">
        <seg>Demasiado para listarlo aquí; vea  L&lt;http://search.cpan.org/dist/ExtUtils-MakeMaker/Changes&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have a DBM database
that you need to share with a third-party C application.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T153607Z" changeid="zipf">
        <seg>Tiene una base de datos DBM que desea compartir con una aplicación en C de terceros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chroot FILENAME
X&lt;chroot&gt; X&lt;root&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170252Z" changeid="explorer">
        <seg>=item chroot NOMBRE_ARCHIVO
X&lt;chroot&gt; X&lt;root&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Look at the L&lt;Digest&gt; module for more robust algorithms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mire en el módulo L&lt;Digest&gt; por algoritmos más robustos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar&gt; for details on setting C&lt;%SIG&gt; entries and for more
examples.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T025050Z" changeid="explorer">
        <seg>Vea L&lt;perlvar&gt; para más detalles sobre la configuración de las entradas C&lt;%SIG&gt; y para ver más ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each 5.005-style thread creation will trigger the warning
C&lt;5.005 threads are deprecated&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T011239Z" changeid="explorer">
        <seg>Cada creación de un I&lt;thread&gt; estilo 5.005 disparará la advertencia C&lt;5.005 threads are deprecated&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;ext/POSIX/t/waitpid&gt; test fails at #1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El test C&lt;ext/POSIX/t/waitpid&gt; falla en el número 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for SCALARs or strings
X&lt;scalar&gt; X&lt;string&gt; X&lt;character&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043447Z" changeid="explorer">
        <seg>=item Functiones para ESCALARES o cadenas
X&lt;scalar&gt; X&lt;string&gt; X&lt;character&gt; X&lt;escalar&gt; X&lt;cadena&gt; X&lt;carácter&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The @ARGV array is then processed as a list
of filenames.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Luego, el array @ARGV es procesado como una lista de nombres de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpodstyle	Perl POD style guide</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T140852Z" changeid="explorer">
        <seg>perlpodstyle	Guía de estilo POD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then one is added to the return value
of C&lt;print&gt; (usually 1).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entonces uno es añadido al valor devuelto por C&lt;print&gt; (generalmente 1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>READLINE this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>READLINE este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optimised C&lt;map&gt; in scalar context</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T105215Z" changeid="explorer">
        <seg>Optimizado C&lt;map&gt; en contexto escalar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlembed		Perl ways to embed perl in your C or C++ application</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000501Z" changeid="explorer">
        <seg>perlembed		Formas de integrar Perl en una aplicación C o C++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;qx/EXPR/&gt;
operator is discussed in more detail in L&lt;perlop/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador C&lt;qx/EXPR/&gt; se discute con más detalle en L&lt;perlop/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your XS module stops working
because some functions cannot be found, in many cases a simple fix is
to add the C&lt;Perl_&gt; prefix to the function and the thread context
C&lt;aTHX_&gt; as the first argument of the function call.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T002057Z" changeid="explorer">
        <seg>Si su módulo XS deja de funcionar debido a que algunas funciones no se pueden encontrar, en muchos casos una solución sencilla es añadir el prefijo C&lt;Perl_&gt; a la función y el contexto del hilo C&lt;aTHX_&gt; como primer argumento de la llamada a la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you evaluate an array in scalar context, it returns the length
of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se evalúa un array en un contexto escalar, éste devuelve la longitud del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A command-line front-end to C&lt;Module::CoreList&gt;, to query what modules
were shipped with given versions of perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234652Z" changeid="explorer">
        <seg>Este front-end de línea de comandos de C&lt;Module::CoreList&gt; permite consultar la lista de módulos incluidos en versiones específicas de perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that the loop control statements described
later will I&lt;NOT&gt; work in this construct, because modifiers don't take
loop labels.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013204Z" changeid="explorer">
        <seg>Note también que las instrucciones de control de bucles descritas más adelante I&lt;NO&gt; funcionarán con esta construcción, porque los modificadores no toman etiquetas de bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;context&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;contexto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item continue BLOCK
X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170336Z" changeid="explorer">
        <seg>=item continue BLOQUE
X&lt;continue&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x   string multiplication</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>x   multiplicación de cadenas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;-DL&gt; removed (the leaktest had been broken and unsupported for years,
use alternative debugging mallocs or tools like valgrind and Purify).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001826Z" changeid="explorer">
        <seg>C&lt;-DL&gt; eliminado (el test de agotamiento estaba roto y no mantenido desde hace años; de otra forma, use malloc de depuración o herramientas como valgrind y Purify).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It cannot short-circuit (of course).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230827Z" changeid="explorer">
        <seg>No puede cortocircuitar (por supuesto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &quot;\&quot; creates a reference to whatever follows it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unario &quot;\&quot; crea una referencia a lo que sigue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl58delta and perl581delta have been added: these are the perldeltas
of 5.8.0 and 5.8.1, detailing the differences respectively between
5.6.0 and 5.8.0, and between 5.8.0 and 5.8.1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180715Z" changeid="explorer">
        <seg>perl58delta y perl581delta han sido añadidos: estos son los perldeltas de 5.8.0 y 5.8.1, detallando las diferencias, respectivamente, entre 5.6.0 y 5.8.0, y entre 5.8.0 y 5.8.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You would have been
able to just keep using Perl 5 with Parrot, the virtual machine which
will compile and run Perl 6 bytecode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230014Z" changeid="explorer">
        <seg>Esto permitiría seguir utilizando Perl 5 con Parrot, la máquina virtual que compilará y ejecutará bytecode de Perl 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+ 20;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>+ 20;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>assigns the value of variable $bar to the scalar variable $foo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>asigna el valor de la variable $bar a la variable escalar $foo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chroot</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chroot</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They fall into two major categories: list operators and named unary
operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se agrupan en dos categorías principales: operadores de listas y operadores unarios con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Core modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014330Z" changeid="explorer">
        <seg>=head2 Módulos integrados en el núcleo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(With 29
years to spare!)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003234Z" changeid="explorer">
        <seg>(¡Con 28 años de sobra!)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing happens as you knew before.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235157Z" changeid="explorer">
        <seg>El procesamiento se realiza igual que antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any way, if you're seeing failures beyond those mentioned in this
document, please consider upgrading to the latest Hurd before reporting
the failure as a bug.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020203Z" changeid="explorer">
        <seg>En cualquier caso, si ve más errores que los mencionados en este documento, debería actualizar a la versión más reciente de Hurd antes de notificar los errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Data::Dumper&gt; upgraded to version 2.121_08</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025852Z" changeid="explorer">
        <seg>C&lt;Data::Dumper&gt; actualizado a la version 2.121_08</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although optimized for
scanning text, Perl also has many excellent tools for slicing
and dicing binary data.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141848Z" changeid="explorer">
        <seg>Aunque está optimizado para el procesamiento de texto, Perl también tiene excelentes herramientas para extraer y cortar datos en binario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine you'd like to find a sequence of non-digits not
followed by &quot;123&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T165927Z" changeid="explorer">
        <seg>Imagínese que le gustaría encontrar una secuencia de no-dígitos que no esté seguido por &quot;123&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that the whole range idea is rather unportable between
character sets--and even within character sets they may cause results
you probably didn't expect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta también que la idea de rango es poco transportable entre conjuntos de caracteres; e incluso dentro de los mismos conjuntos de caracteres pueden causar resultados que probablemente no espera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011110Z" changeid="explorer">
        <seg>=item open IDENTIFICADOR_ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most tasks only require a small subset of the Perl language.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230317Z" changeid="explorer">
        <seg>La mayoría de las tareas sólo requieren conocer un pequeño subconjunto del lenguaje Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That will print out:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233931Z" changeid="explorer">
        <seg>Esto imprimirá:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your interfaces should be understandable by an average Perl programmer.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020532Z" changeid="explorer">
        <seg>Su interfaz debe ser comprensible para un programador promedio de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;t/io/fflush&gt; test fails at #6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El test C&lt;t/io/fflush&gt; falla en el número 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Joseph N. Hall, Joshua A. McAdams, brian d foy</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003414Z" changeid="explorer">
        <seg>Joseph N. Hall, Joshua A. McAdams, brian d foy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice the inner loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193931Z" changeid="explorer">
        <seg>Observe el bucle interior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regarding aesthetics of code lay out, about the only thing Larry
cares strongly about is that the closing curly bracket of
a multi-line BLOCK should line up with the keyword that started the construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con respecto a la estética del código, a lo único que Larry le preocupa es que la llave de cierre de un BLOQUE multilínea debe alinearse con la palabra reservada que inició esa estructura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(1, '-', 10, ',', 20)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(1, '-', 10, ',', 20)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n,m}?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n,m}?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl parses it without error, but when you try to execute a whatever,
it throws an exception with the text C&lt;Unimplemented&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225159Z" changeid="explorer">
        <seg>Perl lo interpreta sin error, pero al intentar ejecutar un blablablá, produce una excepción con el texto C&lt;Unimplemented&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is an error
to try to write off the beginning of the string (i.e., negative OFFSET).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es un error tratar de cancelar el principio de la cadena (es decir, DESPLAZAMIENTO negativo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># then back the top to re-check EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># entonces regresa arriba a recomprobar la EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It would generate the scalar comma operator
there, not the list construction version of the comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se generará aquí el operador coma, no la versión de construcción de listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp; s//BETTY $1 BETTY/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>  &amp;&amp; s//BETTY $1 BETTY/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5115delta	Perl changes in version 5.11.5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl5115delta	Cambios en la versión 5.11.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If bits is 4 or less, the string is broken into bytes, then the bits
of each byte are broken into 8/BITS groups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si bits son 4 o menos, la cadena se divide en bytes, y a continuación, los bits de cada byte se dividen en grupos de 8/BITS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you chop a list, each element is chopped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si recorta una lista, cada elemento es recortado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;a/b is &quot;, $a/$b;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033337Z" changeid="explorer">
        <seg>say &quot;a/b es &quot;, $a/$b;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;FooBar.pm provides an implementation of the FOO protocol and the
related BAR standard.&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015029Z" changeid="explorer">
        <seg>&quot;FooBar.pm proporciona una implementación del protocolo FOO y la norma BAR relacionada.&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if successful, C&lt;undef&gt; on error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024018Z" changeid="explorer">
        <seg>Devuelve verdadero si tuvo éxito, C&lt;undef&gt; en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that everything passes except for some problems in the
packages &quot;Math::BigInt&quot;, &quot;Math::Complex&quot;, and &quot;Math::Trig&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214937Z" changeid="explorer">
        <seg>Esto significa que todo pasa a excepción de algunos problemas en los paquetes &quot;Math::BigInt&quot;, &quot;Math::Complex&quot;, y &quot;Math::Trig&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can internally represent numbers in 3 different ways: as native
integers, as native floating point numbers, and as decimal strings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232430Z" changeid="explorer">
        <seg>Perl puede representar los números internamente de 3 maneras distintas: como enteros nativos, como números de punto flotante nativos y como cadenas decimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A synopsis of the common uses of the module</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T023928Z" changeid="explorer">
        <seg>Una sinopsis de los usos comunes del módulo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;\&gt; X&lt;reference&gt; X&lt;backslash&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;\&gt; X&lt;reference&gt; X&lt;backslash&gt; X&lt;referencia&gt; X&lt;barra diagonal inversa&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aaaaa</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050120Z" changeid="explorer">
        <seg>aaaaa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See also L&lt;Integer Arithmetic&gt; and L&lt;Bitwise String Operators&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220034Z" changeid="explorer">
        <seg>(Vea también L&lt;Aritmética entera&gt; y L&lt;Operadores de bit en cadenas&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Works only for non-negative operands unless you've
loaded the C&lt;Math::Complex&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo funciona para operandos no negativos a menos que haya cargado el módulo C&lt;Math::Complex&gt;x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No message is printed if there is a C&lt;$SIG{__WARN__}&gt; handler
installed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ningún mensaje se imprime si hay instalado un controlador C&lt;$SIG{__WARN__}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Saying C&lt;undef $hash{$key}&gt;
will probably not do what you expect on most predefined variables or
DBM list values, so don't do that; see L&lt;delete&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Decir C&lt;undef $hash{$key}&gt; probablemente no vaya a hacer lo que usted espera en la mayoría de las variables predefinidas o lista de valores DBM, así que no haga eso; vea L&lt;delete&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MPE/iX</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015349Z" changeid="explorer">
        <seg>MPE/iX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both conversions are possible
without loss of precision, and the operation can be performed without
loss of precision then the integer result is used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T233905Z" changeid="explorer">
        <seg>Si ambas conversiones son posibles sin pérdida de precisión y se puede realizar la operación sin pérdida de precisión, se usa el resultado entero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FH, &quot;&gt;&gt;&amp;=OLDFH&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FH, &quot;&gt;&gt;&amp;=OLDFH&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise C&lt;\11&gt; is
a backreference only if at least 11 left parentheses have opened before it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T185620Z" changeid="explorer">
        <seg>Asimismo, \11 es una contrareferencia sólo si, antes, y por lo menos, se han abierto 11 paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If neither of the above default configs work on your platform, you might want
to try</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223625Z" changeid="explorer">
        <seg>Si ninguna de las configuraciones por defecto funcionan en su plataforma, es posible que desee probar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;\b&gt; still means to match at the boundary
between C&lt;\w&gt; and C&lt;\W&gt;, using the C&lt;/a&gt; definitions of them (similarly
for C&lt;\B&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110724T235720Z" changeid="explorer">
        <seg>C&lt;\b&gt; sigue coincidiendo en el límite entre C&lt;\w&gt; y C&lt;\W&gt;, usando las definiciones C&lt;/a&gt; de ellos (lo mismo para C&lt;\B&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with
LOCK_NB.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>OPERACIÓN es una de LOCK_SH, LOCK_EX, o LOCK_UN, posiblemente combinado con LOCK_NB.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The old behaviour was that %tied_hash would return whatever would have been
returned for that hash before the hash was tied (so usually 0).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comportamiento anterior era que %hash_enlazado devolvería todo la que hubiera devuelto este hash antes de ser enlazado (por lo general, 0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Basic BLOCKs
X&lt;block&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T195412Z" changeid="explorer">
        <seg>=head2 BLOQUES básicos
X&lt;block&gt; X&lt;bloque&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If unimplemented, raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no está implementada, lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can find out whether Perl considers &quot;long double&quot; to be the default
floating-point size to use on your platform via L&lt;Config&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>puede averiguar si Perl considera &quot;long double&quot; como el valor por defecto para el tamaño del punto flotante para su plataforma a través de L&lt;Config&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'good men to come to.'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'los hombres buenos por venir.'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@names) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@nombres) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$body = encode('UTF-8', $body);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235246Z" changeid="explorer">
        <seg>$cuerpo_texto = encode('UTF-8', $cuerpo_texto);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't bother with -n32 unless you have 7.1
or later compilers (use cc -version to check).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002507Z" changeid="explorer">
        <seg>No se moleste en poner -n32 a menos que tenga un compilador 7.1 o superior (use cc -version para comprobarlo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;emacs&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225454Z" changeid="explorer">
        <seg>X&lt;emacs&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Packaging</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030724Z" changeid="explorer">
        <seg>=head2 Empaquetado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>g  Match globally, i.e., find all occurrences.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T232833Z" changeid="explorer">
        <seg>g	Coincidencia global, es decir, busca todas las ocurrencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optimisation of C&lt;for (reverse @a)&gt; introduced in perl 5.8.6 could
misbehave when the array had undefined elements and was used in LVALUE
context.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045936Z" changeid="explorer">
        <seg>La optimización de C&lt;for (reverse @a)&gt; introducido en perl 5.8.6 puede portarse mal cuando el array tuviera elementos indefinidos y fuera usado en contexto de IVALOR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rin = $win = $ein = '';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$rin = $win = $ein = '';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sends a signal to a list of processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Manda una señal a una lista de procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>INSTALLATION
============</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T221840Z" changeid="explorer">
        <seg>INSTALACIÓN
===========</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qw/STRING/
X&lt;qw&gt; X&lt;quote, list&gt; X&lt;quote, words&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010312Z" changeid="explorer">
        <seg>=item qw/CADENA/
X&lt;qw&gt; X&lt;quote, list&gt; X&lt;quote, words&gt; X&lt;entrecomillado, lista&gt; X&lt;entrecomillado, palabras&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc/&quot;SysV IPC&quot;&gt; and C&lt;IPC::SysV&gt; documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215756Z" changeid="explorer">
        <seg>Vea también la documentación de L&lt;perlipc/&quot;SysV IPC&quot;&gt; y C&lt;IPC::SysV&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matches as C&lt;S{min}|S{min+1}|...|S{max-1}|S{max}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235802Z" changeid="explorer">
        <seg>Coincide con C&lt;S{min}|S{min+1}|...|S{max-1}|S{max}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;delete&gt;, C&lt;each&gt;, C&lt;exists&gt;, C&lt;keys&gt;, C&lt;values&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;delete&gt;, C&lt;each&gt;, C&lt;exists&gt;, C&lt;keys&gt;, C&lt;values&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsec/&quot;Algorithmic Complexity Attacks&quot;&gt; for the original
rationale behind this change.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T140517Z" changeid="explorer">
        <seg>Vea L&lt;perlsec/&quot;Ataques de complejidad algorítmica&quot;&gt; para la justificación original de este cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a   Use ASCII for \d, \s, \w; specifying two a's further restricts</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T224752Z" changeid="explorer">
        <seg>a	Usa ASCII para \d, \s, \w; con dos 'a' se restringe aún mas la</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hdrs   =  (UNIX_FROM =&gt; split /^(\S*?):\s*/m, $header);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%cabeceras  =  (UNIX_FROM =&gt; split /^(\S*?):\s*/m, $encabezado);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing, but with explicit sort routine</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, pero con una rutina de ordenación explícita</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the implementation of system components is likely to
change over time (and hence should be encapsulated)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020044Z" changeid="explorer">
        <seg>Cuando la implementación de los componentes del sistema es probable que cambie con el tiempo (y por lo tanto debe ser encapsulado)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mac OS X now builds Perl statically by default.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T183515Z" changeid="explorer">
        <seg>Mac OS X ahora por defecto compila Perl de forma estática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over 4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=over 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over 3</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233255Z" changeid="explorer">
        <seg>=over 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How it behaves
depends on the context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El cómo se comporta depende del contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over 5</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T174203Z" changeid="zipf">
        <seg>=over 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if the beginning of a pattern containing a
quantifier succeeds in a way that causes later parts in the pattern to
fail, the matching engine backs up and recalculates the beginning
part--that's why it's called backtracking.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T145900Z" changeid="explorer">
        <seg>Así que, si al principio de un patrón conteniendo un cuantificador logra de alguna manera que las últimas partes del patrón fallen, el motor retrocede y vuelve a recalcular la parte inicial -es por eso por lo que se llama vuelta atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you make
use of something that works only in some given release of Perl and later,
but not earlier, you should place a prominent</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031420Z" changeid="explorer">
        <seg>Siempre que haga uso de algo que sólo funciona en algunas versiones de Perl y superiores, pero no antes, se debe colocar un prominente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following (inefficiently) deletes all the values of %HASH and @ARRAY:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo siguiente borra (ineficientemente) todos los valores de %HASH y @ARRAY:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Children's times are only included for terminated children.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tiempos de los hijos solo se incluyen de los hijos terminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over 8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=over 8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Numeric operators and numeric conversions</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232623Z" changeid="explorer">
        <seg>=head1 Operadores numéricos y conversiones numéricas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $y;           # prints &quot;bar&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002208Z" changeid="zipf">
        <seg>print $y;           # imprime &quot;bar&quot; en pantalla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If, however, the string begins with a
non-alphabetic character (excluding &quot;+&quot; or &quot;-&quot;), Perl will attempt to convert
the string to a numeric and the arithmetic negation is performed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si la cadena comienza con un carácter no-alfabético (con exclusión de &quot;+&quot; o &quot;-&quot;), Perl tratará de convertir la cadena en un código numérico y se lleva a cabo la negación aritmética.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @idx = 0..$#_;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>my @idx = 0..$#_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;characters&gt;: depending on the status of the socket, either
(8-bit) bytes or characters are sent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note los I&lt;caracteres&gt;: dependiendo del estado del socket, son enviados bytes (8-bit) o caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print FH $data		or die &quot;Can't write to FH: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print FH $dato		or die &quot;No puedo escribir a FH: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a format typically
does one C&lt;formline&gt; per line of form, but the C&lt;formline&gt; function itself
doesn't care how many newlines are embedded in the PICTURE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que un formato típicamente hace un C&lt;formline&gt; por línea del formato, pero a la misma función C&lt;formline&gt; no le preocupa cuántos avances de línea están incluidos en el CUADRO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item package NAMESPACE VERSION
X&lt;package&gt; X&lt;module&gt; X&lt;namespace&gt; X&lt;version&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175336Z" changeid="explorer">
        <seg>=item package ESPACIO_NOMBRES VERSIÓN
X&lt;package&gt; X&lt;module&gt; X&lt;namespace&gt; X&lt;version&gt;
X&lt;paquete&gt; X&lt;módulo&gt; X&lt;espacio de nombres&gt; X&lt;versión&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exp EXPR
X&lt;exp&gt; X&lt;exponential&gt; X&lt;antilog&gt; X&lt;antilogarithm&gt; X&lt;e&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T172901Z" changeid="explorer">
        <seg>=item exp EXPR
X&lt;exp&gt; X&lt;exponential&gt; X&lt;antilog&gt; X&lt;antilogarithm&gt; X&lt;e&gt; X&lt;exponencial&gt; X&lt;anti logaritmo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#...                        # print stuff to output</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#...                        # imprimir a la salida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Magazines that frequently carry quality articles on Perl include I&lt;The
Perl Review&gt; ( http://www.theperlreview.com ), I&lt;Unix Review&gt; (
http://www.unixreview.com/ ), I&lt;Linux Magazine&gt; (
http://www.linuxmagazine.com/ ), and Usenix's newsletter/magazine to
its members, I&lt;login:&gt; ( http://www.usenix.org/ ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T112836Z" changeid="explorer">
        <seg>Las revistas que suelen publicar artículos de calidad sobre Perl son I&lt;The Perl Review&gt; ( http://www.theperlreview.com ), I&lt;Unix Review&gt; ( http://www.unixreview.com/ ), I&lt;Linux Magazine&gt; ( http://www.linuxmagazine.com/ ) y la revista/boletín de noticias para los miembros de Usenix, I&lt;login:&gt; ( http://www.usenix.org/ ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't use slash as a delimiter when your regexp has slashes or backslashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No use barras inclinadas como delimitador cuando en su expresión regular tenga barras o contrabarras inclinadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But by saying</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero al decir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,25, 1) = 1   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,25, 1) = 1   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some support for DTrace has been added.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003021Z" changeid="explorer">
        <seg>Se ha añadido algún soporte para DTrace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>comp.lang.perl.announce      Moderated announcement group</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230354Z" changeid="explorer">
        <seg>comp.lang.perl.announce      Grupo de anuncios moderado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?&amp;NAME)&gt;
X&lt;(?&amp;NAME)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T191210Z" changeid="explorer">
        <seg>=item C&lt;(?&amp;NOMBRE)&gt;
X&lt;(?&amp;NOMBRE)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On FreeBSD the full path of the perl interpreter is found by reading
the symlink F&lt;/proc/curproc/file&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En FreeBSD el camino completo del intérprete perl se encuentra leyendo el enlace simbólico F&lt;/proc/curproc/file&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item stat DIRHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012658Z" changeid="explorer">
        <seg>=item stat IDENTIFICADOR_DIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &quot;'&quot; is used as the delimiter, no interpolation
is done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se usa &quot;'&quot; como delimitador, no se realiza ninguna interpolación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@tmp = split;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@tmp = split;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/\Y|$re\Y|/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002859Z" changeid="explorer">
        <seg>/\Y|$re\Y|/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a binary version of
perl available from L&lt;http://www.cp15.org/perl/&gt; which you may wish to
use instead of trying to compile it yourself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay una versión binaria de perl disponible en L&lt;http://www.cp15.org/perl/&gt; que es posible que desee utilizar en lugar de tratar de compilarlo usted mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What does it mean?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T011236Z" changeid="explorer">
        <seg>¿Qué es lo que significa?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of the methods works identically, and is used to install (or
uninstall) a single DBM Filter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111001T155249Z" changeid="zipf">
        <seg>Todos los métodos funcionan de la misma manera y se usan para instalar (o
desinstalar) un filtro DBM individual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%.6d&gt;', 1;      # prints &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%.6d&gt;', 1;      # imprime &quot;&lt;000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ord</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item ord</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See L&lt;perlsyn/&quot;Compound Statements&quot;&gt;.)
X&lt;$+&gt; X&lt;$^N&gt; X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;
X&lt;$1&gt; X&lt;$2&gt; X&lt;$3&gt; X&lt;$4&gt; X&lt;$5&gt; X&lt;$6&gt; X&lt;$7&gt; X&lt;$8&gt; X&lt;$9&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220518Z" changeid="explorer">
        <seg>(Vea L&lt;perlsyn/&quot;Instrucciones compuestas&quot;&gt;.)
X&lt;$+&gt; X&lt;$^N&gt; X&lt;$&amp;&gt; X&lt;$`&gt; X&lt;$'&gt;
X&lt;$1&gt; X&lt;$2&gt; X&lt;$3&gt; X&lt;$4&gt; X&lt;$5&gt; X&lt;$6&gt; X&lt;$7&gt; X&lt;$8&gt; X&lt;$9&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Jed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item Jed</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second version didn't;
it tried to run a program named I&lt;&quot;echo surprise&quot;&gt;, didn't find it, and set
C&lt;$?&gt; to a non-zero value indicating failure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001727Z" changeid="explorer">
        <seg>La segunda versión no; intentó ejecutar un programa llamado literalmente I&lt;&quot;echo sorpresa&quot;&gt;, no lo encontró, y puso C&lt;$?&gt; a un valor distinto de cero para indicar un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lengthening
an array that was previously shortened does not recover values
that were in those elements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alargar un array que ha sido acortado previamente no permite recuperar los valores que había en esos elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For floating-point formats except C&lt;g&gt; and C&lt;G&gt;, this specifies
how many places right of the decimal point to show (the default being 6).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014723Z" changeid="explorer">
        <seg>Para formatos en punto flotante excepto C&lt;g&gt; y C&lt;G&gt;, especifica cuántos lugares a la derecha del punto decimal debe mostrar (el valor predeterminado es 6).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is unpredictable and will make perl unstable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T223401Z" changeid="explorer">
        <seg>El resultado es impredecible y hará a perl inestable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the variable
is preceded with the keyword C&lt;my&gt;, then it is lexically scoped, and
is therefore visible only within the loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T012438Z" changeid="explorer">
        <seg>Si la variable es precedida por la palabra clave C&lt;my&gt;, entonces su ámbito es léxicamente local y por eso es visible sólo dentro del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp; 127) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp; 127) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwuid UID</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getpwuid UID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally used in a C&lt;continue&gt; block at the end of a loop to clear
variables and reset C&lt;??&gt; searches so that they work again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Generalmente se usa en un bloque C&lt;continue&gt;, al final de un bucle para limpiar variables y reinicializar las búsquedas C&lt;??&gt;, para que funcionen de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its argument will be taken
from the next line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su argumento se tomará de la línea siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Apple-provided Perl is still
dynamically linked and shared, and you can enable the sharedness for
your own Perl builds by C&lt;Configure -Duseshrplib&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T190744Z" changeid="explorer">
        <seg>El Perl proporcionado por Apple sigue siendo enlazado de forma dinámica y compartida, y se puede habilitar el nivel de compartición de su propia compilación de Perl por medio de C&lt;Configure -Duseshrplib&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously when running with warnings enabled globally via C&lt;-w&gt;, selective
disabling of specific warning categories would actually turn off all warnings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T043710Z" changeid="explorer">
        <seg>Anteriormente, cuando se ejecutaba con las advertencias habilitadas a nivel global a través de C&lt;-w&gt;, una desactivación selectiva de categorías de advertencias específicas podría, realmente, desactivar todas las advertencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $1 while /(o)/gc; print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $1 while /(o)/gc; print &quot;', pos=&quot;, pos, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then you know
exactly how many bytes it will be in the destination string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235238Z" changeid="explorer">
        <seg>Así podrá saber exactamente cuántos bytes hay en la cadena generada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you would expect, this modifier causes, for example, C&lt;\D&gt; to mean
the same thing as C&lt;[^0-9]&gt;; in fact, all non-ASCII characters match
C&lt;\D&gt;, C&lt;\S&gt;, and C&lt;\W&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T213220Z" changeid="explorer">
        <seg>Como era de esperar, esto hace que el modificador, por ejemplo, C&lt;\D&gt; quiera decir lo mismo que C&lt;[^ 0-9]&gt;; de hecho, todos los caracteres no ASCII coinciden con C&lt;\D&gt;, C&lt;\S&gt; y C&lt;\W&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;h2xs&gt; utility now produces a more modern layout:
F&lt;Foo-Bar/lib/Foo/Bar.pm&gt; instead of F&lt;Foo/Bar/Bar.pm&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180112Z" changeid="explorer">
        <seg>La utilidad C&lt;h2xs&gt; produce ahora un diseño más moderno: F&lt;Foo-Bar/lib/Foo/Bar.pm&gt; en lugar de F&lt;Foo/Bar/Bar.pm&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;mro&gt; is now implemented as an XS extension.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003418Z" changeid="explorer">
        <seg>C&lt;mro&gt; está ahora implementado como una extensión XS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this is
applicable to C&lt;printf &quot;%s&quot;, $value&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234114Z" changeid="explorer">
        <seg>Por ejemplo, esto es aplicable a C&lt;printf &quot;%s&quot;, $valor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Longer-than-32-character filenames are now supported on
OpenVOS, and build properly without IPv6 support.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T231032Z" changeid="explorer">
        <seg>Nombre de archivo Longer-than-32-character ahora están soportados en OpenVOS, y se construye apropiadamente sin soporte IPv6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item open FILEHANDLE,MODE,REFERENCE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011058Z" changeid="explorer">
        <seg>=item open IDENTIFICADOR_ARCHIVO,MODO,REFERENCIA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;attrs&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005442Z" changeid="explorer">
        <seg>=item C&lt;attrs&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's true if one element in @array verifies
C&lt;$scalar ~~ $element&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T222248Z" changeid="explorer">
        <seg>Es cierto si un elemento de @array verifica que C&lt;$scalar ~~ $elemento&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://hop.perl.plover.com/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003547Z" changeid="explorer">
        <seg>http://hop.perl.plover.com/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($filename) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($nombrearchivo) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>banana =&gt; &quot;yellow&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234410Z" changeid="zipf">
        <seg>plátano =&gt; &quot;amarillo&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Files passed on the command line are filtered by default</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030305Z" changeid="explorer">
        <seg>Los archivos pasados en la línea de comandos son, por defecto, filtrados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$tY = sprintf(&quot;%.${POINTS}g&quot;, $Y);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$tY = sprintf(&quot;%.${PUNTOS}g&quot;, $Y);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>directive at the top of the file that needs it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031532Z" changeid="explorer">
        <seg>directiva en la parte superior del archivo que lo necesite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(I&lt;&quot;Rounding to zero&quot;.&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232826Z" changeid="explorer">
        <seg>(I&lt;&quot;Redondeo a cero&quot;&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If three (or more) arguments are specified, the open mode (including
optional encoding) in the second argument are distinct from the filename in
the third.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T001930Z" changeid="explorer">
        <seg>Si se especifican tres (o más) argumentos, es tomado el modo de apertura (incluyendo un codificado opcional) del segundo argumento, a diferencia del nombre del archivo, que estará en el tercer argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you have to
roll yourself a loop or two.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T193431Z" changeid="explorer">
        <seg>En su lugar, tiene que hacer un bucle o dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These strengths make it especially popular with system administrators
and CGI script authors, but mathematicians, geneticists, journalists,
and even managers also use Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T195916Z" changeid="explorer">
        <seg>Por estas cualidades es muy popular entre los administradores de sistemas y los programadores de scripts CGI, pero también lo usan matemáticos, expertos en ingeniería genética, periodistas e incluso directivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5110delta - what is new for perl v5.11.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T232736Z" changeid="explorer">
        <seg>perl5110delta - qué hay de nuevo en perl v5.11.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11623</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11623</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050609Z" changeid="explorer">
        <seg>pero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.8.4 introduced a change so that assignments of C&lt;undef&gt; to a
scalar, or of an empty list to an array or a hash, were optimised away.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T044132Z" changeid="explorer">
        <seg>Perl 5.8.4 introducía un cambio para que las asignaciones de C&lt;undef&gt; a un escalar, o de una lista vacía a un array o un hash, fueran optimizadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-------------------------------------------------------------------------</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-------------------------------------------------------------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose an appropriate license (GPL/Artistic is a good default)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014326Z" changeid="explorer">
        <seg>Elija una licencia adecuada (GPL/Artística es un buen valor por defecto)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Defined-or operators</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143016Z" changeid="explorer">
        <seg>=head2 Operadores definido-o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PATH=uts:$PATH ./Configure ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214239Z" changeid="explorer">
        <seg>PATH=uts:$PATH ./Configure ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At each position of the string the best
match given by non-greedy C&lt;??&gt; is the zero-length match, and the I&lt;second
best&gt; match is what is matched by C&lt;\w&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T232658Z" changeid="explorer">
        <seg>En cada posición de la cadena, la mejor opción dada por el modificador no codicioso C&lt;??&gt; es la coincidencia de longitud cero, y la I&lt;segunda mejor&gt; coincidencia es la que se corresponde con C&lt;\w&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for perl's built in functions that don't fit into any of the
other directories.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014640Z" changeid="explorer">
        <seg>Pruebas de funciones integradas de perl que no se corresponden con ninguno de los demás directorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, C&lt;given&gt; blocks can't always be used as proper expressions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223555Z" changeid="explorer">
        <seg>En la actualidad, los bloques C&lt;given&gt; no siempre se pueden utilizar como expresiones individuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If Unicode (for example, C&lt;\N{}&gt; or code points of 0x100 or
beyond) is being used, the case map used by C&lt;\l&gt;, C&lt;\L&gt;, C&lt;\u&gt;, and
C&lt;\U&gt; is as defined by Unicode.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T233433Z" changeid="explorer">
        <seg>Si se usa Unicode (por ejemplo, C&lt;\N{}&gt; o códigos de punto de 0x100 o superiores), el mapeo de tamaño de caja usado por C&lt;\l&gt;, C&lt;\L&gt;, C&lt;\u&gt; y C&lt;\U&gt; está definido por Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments start with a hash symbol and run to the end of the line</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224730Z" changeid="explorer">
        <seg>Los comentarios comienzan con un símbolo # y van hasta el final de la línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes various features of FreeBSD that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documentos describe varias características de FreeBSD que afectarán a cómo Perl versión 5 (de ahora en adelante sólo Perl) es compilado y/o ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most platforms store
signed integers in two's-complement notation, so usually this is not an issue.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de las plataformas almacenan enteros con signo en notación de complemento a dos, así que por lo general esto no es ningún problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're using strict, you I&lt;must not&gt; declare $a
and $b as lexicals.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T201055Z" changeid="explorer">
        <seg>Si está usando strict, I&lt;no debe&gt; declarar $a y $b como léxicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (my $i = 0; $i &lt; @ary1; $i++) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (my $i = 0; $i &lt; @array1; $i++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\\(.)/$1/g;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225529Z" changeid="explorer">
        <seg>s/\\(.)/$1/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use sigtrap  qw(SEGV BUS);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use sigtrap  qw(SEGV BUS);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more detail on looping constructs (and some that weren't mentioned in
this overview) see L&lt;perlsyn&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225206Z" changeid="explorer">
        <seg>Para obtener más información sobre las estructuras de bucle (y otras estructuras que no se han mencionado en esta introducción), consulte L&lt;perlsyn&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir +($foo) || die;	# (chdir $foo) || die</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir +($foo) || die;	# (chdir $foo) || die</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The terminator of this construct is found using the same rules as
for finding the terminator of a C&lt;{}&gt;-delimited construct, the only
exception being that C&lt;]&gt; immediately following C&lt;[&gt; is treated as
though preceded by a backslash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El terminador de esta construcción es encontrado usando las mismas reglas que para encontrar el terminador de la construcción delimitada por llaves, C&lt;{}&gt;, con la única excepción de que C&lt;]&gt; inmediatamente después de un C&lt;[&gt; es tratado como si estuviera precedido por una barra invertida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Too late for &quot;-T&quot; option
has been changed to the more informative</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212402Z" changeid="explorer">
        <seg>Demasiado tarde para la opción &quot;-T&quot; se ha cambiado para que sea más informativa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp;  and</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232642Z" changeid="explorer">
        <seg>&amp;&amp;  and</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;True\n&quot;      if $array[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Verdadero\n&quot;   if $array[$index];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;W/a&quot;, &quot;\004Gurusamy&quot;)           gives (&quot;Guru&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T174943Z" changeid="explorer">
        <seg>unpack(&quot;W/a&quot;, &quot;\004Gurusamy&quot;)           da (&quot;Guru&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|  a   |  3   |</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225610Z" changeid="explorer">
        <seg>|  a   |  3   |</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.        Match any character (except newline)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042526Z" changeid="explorer">
        <seg>.	Coincide con cualquier carácter (excepto el nueva línea)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The match-once behavior is controlled by the match delimiter being
C&lt;?&gt;; with any other delimiter this is the normal C&lt;m//&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030436Z" changeid="explorer">
        <seg>El comportamiento de la coincidencia de una sola vez, es controlada por el delimitador que comienza por C&lt;?&gt;; con cualquier otro delimitador, se trata del habitual operador C&lt;m//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11643</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11643</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># more flexible:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234651Z" changeid="explorer">
        <seg># más flexible:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For certain applications, the catch and throw pair of
C&lt;eval{}&gt; and die() for exception processing can also be a prudent approach.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ciertas aplicaciones, la pareja C&lt;eval{}&gt; y C&lt;die()&gt; puede ser un prudente planteamiento para el procesamiento de excepciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to list some (not all may be available simultaneously), or it may
be read I&lt;as is&gt;: as F&lt;README.dgux&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>por listar algunos (no todos pueden estar disponibles simultáneamente), o puede ser leído I&lt;tal cual&gt;: como F&lt;README.dgux&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document attempts to describe the Perl Community's &quot;best practice&quot;
for writing Perl modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T012754Z" changeid="explorer">
        <seg>Este documento intenta describir las &quot;mejores prácticas&quot; de la Comunidad Perl para la escritura de módulos Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After preprocessing
described above, and possibly after evaluation if concatenation,
joining, casing translation, or metaquoting are involved, the
resulting I&lt;string&gt; is passed to the RE engine for compilation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Después del proceso previo descrito anteriormente, y posiblemente después de la evaluación si la concatenación, unión, traducción de tamaño de caja, o metaentrecomillado están involucrados, el I&lt;string&gt; resultante es pasado al motor de RE para su compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'\s\t' =~ /\Q\s\t/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222527Z" changeid="explorer">
        <seg>'\s\t' =~ /\Q\s\t/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>API should be understandable by the average programmer</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013516Z" changeid="explorer">
        <seg>La API debe ser comprensible para un programador medio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># The following are compatibility aliases for S_IRUSR, S_IWUSR, S_IXUSR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Los siguientes son los alias de compatibilidad para S_IRUSR, S_IWUSR, S_IXUSR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;until&gt; statement executes the block as long as the expression is
false.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013352Z" changeid="explorer">
        <seg>La instrucción C&lt;until&gt; ejecuta el bloque mientras la expresión sea falsa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now much more picky about extra or missing output from test scripts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T175747Z" changeid="explorer">
        <seg>Ahora es mucho más exigente con la salida extra o con la que falta de los scripts de test.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11656</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11656</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each programmer will, of course, have his or her own preferences in
regards to formatting, but there are some general guidelines that will
make your programs easier to read, understand, and maintain.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada programador tendrá, naturalmente, sus propias preferencias con respecto al estilo, pero hay algunas directrices que harán sus programas más fáciles de leer, entender y mantener.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;XSLoader&gt; is now used for faster loading</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030505Z" changeid="explorer">
        <seg>Ahora se usa C&lt;XSLoader&gt; para acelerar la carga</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precisely which areas
are good and bad is often a personal choice, so asking this question
on Usenet runs a strong risk of starting an unproductive Holy War.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230733Z" changeid="explorer">
        <seg>Precisamente las áreas en las que es bueno o malo suelen ser una opción personal, por lo que hacer esta pregunta en Usenet conlleva un riesgo elevado de iniciar una guerra santa inútil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in scalar context the operator returns
the next value each time it's called, or C&lt;undef&gt; when the list has
run out.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, en contexto escalar el operador devuelve el siguiente valor cada vez que se le llama, o C&lt;undef&gt; cuando la lista se ha agotado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\o{}, \000  character whose ordinal is the given octal number</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043746Z" changeid="explorer">
        <seg>\o{}, \000	carácter cuyo ordinal es el número octal indicado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VMS: waitpid enhancements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>VMS: mejoras en waitpid</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the types of data form a natural hierarchy that can make use of inheritance</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015845Z" changeid="explorer">
        <seg>Cuando los tipos de datos forman una jerarquía natural que puede hacer uso de la herencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support fchmod(2), passing filehandles raises
an exception.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005317Z" changeid="explorer">
        <seg>En sistemas que no admiten fchmod(2), pasarle un identificador de archivo lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonassoc	named unary operators</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no asoc.	operadores unarios nombrados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Declarations
X&lt;declaration&gt; X&lt;undef&gt; X&lt;undefined&gt; X&lt;uninitialized&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040757Z" changeid="explorer">
        <seg>=head2 Declaraciones
X&lt;declaration&gt; X&lt;undef&gt; X&lt;undefined&gt; X&lt;uninitialized&gt; X&lt;declaración&gt; X&lt;indefinido&gt; X&lt;no inicializado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checks if the expression has been evaluated inside of recursion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T194855Z" changeid="explorer">
        <seg>Comprueba si la expresión se ha evaluado en el interior de la recursión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except at the end of a string, having fewer than
two valid digits will result in a warning.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110522T175936Z" changeid="explorer">
        <seg>Salvo en el final de una cadena, con menos de dos dígitos válidos, dará lugar a una advertencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;|tr '[a-z]' '[A-Z]'&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO, &quot;|tr '[a-z]' '[A-Z]'&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing only one of the first two elements as C&lt;undef&gt; is
equivalent to passing a 0 and will not have the effect 
described when both are C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pasando solo uno de los dos primeros elementos como C&lt;undef&gt; es equivalente a pasar un 0 y no tendrá el efecto descrito cuando ambos son C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!open(FOO)) { die &quot;Can't open $FOO: $!&quot;; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (!open(FOO)) { die &quot;No puedo abrir $FOO: $!&quot;; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @files, $File::Find::fullname</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T005600Z" changeid="explorer">
        <seg>push @archivos, $File::Find::fullname</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($ary1[$i] &gt; $ary2[$j]) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($ary1[$i] &gt; $ary2[$j]) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike most locales, which are specific to a language and country pair,
Unicode classifies all the characters that are letters I&lt;somewhere&gt; as
C&lt;\w&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T172019Z" changeid="explorer">
        <seg>A diferencia de la mayoría de las configuraciones regionales, que son específicas de un de un idioma y de un país, Unicode clasifica todos los caracteres que son letras, I&lt;en cualquier parte&gt;, como C&lt;\w&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item select FILEHANDLE
X&lt;select&gt; X&lt;filehandle, default&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T021033Z" changeid="explorer">
        <seg>=item select IDENTIFICADOR_ARCHIVO
X&lt;select&gt; X&lt;filehandle, default&gt; X&lt;identificador de archivo, por defecto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(ARTICLE, &quot;-|&quot;, &quot;caesar &lt;$article&quot;)  # decrypt article</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004044Z" changeid="explorer">
        <seg>open(ARTICULO, &quot;-|&quot;, &quot;caesar &lt;$articulo&quot;)  # decodificar el artículo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Top of form processing is handled automatically:  if there is insufficient
room on the current page for the formatted record, the page is advanced by
writing a form feed, a special top-of-page format is used to format the new
page header before the record is written.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T025643Z" changeid="explorer">
        <seg>El procesado del comienzo del formulario se maneja de forma automática: si no hay suficiente espacio en la página actual para el registro formateado, la página se desplaza escribiendo un avance de página; un formato especial de principio de página es utilizado entonces para dar formato al encabezado de la nueva página antes de que el registro sea escrito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this way C&lt;our&gt; differs from C&lt;use vars&gt;, which is package-scoped.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T174832Z" changeid="explorer">
        <seg>De esta manera, C&lt;our&gt; difiere de C&lt;use vars&gt;, en que su ámbito es el paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl under Mac OS Classic has not been supported since before Perl 5.10
(April 2004).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T014333Z" changeid="explorer">
        <seg>Perl bajo Mac OS Classic no está soportado desde antes de Perl 5.10 (April 2004).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} []gsx;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} []gsx;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Dave Mitchell)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112218Z" changeid="explorer">
        <seg>(Dave Mitchell)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcommunity	Perl community information</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000735Z" changeid="explorer">
        <seg>perlcommunity	Información sobre la comunidad Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Has semantics similar to the following subroutine:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tiene una semántica similar a la subrutina siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CPAN
contains source code, non-native ports, documentation, scripts, and
many third-party modules and extensions, designed for everything from
commercial database interfaces to keyboard/screen control to web
walking and CGI scripts.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230008Z" changeid="explorer">
        <seg>En CPAN puede encontrar código fuente, adaptaciones a plataformas no nativas, documentación, scripts y muchos módulos y extensiones de terceros, diseñados para todo tipo de aplicaciones, como interfaces de bases de datos comerciales, control de pantalla y teclado, exploración automática de sitios web y creación de scripts CGI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is a hash, it chops the hash's values, but not its keys.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE es un hash, recorta los valores del hash, pero no sus claves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-       left-justify within the field</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-       justifica a la izquierda dentro del campo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wanted =&gt; sub {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225447Z" changeid="explorer">
        <seg>wanted =&gt; sub {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$                   end of string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T235535Z" changeid="zipf">
        <seg>$                   final de una cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, several special variables that provide windows into
the inner working of Perl have names containing punctuation characters
and control characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, ciertas variables especiales que proporcionan acceso al medio interno de Perl tienen nombres que contienen caracteres de puntuación y caracteres de control.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;goto &amp;&gt; is now more robust - bugs in deep recursion and chained C&lt;goto &amp;&gt;
have been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T211150Z" changeid="explorer">
        <seg>C&lt;goto &amp;&gt; es ahora más robusto - errores en la recursividad profunda y C&lt;goto &amp;&gt; encadenados han sido corregidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232603Z" changeid="explorer">
        <seg>Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington y otros autores indicados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always returns the
undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre devuelve el valor indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsyn/&quot;Switch statements&quot;&gt; for detailed information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234446Z" changeid="explorer">
        <seg>Ver L&lt;perlsyn/&quot;Instrucciones Switch&quot;&gt; para obtener información detallada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This latter is useful for counting characters in a class or for
squashing character sequences in a class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto último es útil para el recuento de caracteres de una clase o para reducir las secuencias de caracteres de una clase.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the C&lt;Term::ReadKey&gt;
module from your nearest CPAN site; details on CPAN can be found under
L&lt;perlmodlib/CPAN&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T162030Z" changeid="explorer">
        <seg>Ver también el módulo C&lt;Term::ReadKey&gt; en su sitio CPAN más cercano; detalles sobre CPAN se pueden encontrar en L&lt;perlmodlib/CPAN&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some bugs have been fixed in the hash internals.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T111003Z" changeid="explorer">
        <seg>Algunos errores han sido corregidos en los procedimientos internos de los hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you understand
this rule, you may skip the rest of this section on the first
reading.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted entiende esta regla, puede omitir la primera lectura del resto de esta sección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless (ref($r)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless (ref($r)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use File::Find::Rule;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225446Z" changeid="explorer">
        <seg>use File::Find::Rule;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Generic fixes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010551Z" changeid="explorer">
        <seg>=head2 Arreglos genéricos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the right side is either a C&lt;[...]&gt;, C&lt;{...}&gt;, or a
C&lt;(...)&gt; subscript, then the left side must be either a hard or
symbolic reference to an array, a hash, or a subroutine respectively.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el lado derecho es, o una C&lt;[...]&gt;, C&lt;{...}&gt;, o un subrango C&lt;(...)&gt;, entonces el lado izquierdo debe ser una referencia dura o simbólica a un array, un hash, o una subrutina, respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Nicholas Clark)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112032Z" changeid="explorer">
        <seg>(Nicholas Clark)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: Once Perl sees that you need one of C&lt;$&amp;&gt;, C&lt;$`&gt;, or
C&lt;$'&gt; anywhere in the program, it has to provide them for every
pattern match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;ADVERTENCIA&gt;: Una vez que Perl considera que necesitas una de C&lt;$&amp;&gt;, C&lt;$`&gt;, o C&lt;$'&gt;, en cualquier parte del programa, las usará para todos los patrones de coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 List Operators (Rightward)
X&lt;operator, list, rightward&gt; X&lt;list operator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001712Z" changeid="explorer">
        <seg>=head2 Operadores de lista (por la derecha)
X&lt;operator, list, rightward&gt; X&lt;list operator&gt; X&lt;operador, lista, por la derecha&gt; X&lt;operador de lista&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Richard Foley with Andy Lester</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003651Z" changeid="explorer">
        <seg>Richard Foley con Andy Lester</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;our&gt; associates a simple name with a package variable in the current
package for use within the current scope.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;our&gt; asocia un nombre sencillo con una variable de paquete en el paquete actual para ser usado en el ámbito actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>srand (time ^ $$ ^ unpack &quot;%L*&quot;, `ps axww | gzip -f`);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>srand (time ^ $$ ^ unpack &quot;%L*&quot;, `ps axww | gzip -f`);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a % 2 ? $a += 10 : $a += 2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054114Z" changeid="explorer">
        <seg>$a % 2 ? $a += 10 : $a += 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unshift(@ARGV, '-e') unless $ARGV[0] =~ /^-/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unshift(@ARGV, '-e') unless $ARGV[0] =~ /^-/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SECONDS is not
specified, the value stored in C&lt;$_&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se ha especificado SEGUNDOS, se usará el valor almacenado en C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>June 1, 2000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 de junio 2000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point numbers are only approximations to what a mathematician
would call real numbers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Números de punto flotante son sólo aproximaciones a lo que un matemático llamaría a los números reales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The build system that Perl uses is called metaconfig. This system is
maintained separately from the Perl core.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014910Z" changeid="explorer">
        <seg>Perl usa un sistema de compilación denominado metaconfig. El mantenimiento de este sistema se realiza por separado del mantenimiento del núcleo de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;chop&gt; returns the last character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;chop&gt; devuelve el último carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the output is empty and C&lt;$@&gt; already contains a value (typically from a
previous eval) that value is used after appending C&lt;&quot;\t...caught&quot;&gt;
to C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la salida está vacía y C&lt;$@&gt; ya contiene un valor (típicamente de un eval() anterior) este valor es utilizado después de añadirle C&lt;&quot;\t...caught&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means it actually
has both compile-time and run-time effects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que tiene efectos tanto en tiempo de compilación como en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should have received a copy of the Artistic License with this
Kit, in the file named &quot;Artistic&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T223212Z" changeid="explorer">
        <seg>Debería haber recibido una copia de la Licencia Artística con este kit, en el archivo denominado &quot;Artistic&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/foo/bar/;               # replaces foo with bar in $_</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T030211Z" changeid="explorer">
        <seg>s/foo/bar/;               # reemplaza foo por bar en $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\d        [3]  Match a decimal digit character</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223712Z" changeid="explorer">
        <seg>\d	 [3]  Coincide con un dígito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl51310delta	Perl changes in version 5.13.10</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141258Z" changeid="explorer">
        <seg>perl51310delta	Cambios en la versión 5.13.10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># search for some stuff and put it into files</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># buscar por algo y ponerlo en el archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POS
must be a value returned by C&lt;telldir&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>POS debe ser un valor devuelto por C&lt;telldir&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opens a socket of the specified kind and attaches it to filehandle
SOCKET.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012541Z" changeid="explorer">
        <seg>Abre un socket de la clase especificada y lo adhiere al identificador de archivo SOCKET.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T000635Z" changeid="explorer">
        <seg>and</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Even\n&quot; if ($x &amp; 1) == 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Par\n&quot; if ($x &amp; 1) == 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You can use C&lt;for my $_ (@array)&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Puede usar C&lt;for my $_ (@array)&gt;.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A coderef is now acceptable for C&lt;CHECK&gt;!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030838Z" changeid="explorer">
        <seg>¡Ahora se acepta una referencia a código en C&lt;CHECK&gt;!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s	Squash duplicate replaced characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s	Elimina caracteres duplicados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, if many elements may be undefined you may see the
following unattractive method calls:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022225Z" changeid="explorer">
        <seg>Además, si muchos elementos pueden estar indefinidos puede ver las siguientes poco atractivas llamadas de métodos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ARRAY = ();    # completely empty @ARRAY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ARRAY = ();    # vaciar completamente @ARRAY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub bintodec {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub bintodec {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following equivalences hold (assuming C&lt;&lt; $[ == 0 and $#a &gt;= $i &gt;&gt; )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las siguientes equivalencias se mantienen (suponiendo que C&lt;&lt; $[ == 0 y $#a &gt;= $i &gt;&gt; )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;ptardiff&gt; is a small script used to generate a diff between the contents
of a tar archive and a directory tree.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T013419Z" changeid="explorer">
        <seg>C&lt;ptardiff&gt; es una pequeña utilidad que genera las diferencias entre los contenidos de un archivo tar y un árbol de directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many, many code points, but computers work with bytes, and a byte has
room for only 256 values.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234353Z" changeid="explorer">
        <seg>Hay muchísimos códigos de carácter, pero el hardware trabaja con bytes, y un byte sólo puede representar 256 valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opendir(D, $dir)	 or die &quot;can't opendir $dir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>opendir(D, $dir)	 or die &quot;no puedo hacer opendir $dir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>prints</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050139Z" changeid="explorer">
        <seg>imprime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes how Perl internally handles numeric values.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232314Z" changeid="explorer">
        <seg>En este documento se describe el procesamiento interno de valores numéricos en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values are usually referred to by name, or through a named reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A los valores se accede normalmente por su nombre, o a través de una referencia con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying it twice
gives added protection.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000215Z" changeid="explorer">
        <seg>Especificándolo dos veces ofrece una protección adicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>;-)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T114341Z" changeid="zipf">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, this has to
unwind one hash and build a whole new one, which may take some time
on a large hash, such as from a DBM file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además, esto tiene el efecto de desmontar un hash y construir uno nuevo, algo que puede tardar algún tiempo en un hash grande, como en un archivo DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FORMAT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FORMAT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Bash</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225453Z" changeid="explorer">
        <seg>=item Bash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, C&lt;defined @$foo&gt; and
C&lt;defined %$foo&gt; are still allowed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T034922Z" changeid="explorer">
        <seg>(Sin embargo, C&lt;defined @$foo&gt; y C&lt;defined %$foo&gt; todavía están permitidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Braces are required in referring to named capture groups, but are optional for
absolute or relative numbered ones.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T160134Z" changeid="explorer">
        <seg>Las llaves son necesarias al referirse a los grupos de captura de llamada, pero son opcionales para los números absolutos o relativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The caller is responsible for incrementing the reference count of the array
returned if it wants to keep the structure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114944Z" changeid="explorer">
        <seg>El llamador es responsable de incrementar el contador de referencias del array devuelto si se quiere mantener la estructura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the arctangent of Y/X in the range -PI to PI.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el arcotangente de Y/X en el rango -PI a PI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub myopen {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub miopen {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Verbs without an argument</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003230Z" changeid="explorer">
        <seg>=item Verbos sin argumento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous assignments are exactly equivalent to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las asignaciones anteriores son exactamente iguales a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may otherwise modify your copy of this Package in any way, provided
that you insert a prominent notice in each changed file stating how and
when you changed that file, and provided that you do at least ONE of the
following:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004109Z" changeid="explorer">
        <seg>De lo contrario puede modificar su copia de este Paquete de cualquier manera, siempre que se inserte de forma visible en cada archivo cambiado, indicando cómo y cuándo se ha cambiado ese archivo, y siempre que usted haga por lo menos UNO de los puntos siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 IRIX: t/uni/tr_7jis.t falsely failing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003958Z" changeid="explorer">
        <seg>=head2 IRIX: t/uni/tr_7jis.t falla falsamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Buffer overflow in prime_env_iter: %s</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110307T000801Z" changeid="explorer">
        <seg>=item Buffer overflow in prime_env_iter: %s</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = grep {!/^#/} @bar;    # weed out comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = grep {!/^#/} @bar;    # quitar los comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No, Perl is easy to start learning--and easy to keep learning.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230259Z" changeid="explorer">
        <seg>No. Es fácil adquirir los conocimientos básicos; y también lo es seguir aprendiendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(??{ EXPR })&gt;, C&lt;(?PARNO)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045954Z" changeid="explorer">
        <seg>=item C&lt;(??{ EXPR })&gt;, C&lt;(?PARNO)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Mastering Perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003351Z" changeid="explorer">
        <seg>=item I&lt;Mastering Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlmod&gt;, L&lt;perlmodlib&gt;, and L&lt;perlmodinstall&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001146Z" changeid="explorer">
        <seg>Se describe en L&lt;perlmod&gt;, L&lt;perlmodlib&gt; y L&lt;perlmodinstall&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;&gt; is just a synonym for &lt;ARGV&gt;, which
is magical.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;&gt; es justo un sinónimo de &lt;ARGV&gt;, lo cual es mágico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aab</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050707Z" changeid="explorer">
        <seg>aab</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In decimal representation this is close
to 16 decimal digits and decimal exponents in the range of -304..304.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232529Z" changeid="explorer">
        <seg>En representación decimal, estos límites se acercan a 16 dígitos decimales y exponentes decimales en el intervalo -304..304.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a lexical
pragma, like C&lt;strict&gt; or C&lt;warnings&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192910Z" changeid="explorer">
        <seg>Se trata de una pragma léxico, al igual que C&lt;strict&gt; o C&lt;warnings&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aaa</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050704Z" changeid="explorer">
        <seg>aaa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach (@array) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach (@array) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array   Array     arrays are comparable[2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Array       Array      arrays son comparables[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 4   ==          4 00100000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 4   ==          4 00100000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Where do I send bug reports?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231105Z" changeid="explorer">
        <seg>=head2 ¿A qué dirección debo enviar los informes de error?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SPLICE this, offset, length, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SPLICE este, desplazamiento, longitud, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
returns the log of C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171426Z" changeid="explorer">
        <seg>Si EXPR se omite, devuelve el logaritmo de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As before, the rules to determine
where the C&lt;code&gt; ends are currently somewhat convoluted.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T182605Z" changeid="explorer">
        <seg>Como antes, las reglas para determinar el lugar donde C&lt;código&gt; termina son algo enrevesadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Assignment Operators
X&lt;assignment&gt; X&lt;operator, assignment&gt; X&lt;=&gt; X&lt;**=&gt; X&lt;+=&gt; X&lt;*=&gt; X&lt;&amp;=&gt;
X&lt;&lt;&lt; &lt;&lt;= &gt;&gt;&gt; X&lt;&amp;&amp;=&gt; X&lt;-=&gt; X&lt;/=&gt; X&lt;|=&gt; X&lt;&lt;&lt; &gt;&gt;= &gt;&gt;&gt; X&lt;||=&gt; X&lt;//=&gt; X&lt;.=&gt;
X&lt;%=&gt; X&lt;^=&gt; X&lt;x=&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001252Z" changeid="explorer">
        <seg>=head2 Operadores de asignación
X&lt;assignment&gt; X&lt;operator, assignment&gt; X&lt;=&gt; X&lt;**=&gt; X&lt;+=&gt; X&lt;*=&gt; X&lt;&amp;=&gt;
X&lt;&lt;&lt; &lt;&lt;= &gt;&gt;&gt; X&lt;&amp;&amp;=&gt; X&lt;-=&gt; X&lt;/=&gt; X&lt;|=&gt; X&lt;&lt;&lt; &gt;&gt;= &gt;&gt;&gt; X&lt;||=&gt; X&lt;//=&gt; X&lt;.=&gt;
X&lt;%=&gt; X&lt;^=&gt; X&lt;x=&gt; X&lt;asignación&gt; X&lt;operador, asignación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll probably have to say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Probablemente escribirá</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step is the last one for all constructs except regular expressions,
which are processed further.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este paso es el último para todas las construcciones, salvo las expresiones regulares, que son procesadas ulteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The error &quot;Can't locate Foo.pm in @INC&quot; now lists the contents of @INC
for easier debugging.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001255Z" changeid="explorer">
        <seg>El error &quot;Can't locate Foo.pm in @INC&quot; ahora lista los contenidos de @INC para una depuración más sencilla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 I copied the perl binary from one machine to another, but scripts don't work.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225841Z" changeid="explorer">
        <seg>=head2 He copiado el binario perl de una máquina a otra, pero los scripts no funcionan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;SelfLoader&gt; for more description of __DATA__, and
an example of its use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;Autocargador&gt; para una mayor descripción de __DATA__, y ejemplos de su uso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact meaning of the $gcos field varies but it usually contains
the real name of the user (as opposed to the login name) and other
information pertaining to the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El significado exacto del campo $gcos varía pero usualmente contiene el nombre real del usuario (como opuesto al nombre de login) y otra información perteneciente al usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means for example that C&lt;$version{2.0}++&gt; is
equivalent to C&lt;$version{2}++&gt;, not to C&lt;$version{'2.0'}++&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T035440Z" changeid="explorer">
        <seg>Esto significa, por ejemplo, que C&lt;$version{2.0}++&gt; es equivalente a C&lt;$version{2}++&gt;, no a C&lt;$version{'2.0'}++&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't require every module user to jump through the same hoops to achieve a
simple result.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021118Z" changeid="explorer">
        <seg>No exija a cada usuario del módulo saltar a través de los mismos aros para lograr un resultado sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For delays of finer granularity than one second, the Time::HiRes module
(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides ualarm().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para lapsos de tiempo inferiores a un segundo, el módulo Time::HiRes (en CPAN, y desde Perl 5.8 parte de la distribución estándar) ofrece ualarm().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment operators work as in C.  That is,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operadores de asignación funcionan como en C. Es decir,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@$ = (eval{/$re/},$@!~/unmatched/i);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225532Z" changeid="explorer">
        <seg>@$ = (eval{/$re/},$@!~/unmatched/i);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implicit localization occurs I&lt;only&gt; in a C&lt;foreach&gt;
loop.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T212259Z" changeid="explorer">
        <seg>Esta implícita localización ocurre I&lt;solamente&gt; en un bucle C&lt;foreach&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 was an oft
used term for Chip Salzenberg's project to rewrite Perl in C++ named
Topaz.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230046Z" changeid="explorer">
        <seg>Perl 6 era un nombre que se solía usar para hacer referencia a un proyecto de Chip Salzenberg, con nombre clave Topaz, consistente en reescribir Perl en C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rec = {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$rec = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl
bug database at http://bugs.perl.org.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted encuentra algo que piensa que es un error, podría verificar los artículos publicados recientemente en el grupo de noticias comp.lang.perl.misc y la base de datos de errores de perl en http://bugs.perl.org/.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item SlickEdit</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item SlickEdit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $expire
field, if present, encodes the expiration period of the account or the
password.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El campo $expira, si está presente, codifica el periodo de expiración de la cuenta o de la contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Actually, one good reason is when you already have an existing
application written in another language that's all done (and done
well), or you have an application language specifically designed for a
certain task (e.g. prolog, make).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231124Z" changeid="explorer">
        <seg>La verdad, una buena razón es tener una aplicación escrita en otro lenguaje que funciona bien y está bien programada, o disponer de un lenguaje para aplicaciones diseñado específicamente para una tarea determinada (como prolog o make).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = $b or $c;		# bug: this is wrong</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a = $b or $c;		# error: esto está mal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two new cases where C&lt;when&gt; now
interprets its argument as a boolean, instead of an expression to be used
in a smart match:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110705T233055Z" changeid="explorer">
        <seg>Hay dos nuevos casos en el que ahora C&lt;when&gt; interpreta su argumento como un valor booleano, en lugar de una expresión que se utiliza en una coincidencia inteligente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Version numbering</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T025119Z" changeid="explorer">
        <seg>=head2 Numerado de versión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Install</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Instalación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eof FILEHANDLE
X&lt;eof&gt;
X&lt;end of file&gt;
X&lt;end-of-file&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T005828Z" changeid="explorer">
        <seg>=item eof IDENTIFICADOR_ARCHIVO
X&lt;eof&gt; X&lt;end of file&gt; X&lt;end-of-file&gt; X&lt;fin de archivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>otherwise it's necessary to protect any leading and trailing whitespace:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>de lo contrario es necesario proteger los espacios en blanco iniciales y finales:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the constructs except here-docs, single characters are used as starting
and ending delimiters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las construcciones, salvo los documentos incrustados, caracteres simples son utilizados como delimitadores de inicio y finalización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Shell&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T020408Z" changeid="explorer">
        <seg>C&lt;Shell&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = $ok ? $b : $c;  # get a scalar</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053840Z" changeid="explorer">
        <seg>$a = $ok ? $b : $c;  # obtiene un escalar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 4) = 8   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 4) = 8   ==       2048 00000000000100000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or the opposite of a C&lt;push&gt;,
depending on how you look at it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>O lo contrario de un C&lt;push&gt;, dependiendo de cómo se mire.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shmread() taints the variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shmread() contamina a la variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Quads are available only if your system supports 64-bit</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Cuádruplos están disponibles solo si su sistema soporta valores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;o?&gt; matches at the beginning of C&lt;'foo'&gt;, and since the position
in the string is not moved by the match, C&lt;o?&gt; would match again and again
because of the C&lt;*&gt; quantifier.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230628Z" changeid="explorer">
        <seg>El C&lt;o?&gt; coincide con el inicio de C&lt;'foo'&gt;, y como la posición en la cadena no se ha movido por la coincidencia, C&lt;o?&gt; coincidirá una y otra vez a causa del cuantificador C&lt;*&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may include dynamically
looking back your call-stack at run time to find the LABEL.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto puede incluir el analizar la pila de llamadas, de forma dinámica, en tiempo real, para encontrar la ETIQUETA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {$a &lt;=&gt; $b} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {$a &lt;=&gt; $b} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directory contains XS-using modules which are only released as part of
the core.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014413Z" changeid="explorer">
        <seg>Este directorio contiene módulos que usan XS y que solo se publican como parte del núcleo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return C&lt;undef&gt; or an empty list if the C C&lt;gettimeofday()&gt; function fails</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040917Z" changeid="explorer">
        <seg>Devuelve C&lt;undef&gt; o una lista vacía si falla la función en C C&lt;gettimeofday()&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the Copyright Holder may not be used to endorse or promote
products derived from this software without specific prior written permission.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El nombre del Titular del Copyright no puede utilizarse para apoyar o promocionar productos derivados de este software sin previo consentimiento escrito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	or xor</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	or xor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its exact
           size depends on what a local C compiler calls 'int'.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su tamaño exacto depende de lo que un compilador C local llama 'int').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl was ported to Mac OS by Matthias Neeracher
E&lt;lt&gt;neeracher@mac.comE&lt;gt&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T014356Z" changeid="explorer">
        <seg>Perl fue adaptado a Mac OS por Matthias Neeracher
E&lt;lt&gt;neeracher@mac.comE&lt;gt&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item continue</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item continue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 ACKNOWLEDGEMENTS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T171351Z" changeid="zipf">
        <seg>=head1 AGRADECIMIENTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[This function has been largely superseded by the C&lt;tie&gt; function.]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[Esta función ha sido largamente supeditada por la función C&lt;tie&gt;].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $tX eq $tY;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return $tX eq $tY;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This effectively means that the regex engine &quot;skips&quot; forward
to this position on failure and tries to match again, (assuming that
there is sufficient room to match).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T011139Z" changeid="explorer">
        <seg>Esto significa que, efectivamente, el motor de expresiones regulares &quot;salta&quot; hacia adelante a esta posición en caso de fallo y trata de coincidir de nuevo, (suponiendo que haya espacio suficiente para que coincida).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FAILED at test 57</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214803Z" changeid="explorer">
        <seg>FAILED at test 57</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort(find_records @key);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort(busca_registros @claves);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, the Artistic License
spells all this out for your protection, so you may prefer to use that.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T224600Z" changeid="explorer">
        <seg>Por supuesto, la Licencia Artística hechiza todo esto, para su protección, por lo que quizás prefiera usarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;STRING&gt; is interpolated the same way as I&lt;PATTERN&gt;
in C&lt;m/PATTERN/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T003412Z" changeid="explorer">
        <seg>I&lt;CADENA&gt; es interpolada de la misma manera que I&lt;PATRÓN&gt; en C&lt;m/PATRÓN/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FAILED at test 71</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214812Z" changeid="explorer">
        <seg>FAILED at test 71</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Punctuation&quot; arrays such as C&lt;@*&gt; are usually
interpolated only if the name is enclosed in braces C&lt;@{*}&gt;, but the
arrays C&lt;@_&gt;, C&lt;@+&gt;, and C&lt;@-&gt; are interpolated even without braces.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T023912Z" changeid="explorer">
        <seg>Los arrays de &quot;puntuación&quot; como C&lt;@*&gt; son normalmente interpolados solo si el nombre está encerrado entre llaves C&lt;@{*}&gt;, pero los arrays C&lt;@_&gt;, C&lt;@+&gt;, y C&lt;@-&gt; son interpolados, incluso sin llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Because
backticks always undergo shell expansion as well, see L&lt;perlsec&gt; for
security concerns.)
X&lt;qx&gt; X&lt;`&gt; X&lt;``&gt; X&lt;backtick&gt; X&lt;glob&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220238Z" changeid="explorer">
        <seg>(Debido a que las comillas invertidas siempre provocan una expansión a nivel de shell, vea someterse a expansión de la shell, vea L&lt;perlsec&gt; por motivos de seguridad). X&lt;qx&gt; X&lt;`&gt; X&lt;``&gt; X&lt;backtick&gt; X&lt;glob&gt; X&lt;comilla invertida&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 ctime    inode change time in seconds since the epoch (*)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>10 ctime    tiempo cambio inodo, en segundos desde el (*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$count = ($paragraph =~ s/Mister\b/Mr./g);  # get change-count</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$contador = ($parrafo =~ s/Señor\b/Sr./g);  # obtener el número de cambios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?&gt;#[ \t]*)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002941Z" changeid="explorer">
        <seg>(?&gt;#[ \t]*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.vmesa - building and installing Perl for VM/ESA.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T064729Z" changeid="explorer">
        <seg>README.vmesa - compilando e instalando Perl en VM/ESA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if successful,
false on error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000916Z" changeid="explorer">
        <seg>Devuelve verdadero si tuvo éxito, falso en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because unlike C, in perl you can't freely
interchange arrays and references thereto.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Eso es porque, a diferencia de C, en perl no puede intercambiar libremente los array y referencias a ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;lt&quot;, &quot;le&quot;, &quot;ge&quot;, &quot;gt&quot; and &quot;cmp&quot; use the collation (sort) order specified
by the current locale if C&lt;use locale&gt; is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;lt&quot;, &quot;le&quot;, &quot;ge&quot;, &quot;gt&quot; y &quot;cmp&quot; usan el orden de intercalación (sort) especificado por la configuración regional actual si C&lt;use locale&gt; está en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To (re)open C&lt;STDOUT&gt; or C&lt;STDERR&gt; as an in-memory file, close it first:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para (re)abrir C&lt;STDOUT&gt; o C&lt;STDERR&gt; como un archivo en memoria, primero, cierrelos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your input is binary, and is supposed to remain binary, you shouldn't decode
it to a text string, of course.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235048Z" changeid="explorer">
        <seg>Por supuesto, si la entrada es binaria y debe permanecer así, no debe descodificarla en una cadena de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($in_header) {
            # do something</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053649Z" changeid="explorer">
        <seg>if ($en_cabecera) {
            # hacer algo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;6: got $1\n&quot; if $y =~ /^(\D*)(?=\d)(?!123)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171629Z" changeid="explorer">
        <seg>print &quot;6: tenemos $1\n&quot; if $y =~ /^(\D*)(?=\d)(?!123)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For characters C&lt;&quot;a&quot;..&quot;f&quot;&gt; and C&lt;&quot;A&quot;..&quot;F&quot;&gt;, the result
is compatible with the usual hexadecimal digits, so that C&lt;&quot;a&quot;&gt; and
C&lt;&quot;A&quot;&gt; both generate the nybble C&lt;0xA==10&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T002729Z" changeid="explorer">
        <seg>Para los caracteres C&lt;&quot;a&quot;..&quot;f&quot;&gt; y C&lt;&quot;A&quot;..&quot;F&quot;&gt;, el resultado es compatible con los dígitos hexadecimales acostumbrados, de modo que C&lt;&quot;a&quot;&gt; y C&lt;&quot;A&quot;&gt; generan ambos el nible C&lt;0xA==10&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$num = $cost/$quantity;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$num = $cost/$quantity;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($self) = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225439Z" changeid="explorer">
        <seg>my ($self) = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
instance the above example could also be written as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, el ejemplo anterior también se podría escribir de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/
         (Y)            # group 1
         (              # group 2
            (X)         # group 3
            \g{-1}      # backref to group 3
            \g{-3}      # backref to group 1
         )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045823Z" changeid="explorer">
        <seg>/
         (Y)            # grupo 1
         (              # grupo 2
            (X)         # grupo 3
            \g{-1}      # contraref. a grupo 3
            \g{-3}      # contraref. a grupo 1
         )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn't become false till the next time the range operator
is evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se vuelve falso hasta la próxima vez que el operador rango es evaluado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;FileCache&gt; upgraded to version 1.06</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032129Z" changeid="explorer">
        <seg>C&lt;FileCache&gt; actualizado a la versión 1.06</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>200) { print; } # print 2nd hundred lines, short for
                               #  if ($.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T185042Z" changeid="explorer">
        <seg>200) { print; } # imprime las segundas cien líneas,
                               # versión corta de ($.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@INC</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225447Z" changeid="explorer">
        <seg>@INC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open memory file: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir el archivo en memoria: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closing any piped filehandle causes the parent process to wait for the
child to finish, then returns the status value in C&lt;$?&gt; and
C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T234739Z" changeid="explorer">
        <seg>Cerrando cualquier identificador de archivo entubado hace que el proceso padre espere a que el hijo termine, y devuelva el valor de estado en C&lt;$?&gt; y en C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$hinthash&gt; is a reference to a hash containing the value of C&lt;%^H&gt; when the
caller was compiled, or C&lt;undef&gt; if C&lt;%^H&gt; was empty.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$hinthash&gt; es una referencia a un hash conteniendo el valor de C&lt;%^H&gt; cuando el llamante ha sido compilado, o C&lt;undef&gt; si C&lt;%^H&gt; estaba vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the boilerplate test is now called F&lt;t/Foo-Bar.t&gt;
instead of F&lt;t/1.t&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T180134Z" changeid="explorer">
        <seg>Además, la prueba reutilizable se llama ahora F&lt;t/Foo-Bar.t&gt; en lugar de F&lt;t/1.t&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\bgreen\b/mauve/g;		# don't change wintergreen</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T212938Z" changeid="explorer">
        <seg>s/\bverde\b/malva/g;			# no cambia verdeazul</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Socket library makes this slightly easier:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La biblioteca Socket hace esto ligeramente más fácilmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without the C&lt;/g&gt; modifier, the
C&lt;\G&gt; assertion still anchors at C&lt;pos()&gt; as it was at the start of
the operation (see L&lt;perlfunc/pos&gt;), but the match is of course only
attempted once.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220155Z" changeid="explorer">
        <seg>Sin el modificador C&lt;/g&gt;, la aserción C&lt;\G&gt; todavía se ancla en pos() como si fuera al principio de la operación (vea L&lt;perlfunc/pos&gt;), pero la coincidencia, por supuesto, sólo es probada una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since version 5.8.1, perl uses the /d switch when running the cmd.exe shell
internally for system(), backticks, and when opening pipes to external
programs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142257Z" changeid="explorer">
        <seg>Desde la versión 5.8.1, perl usa el modificador /d cuando se ejecuta el shell cmd.exe, internamente, para system(), comillas invertidas, y al abrir tuberías hacia programas externos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 3, 8) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 3, 8) = 2   ==   33554432 00000000000000000000000001000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstract namespace sockets are Linux-specific socket type that live in
AF_UNIX family, slightly abusing it to be able to use arbitrary
character arrays as addresses: They start with nul byte and are not
terminated by nul byte, but with the length passed to the socket()
system call.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152229Z" changeid="explorer">
        <seg>El espacio de nombres para sockets Abstract son un tipo específico de socket Linux que viven en la familia AF_UNIX, un poco abusando de ella para poder utilizar matrices arbitrarias de array de caracteres tal y como se indica: comienzan con el byte nulo y no se termina con el byte nulo, sino con la longitud pasada a la llamada del sistema socket().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BUGS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T171504Z" changeid="zipf">
        <seg>=head1 ERRORES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can now specify a destination directory for Perl installation
by specifying the DESTDIR variable for C&lt;make install&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T181642Z" changeid="explorer">
        <seg>Ahora se puede especificar un directorio destino para la instalación de Perl mediante la especificación de la variable DESTDIR para C&lt;make install&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Eclipse</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225450Z" changeid="explorer">
        <seg>=item Eclipse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=for comment
This document is in Pod format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T160910Z" changeid="explorer">
        <seg>=for comment
This document is in Pod format.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programs that want to lie to themselves about what was just input 
normally use this command:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los programas que quieren engañarse a sí mismos acerca de lo que se acaba de introducir suelen utilizar este comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example of how this might be used is as follows:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T203621Z" changeid="explorer">
        <seg>Un ejemplo de cómo esto podría ser utilizado es lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $q = $p or return;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>my $q = $p or return;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $file (@filenames) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $archivo (@archivos) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.8.1 uses the /d switch when running the cmd.exe shell
internally for system(), backticks, and when opening pipes to external
programs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005951Z" changeid="explorer">
        <seg>Perl 5.8.1 usa el modificador /d cuando se ejecuta el shell cmd.exe, internamente, para system(), comillas invertidas, y al abrir tuberías hacia programas externos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlthrtut		Perl threads tutorial</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000407Z" changeid="explorer">
        <seg>perlthrtut		Tutorial de subprocesos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the code to be executed doesn't vary, you may use the eval-BLOCK
form to trap run-time errors without incurring the penalty of
recompiling each time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el código a ser ejecutado no varía, puede usar la forma BLOQUE de eval para atrapar errores en tiempo de ejecución sin incurrir en la penalidad de recompilar cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously such assignments would suffer from integer wrap-around
during size calculations causing a misallocation, which would crash perl, and
could theoretically be used for &quot;stack smashing&quot; attacks.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T103322Z" changeid="explorer">
        <seg>Previamente, tales asignaciones podrían verse afectados por la pasada de vuelta de los enteros en los cálculos del tamaño, que causa una mala distribución, que provocaría una caída de perl, y teóricamente podrían ser utilizados para realizar ataques de &quot;ruptura de pila&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar    @array    slice:   @array[0, 2]  @hash{'a', 'b'}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224120Z" changeid="explorer">
        <seg>escalar    @array    porción:  @array[0, 2]  @hash{'a', 'b'}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can now build subsets of Perl core modules by using the
Configure flags C&lt;-Dnoextensions=...&gt; and C&lt;-Donlyextensions=...&gt;,
see F&lt;INSTALL&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T182855Z" changeid="explorer">
        <seg>Ahora se pueden crear subconjuntos de módulos básicos de Perl usando las banderas de Configure C&lt;-Dnoextensions=...&gt; y C&lt;-Donlyextensions=...&gt;, vea F&lt;INSTALL&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO,$foo) || die &quot;Can't open $foo: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO,$foo) || die &quot;No puedo abrir $foo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates to a list of the words extracted out of STRING, using embedded
whitespace as the word delimiters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa a una lista de palabras extraídas de CADENA, utilizando los espacios en blanco incrustados como delimitadores de palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;use strict 'vars'&gt; is in
effect, C&lt;our&gt; lets you use declared global variables without qualifying
them with package names, within the lexical scope of the C&lt;our&gt; declaration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando C&lt;use strict 'vars'&gt; esté activo, C&lt;our&gt; le permite usar variables globales declaradas sin calificarlas con nombres de paquetes, en el ámbito léxico de la declaración C&lt;our&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it was current when we made it available, Perl is constantly evolving
and there may be a more recent version that fixes bugs you've run into or
adds new features that you might find useful.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222550Z" changeid="explorer">
        <seg>A pesar de que estaba vigente cuando lo pusimos a su disposición, Perl está en constante evolución y puede haber una versión más reciente que corrige los errores que ha encontrado o añade nuevas características que le pueden resultar útil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;@DB::args&gt;, like C&lt;@_&gt;, does not hold explicit references to its
elements, so under certain cases its elements may have become freed and
reallocated for other variables or temporary values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;@DB::args&gt;, como C&lt;@_&gt;, no incluye referencias explícitas a sus elementos, por lo que en algunos casos sus elementos pueden haberse liberado y reasignado a otras variables o valores temporales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Pragmata Changes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003337Z" changeid="explorer">
        <seg>=head2 Cambios en la prágmata</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pointer to the linearisation function, described below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114025Z" changeid="explorer">
        <seg>Puntero a la función de linealización, descrita a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your C&lt;umask&gt; were C&lt;0027&gt; (group can't
write; others can't read, write, or execute), then passing
C&lt;sysopen&gt; C&lt;0666&gt; would create a file with mode C&lt;0640&gt; (because 
C&lt;0666 &amp;~ 027&gt; is C&lt;0640&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T024253Z" changeid="explorer">
        <seg>Si su C&lt;umask&gt; fuera C&lt;0027&gt; (el grupo no puede escribir; los otros no pueden leer, escribir o ejecutar), entonces pasando a C&lt;sysopen&gt; C&lt;0666&gt; creará un archivo con el modo C&lt;0640&gt; (porque C&lt;0666 &amp;~ 027&gt; es C&lt;0640&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlre&gt; and
L&lt;perlop&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlre&gt; y L&lt;perlop&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a C&lt;given&gt; statement is also a valid expression (e.g.
when it's the last statement of a block), it evaluates to :</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T105819Z" changeid="explorer">
        <seg>Cuando una instrucción C&lt;given&gt; es también una expresión válida (p.e. cuando es la última instrucción de un bloque), se evalúa a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, when called from within the DB package, caller returns more
detailed information: it sets the list variable C&lt;@DB::args&gt; to be the
arguments with which the subroutine was invoked.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T015933Z" changeid="explorer">
        <seg>Además, cuando se le llama desde el interior de un paquete DB, caller devuelve información más detallada: actualiza la variable C&lt;@DB::args&gt; con los argumentos con los que la subrutina fue invocada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pm.org?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231240Z" changeid="explorer">
        <seg>¿Y pm.org?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$x][$y] = func($x, $y);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$AoA[$x][$y] = func($x, $y);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most if not all systems
implement lockf(3) in terms of fcntl(2) locking, though, so the
differing semantics shouldn't bite too many people.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayor parte si no todos los sistemas implementan lockf(3) en términos de bloqueo con fcntl(2), aunque, las diferencias en la semántica no llame la atención a mucha gente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No space between function name and its opening parenthesis.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin espacio entre el nombre de función y su paréntesis de apertura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, Perl handles this for
us, so we don't have to worry about this.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234506Z" changeid="explorer">
        <seg>Afortunadamente, Perl se encarga de esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it
tests that everyone who is listed in the git log has a corresponding entry in
the F&lt;AUTHORS&gt; file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014715Z" changeid="explorer">
        <seg>Por ejemplo, comprueban que todas las personas que figuran en el registro de git tienen una entrada correspondiente en el archivo F&lt;AUTHORS&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$&amp;&gt; returns the entire matched string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$&amp;&gt; devuelve toda la cadena coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$text =~ s/foo/bar/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234527Z" changeid="explorer">
        <seg>$texto =~ s/foo/bar/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will find this behavior is slightly different from that of
C&lt;$SIG{__DIE__}&gt; handlers (which don't suppress the error text, but can
instead call C&lt;die&gt; again to change it).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted encontrará que este comportamiento es ligeramente diferente a la de los controladores C&lt;$SIG{__DIE__}&gt; (que no suprimen el texto de error, pero puede llamar, en su lugar, a C&lt;die&gt; de nuevo para cambiarlo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n = &quot;1234&quot;;	    # number specified as a string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232310Z" changeid="explorer">
        <seg>$n = &quot;1234&quot;;            # número especificado como una cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, a module C&lt;Foo::Bar&gt; whose source was
stored under F&lt;ext/Foo/Bar/&gt; is now located under F&lt;ext/Foo-Bar/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190456Z" changeid="explorer">
        <seg>En general, un módulo C&lt;Foo::Bar&gt; cuyo código fuente se almacenaba en F&lt;ext/Foo/Bar/&gt;, ahora se encuentra en F&lt;ext/Foo-Bar/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
first alternative includes everything from the last pattern delimiter
(&quot;(&quot;, &quot;(?:&quot;, etc. or the beginning of the pattern) up to the first &quot;|&quot;, and
the last alternative contains everything from the last &quot;|&quot; to the next
closing pattern delimiter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T223427Z" changeid="explorer">
        <seg>La primera alternativa incluye todo, desde el último patrón delimitador (&quot;(&quot;, &quot;(?:&quot;, etc o el comienzo del patrón) hasta el primer &quot;|&quot;, y la última alternativa contiene todo, desde el último &quot;|&quot; hasta el siguiente delimitador de cierre del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;q()&gt;, C&lt;qq()&gt;, and the like are not
supported in place of C&lt;''&gt; and C&lt;&quot;&quot;&gt;, and the only interpolation is for
backslashing the quoting character:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;q()&gt;, C&lt;qq()&gt;, y similares no están soportadas, en lugar de C&lt;''&gt; y C&lt;&quot;&quot;&gt;, y la única interpolación es para escapar el carácter de entrecomillado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one wants the hook to do
nothing in such situations, put</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si uno quiere que el gancho no haga nada en estas situaciones, ponga</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's important to realize that a
regular expression is merely a set of assertions that gives a definition
of success.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110905T003549Z" changeid="explorer">
        <seg>Es importante darse cuenta de que una expresión regular no es más que un conjunto de aserciones que da una definición de lo que consideramos un éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is only one scalar argument or an array with one element in it,
the argument is checked for shell metacharacters, and if there are any,
the entire argument is passed to the system's command shell for parsing
(this is C&lt;/bin/sh -c&gt; on Unix platforms, but varies on other platforms).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sólo hay un argumento escalar o un array con un elemento dentro de él, se comprueba si el argumento tiene metacaracteres, y si hay alguno, el argumento entero es pasado al shell de comandos para que sea interpretado (suele ser C&lt;/bin/sh -c&gt; en plataformas Unix, pero varía en otras plataformas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a*&quot;)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a*&quot;)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor as determined by the value
of C&lt;$^F&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T234546Z" changeid="explorer">
        <seg>En sistemas que soportan la bandera B&lt;close-on-exec&gt; (I&lt;cerrar en ejecución&gt;) en archivos, esta bandera se establecerá para el descriptor de archivo abierto recientemente según lo determinado por el valor de C&lt;$^F&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F  A Perl internal floating-point value (NV) in native format</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>F  Un valor Perl interno de punto flotante (NV) en formato nativo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Changes to type-based dispatch</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T221632Z" changeid="explorer">
        <seg>=head3 Cambios en el despacho basado en tipos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getgrgid GID</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getgrgid GID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other people picked up on this and started to write clever or obfuscated
programs to produce the same output, spinning things quickly out of
control while still providing hours of amusement for their creators and
readers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232022Z" changeid="explorer">
        <seg>Otras personas adoptaron esta tendencia y empezaron a escribir programas astutos o enrevesados para producir el mismo resultado, y se descontroló el asunto, lo que proporcionó grandes momentos de diversión a sus creadores y lectores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, stats C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, stats C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Fixed by Dave
Mitchell)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040613Z" changeid="explorer">
        <seg>(Arreglado por Dave Mitchell)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use feature &quot;:5.10&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use feature &quot;:5.10&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\u		titlecase (not uppercase!) next character only</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232521Z" changeid="explorer">
        <seg>\u		siguiente car. en mayúscula</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the message queue
id, or C&lt;undef&gt; on error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000637Z" changeid="explorer">
        <seg>Devuelve el identificador de una cola de mensajes, o el valor C&lt;undef&gt; si hay un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual sizes (in bytes) of native shorts, ints, longs, and long
longs on the platform where Perl was built are also available from
the command line:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tamaños reales (en bytes) de short, int, long y long largos nativos en la plataforma donde Perl fue compilado también están disponibles desde la línea de comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1  &quot;jane&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032550Z" changeid="explorer">
        <seg>1  &quot;jane&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It's possible to do things with named capture groups that would otherwise
require C&lt;(??{})&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T141757Z" changeid="explorer">
        <seg>(De este modo es posible hacer cosas con los grupos de captura con nombres que, de otro modo, requerirían código C&lt;(??{})&gt;.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem here is that both the group named C&lt;&lt; a &gt;&gt; and the group
named C&lt;&lt; b &gt;&gt; are aliases for the group belonging to C&lt;&lt; $1 &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T200503Z" changeid="explorer">
        <seg>El problema aquí es que tanto el búfer nominado C&lt;&lt; a &gt;&gt; como el grupo nominado C&lt;&lt; b &gt;&gt; son alias del grupo perteneciente a C&lt;&lt; $1 &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ .= qq</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ .= qq</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>no autovivification;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225619Z" changeid="explorer">
        <seg>no autovivification;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used with C&lt;.&gt;, the repeat count determines the starting position to
calculate the value offset as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se utiliza con C&lt;.&gt;, el número de repeticiones determina la posición de partida para calcular el valor de desplazamiento de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL foreach VAR (LIST) BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA foreach VAR (LIST) BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arguments are interpreted
as follows: if a given argument is numeric, the argument is passed as
an int.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los argumentos se interpretan de la siguiente manera: si un argumento dado es numérico, el argumento se pasa como un int.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is flexible and extensible enough for you to use on virtually any
task, from one-line file-processing tasks to large, elaborate systems.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230824Z" changeid="explorer">
        <seg>Por su flexibilidad y capacidad de ampliación, Perl se puede usar prácticamente para cualquier tarea, desde el procesamiento de archivos en una línea hasta el desarrollo de sistemas grandes y complejos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do_something;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hacer_algo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|  d   |  0   |</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225610Z" changeid="explorer">
        <seg>|  d   |  0   |</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Unicode is
in the process of reconsidering and revising their recommendations.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162850Z" changeid="explorer">
        <seg>Sin embargo, Unicode se encuentra en el proceso de reconsideraciones y revisando sus recomendaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $j++ until $j &gt;  10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $j++ until $j &gt;  10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when ([qw(foo bar)] { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T222422Z" changeid="explorer">
        <seg>when ([qw(foo bar)] { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $foo, exit;	# Nor is this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $foo, exit;	# Tampoco esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sh Configure -DPASE ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T134834Z" changeid="explorer">
        <seg>sh Configure -DPASE ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>syscall(&amp;SYS_write, fileno(STDOUT), $s, length $s);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>syscall(&amp;SYS_write, fileno(STDOUT), $s, length $s);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Windows-specific tests.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014704Z" changeid="explorer">
        <seg>Pruebas específicas de Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl defines the following zero-width assertions:
X&lt;zero-width assertion&gt; X&lt;assertion&gt; X&lt;regex, zero-width assertion&gt;
X&lt;regexp, zero-width assertion&gt;
X&lt;regular expression, zero-width assertion&gt;
X&lt;\b&gt; X&lt;\B&gt; X&lt;\A&gt; X&lt;\Z&gt; X&lt;\z&gt; X&lt;\G&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225605Z" changeid="explorer">
        <seg>Perl define las siguientes aserciones de ancho cero:
X&lt;zero-width assertion&gt; X&lt;assertion&gt; X&lt;regex, zero-width assertion&gt;
X&lt;regexp, zero-width assertion&gt;
X&lt;regular expression, zero-width assertion&gt;
X&lt;\b&gt; X&lt;\B&gt; X&lt;\A&gt; X&lt;\Z&gt; X&lt;\z&gt; X&lt;\G&gt;
X&lt;aserción ancho cero&gt; X&lt;aserción&gt; X&lt;regex, aserción ancho cero&gt;
X&lt;regexp, aserción ancho cero&gt;
X&lt;expresión regular, aserción ancho cero&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All text strings are in this internal format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110405T000938Z" changeid="explorer">
        <seg>Todas las cadenas de texto tienen este formato interno</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the reverse, use L&lt;/ord&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para lo contrario, use L&lt;/ord&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:encoding(...)&gt; layer implicitly introduces the C&lt;:utf8&gt; layer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La capa C&lt;:encoding(...)&gt; implícitamente introduce la capa C&lt;:utf8&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* text-mode STDIO</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015304Z" changeid="explorer">
        <seg>* modo texto en STDIO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,31, 1) = 1   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,31, 1) = 1   == 2147483648 00000000000000000000000000000001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Andy Lester supplied many improvements to determine which function
parameters and local variables could actually be declared C&lt;const&gt; to the C
compiler.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051724Z" changeid="explorer">
        <seg>Andy Lester suministró muchas mejoras para determinar qué parámetros de las funciones y qué variables locales podrían realmente ser declaradas C&lt;const&gt; para el compilador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Testing Anomalies of Perl on VM/ESA</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T111449Z" changeid="explorer">
        <seg>=head2 Probando anomalías de Perl en VM/ESA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;CR CR LF&quot; problem of has been fixed, binmode(FH, &quot;:crlf&quot;)
is now effectively a no-op.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001333Z" changeid="explorer">
        <seg>El problema &quot;CR CR LF&quot; ha sido fijado, binmode(FH &quot;:crlf&quot;) es ahora, efectivamente, una no-operación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dprofpp</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225449Z" changeid="explorer">
        <seg>dprofpp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special string C&lt;&quot;0 but true&quot;&gt; is exempt from B&lt;-w&gt; complaints
about improper numeric conversions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La cadena especial C&lt;&quot;0 but true&quot;&gt; (0, pero verdadero) es una excepción de los mensajes de aviso activados por B&lt;-w&gt; sobre una conversión numérica impropia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful for displaying ordinal values of
characters in arbitrary strings:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto puede ser útil para mostrar los valores ordinales de caracteres en cadenas arbitrarias:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The notation is C&lt;(?E&lt;lt&gt;I&lt;name&gt;E&lt;gt&gt;...)&gt; to declare and C&lt;\g{I&lt;name&gt;}&gt; to
reference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002507Z" changeid="explorer">
        <seg>La notación es C&lt;(?E&lt;lt&gt;I&lt;nombre&gt;E&lt;gt&gt;...)&gt; para declararlo y C&lt;\g{I&lt;nombre&gt;}&gt; para referirse a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;h2ph|h2ph&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234446Z" changeid="explorer">
        <seg>=item L&lt;h2ph|h2ph&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl extensions on Windows now can be statically built into the Perl DLL,
thanks to a work by Vadim Konovalov.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T043441Z" changeid="explorer">
        <seg>Extensiones Perl en Windows pueden ahora ser estáticamente compiladas en Perl DLL, gracias al trabajo de Vadim Konovalov.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($file) = &lt;blurch*&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($archivo) = &lt;loquesea*&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;ccxxcc&quot;,65,66,67,68);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;ccxxcc&quot;,65,66,67,68);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C-style Logical And
X&lt;&amp;&amp;&gt; X&lt;logical and&gt; X&lt;operator, logical, and&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T235520Z" changeid="explorer">
        <seg>=head2 And lógico al estilo del C
X&lt;&amp;&amp;&gt; X&lt;logical and&gt; X&lt;operator, logical, and&gt; X&lt;and lógico&gt; X&lt;operador, lógico, and&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;hash, scalar context&gt; X&lt;hash, bucket&gt; X&lt;bucket&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;hash, scalar context&gt; X&lt;hash, contexto escalar&gt; X&lt;hash, bucket&gt; X&lt;hash, cajones&gt; X&lt;bucket&gt; X&lt;cajones&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use warnings;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use warnings;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constructor now knows which module implements SHA-224</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030434Z" changeid="explorer">
        <seg>El constructor ahora sabe qué módulo implementa SHA-224</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$n = 01234;		    # octal integer</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232303Z" changeid="explorer">
        <seg>$n = 01234;             # entero octal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;\n#line &quot; . __LINE__ . ' &quot;' . __FILE__ .&quot;\&quot;\ndie 'foo'&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054705Z" changeid="explorer">
        <seg>eval &quot;\n#línea &quot; . __LINE__ . ' &quot;' . __FILE__ .&quot;\&quot;\ndie 'foo'&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, splice() has three scalar
arguments followed by a list, whereas gethostbyname() has four scalar
arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, splice() tiene tres argumentos escalares seguidos por una lista, mientras que gethostbyname() tiene cuatro argumentos escalares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
means that C&lt;\x7&gt; will be interpreted as C&lt;\x07&gt;, and a lone &lt;\x&gt; will be
interpreted as C&lt;\x00&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T231517Z" changeid="explorer">
        <seg>Esto significa que C&lt;\x7&gt; será interpretado como C&lt;\x07&gt;, y un único C&lt;\x&gt; será interpretado como un C&lt;\x00&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># we'll build auxiliary indices instead</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># construiremos índices auxiliares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlrebackslash	Perl regular expression backslash sequences</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000320Z" changeid="explorer">
        <seg>perlrebackslash	Secuencias de escape en expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(As the inner C&lt;$x&gt; is and
has always referred to C&lt;$::x&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110515Z" changeid="explorer">
        <seg>(Debido a que la variable interna C&lt;$x&gt; es y siempre es referida como C&lt;$::x&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See how much easier this is?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Ha visto que es mucho más fácil?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++($foo = &quot;Az&quot;);	# prints &quot;Ba&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223854Z" changeid="explorer">
        <seg>print ++($foo = &quot;Az&quot;);	# imprime &quot;Ba&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the length of the input string is not evenly divisible by 8, the
remainder is packed as if the input string were padded by null characters
at the end.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la longitud de la cadena de entrada no es divisible por 8, el resto se rellena como si la cadena de entrada estuviera completada con caracteres nulos hasta el final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a =~ s/foo/bar/;         # replaces foo with bar in $a</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T030222Z" changeid="explorer">
        <seg>$a =~ s/foo/bar/;         # reemplaza foo por bar en $a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just run ./Configure script from the top directory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo tiene que ejecutar el script ./Configure desde el directorio principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator and function decides which sort of value would be most
appropriate to return in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada operador y función decide qué clase de valor será más apropiado para devolver en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\n          newline               (LF, NL)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043327Z" changeid="explorer">
        <seg>\n		nueva línea		(LF, NL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 4) = 4   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 4) = 4   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, E-mail and HTTP support MIME headers, so you can use the
C&lt;Content-Type&gt; header.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235349Z" changeid="explorer">
        <seg>Por ejemplo, el correo electrónico y HTTP son compatibles con los encabezados MIME, por lo que puede usar el encabezado C&lt;Content-Type&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item stat EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item stat EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A
number of popular modules are included with the Perl distribution
itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225558Z" changeid="explorer">
        <seg>La distribución de Perl incluye muchos módulos populares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$ARGV $.: $_&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$ARGV $.: $_&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left	* / % x</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>izquierda	* / % x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($startx = $x = 4; $x &lt;= 8; $x++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053005Z" changeid="explorer">
        <seg>for ($startx = $x = 4; $x &lt;= 8; $x++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-s  File has nonzero size (returns size in bytes).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004627Z" changeid="explorer">
        <seg>-s  Archivo no tiene tamaño cero (devuelve el tamaño en bytes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select(REPORT1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select(INFORME1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;GUI&gt; X&lt;Tk&gt; X&lt;Wx&gt; X&lt;WxWidgets&gt; X&lt;Gtk&gt; X&lt;Gtk2&gt; X&lt;CamelBones&gt; X&lt;Qt&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225454Z" changeid="explorer">
        <seg>X&lt;GUI&gt; X&lt;Tk&gt; X&lt;Wx&gt; X&lt;WxWidgets&gt; X&lt;Gtk&gt; X&lt;Gtk2&gt; X&lt;CamelBones&gt; X&lt;Qt&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For blessed references, the
&quot;Object&quot; entries apply.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para referencias bendecidas, se aplica la entrada &quot;Objeto&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item use VERSION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item use VERSIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Object  Any       invokes ~~ overloading on $object, or falls back:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Objeto      Cualquiera invoca ~~ sobrecargado en $objeto, o termina:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>---------------     ---------------</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232336Z" changeid="explorer">
        <seg>------------------- ---------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perllocale&gt;
and L&lt;POSIX&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perllocale&gt; y L&lt;POSIX&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub&gt; and L&lt;perlref&gt; for details about subroutines and
references; see L&lt;attributes&gt; and L&lt;Attribute::Handlers&gt; for more
information about attributes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015338Z" changeid="explorer">
        <seg>Vea L&lt;perlsub&gt; y L&lt;perlref&gt; para los detalles acerca de subrutinas y referencias; vea L&lt;attributes&gt; y L&lt;Attribute::Handlers&gt; para obtener más información acerca de los atributos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Gisle Aas)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T111921Z" changeid="explorer">
        <seg>(Gisle Aas)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign something shorter than LENGTH,
the string will shrink, and if you assign something longer than LENGTH,
the string will grow to accommodate it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si asigna algo más corto que LONGITUD, la cadena se reducirá, y si asigna algo más largo que LONGITUD, la cadena crecerá para acogerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named backreference.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T214608Z" changeid="explorer">
        <seg>Referencia inversa nominada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrun/PERL_SIGNALS&gt;
and L&lt;perlipc/&quot;Deferred Signals (Safe Signals)&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T155643Z" changeid="explorer">
        <seg>Vea L&lt;perlrun/PERL_SIGNALS&gt; y L&lt;perlipc/&quot;Señales diferidas (Acceso seguro a señales)&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, a list assignment in list context produces the list of
lvalues assigned to, and a list assignment in scalar context returns
the number of elements produced by the expression on the right hand
side of the assignment.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T203547Z" changeid="explorer">
        <seg>Del mismo modo, una asignación de lista en contexto de lista produce la lista de I&lt;ivalores&gt; asignados, y una asignación de lista en contexto escalar devuelve el número de elementos producidos por la expresión en el lado derecho de la asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item next LABEL
X&lt;next&gt; X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191539Z" changeid="explorer">
        <seg>=item next ETIQUETA
X&lt;next&gt; X&lt;continue&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chomp</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chomp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The C&lt;$*&gt; variable has been removed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142611Z" changeid="explorer">
        <seg>=head2 La variable C&lt;$*&gt; ha sido eliminada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setnetent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setnetent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows one to
define subpatterns which will be executed only by the recursion mechanism.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213454Z" changeid="explorer">
        <seg>Esto permite definir sub-patrones que serán ejecutados sólo mediante el mecanismo de la recursión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># NOTE: The examples above featuring &quot;W&quot; and &quot;c&quot; are true</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># NOTA: Los ejemplos anteriores de &quot;W&quot; y &quot;c&quot; son correctos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11725</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11725</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 4) = 4   ==          4 00100000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 4) = 4   ==          4 00100000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contains links to information for module
authors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T032139Z" changeid="explorer">
        <seg>Contiene enlaces de información para los autores de módulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $null = substr $name, 6, 2;   # returns &quot;&quot; (no warning)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $nulo = substr $nombre, 7, 2;  # devuelve &quot;&quot; (sin advertencia)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return value of -1
indicates a failure to start the program or an error of the wait(2) system
call (inspect $!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001904Z" changeid="explorer">
        <seg>El retorno de valor de -1 indica un error en el arranque del programa o un error de la llamada al sistema wait(2) (inspeccionar $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the REPLACEMENTLIST is empty, the SEARCHLIST is replicated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la LISTA_REEMPLAZO está vacía, la LISTA_BÚSQUEDA es replicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results end up in C&lt;$1&gt;, C&lt;$2&gt; and so on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T232457Z" changeid="zipf">
        <seg>Los resultados se almacenan en C&lt;$1&gt;, C&lt;$2&gt;, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($fh) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my ($fh) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for throwing away some of the return values of a
function:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para descartar algunos de los valores de retorno de una función:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;a&gt;, C&lt;A&gt;, and C&lt;Z&gt; types gobble just one value, but pack it as a
string of length count, padding with nulls or spaces as needed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tipos C&lt;a&gt;, C&lt;A&gt;, y C&lt;Z&gt; absorben un solo valor, pero se empaqueta como una cadena de longitud indicada, rellenada con nulos o espacios según sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could write the last two using the C&lt;-u&gt; and C&lt;-d&gt; operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Podría escribir las dos últimas utilizando los operadores C&lt;-u&gt; y C&lt;-d&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
and only if the input symbol is the only thing inside the conditional
of a C&lt;while&gt; statement (even if disguised as a C&lt;for(;;)&gt; loop),
the value is automatically assigned to the global variable $_,
destroying whatever was there previously.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T105009Z" changeid="explorer">
        <seg>Si y sólo si el símbolo de entrada es la única cosa dentro de la condición de una instrucción C&lt;while&gt; (incluso si está disfrazado como un bucle C&lt;for(;;)&gt;), el valor es automáticamente asignado a la variable global $_, destruyendo su valor anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The numbering within each branch will be as normal, and any groups
following this construct will be numbered as though the construct
contained only one branch, that being the one with the most capture
groups in it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T200159Z" changeid="explorer">
        <seg>La numeración dentro de cada rama será la normal, y cualquier grupo después de esta construcción se numerará como si la construcción contuviera una sola rama, que es la que tiene más grupos de captura dentro de si.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just understand
that older releases will choke on it during compilation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T031353Z" changeid="explorer">
        <seg>Sólo entienda que las versiones anteriores de Perl se ahogarán en él durante la compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>length pack(&quot;s&quot;), length pack(&quot;s!&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>length pack(&quot;s&quot;), length pack(&quot;s!&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when( /^-?(?:\d+\.?|\.\d)\d*\z/ )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225622Z" changeid="explorer">
        <seg>when( /^-?(?:\d+\.?|\.\d)\d*\z/ )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 INTRODUCTION</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T012731Z" changeid="explorer">
        <seg>=head1 INTRODUCCIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Irix 5.3</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004549Z" changeid="explorer">
        <seg>=head2 Irix 5.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Readable\n&quot; if -r _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Leíble\n&quot; if -r _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &lt;*.c&gt; &gt;&gt; operator is discussed in
more detail in L&lt;perlop/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185205Z" changeid="explorer">
        <seg>El operador C&lt;&lt; &lt;*.c&gt; &gt;&gt; se discute con más detalle en L&lt;perlop/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Tim Jenness and Simon Cozens</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003643Z" changeid="explorer">
        <seg>Tim Jenness y Simon Cozens</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item undef EXPR
X&lt;undef&gt; X&lt;undefine&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210130Z" changeid="explorer">
        <seg>=item undef EXPR
X&lt;undef&gt; X&lt;undefine&gt; X&lt;indefine&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://lists.perl.org/showlist.cgi?name=perl-mvs</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220624Z" changeid="explorer">
        <seg>http://lists.perl.org/showlist.cgi?name=perl-mvs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item write FILEHANDLE
X&lt;write&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013509Z" changeid="explorer">
        <seg>=item write IDENTIFICADOR_ARCHIVO
X&lt;write&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\L		lowercase all characters till \E seen</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232539Z" changeid="explorer">
        <seg>\L		minúsculas hasta encontrar \E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2  0..2  &quot;homer&quot; &quot;marge&quot; &quot;bart&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032421Z" changeid="explorer">
        <seg>2  0..2  &quot;homer&quot; &quot;marge&quot; &quot;bart&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hash{123} = &quot;def&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190202Z" changeid="zipf">
        <seg>$hash{123} = &quot;def&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until the C&lt;(*PRUNE)&gt; verb is reached,
A may backtrack as necessary to match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T011423Z" changeid="explorer">
        <seg>Hasta que el verbo C&lt;(*PRUNE)&gt; se alcance, A puede volver atrás tanto como sea necesario para que se produzca la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This 'cheat sheet' is a handy reference, meant for beginning Perl
programmers.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T214931Z" changeid="explorer">
        <seg>Esta 'hoja resumen' es una referencia útil para programadores principiantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, those functions will not be
compiled in if you add C&lt;-DNO_MATHOMS&gt; in the compiler flags.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T041239Z" changeid="explorer">
        <seg>Sin embargo, esas funciones no serán compiladas si agrega C&lt;-DNO_MATHOMS&gt; en las opciones del compilador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbook		Perl book information</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000546Z" changeid="explorer">
        <seg>perlbook		Información sobre libros de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This uses a new warnings category: &quot;imprecision&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010158Z" changeid="explorer">
        <seg>Utiliza una nueva categoría de advertencias: &quot;imprecision&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%g&gt;', 100;      # prints &quot;&lt;100&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%g&gt;', 100;      # imprime &quot;&lt;100&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a couple of special arrays too, such as C&lt;@ARGV&gt; (the command
line arguments to your script) and C&lt;@_&gt; (the arguments passed to a
subroutine).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224915Z" changeid="explorer">
        <seg>También hay dos arrays especiales: C&lt;@ARGV&gt; (los argumentos de línea de comandos pasados al script) y C&lt;@_&gt; (los argumentos pasados a una subrutina).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is the moral equivalent of these two:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es el equivalente moral de estos dos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;scrolling_list()&gt; select attribute fixed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025118Z" changeid="explorer">
        <seg>Arreglado el atributo para select en C&lt;scrolling_list()&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could also read C&lt;$^A&gt;
and then set C&lt;$^A&gt; back to C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede también leer C&lt;$^A&gt; y volver a ponerla otra vez a C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty echo&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty echo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perldoc|perldoc&gt;, L&lt;pod2man|pod2man&gt;, L&lt;perlpod&gt;,
L&lt;pod2html|pod2html&gt;, L&lt;pod2usage|pod2usage&gt;, L&lt;podselect|podselect&gt;,
L&lt;podchecker|podchecker&gt;, L&lt;splain|splain&gt;, L&lt;perldiag&gt;,
L&lt;roffitall|roffitall&gt;, L&lt;a2p|a2p&gt;, L&lt;s2p|s2p&gt;, L&lt;find2perl|find2perl&gt;,
L&lt;File::Find|File::Find&gt;, L&lt;pl2pm|pl2pm&gt;, L&lt;perlbug|perlbug&gt;,
L&lt;h2ph|h2ph&gt;, L&lt;c2ph|c2ph&gt;, L&lt;h2xs|h2xs&gt;, L&lt;dprofpp|dprofpp&gt;,
L&lt;Devel::DProf&gt;, L&lt;enc2xs&gt;, L&lt;xsubpp&gt;, L&lt;cpan&gt;, L&lt;cpanp&gt;, L&lt;cpan2dist&gt;,
L&lt;instmodsh&gt;, L&lt;piconv&gt;, L&lt;prove&gt;, L&lt;corelist&gt;, L&lt;ptar&gt;, L&lt;ptardiff&gt;,
L&lt;shasum&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231657Z" changeid="explorer">
        <seg>L&lt;perldoc|perldoc&gt;, L&lt;pod2man|pod2man&gt;, L&lt;perlpod&gt;,
L&lt;pod2html|pod2html&gt;, L&lt;pod2usage|pod2usage&gt;, L&lt;podselect|podselect&gt;,
L&lt;podchecker|podchecker&gt;, L&lt;splain|splain&gt;, L&lt;perldiag&gt;,
L&lt;roffitall|roffitall&gt;, L&lt;a2p|a2p&gt;, L&lt;s2p|s2p&gt;, L&lt;find2perl|find2perl&gt;,
L&lt;File::Find|File::Find&gt;, L&lt;pl2pm|pl2pm&gt;, L&lt;perlbug|perlbug&gt;,
L&lt;h2ph|h2ph&gt;, L&lt;c2ph|c2ph&gt;, L&lt;h2xs|h2xs&gt;, L&lt;dprofpp|dprofpp&gt;,
L&lt;Devel::DProf&gt;, L&lt;enc2xs&gt;, L&lt;xsubpp&gt;, L&lt;cpan&gt;, L&lt;cpanp&gt;, L&lt;cpan2dist&gt;,
L&lt;instmodsh&gt;, L&lt;piconv&gt;, L&lt;prove&gt;, L&lt;corelist&gt;, L&lt;ptar&gt;, L&lt;ptardiff&gt;,
L&lt;shasum&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Argument processing and
value returned work just like C&lt;ioctl&gt; below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procesado de argumentos y el valor devuelto funcionan como C&lt;ioctl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Other interesting, non-Perl books</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003713Z" changeid="explorer">
        <seg>=head2 Otros libros interesantes (no específicos de Perl)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These override the normal built-ins, supplying
versions that return objects with the appropriate names
for each field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas sobreescriben a las integradas, con versiones que devuelven objetos con los nombres apropiados para cada campo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir($foo)   || die;	# (chdir $foo) || die</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir($foo)   || die;	# (chdir $foo) || die</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item F&lt;perlthanks&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005515Z" changeid="explorer">
        <seg>=item F&lt;perlthanks&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2000 Irix 6.2 Posix 1003.1b support modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T004302Z" changeid="explorer">
        <seg>2000 Irix 6.2 Posix 1003.1b soporte de módulos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you know I&lt;exactly&gt; what you're doing, you can use the C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt;
modifiers to force big- or little-endian byte-order on floating-point values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sabe I&lt;exactamente&gt; lo que está haciendo, puede usar los modificadores C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt; para forzas una ordenación de bytes de los valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/ ( A (*THEN) B | C (*THEN) D ) /</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050626Z" changeid="explorer">
        <seg>/ ( A (*THEN) B | C (*THEN) D ) /</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;(?-1)&gt; refers to the most recently
declared group, and C&lt;(?+1)&gt; indicates the next group to be declared.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T212706Z" changeid="explorer">
        <seg>Así C&lt;(?-1)&gt; se refiere al grupo declarado más recientemente, y C&lt;(?+1)&gt; se refiere al siguiente grupo a ser declarado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item abs VALUE
X&lt;abs&gt; X&lt;absolute&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165421Z" changeid="explorer">
        <seg>=item abs VALOR
X&lt;abs&gt; X&lt;absolute&gt; X&lt;absoluto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the C&lt;..&gt; and C&lt;...&gt; flip-flop operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>los operadores biestables C&lt;..&gt; y C&lt;...&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Truncates the file opened on FILEHANDLE, or named by EXPR, to the
specified length.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T013313Z" changeid="explorer">
        <seg>Trunca el archivo abierto en IDENTIFICADOR_ARCHIVO, o nombrado por EXPR, a la longitud especificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Win32: fix bugs in handling of the virtualized environment</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001509Z" changeid="explorer">
        <seg>Win32: errores arreglados en el manejo de entornos virtualizados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Works
only for fixed-width look-behind.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212814Z" changeid="explorer">
        <seg>Sólo funciona para antecedentes de ancho fijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;The value of $key is $hash{$key}\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234942Z" changeid="zipf">
        <seg>print &quot;El valor de $clave es $hash{$clave}\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Earlier releases interpreted the bareword as a directory name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T235049Z" changeid="explorer">
        <seg>Versiones anteriores interpretaban la palabra sencilla como un nombre de directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be careful when using the branch reset pattern in combination with 
named captures.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T124956Z" changeid="explorer">
        <seg>Tenga cuidado al utilizar el patrón de reinicio de rama en combinación con la captura nominal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following compound statements may be used to control flow:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013257Z" changeid="explorer">
        <seg>Las siguientes instrucciones compuestas pueden ser usadas para controlar el flujo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you have Perl installed, a wealth of documentation is available to you
through the 'perldoc' tool.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222137Z" changeid="explorer">
        <seg>Una vez que haya instalado Perl, tendrá disponible una gran cantidad de documentación a través de la herramienta 'perldoc'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is one minor difference: if variables are declared with C&lt;my&gt;
in the initialization section of the C&lt;for&gt;, the lexical scope of
those variables is exactly the C&lt;for&gt; loop (the body of the loop
and the control sections).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay una pequeña diferencia: si hay variables declaradas con C&lt;my&gt; en la sección de inicialización del C&lt;for&gt;, el ámbito léxico de estas variables es exactamente el bucle C&lt;for&gt; (el cuerpo del bucle y las secciones de control).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item substr EXPR,OFFSET,LENGTH,REPLACEMENT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item substr EXPR,DESPLAZAMIENTO,LONGITUD,REEMPLAZO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$pattern = &quot;(?i)foobar&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234657Z" changeid="explorer">
        <seg>$patron = &quot;(?i)foobar&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The index function searches for one string within another, but without
the wildcard-like behavior of a full regular-expression pattern match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función index busca por un string dentro de otro, pero sin tener el comportamiento de un sistema de coincidencias basado en expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (defined $packed_ip) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (defined $packed_ip) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mark Klein provided a fixed sigsetjmp (that works with dynamic
libraries) in mpeix_setjmp.c</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mark Klein proporcionó un arreglo para sigsetjmp (que trabaja con bibliotecas dinámicas) en mpeix_setjmp.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to change the installation directory or
have a standard DG/UX with C compiler GCC-2.7.2.x
then you have no choice than to do an interactive
build by issuing the command:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea cambiar el directorio de instalación o tiene una DG/UX estándar con un compilador de C GCC-2.7.2.x, entonces no tiene más remedio que hacer una compilación interactiva mediante la ejecución de la orden:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a new lexically-scoped alternative for the C&lt;Fatal&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110921T145228Z" changeid="explorer">
        <seg>Es una nueva alternativa de ámbito léxico para el módulo C&lt;Fatal&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C subroutines (or comparably compiled subroutines in other
languages) supplied by you and linked into this Package in order to
emulate subroutines and variables of the language defined by this
Package shall not be considered part of this Package, but are the
equivalent of input as in Paragraph 6, provided these subroutines do
not change the language in any way that would cause it to fail the
regression tests for the language.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Subrutinas en C (o, comparativamente, subrutinas compiladas en otros lenguajes) suministradas por usted y vinculadas a este Paquete con el fin de emular a subrutinas y variables del lenguaje definido por este Paquete no se considerarán parte de este Paquete, sino que son el equivalente a lo indicado en el apartado 6, siempre que estas subrutinas no cambien el lenguaje de cualquier manera que pudieran hacer fracasar las pruebas de regresión para el lenguaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item B&lt;filter_fetch_value&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190505Z" changeid="zipf">
        <seg>=item B&lt;filter_fetch_value&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot;$name\n&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234254Z" changeid="explorer">
        <seg>print(&quot;$nombre\n&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many systems the C&lt;O_EXCL&gt; flag is available for opening files in
exclusive mode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En muchos sistemas la bandera C&lt;O_EXCL&gt; está disponible para abrir archivos en modo exclusivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, it must match C&lt;/^[_A-Za-z][_A-Za-z0-9]*\z/&gt; or
its Unicode extension (see L&lt;utf8&gt;),
though it isn't extended by the locale (see L&lt;perllocale&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T214154Z" changeid="explorer">
        <seg>En otras palabras, debe coincidir con C&lt;/^[_A-Za-z][_A-Za-z0-9]*\z/&gt; o
su extensión Unicode (ver L&lt;utf8&gt;), aunque no esté ampliada por la configuración regional (ver L&lt;perllocale&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Athena</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225455Z" changeid="explorer">
        <seg>=item Athena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a regular C&lt;foreach&gt; loop for this purpose would be clearer in
most cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de un bucle C&lt;foreach&gt; normal para este propósito sería más claro en la mayoría de los casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 11743</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 11743</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have only
one C&lt;study&gt; active at a time: if you study a different scalar the first
is &quot;unstudied&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo puede tener una C&lt;study&gt; activa a la vez: si usted estudia un escalar diferente, la primera queda &quot;sin estudiar&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @caps, uc($_);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @mayusculas, uc($_);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For constructs with three-part delimiters (C&lt;s///&gt;, C&lt;y///&gt;, and
C&lt;tr///&gt;), the search is repeated once more.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para construcciones con delimitadores en tres partes (C&lt;s///&gt;, C&lt;y///&gt;, y C&lt;tr///&gt;), la búsqueda se repite una vez más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;chomp&gt;, C&lt;chop&gt;, C&lt;chr&gt;, C&lt;crypt&gt;, C&lt;hex&gt;, C&lt;index&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;,
C&lt;length&gt;, C&lt;oct&gt;, C&lt;ord&gt;, C&lt;pack&gt;, C&lt;q//&gt;, C&lt;qq//&gt;, C&lt;reverse&gt;,
C&lt;rindex&gt;, C&lt;sprintf&gt;, C&lt;substr&gt;, C&lt;tr///&gt;, C&lt;uc&gt;, C&lt;ucfirst&gt;, C&lt;y///&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043451Z" changeid="explorer">
        <seg>C&lt;chomp&gt;, C&lt;chop&gt;, C&lt;chr&gt;, C&lt;crypt&gt;, C&lt;hex&gt;, C&lt;index&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;,
C&lt;length&gt;, C&lt;oct&gt;, C&lt;ord&gt;, C&lt;pack&gt;, C&lt;q//&gt;, C&lt;qq//&gt;, C&lt;reverse&gt;,
C&lt;rindex&gt;, C&lt;sprintf&gt;, C&lt;substr&gt;, C&lt;tr///&gt;, C&lt;uc&gt;, C&lt;ucfirst&gt;, C&lt;y///&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tools exist to help you to build your module in a MakeMaker-friendly
style.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030917Z" changeid="explorer">
        <seg>Existen herramientas para ayudarle a construir su módulo en un estilo MakeMaker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for core modules in the F&lt;lib/&gt; directory are right next to the module
itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014540Z" changeid="explorer">
        <seg>Las pruebas de los módulos del núcleo del directorio F&lt;lib/&gt; se encuentran junto al módulo correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can determine your system endianness with this incantation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede determinar la ordenación de bytes de su sistema con este conjuro:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s  A signed short (16-bit) value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s  Un valor de un corto con signo (16 bit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this means
that the contents of capture groups defined inside an eval'ed pattern
are not available outside of the pattern, and vice versa, there is no
way for the inner pattern to refer to a capture group defined outside.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T202056Z" changeid="explorer">
        <seg>Tenga en cuenta que esto significa que los contenidos de los grupos de captura definidos dentro de un patrón evaluado no están disponibles fuera del patrón, y viceversa, no hay manera de que el patrón interno se refiera a un grupo de captura definido fuera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Your new toolkit</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234929Z" changeid="explorer">
        <seg>=head2 Su nuevo kit de herramientas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is the character specified by the hexadecimal number between
the braces.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T202347Z" changeid="explorer">
        <seg>El resultado es el carácter especificado por el número hexadecimal entre las llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no decrypt function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe la función decrypt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defined $a ? $a : $b</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015126Z" changeid="explorer">
        <seg>defined $a ? $a : $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#.5o&gt;', 012345;   # prints &quot;&lt;012345&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#.5o&gt;', 012345;   # imprime &quot;&lt;012345&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Multiplicative Operators
X&lt;operator, multiplicative&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234355Z" changeid="explorer">
        <seg>=head2 Operadores multiplicativos
X&lt;operator, multiplicative&gt; X&lt;operador, multiplicativo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># The below doesn't match, and it isn't clear what $1 and $2 would</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162408Z" changeid="explorer">
        <seg># Lo siguiente no coincide, y no está claro que contendrá $1 y $2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;ExtUtils::MakeMaker&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010755Z" changeid="explorer">
        <seg>=item C&lt;ExtUtils::MakeMaker&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the left part is delimited by bracketing punctuation (that is C&lt;()&gt;,
C&lt;[]&gt;, C&lt;{}&gt;, or C&lt;&lt; &lt;&gt; &gt;&gt;), the right part needs another pair of
delimiters such as C&lt;s(){}&gt; and C&lt;tr[]//&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T214631Z" changeid="explorer">
        <seg>Si la parte izquierda está delimitada por signos de puntuación emparejados (es decir, C&lt;()&gt;, C&lt;[]&gt;, C&lt;{}&gt;, o C&lt;&lt; &lt;&gt; &gt;&gt;), la parte derecha necesita otro par de delimitadores, como en C&lt;s(){}&gt; y C&lt;tr[]//&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when a message is received, the message type as a
native long integer will be the first thing in VAR, followed by the
actual message.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que en cuanto se recibe un mensaje, el tipo de mensaje, en formato de un entero largo en forma nativa, será la primera cosa almacenada en VAR, seguida por el mensaje real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are three examples:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T025346Z" changeid="explorer">
        <seg>Aquí hay tres ejemplos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/(\d\s){3}/         a three digits, each followed by a whitespace
                        character (eg &quot;3 4 5 &quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055706Z" changeid="explorer">
        <seg>/(\d\s){3}/         tres dígitos, cada uno seguido de un carácter
                        espacio (ej. &quot;3 4 5 &quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/oct&gt; if all you have is a string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023328Z" changeid="explorer">
        <seg>Vea también L&lt;/oct&gt; si todo lo que tiene es una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/io/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014623Z" changeid="explorer">
        <seg>=item * F&lt;t/io/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, this operator is implemented using the standard
C&lt;File::Glob&gt; extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comenzando con v5.6.0, este operador está implementado usando la extensión estándar C&lt;File::Glob&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SCALAR will be grown or shrunk 
so that the last character actually read is the last character of the
scalar after the read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESCALAR crecerá o se reducirá de manera que el último carácter leído es el último carácter del escalar después de la lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub show(+) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032158Z" changeid="explorer">
        <seg>sub show(+) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sysopen(HANDLE, $path, O_RDWR|O_CREAT|O_EXCL)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sysopen(HANDLE, $ruta, O_RDWR|O_CREAT|O_EXCL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlgpl		GNU General Public License</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000821Z" changeid="explorer">
        <seg>perlgpl		Licencia GNU General Public License</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Executable\n&quot; if -x _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Ejecutable\n&quot; if -x _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hint: you could say
C&lt;open(LOG,'logfile')&gt; rather than C&lt;open(log,'logfile')&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un consejo: es mejor escribir C&lt;open(LOG,'archlog')&gt; que C&lt;open(log,'archlog')&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get all normal letters of the English alphabet, or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener todas las letras normales del alfabeto Inglés, o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close OUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close OUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One or more sections or subsections giving greater detail of available 
methods and routines and any other relevant information.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024530Z" changeid="explorer">
        <seg>Una o más secciones o subsecciones dando mayor detalle de los métodos disponibles y las rutinas y cualquier otra información pertinente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Put an asterisk C&lt;*&gt; before the C&lt;v&gt; to override the string to
use to separate the numbers:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pone un asterisco C&lt;*&gt; antes de C&lt;v&gt; para reemplazar la cadena a utilizar para separar los números:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl source tree is big.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T013233Z" changeid="explorer">
        <seg>El árbol de código fuente de Perl es frondoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A precomputed hash value for the MRO's name, or 0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114209Z" changeid="explorer">
        <seg>Un valor de hash calculado previamente para el nombre del MRO, o 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't make
your users specify parameters which will almost always be the same.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022441Z" changeid="explorer">
        <seg>No haga que los usuarios especifiquen parámetros que casi siempre sean los mismos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = [ split &quot; &quot;, &lt;&gt; ];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030409Z" changeid="explorer">
        <seg>$AoA[$i] = [ split &quot; &quot;, &lt;&gt; ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for modules in F&lt;ext/&gt; and the dual-life modules are in F&lt;t/&gt;
subdirectories for each module, like a standard CPAN distribution.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014549Z" changeid="explorer">
        <seg>Las pruebas de los módulos de F&lt;ext/&gt; y los módulos de evolución dual están en los subdirectorios F&lt;t/&gt; de cada módulo, como en una distribución de CPAN estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str =~ /^\w/;       # Match!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001218Z" changeid="explorer">
        <seg>$str =~ /^\w/;       # ¡Coincide!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using single-quote as a delimiter protects the command from Perl's
double-quote interpolation, passing it on to the shell instead:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando comillas simples como delimitadores impide la interpolación del doble entrecomillado de Perl, pasándolo, en su lugar, al shell:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the power comes from implicit smart matching:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayor parte del poder viene de la coincidencia inteligente implícita:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack('s&lt;l&lt;', -42, 4711);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack('s&lt;l&lt;', -42, 4711);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&lt; (?&gt;S) &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045935Z" changeid="explorer">
        <seg>=item C&lt;&lt; (?&gt;S) &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = 3/22;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033323Z" changeid="explorer">
        <seg>$a = 3/22;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001322Z" changeid="explorer">
        <seg>Se describe en L&lt;perlsub&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($HOST = $host) =~ tr/a-z/A-Z/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($HOST = $host) =~ tr/a-z/A-Z/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The faulty pointer arithmetic has been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000120Z" changeid="explorer">
        <seg>La aritmética de punteros errónea ha sido corregida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also parsed as terms are the C&lt;do {}&gt; and C&lt;eval {}&gt; constructs, as
well as subroutine and method calls, and the anonymous
constructors C&lt;[]&gt; and C&lt;{}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También son analizados como términos las construcciones C&lt;do {}&gt; y C&lt;eval {}&gt;, así como subrutina y llamadas a métodos, y los constructores anónimos C&lt;[]&gt; y C&lt;{}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print {$fh} $binary;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234632Z" changeid="explorer">
        <seg>print {$fh} $binario;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no need to have a C&lt;main()&gt; function or anything of
that kind.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224725Z" changeid="explorer">
        <seg>Es decir, no es necesario utilizar una función C&lt;main()&gt; ni nada similar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result may be used as a subpattern in a match:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resultado puede ser utilizado como un sub-patrón en una coincidencia:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Tim Bunce and Alligator Descartes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003526Z" changeid="explorer">
        <seg>Tim Bunce y Alligator Descartes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A local modifies the listed variables to be local to the enclosing
block, file, or eval.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un local() modifica las variables listadas para que sean locales en el bloque que les rodea, un archivo o un eval().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;%ENV = ()&gt; and C&lt;%ENV = @list&gt; now work as expected (except on VMS
where it generates a fatal error).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;%ENV = ()&gt; y C&lt;%ENV = @list&gt; ahora funcionan como se esperaba (excepto sobre VMS donde genera un error fatal).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-0-596-00476-7 [December 2003]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003607Z" changeid="explorer">
        <seg>ISBN 978-0-596-00476-7 [Diciembre de 2003]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># be even if it did!!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162456Z" changeid="explorer">
        <seg># ¡Incluso si ya lo ha intentado!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;No argument to customre::import allowed&quot; if @_;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001838Z" changeid="explorer">
        <seg>die &quot;No se permiten argumentos para customre::import&quot; if @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In completely unrelated news, you can now use safe signals with
POSIX::SigAction.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T155225Z" changeid="explorer">
        <seg>En noticias aparte, ahora puede usar señales de forma segura con POSIX::sigaction.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item threads</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015335Z" changeid="explorer">
        <seg>=item threads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello, $name\n&quot;;     # works fine</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T124136Z" changeid="zipf">
        <seg>print &quot;Hola, $nombre\n&quot;;  # funciona correctamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 0, 8) = 128 ==        128 00000001000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 0, 8) = 128 ==        128 00000001000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reentrant functions will (once more) work with C++.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Funciones reentrantes trabajarán (una vez más) con C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>% perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>% perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It was abandoned in 2006
( http://www.nntp.perl.org/group/perl.ponie.dev/487 ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T225956Z" changeid="explorer">
        <seg>Se abandonó en 2006 ( http://www.nntp.perl.org/group/perl.ponie.dev/487 ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $middle = substr $s, 4, -11;    # black cat climbed the</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $middle = substr $s, 3, -12;    # gato negro subió el</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For reference on how regular expressions are used in matching
operations, plus various examples of the same, see discussions of
C&lt;m//&gt;, C&lt;s///&gt;, C&lt;qr//&gt; and C&lt;??&gt; in L&lt;perlop/&quot;Regexp Quote-Like
Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para tener una referencia sobre cómo las expresiones regulares se utilizan en operaciones de búsqueda, además de varios ejemplos de lo mismo, vea las discusiones sobre C&lt;m//&gt; C&lt;s///&gt;, C&lt;qr//&gt; y C&lt;??&gt; en L&lt;perlop/&quot;Operadores Regexp Entrecomillados&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most subroutines do not
need to bother, though.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, la mayoría de las subrutinas no necesitan encargarse de esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME
X&lt;regular expression&gt; X&lt;regex&gt; X&lt;regexp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T224505Z" changeid="explorer">
        <seg>=head1 NOMBRE
X&lt;expresión regular&gt; X&lt;regex&gt; X&lt;regexp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhist		Perl history records</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000629Z" changeid="explorer">
        <seg>perlhist		Registros históricos de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Namespaces with all lowercase names are considered reserved for
Perl pragmata.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio de nombres en minúsculas está considerado reservado para los pragmas de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Perl scripts have always been able to be larger than that, it's just
that the linenumber for reported errors and warnings have &quot;wrapped
around&quot;.)  While scripts that large usually indicate a need to rethink
your code a bit, such Perl scripts do exist, for example as results
from generated code.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T233002Z" changeid="explorer">
        <seg>(Los programas Perl siempre han sido capaces de tener más que eso, es sólo que los números de línea de los informes de errores y advertencias son &quot;reiniciados&quot;.) Mientras que scripts tan grandes como estos, por lo general, indican la necesidad de repensar un poco el código, scripts de Perl como estos existen, por ejemplo, de resultas de un código generado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Affrus</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225453Z" changeid="explorer">
        <seg>=item Affrus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This problem has
been corrected by adding directory syntax to relative path names, thus
preventing logical name translation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000810Z" changeid="explorer">
        <seg>Este problema se ha corregido mediante la adición de la sintaxis de directorio de nombres de ruta de acceso relativo, evitando así la traducción de nombres lógicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider generalizing your
code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere generalizar su código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?&lt;=pattern)&gt; C&lt;\K&gt;
X&lt;(?&lt;=)&gt; X&lt;look-behind, positive&gt; X&lt;lookbehind, positive&gt; X&lt;\K&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T211446Z" changeid="explorer">
        <seg>=item C&lt;(?&lt;=patrón)&gt; C&lt;\K&gt;
X&lt;(?&lt;=)&gt; X&lt;antecedente, positivo&gt; X&lt;antecedente, positivo&gt; X&lt;\K&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make -f Makefile.micro patch_uconfig</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make -f Makefile.micro patch_uconfig</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Memory optimisations</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T112215Z" changeid="explorer">
        <seg>=head2 Optimizaciones de la memoria</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Add one to the value of any numbers in the string</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Suma uno al valor de todos los números en la cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use any combination of the methods from none to all four.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T153342Z" changeid="zipf">
        <seg>Puede usar cualquier combinación de estos métodos (desde ninguno hasta los cuatro).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>COPYRIGHT and LICENSE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024551Z" changeid="explorer">
        <seg>COPYRIGHT y LICENCIA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Written by Jarkko Hietaniemi &lt;F&lt;jhi@iki.fi&gt;&gt;, with many contributions
from The Perl Porters and Perl Users submitting feedback and patches.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Escrito por Jarkko Hietaniemi &lt;F&lt;jhi@iki.fi&gt;&gt;, con muchas contribuciones de los I&lt;Perl Porters&gt; y usuarios Perl que suministraron comentarios y revisiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my ($x_lo, $x_hi,</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053106Z" changeid="explorer">
        <seg>my ($x_lo, $x_hi,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$oldfh = select(HANDLE); $| = 1; select($oldfh);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$anterior_fh = select(HANDLE); $| = 1; select($anterior_fh);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the right side of a list operator, the comma has very low precedence,
such that it controls all comma-separated expressions found there.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230127Z" changeid="explorer">
        <seg>En el lado derecho de un operador de lista, la coma tiene una precedencia muy baja, de forma que controla todas las expresiones separadas por comas que se encuentren allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, rounding is strongly biased to 0, though a number like
C&lt;&quot;0.99999999999999999999&quot;&gt; has a chance of being rounded to 1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232840Z" changeid="explorer">
        <seg>En particular, hay un sesgo muy fuerte de redondeo a 0, aunque es posible que un número como C&lt;&quot;0.99999999999999999999&quot;&gt; se redondee a 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main interface to Perl's documentation is C&lt;perldoc&gt;, although
if you're reading this, it's more than likely that you've already found
it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233319Z" changeid="explorer">
        <seg>Como ya sabe, la interfaz principal de la documentación de Perl es C&lt;perldoc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>^O {^M}^[O^T</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225450Z" changeid="explorer">
        <seg>^O {^M}^[O^T</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?PARNO)&gt; C&lt;(?-PARNO)&gt; C&lt;(?+PARNO)&gt; C&lt;(?R)&gt; C&lt;(?0)&gt;
X&lt;(?PARNO)&gt; X&lt;(?1)&gt; X&lt;(?R)&gt; X&lt;(?0)&gt; X&lt;(?-1)&gt; X&lt;(?+1)&gt; X&lt;(?-PARNO)&gt; X&lt;(?+PARNO)&gt;
X&lt;regex, recursive&gt; X&lt;regexp, recursive&gt; X&lt;regular expression, recursive&gt;
X&lt;regex, relative recursion&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T183355Z" changeid="explorer">
        <seg>=item C&lt;(?PARNO)&gt; C&lt;(?-PARNO)&gt; C&lt;(?+PARNO)&gt; C&lt;(?R)&gt; C&lt;(?0)&gt;
X&lt;(?PARNO)&gt; X&lt;(?1)&gt; X&lt;(?R)&gt; X&lt;(?0)&gt; X&lt;(?-1)&gt; X&lt;(?+1)&gt; X&lt;(?-PARNO)&gt; X&lt;(?+PARNO)&gt; X&lt;regex, recursiva&gt; X&lt;regexp, recursiva&gt; X&lt;expresión regular, recursiva&gt; X&lt;regex, recursión relativa&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thu Nov  2 00:42:39 5576711</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225528Z" changeid="explorer">
        <seg>Thu Nov  2 00:42:39 5576711</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbeos		Perl notes for BeOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlbeos		Notas para BeOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or technically speaking, a location capable of holding a hard
reference, if it's an array or hash reference being used for
assignment.)  See L&lt;perlreftut&gt; and L&lt;perlref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220008Z" changeid="explorer">
        <seg>(O técnicamente hablando, un lugar capaz de contener una referencia dura, si se trata de una asignación de una referencia a un array o un hash). Vea L&lt;perlreftut&gt; y L&lt;perlref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perltie&gt;,
L&lt;Tie::Hash&gt;, L&lt;Tie::Array&gt;, L&lt;Tie::Scalar&gt;, and L&lt;Tie::Handle&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perltie&gt;, L&lt;Tie::Hash&gt;, L&lt;Tie::Array&gt;, L&lt;Tie::Scalar&gt;, y L&lt;Tie::Handle&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>7 size     total size of file, in bytes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>7 size     tamaño total del archivo, en bytes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't open $foo: $!&quot; unless open(FOO,$foo);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo abrir $foo: $!&quot; unless open(FOO,$foo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_CTIME 	   if $opt_c;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_CTIME 	   if $opt_c;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When C&lt;$/&gt; is set to C&lt;undef&gt;
(sometimes known as file-slurp mode) and the file is empty, it
returns C&lt;''&gt; the first time, followed by C&lt;undef&gt; subsequently.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando C&lt;$/&gt; está configurado a C&lt;undef&gt; (a veces conocido como modo sorber-el-archivo) y el archivo está vacío, devuelve C&lt;''&gt; la primera vez, seguido por un C&lt;undef&gt;, posteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator quotes (and possibly compiles) its I&lt;STRING&gt; as a regular
expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este operador entrecomilla (y posiblemente compila) I&lt;CADENA&gt; como una expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enhanced documentation including MD5 weaknesses discovered lately</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030535Z" changeid="explorer">
        <seg>Documentación mejorada incluyendo las últimas debilidades descubiertas en MD5 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$decimal = oct( &quot;0b$input&quot; );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225515Z" changeid="explorer">
        <seg>$decimal = oct( &quot;0b$input&quot; );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/pattern/) {{</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/patrón/) {{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replace any occurrence of C&lt;if BLOCK&gt; by C&lt;if (do BLOCK)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Reemplace cada ocurrencia de C&lt;if BLOQUE&gt; por C&lt;if (do BLOQUE)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIRSTKEY this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FIRSTKEY este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;(?PARNO)&gt; for a different, more efficient way to accomplish
the same task.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220536Z" changeid="explorer">
        <seg>Vea también C&lt;(?PARNO)&gt; para ver una manera diferente, más eficaz para realizar la misma tarea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// now behaves like || in when clauses</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T010442Z" changeid="explorer">
        <seg>// ahora se comporta como || en las cláusulas when</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T223129Z" changeid="explorer">
        <seg>Este programa es distribuido con la esperanza de que será útil, pero SIN NINGUNA GARANTÍA; incluso sin la garantía implícita de COMERCIALIZACIÓN o IDONEIDAD PARA UN PROPÓSITO PARTICULAR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior that this switch
enabled in 5.6.x releases may be supported in a transparent,
data-dependent fashion in a future release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T142030Z" changeid="explorer">
        <seg>El comportamiento que esta opción activaba en las versiones 5.6.x puede ser soportada de manera transparente, dependiendo de la moda, en una próxima versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0       use zeros, not spaces, to right-justify</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0       usa ceros, no espacios, justificados a la derecha</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you build this from scratch, make sure you have a version
of ld which supports it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si construye esto desde cero, asegúrese de que tiene una versión de ld que lo apoye.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls the System V IPC function msgrcv to receive a message from
message queue ID into variable VAR with a maximum message size of
SIZE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a la función System V IPC msgrcv para recibir un mensaje desde la cola de mensaje ID en la variable VAR con un tamaño máximo de mensaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may change in a future version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213555Z" changeid="explorer">
        <seg>Esto puede cambiar en una futura versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When your manager forbids it--but do consider replacing them :-).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231111Z" changeid="explorer">
        <seg>Cuando su jefe se lo prohíba; en ese caso, debe pensar en reemplazarlo (a su jefe) :-).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Magic goto and eval</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T191950Z" changeid="explorer">
        <seg>=head2 goto y eval mágicos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;()&gt; group is a sub-TEMPLATE enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un grupo C&lt;()&gt; es una sub-PLANTILLA encerrada entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is typically run by the makefiles created by L&lt;ExtUtils::MakeMaker&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234622Z" changeid="explorer">
        <seg>Lo suelen ejecutar los archivos makefile generados por L&lt;ExtUtils::MakeMaker&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item localtime</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item localtime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>permute { print &quot;@_\n&quot; } split;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>permute { print &quot;@_\n&quot; } split;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CGCC-2.7.2.x
that comes with the DG/UX OS does NOT know the -pthread
switch.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CGCC-2.7.2.x que viene con el sistema operativo DG/UX NO conoce la opción -pthread.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$db-&gt;filter_fetch_value(</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190132Z" changeid="zipf">
        <seg>$db-&gt;filter_fetch_value(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item p
X&lt;/p&gt; X&lt;regex, preserve&gt; X&lt;regexp, preserve&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222833Z" changeid="explorer">
        <seg>=item p
X&lt;/p&gt; X&lt;regex, preserve&gt; X&lt;regexp, preserve&gt; X&lt;regex, preservar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, if you have created a
temporary value that you keep no pointer to, C&lt;sv_2mortal()&gt; to ensure that
it is disposed of correctly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114852Z" changeid="explorer">
        <seg>Por lo tanto, si ha creado un valor temporal que se mantiene sin puntero a C&lt;sv_2mortal()&gt;, asegúrese de que se elimina de forma correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Configure&gt; will now detect C&lt;clearenv&gt; and C&lt;unsetenv&gt;, thanks to a
patch from Alan Burlison.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T034501Z" changeid="explorer">
        <seg>C&lt;Configure&gt; ahora detectará C&lt;clearenv&gt; y C&lt;unsetenv&gt;, gracias a un parche de Alan Burlison.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, if you try this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, si intenta esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>each file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>por cada archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\c?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204557Z" changeid="explorer">
        <seg>\c?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Text::ParseWords;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225537Z" changeid="explorer">
        <seg>use Text::ParseWords;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select STDOUT; $| = 1;  # make unbuffered</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110307T000422Z" changeid="explorer">
        <seg>select STDOUT; $| = 1;  # hacerlo sin búfer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use bigrat;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033318Z" changeid="explorer">
        <seg>use bigrat;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub square {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T235522Z" changeid="zipf">
        <seg>sub cuadrado {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following documentation is written in euc-jp encoding.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055053Z" changeid="explorer">
        <seg>The following documentation is written in euc-jp encoding.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $aref = shift;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225542Z" changeid="explorer">
        <seg>my $aref = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So C&lt;:5.10&gt; and C&lt;:5.10.X&gt;
have identical effect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152423Z" changeid="explorer">
        <seg>Por tanto, C&lt;:5,10&gt; y C&lt;:5.10.X&gt; tienen un efecto idéntico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array   Hash      hash keys intersection   grep { exists $b-&gt;{$_} } @$a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Array       Hash       claves hash intersección         grep { exists $b-&gt;{$_} } @$a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;cpan2dist&gt; is a tool to create distributions (or packages) from CPAN
modules, then suitable for your package manager of choice.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235056Z" changeid="explorer">
        <seg>F&lt;cpan2dist&gt; es una herramienta que permite crear distribuciones (o paquetes) compatibles con distintos administradores de paquetes a partir de módulos de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset;          # just reset ?one-time?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>reset;          # sólo reinicia las ?una-vez?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may also be
information at http://www.perl.org, the Perl Home Page.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede haber información en http://www.perl.org/, La página oficial de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%h = (first =&gt; 'A', second =&gt; 'B');</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150251Z" changeid="explorer">
        <seg>%h = (primero =&gt; 'A', segundo =&gt; 'B');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The yada-yada--or whatever--cannot stand in for an expression that is
part of a larger statement since the C&lt;...&gt; is also the three-dot version
of the binary range operator (see L&lt;Range Operators&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225617Z" changeid="explorer">
        <seg>El blablablá -o lo-que-sea- no puede sustituir a una expresión que forma parte de una instrucción más grande debido a que C&lt;...&gt; es también la versión de tres puntos del operador rango (vea L&lt;Operadores de rango&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-g  File has setgid bit set.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004804Z" changeid="explorer">
        <seg>-g  Archivo tiene puesto el bit setgid.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuration now tests for the presence of C&lt;poll()&gt;, and IO::Poll
now uses the vendor-supplied function if detected.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T233252Z" changeid="explorer">
        <seg>Configuración ahora prueba por la presencia de C&lt;poll()&gt;, e IO::Poll ahora utiliza la función suministrada por el proveedor, si es detectada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $count, &quot;\n&quot;; sleep(1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $cuenta, &quot;\n&quot;; sleep(1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>week_display();</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021428Z" changeid="explorer">
        <seg>semana_muestra();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, concatenates the
elements of LIST and returns a string value with all characters
in the opposite order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, concatena los elementos LISTA y devuelve un valor de cadena con todos los caracteres en orden inverso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;Hurrah!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225452Z" changeid="explorer">
        <seg>say &quot;¡Hurra!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, matches that would cross the Unicode
rules/non-Unicode rules boundary (ords 255/256) will not succeed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T220534Z" changeid="explorer">
        <seg>Sin embargo, las coincidencia que podrían cruzar los márgenes de las reglas Unicode/no-Unicode (ordinales 255/256) no tendrán éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict &quot;refs&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T201249Z" changeid="explorer">
        <seg>use strict &quot;refs&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some examples of how that works on an ASCII platform:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001053Z" changeid="explorer">
        <seg>Aquí hay algunos ejemplos de cómo funciona esto en una plataforma ASCII:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ioctl FILEHANDLE,FUNCTION,SCALAR
X&lt;ioctl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010809Z" changeid="explorer">
        <seg>=item ioctl IDENTIFICADOR_ARCHIVO,FUNCIÓN,ESCALAR
X&lt;ioctl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(*PRUNE)&gt; C&lt;(*PRUNE:NAME)&gt;
X&lt;(*PRUNE)&gt; X&lt;(*PRUNE:NAME)&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T010952Z" changeid="explorer">
        <seg>=item C&lt;(*PRUNE)&gt; C&lt;(*PRUNE:NOMBRE)&gt;
X&lt;(*PRUNE)&gt; X&lt;(*PRUNE:NOMBRE)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the C&lt;continue&gt; keyword to fall through from one
case to the next:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T012552Z" changeid="explorer">
        <seg>Puede usar la palabra clave C&lt;continue&gt; para pasar de un caso al siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are probably very nice books published after this list
was included in your Perl release, and you can check the latest
released version at http://perldoc.perl.org/perlbook.html .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003805Z" changeid="explorer">
        <seg>Es probable que se hayan publicado libros muy interesantes desde que se incluyó la lista en esta versión de Perl. Si lo desea, puede consultar la versión más reciente de la lista en http://perldoc.perl.org/perlbook.html .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir $foo * 20;	# chdir ($foo * 20)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir $foo * 20;	# chdir ($foo * 20)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the umask for the process to EXPR and returns the previous value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Establece la umask para el proceso a EXPR y devuelve el valor anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, Perl overloads
certain operations based on whether the expected return value is
singular or plural.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, Perl sobrecarga ciertas operaciones basándose en si el valor de retorno esperado es singular o plural.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FILEHANDLE, &quot;&lt;&amp;=$fd&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FILEHANDLE, &quot;&lt;&amp;=$fd&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;&lt;%s&gt;&quot;, &quot;a&quot;;       # prints &quot;&lt;a&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014545Z" changeid="explorer">
        <seg>printf &quot;&lt;%s&gt;&quot;, &quot;a&quot;;       # imprime &quot;&lt;a&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside an C&lt;eval&gt; the error message is stuffed
into C&lt;$@&gt; and the C&lt;eval&gt; is terminated with the undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170737Z" changeid="explorer">
        <seg>Dentro de un C&lt;eval()&gt;, el mensaje de error es colocado en C&lt;$@&gt; y el C&lt;eval&gt; termina con el valor I&lt;undef&gt; (indefinido).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/%(.)/$percent{$1} || $&amp;/ge;	# expr now, so /e</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213232Z" changeid="explorer">
        <seg>s/%(.)/$porciento{$1} || $&amp;/ge;		# ahora es una expr., así que /e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Operator Precedence and Associativity
X&lt;operator, precedence&gt; X&lt;precedence&gt; X&lt;associativity&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T232300Z" changeid="explorer">
        <seg>=head2 Precedencia de operadores y asociatividad
X&lt;operator, precedence&gt; X&lt;precedence&gt; X&lt;associativity&gt; X&lt;operador, precedencia&gt; X&lt;precedencia&gt; X&lt;asociatividad&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which produces:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T003052Z" changeid="explorer">
        <seg>que produce:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item localtime EXPR
X&lt;localtime&gt; X&lt;ctime&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T190706Z" changeid="explorer">
        <seg>=item localtime EXPR
X&lt;localtime&gt; X&lt;ctime&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the risk of stating the obvious, modules are intended to be modular.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014814Z" changeid="explorer">
        <seg>A riesgo de afirmar lo obvio, los módulos están destinados a ser modulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-R  File is readable by real uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004542Z" changeid="explorer">
        <seg>-R  Archivo es legible por el uid/gid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think carefully about whether OO is appropriate for your module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020238Z" changeid="explorer">
        <seg>Piense con cuidado acerca de si la POO es apropiada para su módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to select on many filehandles, you may wish to write a
subroutine like this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012338Z" changeid="explorer">
        <seg>Si desea seleccionar en muchos identificadores de archivo, puede desear escribir una subrutina de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlstyle - Perl style guide</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlstyle - Guía de estilo Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check whether it's already 
been done in Perl, and avoid re-inventing the wheel unless you have a 
good reason.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014608Z" changeid="explorer">
        <seg>Compruebe si ya se ha hecho en Perl, y evitará tener que volver a inventar la rueda, a menos que tenga una buena razón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This effectively provides variable-length
look-behind.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T200816Z" changeid="explorer">
        <seg>Esto, efectivamente, ofrece la posibilidad de búsquedas de antecedentes de longitud variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($line =~ s/\\$//) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($linea =~ s/\\$//) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many good books have been written about Perl--see the section later in
L&lt;perlfaq2&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230303Z" changeid="explorer">
        <seg>Se han escrito muchos libros buenos sobre Perl. Encontrará más información en una sección posterior de L&lt;perlfaq2&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Low-level socket functions
X&lt;socket&gt; X&lt;sock&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T202127Z" changeid="explorer">
        <seg>=item Funciones de bajo nivel de sockets
X&lt;socket&gt; X&lt;sock&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 C&lt;no VERSION&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T200101Z" changeid="explorer">
        <seg>=head2 C&lt;no VERSION&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596514273/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003323Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596514273/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, a pattern such as C&lt;((?i)(&amp;NAME))&gt; does not
change the case-sensitivity of the &quot;NAME&quot; pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110306T231557Z" changeid="explorer">
        <seg>En otras palabras, un patrón como C&lt;((?i)(&amp;NOMBRE))&gt; no cambia la sensibilidad al tamaño de caja del patrón &quot;NOMBRE&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.........</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>.........</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $pat (@pats) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T233859Z" changeid="explorer">
        <seg>for $patron (@patrones) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This program provides an easy way to send a thank-you message back to the
authors and maintainers of perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234432Z" changeid="explorer">
        <seg>Este programa proporciona una manera sencilla de enviar un mensaje de agradecimiento a las personas que se encargan de desarrollar y mantener perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always returns
1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre devuelve 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're using a relatively modern operating system and want to
install this version of Perl locally, run the following commands:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T221859Z" changeid="explorer">
        <seg>Si está usando un sistema operativo relativamente moderno y desea instalar esta versión de Perl a nivel local, ejecute los siguientes comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raises an exception when used on a machine that doesn't
implement POSIX setpgid(2) or BSD setpgrp(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Eleva una excepción si se usa en una máquina que no implemente POSIX setpgid(2) o BSD setpgrp(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, the return values from the
various get routines are as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, los valores devueltos por varias de ellas son como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler bug has been
reported to SGI.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003826Z" changeid="explorer">
        <seg>El error del compilador ha sido reportado a SGI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above uses DB_File, but again it will work with any of the
DBM modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T132000Z" changeid="zipf">
        <seg>El código anterior usa DB_File, pero funcionará con cualquiera de los módulos DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\     references      $$foo[1]       aka $foo-&gt;[1]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224137Z" changeid="explorer">
        <seg>\     crear referencia      $$foo[1]       equivale a $foo-&gt;[1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ref_to_AoA is a reference to an
array, whereas @AoA is an array proper.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ref_to_AoA es una referencia a un array, mientras que @AoA es un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system(&quot;program args 1&gt;program.stdout 2&gt;program.stderr&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system(&quot;programa argumentos 1&gt;programa.stdout 2&gt;programa.stderr&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050535Z" changeid="explorer">
        <seg>'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In OS X C&lt;setreuid&gt; and friends are troublesome - perl will now work
around their problems as best possible.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En OS X, C&lt;setreuid&gt; y amigos, son molestos; perl ahora trabajará en torno a sus problemas de la mejor manera posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The old home for the module tests, you shouldn't put anything new in
here.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014722Z" changeid="explorer">
        <seg>Antiguo directorio de las pruebas de módulos. No debe colocar nada aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get platform independent controls, you can use C&lt;\N{...}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T205552Z" changeid="explorer">
        <seg>Para obtener caracteres de control independientes de la plataforma, se puede utilizar C&lt;\N{...}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To remove a directory tree recursively (C&lt;rm -rf&gt; on Unix) look at
the C&lt;rmtree&gt; function of the L&lt;File::Path&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para eliminar un árbol de directorio recursivamente (C&lt;rm -rf&gt; en Unix) mire la función C&lt;rmtree&gt; del módulo L&lt;File::Path&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dec = oct(&quot;33653337357&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225514Z" changeid="explorer">
        <seg>$dec = oct(&quot;33653337357&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception: It is always safe to delete the item most recently
returned by C&lt;each()&gt;, so the following code works properly:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Excepción: siempre es seguro borrar el último ítem devuelto por C&lt;each()&gt;, por lo que entonces el siguiente código funcionará correctamente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specify pre-requisites in Makefile.PL or Build.PL</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014056Z" changeid="explorer">
        <seg>Especifique los prerequisitos previos en Makefile.PL o Build.PL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is
necessary to access these long values from outside Perl, be aware that
they are implemented using search list logical names that store the
value in pieces, each 255-byte piece (up to 128 of them) being an
element in the search list.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000429Z" changeid="explorer">
        <seg>Si es necesario acceder a estos valores largos desde el exterior de Perl, sea consciente de que se implementan utilizando los nombres de la lista de búsqueda lógica que almacena el valor en partes, de 255 bytes cada una (hasta 128 de ellas) de cada elemento de la lista de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to the people who asked about this kind of stuff in several Perl IRC
channels, and have constantly reminded me that a simpler explanation was
needed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235520Z" changeid="explorer">
        <seg>Todas las personas que han hecho preguntas sobre este tema en diversos canales IRC sobre Perl y que me han recordado constantemente lo necesaria que era una explicación más sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failed match normally resets the
search position to the beginning of the string, but you can avoid that
by adding the C&lt;/c&gt; modifier (e.g. C&lt;m//gc&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una coincidencia fallida, normalmente, restablece la posición de búsqueda al principio de la cadena, pero puede evitarlo añadiendo el modificador C&lt;/c&gt; (por ejemplo C&lt;m//gc&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This utility, that comes with the C&lt;Digest::SHA&gt; module, is used to print
or verify SHA checksums.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235015Z" changeid="explorer">
        <seg>Esta utilidad, que se incluye con el módulo C&lt;Digest::SHA&gt;, se usa para imprimir o comprobar sumas de control SHA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\x7&quot;       &quot;\x07&quot;    no</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204122Z" changeid="explorer">
        <seg>&quot;\x7&quot;       &quot;\x07&quot;       no</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the following scenario.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110819T095524Z" changeid="zipf">
        <seg>Por ejemplo, considere el siguiente escenario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now shows elapsed time in milliseconds.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035835Z" changeid="explorer">
        <seg>Ahora muestra el tiempo transcurrido en milisegundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(TTY, &quot;+&gt;/dev/tty&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T024830Z" changeid="explorer">
        <seg>open(TTY, &quot;+&gt;/dev/tty&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.haiku - Perl version 5.10+ on Haiku</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.haiku - Perl versión 5.10+ en Haiku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/%(.)/$percent{$1}/g;	# change percent escapes; no /e</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035036Z" changeid="explorer">
        <seg>s/%(.)/$porciento{$1}/g;			# cambia los escapados con el %; sin /e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add LC_MESSAGES to POSIX :locale_h export tag</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadir LC_MESSAGES a la etiqueta de exportación :locale_h de POSIX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Most of these one character names have a predefined
significance to Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(La mayor parte de estos nombres de un solo carácter tienen un significado predefinido para Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>n and m are limited
to non-negative integral values less than a preset limit defined when perl is built.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>n y m están limitados a enteros no negativos menores que un límite predefinido cuando perl se compiló.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They have strange names so they don't accidentally
collide with one of your normal variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Éstas tienen extraños nombres, y por tanto no pueden colisionar accidentalmente con ninguna de sus variables normales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%#.6x&gt;', 1;     # prints &quot;&lt;0x000001&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%#.6x&gt;', 1;     # imprime &quot;&lt;0x000001&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to replace such an alphanumeric name with an expression
that returns a reference to the appropriate type.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es posible sustituir cualquier nombre alfanumérico por una expresión que devuelva una referencia a un dato del tipo apropiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215148Z" changeid="explorer">
        <seg>Además:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item splice ARRAY or EXPR,OFFSET,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181303Z" changeid="explorer">
        <seg>=item splice ARRAY o EXPR,DESPLAZAMIENTO,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpgrp PID
X&lt;getpgrp&gt; X&lt;group&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173531Z" changeid="explorer">
        <seg>=item getpgrp PID
X&lt;getpgrp&gt; X&lt;group&gt; X&lt;grupo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp; s//MARGE $1 MARGE/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;&amp; s//MARGE $1 MARGE/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 General tools</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234655Z" changeid="explorer">
        <seg>=head2 Herramientas de propósito general</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course,
Perl has its internal encoding to store the string in memory, but ignore that.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235228Z" changeid="explorer">
        <seg>Por supuesto, Perl utiliza su propia codificación para almacenar la cadena en memoria, pero el usuario no tiene que conocer los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not everything in Perl changes every day.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003826Z" changeid="explorer">
        <seg>En Perl no todo cambia a diario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function implementing
the C&lt;\u&gt; escape in double-quoted strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la función interna del escapado C&lt;\u&gt; en las cadenas doblemente entrecomilladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... except inside quoted strings:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230706Z" changeid="zipf">
        <seg>... salvo cuando está entre comillas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a private exception trap for divide-by-zero</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un trampa privada para una excepción de división-por-cero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;SOCKET&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015306Z" changeid="explorer">
        <seg>while (&lt;SOCKET&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may also be
information at http://www.perl.com/, the Perl Home Page.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede haber información en http://www.perl.com/, La página oficial de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!=  inequality</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T120430Z" changeid="zipf">
        <seg>!=  distinto que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($key,$value) = each $hashref) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T160338Z" changeid="explorer">
        <seg>while (($clave,$valor) = each $hashref) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\w                  a word character (a-z, A-Z, 0-9, _)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230250Z" changeid="zipf">
        <seg>\w                  un carácter de palabra (a-z, A-Z, 0-9, _)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ref_to_AoA-&gt;[2][2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ref_to_AoA-&gt;[2][2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unpack TEMPLATE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item unpack PLANTILLA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when backslashes are used as the delimiters (like C&lt;qq\\&gt; and
C&lt;tr\\\&gt;), nothing is skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, cuando se usan las barras invertidas como delimitadores (como C&lt;qq\\&gt; y C&lt;tr\\\&gt; ), no se omite nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setprotoent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setprotoent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TEMPLATE has the same format as in the C&lt;pack&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La PLANTILLA tiene el mismo formato que en la función C&lt;pack&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s{}{}	    Substitution	  yes*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s{}{}	    Substitución	  sí*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the lvalue returned by the three-argument version of substr() acts as
a 'magic bullet'; each time it is assigned to, it remembers which part
of the original string is being modified; for example:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T015711Z" changeid="explorer">
        <seg>Tenga en cuenta que el I&lt;ivalor&gt;&gt; devuelto por la versión de tres argumentos de substr() actúa como una 'bala mágica'; cada vez que se le asigna, recuerda qué parte de la cadena original se ha modificado; por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the offset of where the last C&lt;m//g&gt; search left off for the
variable in question (C&lt;$_&gt; is used when the variable is not
specified).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175832Z" changeid="explorer">
        <seg>Devuelve el desplazamiento donde la última búsqueda C&lt;m//g&gt; terminó para la variable en cuestión (C&lt;$_&gt; es usada cuando no se especifica ninguna variable).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loops, subroutines and other
control structures allow you to jump around within the code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bucles, subrutinas y otras estructuras de control le permiten saltar a lo largo del código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some passes discussed below are performed concurrently, but because
their results are the same, we consider them individually.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos pases discutidos a continuación se realizan de forma simultanea, pero como sus resultados son los mismos, los consideramos por separado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub wanted {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234242Z" changeid="explorer">
        <seg>sub wanted {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Examples</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115338Z" changeid="explorer">
        <seg>=head1 Ejemplos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exec LIST
X&lt;exec&gt; X&lt;execute&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171653Z" changeid="explorer">
        <seg>=item exec LISTA
X&lt;exec&gt; X&lt;execute&gt; X&lt;ejecutar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar is a 
single string (of any size, limited only by the available memory),
number, or a reference to something (which will be discussed
in L&lt;perlref&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T234241Z" changeid="explorer">
        <seg>Un escalar es una cadena de caracteres (de cualquier tamaño, limitada únicamente por la memoria disponible), un número o una referencia a algo (esto se tratará en L&lt;perlref&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr/a-zA-Z//s;		# bookkeeper -&gt; bokeper</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr/a-zA-Z//s;		# coonnttaable -&gt; contable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Breaking complex templates into
individual line-by-line components, suitably annotated, can do as much to
improve legibility and maintainability of pack/unpack formats as C&lt;/x&gt; can
for complicated pattern matches.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Rompiendo plantillas complejas en líneas individuales, debidamente comentadas, puede servir para mejorar la legibilidad y facilitar el mantenimiento de los formatos pack/unpack, como C&lt;/x&gt; lo es para las expresiones regulares complicadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($foo = &quot;$bar&quot;) =~ s/this/that/;	# convert to string, copy, then change</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034941Z" changeid="explorer">
        <seg>($foo = &quot;$bar&quot;) =~ s/este/aquel/;		# convierte a cadena, copia, y luego cambia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A second C&lt;e&gt; modifier will cause the replacement portion
to be C&lt;eval&gt;ed before being run as a Perl expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un segundo modificador C&lt;e&gt; hará que la parte de reemplazo sea C&lt;eval&gt;uada antes de la ejecución como una expresión Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -e '$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)' *</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225503Z" changeid="explorer">
        <seg>perl -e '$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)' *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031333Z" changeid="explorer">
        <seg>&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates the BLOCK or EXPR for each element of LIST (locally setting
C&lt;$_&gt; to each element) and returns the list value composed of the
results of each such evaluation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa el BLOQUE o EXPR para cada elemento de LISTA (poniendo localmente C&lt;$_&gt; a cada elemento) y devuelve una lista de valores compuesta de los resultados de cada evaluación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new option, Pair, allows choosing the separator between hash keys
and values.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T171805Z" changeid="explorer">
        <seg>Una nueva opción, Pair, permite elegir el separador entre las claves y valores de un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Find a hex digit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Buscar un dígito hexadecimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Socket;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Socket;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Changed Internals</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Cambios internos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implements the fcntl(2) function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Implementa la función fcntl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any following text is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier texto que le siga, es ignorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension modules can also hook into the Perl parser to define new
kinds of compound statement.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013431Z" changeid="explorer">
        <seg>Hay módulos de extensiones que también pueden engancharse en el intérprete de Perl para definir nuevas clases de instrucciones compuestas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All variants of Unix, Mac OS (old and new), and Stream_LF files on VMS use
a single character to end each line in the external representation of text
(even though that single character is CARRIAGE RETURN on old, pre-Darwin
flavors of Mac OS, and is LINE FEED on Unix and most VMS files).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022733Z" changeid="explorer">
        <seg>Todas las variantes de Unix, Mac OS (viejo y nuevo) y los archivos Stream_LF sobre VMS usan un único carácter al final de cada línea en la representación externa del texto (incluso si el carácter único es un RETORNO DE CARRO en el antiguo, pre-Darwin sabor de Mac OS, y un AVANCE DE LÍNEA en los Unix y la mayor parte de los archivos VMS).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
argument is omitted, tests C&lt;$_&gt;, except for C&lt;-t&gt;, which tests STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el argumento se omite, se prueba C&lt;$_&gt;, excepto para C&lt;-t&gt;, que prueba STDIN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Padre</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>=item Padre</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ord(&quot;z&quot;))      gives &quot;2ab&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ord(&quot;z&quot;))      da &quot;2ab&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Better to omit it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es mejor omitirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new filename symbolically linked to the old filename.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea un nuevo nombre de archivo vinculado simbólicamente al nombre del archivo antiguo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POSIX::sigprocmask function can now retrieve the current signal mask without
also setting it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función POSIX::sigprocmask ahora puede recuperar la máscara de señales actual sin tener que establecerla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you'd like to manually inspect C&lt;system&gt;'s failure, you can check all
possible failure modes by inspecting C&lt;$?&gt; like this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001916Z" changeid="explorer">
        <seg>Si desea inspeccionar manualmente el error de C&lt;system&gt;, puede comprobar todas las posibles causas del error mediante la inspección de C&lt;$?&gt; como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $rex;                 # prints (?si-xm:my.STRING)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $rex;                 # imprime (?si-xm:mi.CADENA)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's well established that
modern programs need to be capable of communicating funny accented letters, and
things like euro symbols.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T233203Z" changeid="explorer">
        <seg>Los programas modernos deben poder comunicar caracteres acentuados o símbolos como el del euro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's how you get at elements in an array:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224848Z" changeid="explorer">
        <seg>Para obtener los elementos de un array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ABC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ABC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here $subroutine may be C&lt;(eval)&gt; if the frame is not a subroutine
call, but an C&lt;eval&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí, $subrutina puede ser C&lt;(eval)&gt; si el marco de llamada no es una llamada a una subrutina, sino un C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add the \[$@%&amp;*] prototype support</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadir soporte al prototipado de \[$@%&amp;*]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;canonpath()&gt; on Win32 now collapses F&lt;foo\..&gt; sections correctly.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025822Z" changeid="explorer">
        <seg>C&lt;canonpath()&gt; en Win32 ahora colapsa secciones F&lt;foo\..&gt; correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 7, 4) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 7, 4) = 1   ==  268435456 00000000000000000000000000001000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perhaps you could move them?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014730Z" changeid="explorer">
        <seg>¿Se anima a moverlas?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( /$pattern/i ) { }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T234640Z" changeid="explorer">
        <seg>if ( /$patron/i ) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lock($mbox);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lock($mbox);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't forget Perl modules, either.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230555Z" changeid="explorer">
        <seg>Y no olvidemos los módulos Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSE this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CLOSE este</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So to split
a string into individual characters, the following:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que para dividir una cadena en caracteres individuales, lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all
systems read C&lt;&quot;\r&quot;&gt; as ASCII CR and C&lt;&quot;\n&quot;&gt; as ASCII LF.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No todos los sistemas leen C&lt;&quot;\r&quot;&gt; como ASCII CR y C&lt;&quot;\n&quot;&gt; como ASCII LF.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can arrange for a callback to be run just before the C&lt;die&gt;
does its deed, by setting the C&lt;$SIG{__DIE__}&gt; hook.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede disponer que una retrollamada se ejecute antes de que C&lt;die&gt; haga sus funciones, actualizando el gancho C&lt;$SIG{__DIE__}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$vec = Bit::Vector-&gt;new_Dec(32, -559038737);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225514Z" changeid="explorer">
        <seg>$vec = Bit::Vector-&gt;new_Dec(32, -559038737);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://oreilly.com/catalog/9780596004781/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003147Z" changeid="explorer">
        <seg>http://oreilly.com/catalog/9780596004781/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Perl stringifies uncaught exception messages before display,
you'll probably want to overload stringification operations on
exception objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como Perl convertirá en cadena de caracteres los mensajes de excepción no capturados antes de mostrarlos, quizás quiera sobrecargar las operaciones de conversión a cadena en objetos de excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A PATTERN of C&lt;/^/&gt; is treated as if it were C&lt;/^/m&gt;, since it isn't
much use otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un PATRÓN C&lt;/^/&gt; es tratado como si fuera C&lt;/^/m&gt;, ya que de lo contrario no serviría de mucho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># In Foo.pm</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># En Foo.pm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the currently selected filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012215Z" changeid="explorer">
        <seg>Devuelve el identificador de archivo seleccionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is at this step that C&lt;\1&gt; is begrudgingly converted to C&lt;$1&gt; in
the replacement text of C&lt;s///&gt;, in order to correct the incorrigible
I&lt;sed&gt; hackers who haven't picked up the saner idiom yet.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es en este paso que C&lt;\1&gt; es convertido, de mala gana, en C&lt;$1&gt; en el texto de reemplazo de C&lt;s///&gt;, con el fin de corregir a los incorregibles hackers de I&lt;sed&gt; que todavía no han aprendido la correcta forma de indicar esta expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Configure&gt; will now detect C&lt;clearenv&gt; and C&lt;unsetenv&gt;, thanks to a patch
from Alan Burlison.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T043035Z" changeid="explorer">
        <seg>C&lt;Configure&gt; ahora detectará C&lt;clearenv&gt; y C&lt;unsetenv&gt;, gracias a un parche de Alan Burlison.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internal cleanup only</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Solo limpieza interior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an element off the end of the string is written to, Perl will first
extend the string with sufficiently many zero bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se escribe un elemento al final de la cadena, Perl primero extenderá la cadena con una cantidad suficiente de bytes cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &quot;'&quot; is the delimiter, no interpolation is performed on the PATTERN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si &quot;'&quot; &quot;es el delimitador, no se realiza interpolación en el PATRÓN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmacos		Perl notes for Mac OS (Classic)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmacos		Notas para Mac OS (Classic)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, the behaviour of C&lt;sort()&gt; is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, el comportamiento de C&lt;sort()&gt; es indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or perhaps as a real reference, like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o tal vez como una referencia real, de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, quoted strings cannot span multiple lines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por último, las cadenas entrecomilladas no puede abarcar varias líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;:utf8&gt; just marks the data as UTF-8 without further checking,
while C&lt;:encoding(UTF-8)&gt; checks the data for actually being valid
UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T022429Z" changeid="explorer">
        <seg>C&lt;:utf8&gt; solo marca los datos como UTF-8 sin más comprobaciones ulteriores, mientras que C&lt;:encoding(UTF-8)&gt; comprueba que los datos sean UTF-8 válidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easier to keep the documentation up
to date, and avoids having to document each piece of code twice (once in
POD and once in comments).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024751Z" changeid="explorer">
        <seg>Esto hace que sea más fácil mantener la documentación al día, y evita tener que documentar cada pieza de código dos veces (una en POD y otra vez en los comentarios).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you know what version or patchlevel a particular feature was
implemented, you can test C&lt;$]&gt; (C&lt;$PERL_VERSION&gt; in C&lt;English&gt;) to see if it
will be there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted sabe en qué versión o patchlevel fue implementada una cierta característica, puede comprobar C&lt;$]&gt; (C&lt;$PERL_VERSION&gt; en C&lt;English&gt;) para ver si está incluida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec @args;               # subject to shell escapes
                                # if @args == 1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044348Z" changeid="explorer">
        <seg>exec @args;               # sujeto a los escapados del shell
                                # if @args == 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -e 'print &quot;Hello world\n&quot;'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T011113Z" changeid="explorer">
        <seg>perl -e 'print &quot;Hello world\n&quot;'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Tie::Hash&gt; upgraded to version 1.02</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040719Z" changeid="explorer">
        <seg>C&lt;Tie::Hash&gt; actualizado a la versión 1.02</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With an C&lt;eval&gt;, you should be especially careful to remember what's
being looked at when:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dentro de C&lt;eval&gt;, debe, especialmente, recordar que es lo que está haciendo en cada momento:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl570delta	Perl changes in version 5.7.0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl570delta	Cambios en la versión 5.7.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;TTY&gt; =~ /^y/i &amp;&amp; foo();	# do foo if desired</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;TTY&gt; =~ /^s/i &amp;&amp; foo();	# hacer foo() si así se desea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Perl Functions by Category
X&lt;function&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043338Z" changeid="explorer">
        <seg>=head2 Funciones Perl por categoría
X&lt;function&gt; X&lt;función&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 mode   2 hour       2 line         $/    input separator</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224338Z" changeid="explorer">
        <seg>2 mode   2 hora       2 línea           $/    separador entrada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our $x;  my $x;	# warns</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T040534Z" changeid="explorer">
        <seg>our $x;  my $x;	# avisa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;U4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;U4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also
that, currently, C&lt;\G&gt; is only properly supported when anchored at the
very beginning of the pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205156Z" changeid="explorer">
        <seg>Tenga en cuenta también que, actualmente, C&lt;\G&gt; está sólo adecuadamente soportado cuando es anclado al comienzo del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any pattern containing a special backtracking verb that allows an argument
has the special behaviour that when executed it sets the current package's
C&lt;$REGERROR&gt; and C&lt;$REGMARK&gt; variables.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T005342Z" changeid="explorer">
        <seg>Cualquier patrón que contenga un verbo especial para la vuelta atrás que permita un argumento, tiene el comportamiento especial de que cuando es ejecutado establece las variables C&lt;$REGERROR&gt; y C&lt;$REGMARK&gt; en el paquete actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not consider one style to be better than others - &quot;There
Is More Than One Way Of Doing It&quot; is one Perl's mottos.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004532Z" changeid="explorer">
        <seg>Ningún estilo es mejor que otro. No olvide que uno de los lemas de Perl es &quot;Se puede hacer de varias maneras&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure that your module has a license, and that the full text of it
is included in the distribution (unless it's a common one and the terms
of the license don't require you to include it).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T031019Z" changeid="explorer">
        <seg>Asegúrese de que el módulo tiene una licencia, y que el texto completo de la misma está incluida en la distribución (a menos que sea muy común y los términos de la licencia no requieran que la incluya).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However any other combinations of C&lt;\&gt; followed by a character
are not substituted but only skipped, in order to parse them
as regular expressions at the following step.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No obstante, cualquier otra combinación de C&lt;\&gt; seguido de un carácter no va a ser sustituido, sino sólo obviado, con el fin de analizarlos como expresiones regulares en el paso siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Interpolation
X&lt;interpolation&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010450Z" changeid="explorer">
        <seg>=item Interpolación
X&lt;interpolation&gt; X&lt;interpolación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The possible
modifiers are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los posibles modificadores son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;/&gt; will
finish the regular expression, C&lt;\/&gt; will be stripped to C&lt;/&gt; on
the previous step, and C&lt;\\/&gt; will be left as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;/&gt; terminará la expresión regular, C&lt;\/&gt; será reducido a C&lt;/&gt; en el paso anterior, y C&lt;\\/&gt; será mantenido tal cual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pos($string) = 1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045505Z" changeid="explorer">
        <seg>pos($string) = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is just a funny way to write</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es sólo una manera divertida de escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Cwd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Cwd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ++($foo = &quot;a0&quot;);	# prints &quot;a1&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T223841Z" changeid="explorer">
        <seg>print ++($foo = &quot;a0&quot;);	# imprime &quot;a1&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Feynman&quot; =&gt; &quot;Richard&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;Feynman&quot; =&gt; &quot;Richard&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So doing this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110221T004840Z" changeid="explorer">
        <seg>So doing this:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Internal format</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234823Z" changeid="explorer">
        <seg>=head3 Formato interno</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Character mode is the default unless the format string 
starts with C&lt;U&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El modo carácter es el defecto a menos que la cadena de formato se inicia con C&lt;U&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 8) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 8) = 1   ==      65536 00000000000000001000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about perlbug, either type
'perldoc perlbug' or just 'perlbug' on a line by itself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222459Z" changeid="explorer">
        <seg>Para obtener más información acerca de perlbug, escriba 'perldoc perlbug', o simplemente, 'perlbug' en la misma línea de comandos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A useful idiom for C&lt;lex&gt;-like scanners is C&lt;/\G.../gc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un modismo útil para escáneres tipo C&lt;lex&gt; es C&lt;/\G.../gc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Scalar::Util</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015251Z" changeid="explorer">
        <seg>=item Scalar::Util</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example in
L&lt;perlipc/&quot;Sockets: Client/Server Communication&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el ejemplo en L&lt;perlipc/&quot;Sockets: Comunicación Cliente/Servidor&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@matches = ( 'foo' =~ m{ o?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230718Z" changeid="explorer">
        <seg>@coincidencias = ( 'foo' =~ m{ o?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Optimization of shift; and pop; calls without arguments</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T053831Z" changeid="explorer">
        <seg>=head2 Optimización de llamadas shift; y pop; sin argumentos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also subscript a list to get a single element from it:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150035Z" changeid="explorer">
        <seg>También puede subindexar una lista para obtener un solo elemento de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other restrictions include whether it works on directories,
open files, or pre-existing files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otras restricciones incluyen si funciona en directorios, archivos abiertos, o archivos pre-existentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Text\n&quot; if -T _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Texto\n&quot; if -T _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value to pack is too long, the result is truncated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el valor a empaquetar es demasiado largo, el resultado se trunca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;-I&lt;X&gt;&gt;, C&lt;chdir&gt;, C&lt;chmod&gt;, C&lt;chown&gt;, C&lt;chroot&gt;, C&lt;fcntl&gt;, C&lt;glob&gt;,
C&lt;ioctl&gt;, C&lt;link&gt;, C&lt;lstat&gt;, C&lt;mkdir&gt;, C&lt;open&gt;, C&lt;opendir&gt;,
C&lt;readlink&gt;, C&lt;rename&gt;, C&lt;rmdir&gt;, C&lt;stat&gt;, C&lt;symlink&gt;, C&lt;sysopen&gt;,
C&lt;umask&gt;, C&lt;unlink&gt;, C&lt;utime&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;chomp&gt;, C&lt;chop&gt;, C&lt;chr&gt;, C&lt;crypt&gt;, C&lt;hex&gt;, C&lt;index&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;, C&lt;length&gt;, C&lt;oct&gt;, C&lt;ord&gt;, C&lt;pack&gt;, C&lt;q//&gt;, C&lt;qq//&gt;, C&lt;reverse&gt;, C&lt;rindex&gt;, C&lt;sprintf&gt;, C&lt;substr&gt;, C&lt;tr///&gt;, C&lt;uc&gt;, C&lt;ucfirst&gt;, C&lt;y///&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 while $string =~ s/\t+/' ' x (length($&amp;) * 8 - length($`) % 8)/e;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225533Z" changeid="explorer">
        <seg>1 while $string =~ s/\t+/' ' x (length($&amp;) * 8 - length($`) % 8)/e;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfilter		Perl source filters</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfilter		Filtros de código fuente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># pack big-endian 16- and 32-bit unsigned integers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># empaqueta 16 y 32-bit enteros sin signo, en big-endian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item atan2 Y,X
X&lt;atan2&gt; X&lt;arctangent&gt; X&lt;tan&gt; X&lt;tangent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165537Z" changeid="explorer">
        <seg>=item atan2 Y,X
X&lt;atan2&gt; X&lt;arctangent&gt; X&lt;tan&gt; X&lt;tangent&gt; X&lt;arcotangente&gt; X&lt;tangente&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item 12874</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item 12874</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The equivalence of strings and v-strings (e.g.
that currently 5.8.0 is equal to &quot;\5\8\0&quot;) will go away.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T005839Z" changeid="explorer">
        <seg>La equivalencia de cadenas y v-strings (p. e., que en la actualidad 5.8.0 es igual a &quot;\5\8\0&quot;) va a desaparecer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These arguments are also evaluated
from left to right.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos argumentos también son evaluados de izquierda a derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may or may not choose to follow this usage.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231546Z" changeid="explorer">
        <seg>Usted puede elegir adoptarla o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the data is aggregated in obvious structures that will become objects</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015837Z" changeid="explorer">
        <seg>Cuando los datos se agregan en estructuras tan obvias que se convertirán en objetos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of any other character following the &quot;c&quot; besides those listed above is
discouraged, and some are deprecated with the intention of removing
those in Perl 5.16.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T205323Z" changeid="explorer">
        <seg>No se recomienda el uso de cualquier otro carácter después de la &quot;c&quot;, aparte de los mencionados anteriormente, y algunos de ellos están en desuso, con la intención de eliminarlas en Perl v5.16.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The L&lt;Time::gmtime&gt; and L&lt;Time::localtime&gt; modules provide a convenient,
by-name access mechanism to the gmtime() and localtime() functions,
respectively.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171355Z" changeid="explorer">
        <seg>Los módulos L&lt;Time::gmtime&gt; y L&lt;Time::localtime&gt; proporcionan convenientes mecanismos de acceso por nombres para las funciones gmtime() y localtime(), respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (s|({.*}.*){.*}|$1 |) {}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (s|({.*}.*){.*}|$1 |) {}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The standard release of perl (the one maintained by the perl
development team) is distributed only in source code form.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225346Z" changeid="explorer">
        <seg>La versión estándar de perl (la mantenida por el equipo de desarrollo de perl) sólo se distribuye en forma de código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach my $key (keys %hash) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234932Z" changeid="zipf">
        <seg>foreach my $clave (keys %hash) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlretut		Perl regular expressions tutorial</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000206Z" changeid="explorer">
        <seg>perlretut		Tutorial de expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Logical Not
X&lt;operator, logical, not&gt; X&lt;not&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001759Z" changeid="explorer">
        <seg>=head2 Not lógico
X&lt;operator, logical, not&gt; X&lt;not&gt; X&lt;operador, lógico, not&gt; X&lt;not&gt; X&lt;no&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this utility requires the
C&lt;Text::Diff&gt; module to function properly; this module isn't distributed
with perl, but is available from the CPAN.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234954Z" changeid="explorer">
        <seg>(Tenga en cuenta que esta utilidad requiere el módulo C&lt;Text::Diff&gt; para funcionar correctamente; este módulo no se distribuye con perl, pero está disponible en CPAN.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is,
if the left operand is false, the right operand is not even evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, si el operando izquierdo es falso, el operando de la derecha no es ni siquiera evaluado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select(REPORT2);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>select(INFORME2);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest need it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El resto lo necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $sentence_rx = qr{</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025320Z" changeid="explorer">
        <seg>my $sentencia_rx = qr{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One simple way to check that things are in the right place is to print out
the hard-coded C&lt;@INC&gt; that perl looks through for libraries:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225905Z" changeid="explorer">
        <seg>Una manera sencilla de comprobar que todo está en su sitio es imprimir en pantalla la variable C&lt;@INC&gt; incrustada en el programa, en la que perl busca las bibliotecas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using named
captures in a branch reset pattern, it's best to use the same names,
in the same order, in each of the alternations:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T125322Z" changeid="explorer">
        <seg>Si está utilizando capturas nominadas en un patrón de reinicio de rama, lo mejor es utilizar los mismos nombres, en el mismo orden, en cada una de las alternativas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -MTime::Piece -le 'print localtime-&gt;yday'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>$ perl -MTime::Piece -le 'print localtime-&gt;yday'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OO Perl is relatively simple and is implemented using references which
know what sort of object they are based on Perl's concept of packages.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225541Z" changeid="explorer">
        <seg>La programación orientada a objetos en Perl es relativamente sencilla y se implementa con referencias que &quot;conocen&quot; qué tipo de objeto son, basándose en el concepto de paquetes de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To learn how to install modules you download from CPAN, read
L&lt;perlmodinstall&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225606Z" changeid="explorer">
        <seg>Para aprender a instalar los módulos que descargue de CPAN, lea L&lt;perlmodinstall&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, when a quantified subpattern does not allow the rest of the
overall pattern to match, Perl will backtrack.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma predeterminada, cuando un sub-patrón cuantificado no permite que el resto del patrón coincida, Perl dará marcha atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;That doesn't look like a number&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;Esto no parece un número&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Both of these count from 0 to 10.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Estas dos líneas cuentan de 0 a 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close($handle)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T000952Z" changeid="explorer">
        <seg>close($handle)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Input from &lt;&gt; comes either from
standard input, or from each file listed on the command line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La entrada desde &lt;&gt; puede venir, ya sea desde la entrada estándar, o de cada archivo listado en la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a special form of this construct, called C&lt;\K&gt;, which causes the
regex engine to &quot;keep&quot; everything it had matched prior to the C&lt;\K&gt; and
not include it in C&lt;$&amp;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T144821Z" changeid="explorer">
        <seg>Hay una forma especial de esta construcción, llamada C&lt;\K&gt;, que hace que el motor regex &quot;salte&quot; todo lo que haya coincidido anteriormente a la C&lt;\K&gt; y no lo incluya en C&lt;$&amp;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that using C&lt;eval&gt; neither silences Perl from printing
warnings to STDERR, nor does it stuff the text of warning messages into C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado porque usar C&lt;eval&gt; ni silencia a Perl a la hora de imprimir avisos al STDERR, ni rellena el texto de los mensajes de aviso dentro de C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $INC{$filename}) {
           return 1 if $INC{$filename};
           die &quot;Compilation failed in require&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050939Z" changeid="explorer">
        <seg>if (exists $INC{$archivo}) {
           return 1 if $INC{$archivo};
           die &quot;Falló la compilación en require&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Frequently called programs (like CGI scripts) that simply use</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Programas ejecutados frecuentemente (como los scripts CGI) usan, simplemente,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dec = hex(&quot;DEADBEEF&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225513Z" changeid="explorer">
        <seg>$dec = hex(&quot;DEADBEEF&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scripts and library files supplied as input to or produced as
output from the programs of this Package do not automatically fall
under the copyright of this Package, but belong to whoever generated
them, and may be sold commercially, and may be aggregated with this
Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las secuencias de comandos y archivos de biblioteca suministrados como entrada o producidos como salida de los programas de este Paquete no quedan automáticamente bajo el copyright de este Paquete, sino que pertenecen a quien los ha generado, y puede ser vendidos comercialmente, y se podrán sumar a este paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just because you can subscript a list value like
a normal array does not mean that you can subscript a list value as a
hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo porque usted puede indexar una lista de valores como un array normal no significa que puede indexar una lista de valores como un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item tell</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item tell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item flock FILEHANDLE,OPERATION
X&lt;flock&gt; X&lt;lock&gt; X&lt;locking&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010445Z" changeid="explorer">
        <seg>=item flock IDENTIFICADOR_ARCHIVO,OPERACIÓN
X&lt;flock&gt; X&lt;lock&gt; X&lt;locking&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following problems are encountered with Haiku revision 28311:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los siguientes problemas se encuentran en la versión Haiku 28311:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($ARGV = shift) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($ARGV = shift) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say &quot;I like apples.&quot; 	    when /apples?/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234708Z" changeid="explorer">
        <seg>say &quot;Me gustan las manzanas.&quot;		when /manzanas?/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(23,1,1);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>set_vec(23,1,1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $hash{A}{B}{$key})       { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $hash{A}{B}{$clave})       { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, writers of overloading routines
for smart match mostly need to worry only with comparing against a scalar,
and possibly with stringification overloading; the other common cases
will be automatically handled consistently.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T184901Z" changeid="explorer">
        <seg>Por lo tanto, los programadores de rutinas de sobrecarga de coincidencia inteligente solo tienen que preocuparse de la comparación contra un escalar, y posiblemente, con una sobrecarga de la operación de convertir en cadena de caracteres; los otros casos comunes serán automáticamente gestionados de forma coherente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Updated Modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T003433Z" changeid="explorer">
        <seg>=head2 Módulos actualizados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec $shell '-sh';    # pretend it's a login shell</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec $shell '-sh';    # finge que es un shell de login</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of these pseudo-modules import semantics into the current
block scope (like C&lt;strict&gt; or C&lt;integer&gt;, unlike ordinary modules,
which import symbols into the current package (which are effective
through the end of the file).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos de estos pseudo-módulos importa semántica en el ámbito del bloque actual (como C&lt;strict&gt; o C&lt;integer&gt;, a diferencia de los módulos comunes, que importan los símbolos en el paquete actual (que son efectivos hasta el final del archivo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case I&lt;is&gt; significant--&quot;FOO&quot;,
&quot;Foo&quot;, and &quot;foo&quot; are all different names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El tamaño de caja I&lt;es&gt; significativo: &quot;FOO&quot;, &quot;Foo&quot; y &quot;foo&quot; son todos ellos nombres diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is I&lt;not&gt; what you want to use to capture
the output from a command; for that you should use merely backticks or
C&lt;qx//&gt;, as described in L&lt;perlop/&quot;`STRING`&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T023157Z" changeid="explorer">
        <seg>Esto I&lt;no&gt; es lo que desea utilizar para capturar la salida de un comando; para eso debería utilizar solamente las comillas invertidas o C&lt;qx//&gt;, como se describe en L&lt;perlop/&quot;`CADENA`&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;variable, built-in&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;variable, built-in&gt; X&lt;variable, primitiva&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whereas here's how a Perl programmer more comfortable with the idiom might
do it:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y aquí está cómo un programador de Perl, más cómodo con el lenguaje, puede hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line-noise lowercase line-noise UPPERCASE line-noise UPPERCASE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205602Z" changeid="explorer">
        <seg>línea-ruido minúsculas línea-ruido MAYÚSCULAS línea-ruido MAYÚSCULAS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, you want to use either the current
stable release, or the stable release immediately prior to that one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200610Z" changeid="explorer">
        <seg>En general, conviene usar la versión estable actual o la versión estable inmediatamente anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shrink-wrapped CDs with perl on them are available from several sources if
that will help.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231054Z" changeid="explorer">
        <seg>Si sirve de ayuda, varias fuentes ofrecen CDs empaquetados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It binds even more
tightly than unary minus, so -2**4 is -(2**4), not (-2)**4.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se une aún más estrechamente que la resta unaria, por lo que -2**4 es -(2**4), no (-2)**4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BUILD</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 BUILD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Who develops it?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T195941Z" changeid="explorer">
        <seg>¿Quién lo desarrolla?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To mark FILEHANDLE as UTF-8, use C&lt;:utf8&gt; or C&lt;:encoding(UTF-8)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023638Z" changeid="explorer">
        <seg>Para indicar IDENTIFICADOR_ARCHIVO como UTF-8, use C&lt;:utf8&gt; o C&lt;:encoding(UTF-8)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfork		Perl fork() information</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfork		Información sobre fork()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item waitpid PID,FLAGS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item waitpid PID,BANDERAS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ref_to_AoA = [</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ref_a_AoA = [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unshift(@ARGV, '-') unless @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unshift(@ARGV, '-') unless @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ($foo), exit;	# Or even this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ($foo), exit;	# O incluso esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/uni/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014658Z" changeid="explorer">
        <seg>=item * F&lt;t/uni/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keywords C&lt;given&gt; and C&lt;when&gt; are analogous
to C&lt;switch&gt; and C&lt;case&gt; in other languages, so the code
above could be written as</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T012521Z" changeid="explorer">
        <seg>Las palabras clave C&lt;given&gt; y C&lt;when&gt; son análogos a C&lt;switch&gt; y C&lt;case&gt; en otros lenguajes, por lo que el código anterior podrá ser escrito como</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Google &quot;larry wall quotes&quot;!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232106Z" changeid="explorer">
        <seg>¡Busque &quot;larry wall quotes&quot; en Google!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item mkdir</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item mkdir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113428Z" changeid="explorer">
        <seg>Entonces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that, try something more like:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para esto, intente algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcompile 	Perl compiler suite intro</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000451Z" changeid="explorer">
        <seg>perlcompile 	Herramientas de compilación de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used together, as C&lt;/ms&gt;, they let the &quot;.&quot; match any character whatsoever,
while still allowing &quot;^&quot; and &quot;$&quot; to match, respectively, just after
and just before newlines within the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usados juntos, como C&lt;/ms&gt;, permiten que &quot;.&quot; coincida con cualquier carácter, mientras que siguen permitiendo que &quot;^&quot; y &quot;$&quot; coincidan, respectivamente, con el después y el antes de los caracteres nueva línea dentro de la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
also can't be used to go into a construct that is optimized away.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco puede ir en una construcción que sea optimizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Arithmetic operators during C&lt;use integer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T233952Z" changeid="explorer">
        <seg>=item Operadores aritméticos con C&lt;use integer&gt; activo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A null pointer is created if the corresponding value for
C&lt;p&gt; or C&lt;P&gt; is C&lt;undef&gt;; similarly with unpack(), where a null pointer
unpacks into C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un puntero nulo es creado si el valor correspondiente para C&lt;p&gt; o C&lt;P&gt; es C&lt;undef&gt;; de forma similar con unpack(), donde un puntero nulo se descomprime en C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real numbers (floats and doubles) are in native machine format only.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los números reales (float y double) solo están en formato nativo de la máquina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike C&lt;dbmopen&gt;, the C&lt;tie&gt; function will not C&lt;use&gt; or C&lt;require&gt; a module
for you; you need to do that explicitly yourself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia de C&lt;dbmopen&gt;, la función C&lt;tie&gt; no usará C&lt;use&gt; o C&lt;require&gt; de un módulo por usted; necesitará hacerlo de forma explícita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Has it been done before?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014533Z" changeid="explorer">
        <seg>=head2 ¿Se ha hecho antes?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\s*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\s*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>force the argument into the string format.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234105Z" changeid="explorer">
        <seg>Fuerzan la conversión del argumento al formato de cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you get to choose, it's a good idea to standardize on UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235141Z" changeid="explorer">
        <seg>Si puede elegir, es recomendable utilizar UTF-8 de manera estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IMODE($mode)    the part of $mode containing the permission bits
            and the setuid/setgid/sticky bits</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052048Z" changeid="explorer">
        <seg>S_IMODE($modo)    la parte de $modo conteniendo los bit de permiso
            y los bit setuid/setgid/sticky</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several modules let you calculate with (bound only by memory and CPU time)
unlimited or fixed precision.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T033611Z" changeid="explorer">
        <seg>Hay varios módulos que permiten calcular con precisión fija o ilimitada (limitada únicamente por la memoria y el tiempo de CPU).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The match operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador de emparejamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function works like the system call by the same name: it makes the
named directory the new root directory for all further pathnames that
begin with a C&lt;/&gt; by your process and all its children.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta funcion trabaja como la llamada del sistema del mismo nombre: hace que el directorio indicado sea el directorio raíz de los siguientes caminos que comiencen por un C&lt;/&gt; en su proceso y todos sus hijos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&lt;=&gt;&quot; returns -1, 0, or 1 depending on whether the left
argument is numerically less than, equal to, or greater than the right
argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&lt;=&gt;&quot; devuelve -1, 0, o 1 dependiendo de si el argumento de la izquierda es numéricamente menor, igual o mayor que el argumento de la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A program is what you give the audience.&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231705Z" changeid="explorer">
        <seg>y que un programa es lo que se ofrece al público.&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmroapi		Perl method resolution plugin interface</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlmroapi		Interfaz de complementos: resolución de métodos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TYPE is currently bound to the use of C&lt;fields&gt; pragma,
and attributes are handled using the C&lt;attributes&gt; pragma, or starting
from Perl 5.8.0 also via the C&lt;Attribute::Handlers&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TIPO está vinculado al uso del pragma C&lt;fields&gt;, y los atributos se manejan con el pragma C&lt;attributes&gt;, o a partir de Perl 5.8.0 también a través del módulo C&lt;Attribute::Handlers&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gcc versions 3.x introduced a new warning that caused a lot of noise
during Perl compilation: C&lt;gcc -Ialreadyknowndirectory (warning:
changing search order)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T181845Z" changeid="explorer">
        <seg>versiones 3.x de gcc introdujeron una nueva advertencia que causaba mucho ruido en la compilación Perl: C&lt;gcc -Ialreadyknowndirectory (advertencia: cambiando el órden de búsqueda)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything
matching PATTERN is taken to be a delimiter separating the fields.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier cosa concordante con el PATRÓN se toma como un delimitador que separa los campos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &quot;independent&quot; subexpression, one which matches the substring
that a I&lt;standalone&gt; C&lt;pattern&gt; would match if anchored at the given
position, and it matches I&lt;nothing other than this substring&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T205802Z" changeid="explorer">
        <seg>Un subexpresión &quot;independiente&quot;, aquella que coincide la subcadena con un I&lt;único&gt; C&lt;patrón&gt; que coincidiría si estuviera anclada en la posición indicada, y no coincide con I&lt;ninguna otra más que esta subcadena&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;my&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;my&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may explicitly show which type of
operation you intend by using C&lt;&quot;&quot;&gt; or C&lt;0+&gt;, as in the examples below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede indicar, explícitamente, el tipo de operación que desea realizar utilizando C&lt;&quot;&quot;&gt; o C&lt;0+&gt;, como en los ejemplos siguientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many modules updated from CPAN incorporate new tests.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T011422Z" changeid="explorer">
        <seg>Muchos módulos actualizados desde CPAN incorporan nuevas pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To delete a filter pass C&lt;undef&gt; to it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111003T120849Z" changeid="zipf">
        <seg>Para eliminar un filtro debe pasarle C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(1,1,1);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>set_vec(1,1,1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use sort     qw(stable _quicksort _mergesort);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use sort     qw(stable _quicksort _mergesort);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Additive Operators
X&lt;operator, additive&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T234414Z" changeid="explorer">
        <seg>=head2 Operadores aditivos
X&lt;operator, additive&gt; X&lt;operador, aditivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 while s/\t+/' ' x (length($&amp;)*8 - length($`)%8)/e;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 while s/\t+/' ' x (length($&amp;)*8 - length($`)%8)/e;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you can assign to a list of variables, you can also assign to
an array or hash slice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ya que se puede asignar a una lista de variables, también se puede asignar a un array o una porción de hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New &quot;To%s: illegal mapping '%s'&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003015Z" changeid="explorer">
        <seg>=head2 Nuevo &quot;I&lt;To%s: illegal mapping '%s'&gt;&quot; (A %s: mapeo ilegal '%s')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function is now largely obsolete, mostly because it's very hard to
convert a core file into an executable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función es obsoleta desde hace mucho tiempo, en parte porque es muy difícil convertir un volcado del núcleo en un ejecutable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For portability, when using features that may not be implemented on
every machine, test the construct in an eval to see if it fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la portabilidad, cuando utilice características que pueden no estar implementadas en todas las máquinas, compruebe el código en un eval para ver si falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following pattern matches a parenthesized group:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T182614Z" changeid="explorer">
        <seg>El siguiente patrón coincide con un grupo de paréntesis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;perldoc&gt; will extract and format the documentation from any file
in the current directory, any Perl module installed on the system, or
any of the standard documentation pages, such as this one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233335Z" changeid="explorer">
        <seg>F&lt;perldoc&gt; extrae y aplica formato a la documentación de cualquier archivo del directorio actual, cualquier módulo Perl instalado en el sistema o cualquiera de las páginas de documentación estándar, como ésta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item rmdir</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item rmdir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be helpful to check
C&lt;$!&gt; when you are reading from filehandles you don't trust, such as a
tty or a socket.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011723Z" changeid="explorer">
        <seg>Puede ser útil comprobar C&lt;$!&gt; cuando está leyendo de identificadores de archivo en los que no confía, como tty o un socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef $/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use vars qw(@ISA);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015317Z" changeid="explorer">
        <seg>use vars qw(@ISA);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use
a PID of C&lt;0&gt; to get the current process group for the
current process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use un PID de C&lt;0&gt; para obtener el grupo del proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entire arrays (and slices of arrays and hashes) are denoted by '@',
which works much as the word &quot;these&quot; or &quot;those&quot; does in English,
in that it indicates multiple values are expected.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T145411Z" changeid="explorer">
        <seg>Los arrays enteros (y las porciones de arrays o hashes) son designados por '@', que funciona como los determinantes &quot;estos&quot; o &quot;esos&quot; del Español, indicando que se esperan múltiples valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$re = &lt;&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T222803Z" changeid="explorer">
        <seg>$re = &lt;&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To simplify multi-line substitutions, the &quot;.&quot; character never matches a
newline unless you use the C&lt;/s&gt; modifier, which in effect tells Perl to pretend
the string is a single line--even if it isn't.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para simplificar la sustitución de varias líneas, el carácter &quot;.&quot;  no coincide con una nueva línea a menos que utilice el modificador C&lt;/s&gt;, que en efecto dice a Perl que asuma que la cadena es una sola línea -incluso si no lo es-.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash    Regex     hash key grep            grep /$b/, keys %$a</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hash        Regex      grep clave hash                  grep /$b/, keys %$a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure you choose an appropriate name for your module early on.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015200Z" changeid="explorer">
        <seg>Asegúrese de elegir un nombre apropiado para el módulo desde el principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a = $ok ? @b : @c;  # oops, that's just a count!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054028Z" changeid="explorer">
        <seg>$a = $ok ? @b : @c;  # oops, ¡esto solo cuenta elementos!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;termcap.pl&gt;, F&lt;tainted.pl&gt;, F&lt;stat.pl&gt;, F&lt;shellwords.pl&gt;, F&lt;pwd.pl&gt;,
F&lt;open3.pl&gt;, F&lt;open2.pl&gt;, F&lt;newgetopt.pl&gt;, F&lt;look.pl&gt;, F&lt;find.pl&gt;,
F&lt;finddepth.pl&gt;, F&lt;importenv.pl&gt;, F&lt;hostname.pl&gt;, F&lt;getopts.pl&gt;,
F&lt;getopt.pl&gt;, F&lt;getcwd.pl&gt;, F&lt;flush.pl&gt;, F&lt;fastcwd.pl&gt;, F&lt;exceptions.pl&gt;,
F&lt;ctime.pl&gt;, F&lt;complete.pl&gt;, F&lt;cacheout.pl&gt;, F&lt;bigrat.pl&gt;, F&lt;bigint.pl&gt;,
F&lt;bigfloat.pl&gt;, F&lt;assert.pl&gt;, F&lt;abbrev.pl&gt;, F&lt;dotsh.pl&gt;, and
F&lt;timelocal.pl&gt; are all now deprecated.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010236Z" changeid="explorer">
        <seg>F&lt;termcap.pl&gt;, F&lt;tainted.pl&gt;, F&lt;stat.pl&gt;, F&lt;shellwords.pl&gt;, F&lt;pwd.pl&gt;, F&lt;open3.pl&gt;, F&lt;open2.pl&gt;, F&lt;newgetopt.pl&gt;, F&lt;look.pl&gt;, F&lt;find.pl&gt;, F&lt;finddepth.pl&gt;, F&lt;importenv.pl&gt;, F&lt;hostname.pl&gt;, F&lt;getopts.pl&gt;, F&lt;getopt.pl&gt;, F&lt;getcwd.pl&gt;, F&lt;flush.pl&gt;, F&lt;fastcwd.pl&gt;, F&lt;exceptions.pl&gt;, F&lt;ctime.pl&gt;, F&lt;complete.pl&gt;, F&lt;cacheout.pl&gt;, F&lt;bigrat.pl&gt;, F&lt;bigint.pl&gt;, F&lt;bigfloat.pl&gt;, F&lt;assert.pl&gt;, F&lt;abbrev.pl&gt;, F&lt;dotsh.pl&gt;, y F&lt;timelocal.pl&gt; son ahora obsoletas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Make . match a newline)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T054215Z" changeid="explorer">
        <seg>(Hace que . coincida con un car. de nueva línea)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qx/STRING/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item qx/STRING/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you've used
-OPT:fast_io=ON and this happens, try removing it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T003222Z" changeid="explorer">
        <seg>Si ha utilizado -OPT:fast_io=ON y sucede esto, pruebelo de nuevo quitándolo antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die $e if defined $e</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die $e if defined $e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In older versions of Perl, if your system had neither DBM nor
ndbm, calling C&lt;dbmopen&gt; produced a fatal error; it now falls back to
sdbm(3).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En las viejas versiones de Perl, si el sistema no tenía ni DBM ni ndbm, llamando a C&lt;dbmopen&gt; producía un error fatal; ahora lo intentaría con sdbm(3).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For further details see L&lt;perltie&gt;, L&lt;&quot;tied VARIABLE&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215845Z" changeid="explorer">
        <seg>Para más detalles, vea L&lt;perltie&gt;, L&lt;&quot;tied VARIABLE&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple C&lt;our&gt; declarations with the same name in the same lexical
scope are allowed if they are in different packages.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Múltiples declaraciones C&lt;our&gt; con el mismo nombre en el mismo ámbito léxico son permitidas si están en diferentes paquetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return unless defined wantarray; # don't bother doing more</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return unless defined wantarray; # no nos molestamos más</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;overload&gt; for details about that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;overload&gt; para los detalles sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @idx, reverse splice @idx, $p;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225559Z" changeid="explorer">
        <seg>push @idx, reverse splice @idx, $p;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;grep&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;grep&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\p{Lu}                      # capital letter</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025416Z" changeid="explorer">
        <seg>\p{Lu}                      # letra mayúscula</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a space and a plus sign are given as the flags at once,
a plus sign is used to prefix a positive number.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando un espacio y un signo más se dan como banderas de forma simultánea, un signo más es usado para prefijar un número positivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item FreeBSD</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005641Z" changeid="explorer">
        <seg>=item FreeBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not illegal to clear a restricted hash, so the warning
was removed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001721Z" changeid="explorer">
        <seg>No es ilegal borrar un hash restringido, por lo que el aviso fue retirado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Comments
X&lt;comment&gt; X&lt;#&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T040820Z" changeid="explorer">
        <seg>=head2 Comentarios
X&lt;comment&gt; X&lt;#&gt; X&lt;comentario&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
operator may be any of:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador puede ser cualquiera de:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qr/STRING/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item qr/STRING/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular the following metacharacters have their standard I&lt;egrep&gt;-ish
meanings:
X&lt;metacharacter&gt;
X&lt;\&gt; X&lt;^&gt; X&lt;.&gt; X&lt;$&gt; X&lt;|&gt; X&lt;(&gt; X&lt;()&gt; X&lt;[&gt; X&lt;[]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, los siguientes metacaracteres mantienen su significados estándar heredados del C&lt;egrep&gt;:
X&lt;metacarácter&gt;
X&lt;\&gt; X&lt;^&gt; X&lt;.&gt; X&lt;$&gt; X&lt;|&gt; X&lt;(&gt; X&lt;()&gt; X&lt;[&gt; X&lt;[]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add the sort pragma</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadido el pragma sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A memory leak in the fork() emulation has been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T000827Z" changeid="explorer">
        <seg>Una pérdida de memoria en la emulación de fork() se ha arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to its precedence, you must
be careful to avoid using it as replacement for the C&lt;||&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230627Z" changeid="explorer">
        <seg>Debido a su precedencia, debería evitar el uso de este operador como un reemplazo del operador C&lt;||&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@newAoA = map { [ @{ $AoA[$_] } [ 7..12 ] ] } 4 ..</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T195315Z" changeid="explorer">
        <seg>@newAoA = map { [ @{ $AoA[$_] } [ 7..12 ] ] } 4 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;next&gt; command starts the next iteration of the loop:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;next&gt; inicia la siguiente iteración del bucle:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$.\t$_&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$.\t$_&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns C&lt;1&gt; for success; on error, returns C&lt;undef&gt; if
the first argument is not a valid filehandle, or returns C&lt;0&gt; and sets
C&lt;$!&gt; for any other failure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012521Z" changeid="explorer">
        <seg>Devuelve C&lt;1&gt; para el éxito; en caso de error, devuelve C&lt;undef&gt; si el primer argumento no es un identificador de archivo válido, o devuelve C&lt;0&gt; y actualiza C&lt;$!&gt; por cualquier otro error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(*) Not all fields are supported on all filesystem types.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(*) No todos los campos están soportados por todos los sistemas de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default argument to the C&lt;shift&gt; function just happens to be C&lt;@_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T234934Z" changeid="explorer">
        <seg>El argumento predeterminado de la función C&lt;shift&gt; es C&lt;@_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A comprehensive list of Perl-related mailing lists can be found at:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230937Z" changeid="explorer">
        <seg>Encontrará una lista completa de listas de correo relacionadas con Perl en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;ok\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;correcto\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;cpan&gt; is a command-line interface to CPAN.pm.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235027Z" changeid="explorer">
        <seg>F&lt;cpan&gt; es una interfaz de línea de comandos de CPAN.pm.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$now_string = strftime &quot;%a %b %e %H:%M:%S %Y&quot;, localtime;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ahora = strftime &quot;%a %b %e %H:%M:%S %Y&quot;, localtime;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (defined $$x) {...}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T201256Z" changeid="explorer">
        <seg>if (defined $$x) {...}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;mro&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005457Z" changeid="explorer">
        <seg>=item C&lt;mro&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with any non-default flags appearing between the caret and the colon.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T194841Z" changeid="explorer">
        <seg>con cualquier bandera que no esté puesta por defecto apareciendo entre el circunflejo y el carácter de dos puntos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;Configure&gt; script is ultimately responsible for generating a
F&lt;Makefile&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014903Z" changeid="explorer">
        <seg>El script F&lt;Configure&gt; se encarga de generar un archivo F&lt;Makefile&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\cZ      chr(26)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034630Z" changeid="explorer">
        <seg>\cZ      chr(26)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>l           interpret integer as C type &quot;long&quot; or &quot;unsigned long&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>l           interpreta un entero como un &quot;long&quot; o &quot;unsigned long&quot; del C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getservbyname NAME,PROTO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getservbyname NOMBRE,PROTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use warnings;      &quot;$foo&quot;           LINKS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224323Z" changeid="explorer">
        <seg>use warnings;      &quot;$foo&quot;                 VÍNCULOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Data::Dumper qw( Dumper );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225448Z" changeid="explorer">
        <seg>use Data::Dumper qw( Dumper );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Conditional Operator
X&lt;operator, conditional&gt; X&lt;operator, ternary&gt; X&lt;ternary&gt; X&lt;?:&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T001101Z" changeid="explorer">
        <seg>=head2 Operadores condicionales
X&lt;operator, conditional&gt; X&lt;operator, ternary&gt; X&lt;ternary&gt; X&lt;?:&gt; X&lt;operador, condicional&gt; X&lt;operador, ternario&gt; X&lt;ternario&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is a hash, it chomps the hash's values, but not its keys.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE es un hash, recorta los valores del hash, pero no sus claves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to do
so raises an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intentarlo, lanza una excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0x12 0x34 0x56 0x78  # big-endian</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0x12 0x34 0x56 0x78  # big-endian    (byte superior antes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the new safer model has its problems too.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T152549Z" changeid="explorer">
        <seg>Sin embargo, el nuevo modelo de seguridad también tiene sus problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, this means that you shouldn't use this
for selecting between two aggregates for assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, esto significa que usted no debería usar esto para seleccionar entre dos agregados para hacer una asignación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case you're not familiar with the &quot;regular&quot; Version 8 regex
routines, here are the pattern-matching rules not described above.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212135Z" changeid="explorer">
        <seg>En caso de que no esté familiarizado con la versión 8 &quot;normal&quot; de las rutinas regex, aquí están las reglas de coincidencia de patrones no descritas anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$fh = \*STDIN;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$fh = \*STDIN;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;S{REPEAT_COUNT}&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050046Z" changeid="explorer">
        <seg>=item C&lt;S{CONTADOR_REPETICIÓN}&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5135delta	Perl changes in version 5.13.5</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141405Z" changeid="explorer">
        <seg>perl5135delta	Cambios en la versión 5.13.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can
combine several regexps like this to process a string part-by-part,
doing different actions depending on which regexp matched.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede combinar varias expresiones regulares como ésta para procesar una cadena parte por parte, haciendo diferentes acciones dependiendo de la expresión regular coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;continue&gt; is actually a flow control statement rather than a function.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012349Z" changeid="explorer">
        <seg>C&lt;continue&gt; es realmente una instrucción de control de flujo en lugar de una función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is used by C&lt;AUTOLOAD&gt; subroutines that wish to
load another subroutine and then pretend that the other subroutine had
been called in the first place (except that any modifications to C&lt;@_&gt;
in the current subroutine are propagated to the other subroutine.)
After the C&lt;goto&gt;, not even C&lt;caller&gt; will be able to tell that this
routine was called first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se usa por subrutinas C&lt;AUTOLOAD()&gt; que desean cargar otra subrutina y fingen que ésta otra subrutina ha sido llamada en primer lugar (excepto que cualquier modificación a C&lt;@_&gt; en la subrutina actual se propaga a la otra). Después del C&lt;goto&gt;, ni siquiera C&lt;caller()&gt; será capaz de decir qué rutina fue llamada en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unpack(&quot;N&quot;, pack(&quot;B32&quot;, substr(&quot;0&quot; x 32 . shift, -32)));</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050716Z" changeid="explorer">
        <seg>unpack(&quot;N&quot;, pack(&quot;B32&quot;, substr(&quot;0&quot; x 32 . shift, -32)));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll probably first have to say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Probablemente primero querrá escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;s2p&gt; run
on C&lt;s/foo/bar&gt; will produce a Perl program based around this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234211Z" changeid="explorer">
        <seg>Si se ejecuta F&lt;s2p&gt; sobre C&lt;s/foo/bar&gt;, generará un programa Perl basado en el código siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It contains functions that are
no longer used in the perl core, but that remain available for binary or
source compatibility reasons.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T041144Z" changeid="explorer">
        <seg>Contiene las funciones que ya no se utilizan en el núcleo de perl, pero que siguen estando disponibles por motivos de compatibilidad binaria o de código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$child_pid = open(FROM_KID, &quot;|-&quot;) 	// die &quot;can't fork: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005836Z" changeid="explorer">
        <seg>$child_pid = open(DESDE_EL_HIJO, &quot;|-&quot;)	// die &quot;no puedo hacer fork: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of bracket (square
or curly) governs whether it's an array or a hash being looked at.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El tipo de carácter (corchete o llave) indica si se trata de un array o un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>division preserving 64-bit integers</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>la división preserva los enteros de 64 bits</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use List::MoreUtils qw(uniq);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225548Z" changeid="explorer">
        <seg>use List::MoreUtils qw(uniq);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a 13-element list giving the status info for a file, either
the file opened via FILEHANDLE or DIRHANDLE, or named by EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012644Z" changeid="explorer">
        <seg>Devuelve una lista de 13 elementos dando la información de estado de un archivo, tanto si el archivo ha sido abierto a través de IDENTIFICADOR_ARCHIVO o IDENTIFICADOR_DIR, o nombrado por la EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;will&gt; match, it will B&lt;not&gt; set $1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T182520Z" changeid="explorer">
        <seg>B&lt;habrá&gt; coincidencia, pero B&lt;no&gt; actualizará $1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item next</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item next</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simplified implementation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T024050Z" changeid="explorer">
        <seg>Implementación simplificada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?=pattern)&gt;
X&lt;(?=)&gt; X&lt;look-ahead, positive&gt; X&lt;lookahead, positive&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T211454Z" changeid="explorer">
        <seg>=item C&lt;(?=patrón)&gt;
X&lt;(?=)&gt; X&lt;consiguiente, positivo&gt; X&lt;consiguiente, positivo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MIME::Base64 upgraded to version 3.05</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>MIME::Base64 actualizado a la versión 3.05</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>echo $PATH | perl -nl -072 -e '</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225503Z" changeid="explorer">
        <seg>echo $PATH | perl -nl -072 -e '</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl malloc (C&lt;-Dusemymalloc&gt;) does not work at all in Mac OS X.
This is not that serious, though, since the native malloc works just
fine.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T004303Z" changeid="explorer">
        <seg>El malloc Perl (C&lt;-Dusemymalloc&gt;) no funciona en absoluto en Mac OS X. Sin embargo, esto no es tan grave, debido a que el malloc nativo funciona muy bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@myarray = (5, 50, 500, 5000);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@miarray = (5, 50, 500, 5000);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Devel::DProf&gt; upgraded to version 20050603.00</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030128Z" changeid="explorer">
        <seg>C&lt;Devel::DProf&gt; actualizado a la versión 20050603.00</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Real World SQL Server Administration with Perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003501Z" changeid="explorer">
        <seg>=item I&lt;Real World SQL Server Administration with Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Win32: 4-arg select was broken</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Win32: el select() de 4 argumentos estaba roto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/\w/$&amp; x 2/eg;		# yields 'aabbcc  224466xxyyzz'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T213219Z" changeid="explorer">
        <seg>s/\w/$&amp; x 2/eg;				# queda como 'aabbcc  224466xxyyzz'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, for repeated C&lt;m/()/g&gt; the second-best match is the match at the
position one notch further in the string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T232913Z" changeid="explorer">
        <seg>Del mismo modo, para los repetidos C&lt;m/()/g&gt; la segunda mejor coincidencia es la coincidencia en la posición de una muesca más allá en la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/1/) {
            print &quot;$_\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053718Z" changeid="explorer">
        <seg>/1/) {
            print &quot;$_\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,26, 1) = 1   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,26, 1) = 1   ==   67108864 00000000000000000000000000100000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
0xFF does not caselessly match the character at 0x178, C&lt;LATIN CAPITAL
LETTER Y WITH DIAERESIS&gt;, because 0xFF may not be C&lt;LATIN SMALL LETTER Y
WITH DIAERESIS&gt; in the current locale, and Perl has no way of knowing if
that character even exists in the locale, much less what code point it
is.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T165814Z" changeid="explorer">
        <seg>Por ejemplo, 0xFF no coincide, sin tener en cuenta el tamaño de caja, con el carácter 0x178, C&lt;LATIN CAPITAL LETTER Y WITH DIAERESIS&gt;, porque 0xFF quizás no sea C&lt;LATIN SMALL LETTER Y WITH DIAERESIS&gt; en la región actual, y Perl no tiene manera de saber si ese carácter incluso existe en la región, y mucho menos qué punto de código es.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*?)(\d*)   &lt;&gt; &lt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T234107Z" changeid="explorer">
        <seg>(.*?)(\d*)   &lt;&gt; &lt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's why you should now invoke
it as C&lt;CORE::dump()&gt;, if you don't want to be warned against a possible
typo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y es por esto que debe invocarlo como C&lt;CORE::dump()&gt;, si no quiere recibir un aviso de que posiblemente ha cometido una falta ortográfica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlmroapi - Perl method resolution plugin interface</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T113517Z" changeid="explorer">
        <seg>perlmroapi - Interfaz de complementos: resolución de métodos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is an expression, the value is taken as an indirect
filehandle, generally its name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010409Z" changeid="explorer">
        <seg>Si el IDENTIFICADOR_ARCHIVO es una expresión, el valor es tomado como un identificador de archivo indirecto, generalmente su nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are an implementor, see
L&lt;perlapi/PL_keyword_plugin&gt; for the mechanism.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T012422Z" changeid="explorer">
        <seg>Si es usted un implantador, mire L&lt;perlapi/PL_keyword_plugin&gt; para informarse sobre este mecanismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be consistent with existing modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015305Z" changeid="explorer">
        <seg>Sea consistente con los módulos existentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a match is successful, the C&lt;$REGMARK&gt; variable will be set to the
name of the most recently executed C&lt;(*MARK:NAME)&gt; that was involved
in the match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T125004Z" changeid="explorer">
        <seg>Cuando una coincidencia tiene éxito, la variable C&lt;$REGMARK&gt; se establecerá al nombre de C&lt;(*MARK:NOMBRE)&gt; más recientemente ejecutado que participó en la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Available on 64 bit OpenVMS 8.2 and later.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015604Z" changeid="explorer">
        <seg>Disponible en OpenVMS 8.2 64 bit y siguientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the compiler will precompute the number which that expression
represents so that the interpreter won't have to.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>el compilador precalculará el número que representa esa expresión para que el intérprete no tenga que hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$success;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$exito;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;XSLoader&gt; 0.06 incorporated; small optimisation for calling
C&lt;bootstrap_inherit()&gt; and documentation enhancements.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030749Z" changeid="explorer">
        <seg>C&lt;XSLoader&gt; 0.06 incorporado; pequeña optimización en la llamada a C&lt;bootstrap_inherit()&gt; y mejoras en la documentación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The internal message loop executed by perl during blocking operations
sometimes interfered with messages that were external to Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001005Z" changeid="explorer">
        <seg>El bucle de mensajes interno ejecutado por perl durante las operaciones de bloqueo a veces interfiere con los mensajes que eran externos a Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is just like the C&lt;m/PATTERN/&gt; search, except that it matches
only once between calls to the reset() operator.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205855Z" changeid="explorer">
        <seg>Esto es igual que la búsqueda C&lt;m/patrón/&gt;, salvo que coincide una sola vez entre llamadas al operador reset().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the template C&lt;x[L]&gt; skips as many bytes as in a packed long,
and the template C&lt;&quot;$t X[$t] $t&quot;&gt; unpacks twice whatever $t (when
variable-expanded) unpacks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, la plantilla C&lt;x[L]&gt; salta tantos bytes como en un largo empaquetado, y la plantilla C&lt;&quot;$t X[$t] $t&quot;&gt; desempaqueta dos veces lo que $t desempaquete (cuando se expanda la variable).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME
X&lt;syntax&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T232631Z" changeid="explorer">
        <seg>=head1 NOMBRE
X&lt;syntax&gt; X&lt;sintaxis&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tru64 can now build Perl with the newer Berkeley DBs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T010248Z" changeid="explorer">
        <seg>Tru64 ahora compila Perl con las nuevas base de datos Berkeley.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn't make much sense to decode a PNG image into a
text string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110403T232013Z" changeid="explorer">
        <seg>(por ejemplo, no tiene sentido descodificar una imagen PNG en una cadena de texto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval '$answer =';   # sets $@</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval '$respuesta =';   # actualiza $@</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This fixed regexps of the form /...(??{...;$x})/ to no
longer ignore changes made to $x.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T001424Z" changeid="explorer">
        <seg>Esto arregla expresiones regulares de la forma /...(??{...;$x})/ para que deje de ignorar los cambios realizados en $x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;ne&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;ne&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for real @ARRAYs
X&lt;array&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201027Z" changeid="explorer">
        <seg>=item Funciones para @ARRAY reales
X&lt;array&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (@an_array) { print &quot;has array elements\n&quot; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (@un_array) { print &quot;tiene elementos array\n&quot; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for the absolute basic functionality of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014553Z" changeid="explorer">
        <seg>Pruebas de funcionalidad básica de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://www.apress.com/book/view/159059018X</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003439Z" changeid="explorer">
        <seg>http://www.apress.com/book/view/159059018X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BEGIN { srand() if $] &lt; 5.004 }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225520Z" changeid="explorer">
        <seg>BEGIN { srand() if $] &lt; 5.004 }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\e          escape (think troff)  (ESC)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T043401Z" changeid="explorer">
        <seg>\e		escape (como en troff)	(ESC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($email =~ /([^@]+)@(.+)/) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110205T232652Z" changeid="explorer">
        <seg>if ($email =~ /([^@]+)@(.+)/) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eval BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eval BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
patch removes the deprecation note.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T020042Z" changeid="explorer">
        <seg>Este parche elimina la nota de desaprobación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item unpack TEMPLATE,EXPR
X&lt;unpack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210333Z" changeid="explorer">
        <seg>=item unpack PLANTILLA,EXPR
X&lt;unpack&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might want to keep these desktop references close by your keyboard:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003159Z" changeid="explorer">
        <seg>Es probable que desee tener estas referencias a mano:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also many
other sub-domains for special topics like learning Perl, Perl news,
jobs in Perl, such as:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231327Z" changeid="explorer">
        <seg>Además, existen muchos subdominios dedicados a temas específicos, como el aprendizaje de Perl, noticias sobre Perl o puestos de trabajo para programadores Perl. Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code references with an empty prototype are no longer treated specially.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T004946Z" changeid="explorer">
        <seg>Referencias a código con un prototipo vacío ya no son tratados de forma especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DBNAME
is the name of the database (without the F&lt;.dir&gt; or F&lt;.pag&gt; extension if
any).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NOMBREDB es el nombre de la base de datos (sin la extensión F&lt;.dir&gt; o F&lt;.pag&gt; si las tuviera).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments are usually formatted to be only as wide as required to
display the given value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los argumentos son por lo general formateados para ser sólo tan amplios como para mostrar el valor dado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*?)(\d+)$  &lt;I have 2 numbers: &gt; &lt;53147&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110905T003429Z" changeid="explorer">
        <seg>(.*)(\d+)$   &lt;Tengo 2 números: 5314&gt; &lt;7&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Module::Build you would use the C&lt;make test&gt; equivalent C&lt;perl Build test&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030455Z" changeid="explorer">
        <seg>Para Module::Build debe utilizar el equivalente de C&lt;make test&gt;: C&lt;perl Build test&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now provides numeric macros and meaningful C&lt;Exporter&gt; tags.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035123Z" changeid="explorer">
        <seg>Ahora ofrece macros numéricas y etiquetas C&lt;Exporter&gt; más explicativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from the behavior described above, Perl does not expand
multiple levels of interpolation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de los comportamientos descritos anteriormente, Perl no expande múltiples niveles de interpolación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if
you're expecting a single value from a glob, it is much better to
say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que si está esperando un único valor de una expansión, es mucho mejor escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'1' may actually be any positive integer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'1' puede ser cualquier entero positivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;t/op/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014636Z" changeid="explorer">
        <seg>=item * F&lt;t/op/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually it gets it right, but if it
doesn't it won't realize something is wrong until it gets to the C&lt;}&gt; and
encounters the missing (or unexpected) comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo general, lo hace bien, pero si no, no se dará cuenta de que algo anda mal hasta que llega a la C&lt;}&gt; y se encuentra con la omisión de (o inesperada) coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * http://www.perl.org/advocacy/whyperl.html</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232552Z" changeid="explorer">
        <seg>=item * http://www.perl.org/advocacy/whyperl.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for
reading&quot; even when no data is available, and thus any subsequent C&lt;read&gt;
would block.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013547Z" changeid="explorer">
        <seg>En algunos sistemas Unix, select(2) puede informar de un descriptor de archivo I&lt;socket&gt; como &quot;listo para leer&quot; incluso cuando no hay datos disponibles, y por lo tanto un posterior C&lt;read&gt; producirá un bloqueo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\B  Match except at a word boundary</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225700Z" changeid="explorer">
        <seg>\B  Coincide con cualquier cosa excepto límite de palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.14&gt; will
return two elements in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3,14&gt; devolverá dos elementos en el contexto lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TIESCALAR classname, LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>TIESCALAR clase, LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>e	Evaluate the right side as an expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>e	Evalúa el lado derecho como una expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an uppercased version of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una versión de EXPR, en mayúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for the reason).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para ver la razón).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Math::Complex&gt; upgraded to version 1.35</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033019Z" changeid="explorer">
        <seg>C&lt;Math::Complex&gt; actualizada a la versión 1.35</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
breaking the single input byte C&lt;chr(0x36)&gt; into two groups gives a list
C&lt;(0x6, 0x3)&gt;; breaking it into 4 groups gives C&lt;(0x2, 0x1, 0x3, 0x0)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, rompiendo el byte de entrada C&lt;chr(0x36)&gt; en dos grupos da una lista C&lt;(0x6, 0x3)&gt;; dividiéndolo en 4 grupos da C&lt;(0x2, 0x1, 0x3, 0x0)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 8) = 128 ==      32768 00000000000000010000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 8) = 128 ==      32768 00000000000000010000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>({foo =&gt; &quot;bar&quot;})[0]{foo}</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T014148Z" changeid="explorer">
        <seg>({foo =&gt; &quot;bar&quot;})[0]{foo}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Variable scoping</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T181526Z" changeid="zipf">
        <seg>=head2 Ámbito de las variables</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a      $b        Type of Match Implied    Matching Code</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a          $b         Tipo de Coincidencia             Código similar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Versions prior to perl5.004 had serious security problems with buffer
overflows, and in some cases have CERT advisories (for instance,
http://www.cert.org/advisories/CA-1997-17.html ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200747Z" changeid="explorer">
        <seg>En las versiones anteriores a perl5.004 había problemas de seguridad graves con desbordamiento del búfer y, en algunos casos, notificaciones del CERT (por ejemplo,
http://www.cert.org/advisories/CA-1997-17.html).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162247Z" changeid="explorer">
        <seg>Por lo tanto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the forms without a BLOCK are operative through the end
of the current scope, just like the C&lt;my&gt;, C&lt;state&gt;, and C&lt;our&gt; operators.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T004133Z" changeid="explorer">
        <seg>Es decir, las formas sin un BLOQUE son operativas hasta el final del ámbito actual, al igual que los operadores C&lt;my&gt;, C&lt;state&gt; y C&lt;our&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod 0755, @executables;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod 0755, @ejecutables;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following single statement:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La simple declaración siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^\#   \s*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/^\#   \s*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== 1 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== 1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect of C&lt;keys&gt; is considered highly
experimental.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165250Z" changeid="explorer">
        <seg>Este aspecto de C&lt;keys&gt; es considerado altamente experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;not an integer&quot;       unless /^-?\d+$/;           # rejects +3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;no es un entero&quot;      unless /^-?\d+$/;           # rechaza +3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings created with C&lt;vec&gt; can also be manipulated with the logical
operators C&lt;|&gt;, C&lt;&amp;&gt;, C&lt;^&gt;, and C&lt;~&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cadenas creadas con C&lt;vec&gt; también se pueden manipular con los operadores lógicos C&lt;|&gt;, C&lt;&amp;&gt;, C&lt;^&gt;, y C&lt;~&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlvms		Perl notes for VMS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlvms		Notas para VMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $ref;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef $ref;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chmod LIST
X&lt;chmod&gt; X&lt;permission&gt; X&lt;mode&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170051Z" changeid="explorer">
        <seg>=item chmod LISTA
X&lt;chmod&gt; X&lt;permission&gt; X&lt;mode&gt; X&lt;permisos&gt; X&lt;modo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that the C&lt;-x&gt; and C&lt;-X&gt; may
under this pragma return true even if there are no execute permission
bits set (nor any extra execute permission ACLs).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note también que C&lt;-x&gt; y C&lt;-X&gt; pueden, bajo este pragma, devolver valores verdaderos incluso si los bits de permiso de ejecución no están puestos (ni cualquier permiso ACL extra de ejecución).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s|{.*}| |;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>s|{.*}| |;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&lt; \k'NAME' &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T214552Z" changeid="explorer">
        <seg>=item C&lt;&lt; \k'NOMBRE' &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Manual error checking can be done this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comprobación manual de errores se puede hacer así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Item: $item\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Item: $item\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opening curly on same line as keyword, if possible, otherwise line up.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llave de apertura en la misma línea que la palabra reservada, si es posible, o si no, alineada en vertical con ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(STDOUT, &quot;&gt;&quot;, \$variable)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003810Z" changeid="explorer">
        <seg>open(STDOUT, &quot;&gt;&quot;, \$variable)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl comes with a profiler, the F&lt;Devel::DProf&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231925Z" changeid="explorer">
        <seg>Perl incluye un perfilador, el módulo F&lt;Devel::DProf&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the ordering of hash keys has always been, and
continues to be, affected by the insertion order.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T135257Z" changeid="explorer">
        <seg>Además, el ordenamiento de las claves de un hash siempre ha sido, y sigue siendo, afectado por el orden de la inserción de los elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the undefined value if the array is empty, although this may also
happen at other times.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor indefinido si el array está vacío, aunque esto también puede suceder en otras situaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sentence =~ s{$quoted_substring}{big bad wolf};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T012623Z" changeid="explorer">
        <seg>$instruccion =~ s{$subcadena_escapada}{gran lobo malo};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;ARGV&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;ARGV&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;LDLOADLIBS&gt; is an environment variable used by the linker to link modules
C&lt;/ext&gt; modules to glibc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;LDLOADLIBS&gt; es una variable de entorno usada por el enlazador para enlazar módulos C&lt;/ext&gt; a glibc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE
be open with read intent to use LOCK_SH and requires that it be open
with write intent to use LOCK_EX.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010603Z" changeid="explorer">
        <seg>Note que la emulación de fcntl(2) de flock(3) requiere que IDENTIFICADOR_ARCHIVO sea abierto con intención de leer para usar LOCK_SH y requiere ser abierto con intención de escribir para usar LOCK_EX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)
                or die &quot;Can't set flags for the socket: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050023Z" changeid="explorer">
        <seg>$flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)
                or die &quot;No puedo poner los flags para el socket: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use overload;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045933Z" changeid="explorer">
        <seg>use overload;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;STDIN&gt;) { last unless $_; ... }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;STDIN&gt;) { last unless $_; ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of use</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024039Z" changeid="explorer">
        <seg>Ejemplos de uso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some systems defined C&lt;pipe&gt; in terms of C&lt;socketpair&gt;, in which a call
to C&lt;pipe(Rdr, Wtr)&gt; is essentially:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos sistemas definen C&lt;pipe&gt; en términos de C&lt;socketpair&gt;, en el que una llamada a C&lt;pipe(Rdr, Wtr)&gt; es esencialmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use DateTime;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225526Z" changeid="explorer">
        <seg>use DateTime;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ConTEXT</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item ConTEXT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;*.c&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;*.c&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Perl's prefix dereferencing
operators are typed: $, @, %, and &amp;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Los operadores de desreferencia de Perl están tipificados: $, @, %, y &amp;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a += 2) *= 3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a += 2) *= 3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POD formatting errors in the documentation fixed</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032149Z" changeid="explorer">
        <seg>Arreglados errores de formateo en la documentación POD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example
in L&lt;perlfunc/eof&gt; for how to reset line numbers on each file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vea el ejemplo en L&lt;perlfunc/eof&gt; de cómo restablecer los números de línea en cada archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as soon as the matching engine sees that there's
no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its
mistake and starts over again one character after where it had the
tentative match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T151851Z" changeid="explorer">
        <seg>Sin embargo, tan pronto como el motor de coincidencias ve que no hay espacios en blanco después de &quot;Come&quot; que había guardado en $1, se da cuenta de su error y comienza de nuevo un carácter después de donde había intentado coincidir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the last two digits of the year (e.g., &quot;01&quot; in 2001) do:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T000246Z" changeid="explorer">
        <seg>Para obtener los dos últimos dígitos del año (ej., &quot;01&quot; en 2001) hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also use a signal name in quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar también nombres de señales entrecomilladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:encoding&gt;
also implicitly pushes on top of itself the C&lt;:utf8&gt; layer because
internally Perl operates on UTF8-encoded Unicode characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;:encoding&gt; también se coloca, implícitamente, por encima de la capa C&lt;:utf8&gt; porque Perl, internamente, opera con caracteres Unicode codificados en UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default is a 16-bit checksum.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor predeterminado es una suma de comprobación de 16-bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that it short-circuits: the right expression is evaluated
only if the left expression is false.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T230413Z" changeid="explorer">
        <seg>Esto significa que cortocircuita: es decir, la expresión de la derecha sólo se evalúa si la expresión de la izquierda es falsa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a subroutine or method call</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>una subrutina o llamada a un método</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DOMAIN, TYPE, and PROTOCOL are specified the same as for
the syscall of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DOMINIO, TIPO, y PROTOCOLO son especificados de la misma manera que la llamada del sistema del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The copy of the Unicode Character Database included in Perl 5.9 has
been updated to 4.1.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T012811Z" changeid="explorer">
        <seg>La copia de la base de datos de caracteres Unicode incluidos en Perl 5.9 ha sido actualizado a la 4.1.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above uses SDBM_File, but it will work with any of the DBM
modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T154043Z" changeid="zipf">
        <seg>El código anterior usa SDBM_File, pero funcionará igual con todos los módulos DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;&gt;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;&gt;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ( ! eof($fh) ) {
            defined( $_ = &lt;$fh&gt; )
                or die &quot;readline failed for $arg: $!&quot;;
            ...</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T050759Z" changeid="explorer">
        <seg>while ( ! eof($fh) ) {
            defined( $_ = &lt;$fh&gt; )
                or die &quot;readline falló para $arg: $!&quot;;
            ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the
Internet domain, each address is four bytes long; you can unpack it
by saying something like:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el dominio de Internet, cada dirección son cuatro bytes de longitud; puede desempaquetarlos diciendo algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-T  File is an ASCII text file (heuristic guess).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-T  Archivo es un archivo de texto ASCII (por una suposición heurística).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s/foo/\Ubar/l</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163940Z" changeid="explorer">
        <seg>s/foo/\Ubar/l</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\xq&quot;       &quot;\x00q&quot;   yes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204135Z" changeid="explorer">
        <seg>&quot;\xq&quot;       &quot;\x00q&quot;      sí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For larger ordinals, either use
C&lt;\o{}&gt; , or convert to something else, such as to hex and use C&lt;\x{}&gt;
instead.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T210618Z" changeid="explorer">
        <seg>Para ordinales más grandes, puede usar C&lt;\o{}&gt;, o convertirlo a otra cosa, como por ejemplo, a hexadecimal y usar C&lt;\x{}&gt; en su lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be used to determine which branch of a pattern was matched
without using a separate capture group for each branch, which in turn
can result in a performance improvement, as perl cannot optimize
C&lt;/(?:(x)|(y)|(z))/&gt; as efficiently as something like
C&lt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T140452Z" changeid="explorer">
        <seg>Esto puede ser usado para determinar qué rama de un patrón coincidió sin necesidad de utilizar un grupo de captura separado para cada rama, que, a su vez, puede resultar en una mejora del rendimiento, ya que Perl no puede optimizar C&lt;/(?:(x)|(y)|(z))/&gt; tan eficientemente como algo parecido a C&lt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item make</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024926Z" changeid="explorer">
        <seg>=item make</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allow building on AIX 4.2.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052737Z" changeid="explorer">
        <seg>Se permite la compilación en AIX 4.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exist, they are bugs and reports are welcome.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225929Z" changeid="explorer">
        <seg>hay, los errores e informes serán bienvenidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parentheses
enclose the argument list for C&lt;print&gt; which is evaluated (printing
the result of C&lt;$foo &amp; 255&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los paréntesis encierran la lista de argumentos para C&lt;print&gt; que se evalúa (imprimir el resultado de C&lt;$foo &amp; 255&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you can't remember what mnemonic means,
you've got a problem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no puede recordar lo que significa un mnemónico, usted tiene un problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a comprehensive date and time representation look at the
L&lt;DateTime&gt; module on CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una completa y actualizada representación del tiempo mire en el módulo L&lt;DateTime&gt; en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special care has been taken to ensure that
those operators Do What You Mean while not breaking old code, but some
edge cases involving the empty regular expression may now parse
differently.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143327Z" changeid="explorer">
        <seg>Especial cuidado se ha tomado para garantizar que estos operadores Hagan Lo Que Queremos Decir sin romper código antiguo, pero en algunos casos extremos en los que está implicada una expresión regular vacía, pueden analizarse ahora de manera distinta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is where the notation
C&lt;${arr[$bar]}&gt; comes handy: C&lt;/${arr[0-9]}/&gt; is interpreted as
array element C&lt;-9&gt;, not as a regular expression from the variable
C&lt;$arr&gt; followed by a digit, which would be the interpretation of
C&lt;/$arr[0-9]/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí es donde la notación C&lt;${arr[$bar]}&gt; es muy útil: C&lt;/${arr[0-9]}/&gt; es interpretada como un elemento de array C&lt;-9&gt;, no como una expresión regular desde la variable C&lt;$arr&gt; seguida por un dígito, que puede ser la interpretación de C&lt;/$arr[0-9]/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests for perl's method resolution order implementations (see L&lt;mro&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014635Z" changeid="explorer">
        <seg>Pruebas de las implementaciones de orden de resolución de métodos de perl (vea L&lt;mro&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also refer to capture groups relatively, by using a negative number, so
that C&lt;\g-1&gt; and C&lt;\g{-1}&gt; both refer to the immediately preceding capture
group, and C&lt;\g-2&gt; and C&lt;\g{-2}&gt; both refer to the group before it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002014Z" changeid="explorer">
        <seg>También puede referirse a los grupos de captura, de forma relativa, usando un número negativo, por lo que C&lt;\g-1&gt; y C&lt;\g{-1}&gt; se refieren al grupo de captura inmediatamente anterior, y C&lt;\g-2&gt; y C&lt;\g{-2}&gt; se refieren al grupo anterior a éste.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;IO::Zlib&gt; is an C&lt;IO::&gt;-style interface to C&lt;Compress::Zlib&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T201145Z" changeid="explorer">
        <seg>C&lt;IO::Zlib&gt; es un interfaz con estilo C&lt;IO::&gt; a C&lt;Compress::Zlib&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the database does not exist, it is created with protection
specified by MASK (as modified by the C&lt;umask&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la base de datos no existe, se crea con la protección especificada por MÁSCARA (y modificada por C&lt;umask&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item a, d, l and u
X&lt;/a&gt; X&lt;/d&gt; X&lt;/l&gt; X&lt;/u&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162915Z" changeid="explorer">
        <seg>=item a, d, l y u
X&lt;/a&gt; X&lt;/d&gt; X&lt;/l&gt; X&lt;/u&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can be rewritten as the much more efficient</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T212613Z" changeid="explorer">
        <seg>puede ser reescrito de forma más eficiente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This might just confuse non-robust tools which parse the output of
modules such as Devel::Peek.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T103012Z" changeid="explorer">
        <seg>Esto solo puede confundir a herramientas poco robustas que analicen la salida de los módulos, tales como Desarrollo::Peek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item times</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item times</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The master web site for CPAN is
http://www.cpan.org/ and there is the CPAN Multiplexer at
http://www.cpan.org/CPAN.html which will choose a mirror near you via
DNS.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230015Z" changeid="explorer">
        <seg>El sitio web principal de CPAN está en http://www.cpan.org/ , y hay un multiplexor de CPAN en http://www.cpan.org/CPAN.html que elegirá un servidor reflejado mediante DNS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a clearer picture of
why that pattern matches, contrary to popular expectations:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170143Z" changeid="explorer">
        <seg>He aquí una idea más clara de por qué coincide con el patrón, al contrario de lo esperado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T231711Z" changeid="explorer">
        <seg>m{ (?: NO_CERO_LONGITUD )* (?: CERO_LONGITUD )?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Win32 portability fixes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Arreglos en la portabilidad de Win32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since voting among different estimators may occur,
the result is not predictable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que la promoción puede ocurrir desde distintos estimadores, el resultado no es predecible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Miscellaneous Enhancements</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T030936Z" changeid="explorer">
        <seg>=head2 Mejoras varias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%O    a synonym for %lo</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%O    un sinónimo para %lo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $Config{longsize},     &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $Config{longsize},     &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thank you to the following for contributing to this release:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052804Z" changeid="explorer">
        <seg>Gracias a las siguientes personas por contribuir a esta versión:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Localising C&lt;$^D&gt; no longer generates a diagnostic message about valid -D
flags.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T212319Z" changeid="explorer">
        <seg>Localización de C&lt;$^D&gt; ya no genera un mensaje de diagnóstico sobre banderas válidas -D.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These special variables, like the C&lt;%+&gt; hash and the numbered match variables
(C&lt;$1&gt;, C&lt;$2&gt;, C&lt;$3&gt;, etc.) are dynamically scoped
until the end of the enclosing block or until the next successful
match, whichever comes first.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T192001Z" changeid="explorer">
        <seg>Estas variables especiales, como el hash C&lt;%+&gt; y las variables de coincidencia numeradas (C&lt;$1&gt;, C&lt;$2&gt;, C&lt;$3&gt;, etc.) están dinámicamente contextualizadas hasta el final del bloque actual o hasta la siguiente coincidencia exitosa; lo que ocurra primero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -e &quot;print \&quot;Hello world\n\&quot;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225504Z" changeid="explorer">
        <seg>perl -e &quot;print \&quot;Hello world\n\&quot;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For integer
conversions (C&lt;d u o x X b i D U O&gt;), numbers are usually assumed to be
whatever the default integer size is on your platform (usually 32 or 64
bits), but you can override this to use instead one of the standard C types,
as supported by the compiler used to build Perl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las conversiones de entero (C&lt;d u o x X b i D U O&gt;), se asume que los números son, por lo general, de un tamaño, por defecto, de un entero de su plataforma (normalmente 32 or 64 bits), pero esto se puede reemplazar usando en su lugar uno de los tipos estándares de C, soportados por el compilador usado para construir Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@array  = delete @hash{qw(foo bar baz)}; # @array  is (undef,undef,33)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@array  = delete @hash{qw(foo bar baz)}; # @array es (undef,undef,33)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To check for that,
use eval:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para comprobar esto, use eval:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way distributivity of smart match
across arrays is not broken, as well as the other behaviours with complex
types (coderefs, hashes, regexes).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T184522Z" changeid="explorer">
        <seg>De esta manera no se rompe la distribución del efecto de la coincidencia inteligente a través de arrays, así como otros comportamientos con los tipos complejos (referencias a código, hashes, expresiones regulares).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An effect similar to C&lt;&lt; (?&gt;pattern) &gt;&gt; may be achieved by writing
C&lt;(?=(pattern))\g{-1}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T213914Z" changeid="explorer">
        <seg>Un efecto similar a C&lt;&lt; (?&gt;patrón) &gt;&gt; se puede conseguir escribiendo C&lt;(?=(patrón))\g{-1}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARRAY(0x8031d0)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032531Z" changeid="explorer">
        <seg>ARRAY(0x8031d0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens anywhere the arrow operator is used, including even here:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto sucede en cualquier parte en que se use el operador flecha, incluso aquí:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;readline&gt; (or the operator form, C&lt;&lt; &lt;EXPR&gt; &gt;&gt;) as the
conditional of a C&lt;for&gt; loop is shorthand for the following.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando C&lt;readline&gt; (o el operador C&lt;&lt; &lt;EXPR&gt; &gt;&gt;) como condición de un bucle C&lt;for&gt;, es una forma abreviada de escribir lo siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 How does Perl compare with other languages like Java, Python, REXX, Scheme, or Tcl?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230621Z" changeid="explorer">
        <seg>=head2 ¿Cómo es Perl en comparación con otros lenguajes como Java, Python, REXX, Scheme o Tcl?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Bitwise String Operators
X&lt;operator, bitwise, string&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T185911Z" changeid="explorer">
        <seg>=head2 Operadores de bit en cadenas
X&lt;operator, bitwise, string&gt; X&lt;operador, binario, cadena&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = map { s/this/that/r } @bar	# /r is very useful in maps</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T035005Z" changeid="explorer">
        <seg>@foo = map { s/este/aquel/r } @bar		# /r es muy útil con map</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(.*?)(\d+)   &lt;I have &gt; &lt;2&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110904T234206Z" changeid="explorer">
        <seg>(.*?)(\d+)   &lt;Tengo &gt; &lt;2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;--nofilter&gt; option to override the filtering has been added</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030355Z" changeid="explorer">
        <seg>Se añadió la opción C&lt;--nofilter&gt; para eliminar el filtrado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// (getpwuid($&lt;))[7]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T224306Z" changeid="explorer">
        <seg>// (getpwuid($&lt;))[7]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most systems supporting
fork(), great care has gone into making it extremely efficient (for
example, using copy-on-write technology on data pages), making it the
dominant paradigm for multitasking over the last few decades.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de los sistemas que soportan fork(), se ha tenido gran cuidado en hacerlo extremadamente eficiente (por ejemplo, usando la tecnología copy-on-write en páginas de datos), haciendo de él el paradigma dominante de la multitarea en las últimas décadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print v9786;              # prints SMILEY, &quot;\x{263a}&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print v9786;              # imprime SONRISA, &quot;\x{263a}&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;CPAN/path/...&gt; is a naming convention for files available on CPAN
sites.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230122Z" changeid="explorer">
        <seg>Se usa C&lt;CPAN/ruta/...&gt; como convención de nomenclatura para los archivos disponibles en los sitios de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
Boston, MA 02110-1301, USA or visit their web page on the internet at
http://www.gnu.org/copyleft/gpl.html.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T223352Z" changeid="explorer">
        <seg>Si no es así, escriba a la Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA, o visite su página web en Internet en http://www.gnu.org/copyleft/gpl.html .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substr($name, 7) = 'gap';        # raises an exception</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>substr($nombre, 7) = 'gap';       # lanza una excepción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, 
C&lt;find2perl . -user root -perm 4000 -print&gt; produces the following callback
subroutine for C&lt;File::Find&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234240Z" changeid="explorer">
        <seg>Por ejemplo, C&lt;find2perl . -user root -perm 4000 -print&gt; genera la siguiente subrutina de devolución de llamada para C&lt;File::Find&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a value is duplicated in the original hash, only one of those
can be represented as a key in the inverted hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si un valor está duplicado en el hash original, sólo uno de ellos puede ser representado como clave en el hash invertido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/op/reg_email_thr.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010028Z" changeid="explorer">
        <seg>=item t/op/reg_email_thr.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $bar   = decode('ISO-8859-1', readline STDIN);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235151Z" changeid="explorer">
        <seg>my $bar   = decode('ISO-8859-1', readline STDIN);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;unpack&gt; does the reverse of C&lt;pack&gt;: it takes a string
and expands it out into a list of values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;unpack&gt; hace lo contrario de C&lt;pack&gt;: toma una cadena y se expande hacia fuera en una lista de valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are not the very basics, though.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T233239Z" changeid="explorer">
        <seg>Aunque estos conceptos no son tan básicos...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines can also return values:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las subrutinas también pueden devolver valores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence Tom's quip that &quot;Nothing but perl can
parse Perl.&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T111930Z" changeid="explorer">
        <seg>Ésta es la razón por la que Tom dice que &quot;sólo perl puede analizar Perl&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlartistic - the Perl Artistic License</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlartistic - la Licencia Artística</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This packing may be opened with C&lt;unpack(&quot;l!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este empaquetado se puede abrir con C&lt;unpack(&quot;l!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 2, 4) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 2, 4) = 2   ==        512 00000000010000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if you have programmed in another language
you will see familiar pieces in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que si ha programado en otro lenguaje verá partes en Perl que le serán familiares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly the NULL needs to be taken into account when you are considering
the length of existing keys/values.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T153814Z" changeid="zipf">
        <seg>También hay que tener en cuenta el carácter NULL al determinar la longitud de claves y valores existentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-d  File is a directory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004644Z" changeid="explorer">
        <seg>-d  Archivo es un directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my(@AoA, @tmp);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my(@AoA, @tmp);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It describes in detail how to cope with most idiosyncrasies that the
C&lt;Configure&gt; script can't work around for any given system or
architecture.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225942Z" changeid="explorer">
        <seg>En este documento se describe en detalle cómo tener en cuenta la mayor parte de las idiosincrasias que el script C&lt;Configure&gt; no puede prever para una arquitectura o un sistema específicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* C&lt;sub&gt; was a keyword in Perl 4, but in Perl 5 it is an
operator, which can be used in expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>* C&lt;sub&gt; era una palabra clave en Perl 4, pero en Perl 5 es un operador, por lo cual puede ser usado con paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and when you execute Configure, do it as below, except for adding
PATH=uts:$PATH as a prefix.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214236Z" changeid="explorer">
        <seg>y cuando ejecute Configure, hágalo de la siguiente manera, con la adición de PATH=uts:$PATH como prefijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the slash that terminated C&lt;m//&gt; was followed by a C&lt;SPACE&gt;,
the example above is not C&lt;m//x&gt;, but rather C&lt;m//&gt; with no C&lt;/x&gt;
modifier.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que la barra que terminó C&lt;m//&gt; fue seguida por un C&lt;SPACE&gt;, el ejemplo anterior no es C&lt;m//x&gt;, sino más bien C&lt;m//&gt;, sin el modificador C&lt;/x&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically you will want to C&lt;use I&lt;Module::Name&gt;&gt;, which will then give
you access to exported functions or an OO interface to the module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225612Z" changeid="explorer">
        <seg>Normalmente agregará a su programa la línea C&lt;use I&lt;Nombre::Módulo&gt;&gt;, que le proporcionará acceso a las funciones exportadas o a una interfaz orientada a objetos del módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strawberry Perl: Windows, Perl 5.8.8 and 5.10.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225740Z" changeid="explorer">
        <seg>Strawberry Perl: Windows, Perl 5.8.8 y 5.10.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's all!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¡Eso es todo!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Future Directions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Direcciones futuras</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Really means this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En realidad significa lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also extend an array
by assigning to an element that is off the end of the array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También se puede extender un array haciendo una asignación a un elemento que esté más allá del final del array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set_vec(0,32,17);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225603Z" changeid="explorer">
        <seg>set_vec(0,32,17);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Platform Specific Notes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230445Z" changeid="explorer">
        <seg>=head1 Notas específicas por cada plataforma</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $bits = unpack(&quot;b*&quot;, $vector);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225604Z" changeid="explorer">
        <seg>my $bits = unpack(&quot;b*&quot;, $vector);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;keys @array&gt; in an lvalue context is a syntax
error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;keys @array&gt; en un contexto a la izquierda es un error de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's very useful if you use things like
C&lt;substr&gt;, or C&lt;length&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235214Z" changeid="explorer">
        <seg>Esto resulta muy útil al utilizar funciones como C&lt;substr&gt; o C&lt;length&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the core development team (known as the Perl Porters)
are a rag-tag band of highly altruistic individuals committed to
producing better software for free than you could hope to purchase for
money.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200303Z" changeid="explorer">
        <seg>En concreto, el núcleo del equipo de desarrollo (denominado Perl Porters)
está integrado por un grupo variopinto de personas de gran altruismo, dedicadas a producir gratuitamente software de mejor calidad que el que se podría obtener pagando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $w (0..3) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $w (0..3) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>q  A signed quad (64-bit) value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>q  Un valor cuádruplo con signo (64 bit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item L&lt;ptargrep&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234956Z" changeid="explorer">
        <seg>=item L&lt;ptargrep&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty leading fields are produced when there are positive-width matches at
the beginning of the string; a zero-width match at the beginning of
the string does not produce an empty field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Campos vacíos antecedentes son producidos cuando hay coincidencias de ancho positivas al principio de la cadena; una coincidencia de ancho cero al principio de la cadena no produce un campo vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string =~ /foo${re}bar/;	# can be interpolated in other patterns</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cadena =~ /foo${re}bar/;	# puede ser interpolado en otros patrones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($key, $value) = each %hash) {
          print $key, &quot;\n&quot;;
          delete $hash{$key};   # This is safe</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044056Z" changeid="explorer">
        <seg>while (($clave, $valor) = each %hash) {
          print $clave, &quot;\n&quot;;
          delete $hash{$clave};   # Esto es seguro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lowercase line-noise lowercase lowercase line-noise lowercase</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205723Z" changeid="explorer">
        <seg>minúsculas línea-ruido minúsculas minúsculas línea-ruido minúsculas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl581delta - what is new for perl v5.8.1</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T005424Z" changeid="explorer">
        <seg>perl581delta - qué hay de nuevo en perl v5.8.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;my&gt; in combination with a C&lt;use strict;&gt; at the top of
your Perl scripts means that the interpreter will pick up certain common
programming errors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225051Z" changeid="explorer">
        <seg>Si escribe C&lt;use strict;&gt; al principio de los scripts de Perl y usa C&lt;my&gt;, el intérprete detectará determinados errores frecuentes de programación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many (but not all)
of these leaks have now been eliminated or reduced.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005957Z" changeid="explorer">
        <seg>Muchos (pero no todas) de estas fugas han sido eliminadas o reducidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlhist&gt; for a history of Perl revisions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T225909Z" changeid="explorer">
        <seg>En L&lt;perlhist&gt; encontrará el historial de revisiones de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any single character matches itself, unless it is a I&lt;metacharacter&gt;
with a special meaning described here or above.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T212202Z" changeid="explorer">
        <seg>Cualquier carácter individual coincide consigo mismo, a menos que sea un I&lt;metacarácter&gt; con un significado especial descrito aquí o anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} elsif ( other condition ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002934Z" changeid="zipf">
        <seg>} elsif ( otra condición ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub convert {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002107Z" changeid="explorer">
        <seg>sub convertir {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$  perl -MTime::JulianDay -le 'print local_julian_day( time )'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>$  perl -MTime::JulianDay -le 'print local_julian_day( time )'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Parentheses for capturing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T183354Z" changeid="zipf">
        <seg>=item Paréntesis de captura</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Double quotes or single quotes may be used around literal strings:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224741Z" changeid="explorer">
        <seg>Las cadenas literales se pueden escribir entre comillas dobles o simples:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the outer bracket type has changed, and so our access syntax
has also changed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Observe que el paréntesis más exterior ha cambiado, por lo que nuestra sintaxis de acceso ha cambiado también.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows the pattern to match
literally (except for C&lt;$&gt; and C&lt;@&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T222447Z" changeid="explorer">
        <seg>Esto permite que el patrón coincida literalmente (a excepción de C&lt;$&gt; y C&lt;@&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($string =~ /(.\G)/g) {
         print $1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045514Z" changeid="explorer">
        <seg>while ($string =~ /(.\G)/g) {
         print $1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must specify the block of code for C&lt;sub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001804Z" changeid="explorer">
        <seg>Debe especificar el bloque de código para C&lt;sub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we add a C&lt;(*PRUNE)&gt; before the count like the following</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T011951Z" changeid="explorer">
        <seg>Si añadimos un C&lt;(*PRUNE)&gt; antes de la cuenta, como lo siguiente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is intended to give you a quick overview of the Perl
programming language, along with pointers to further documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224521Z" changeid="explorer">
        <seg>Este documento proporciona una introducción rápida al lenguaje de programación Perl e incluye referencias a documentación adicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's here so that modules, programs, etc., that want to declare
this as their distribution license can link to it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es aquí, si desea declarar esto como su licencia de distribución, donde los módulos, programas, etc, pueden enlazarse con ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;while&gt; repeats the statement I&lt;while&gt; the condition is true.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013126Z" changeid="explorer">
        <seg>C&lt;while&gt; repite la instrucción I&lt;mientras&gt; la condición sea cierta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlwin32		Perl notes for Windows</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlwin32		Notas para Windows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behaves like wait(2) on your system: it waits for a child
process to terminate and returns the pid of the deceased process, or
C&lt;-1&gt; if there are no child processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se comporta como wait(2) de su sistema: espera a que un proceso hijo termine y devuelve el PID del proceso que ha fallecido, o C&lt;-1&gt; si no hay procesos hijos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The inheritance hierarchy of C&lt;B::&gt; modules has changed; C&lt;B::NV&gt; now
inherits from C&lt;B::SV&gt; (it used to inherit from C&lt;B::IV&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T041556Z" changeid="explorer">
        <seg>La jerarquía de la herencia de los módulos C&lt;B::&gt; ha sido cambiada; C&lt;B::NV&gt; ahora hereda desde C&lt;B::SV&gt; (se usaba para heredar desde C&lt;B::IV&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's 
because strings that aren't numbers count as 0, just as they do in B&lt;awk&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es porque las cadenas que no son números cuentan como 0, igual a como se comportan en B&lt;awk&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Socket qw(:DEFAULT :crlf);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015338Z" changeid="explorer">
        <seg>use Socket qw(:DEFAULT :crlf);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every C&lt;when&gt; block is implicitly ended with
a C&lt;break&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada bloque C&lt;when&gt; se termina, implícitamente, con un C&lt;break&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shuts down a socket connection in the manner indicated by HOW, which
has the same interpretation as in the syscall of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cierra una conexión de socket en la manera indicada por el CÓMO, que tiene la misma interpretación que en la llamada del sistema del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Causes the script to sleep for (integer) EXPR seconds, or forever if no 
argument is given.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace que el programa duerman EXPR segundos (entero), o para siempre si se da ningún argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 1.5.5 the threads tests stress_cv,
stress_re, and stress_string are failing unless the environment
variable PERLIO is set to &quot;perlio&quot; (which makes also the io/tell
failure go away).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T003419Z" changeid="explorer">
        <seg>En 1.5.5 las pruebas de threads stress_cv, stress_re y stress_string siguen fallando a menos que la variable de entorno PerlIO se ajuste a &quot;perlio&quot; (que hace también desaparecer el fallo de io/tell).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good error messages should
go to C&lt;STDERR&gt;, include which program caused the problem, what the failed
system call and arguments were, and (VERY IMPORTANT) should contain the
standard system error message for what went wrong.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los buenos mensajes de error deben ir al C&lt;STDERR&gt;, incluyendo qué programa causó el problema, qué función del sistema y qué argumentos fueron, y (MUY IMPORTANTE) debe contener el mensaje de error estándar del sistema por el cual falló.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/wantarray&gt; for more on how the evaluation context can be 
determined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/wantarray&gt; para saber cómo determinar el contexto de la evaluación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last four modifiers listed above, added in Perl 5.14,
control the character set semantics.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T225704Z" changeid="explorer">
        <seg>Los últimos cuatro modificadores enumerados anteriormente, agregados en Perl 5.14, controlan las semánticas del juego de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;format l is %d, l!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;formato l es %d, l!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%10.5s&gt;', &quot;truncated&quot;; # prints &quot;&lt;     trunc&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%10.5s&gt;', &quot;truncado&quot;; # imprime &quot;&lt;     trunc&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's the
same, however, in that it does reparse the file every time you call it,
so you probably don't want to do this inside a loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es lo mismo, sin embargo, en que vuelve a interpretar el archivo cada vez que lo llama, así que, probablemente, no querrá hacer esto dentro de un bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use
FILEHANDLE without a LIST to print the contents of C&lt;$_&gt; to it, you must
use a real filehandle like C&lt;FH&gt;, not an indirect one like C&lt;$fh&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T012017Z" changeid="explorer">
        <seg>Para utilizar IDENTIFICADOR_ARCHIVO sin LISTA para imprimir el contenido de C&lt;$_&gt;, debe usar un identificador de archivo real, como C&lt;FH&gt;, no uno indirecto como C&lt;$fh&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To learn how to use a particular module, use C&lt;perldoc I&lt;Module::Name&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225608Z" changeid="explorer">
        <seg>Para aprender a usar un módulo específico, ejecute C&lt;perldoc I&lt;Nombre::Módulo&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(MEMORY, &quot;&gt;&quot;, \$var)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004104Z" changeid="explorer">
        <seg>open(MEMORIA, &quot;&gt;&quot;, \$var)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the current process group for the specified PID, C&lt;0&gt; for the current
process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Establece el grupo de procesos en curso para el PID especificado, C&lt;0&gt; para el proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'foo' =~ m{ ( o?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050253Z" changeid="explorer">
        <seg>'foo' =~ m{ ( o?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that some command shells may place restrictions on the length
of the command line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que algunos shell de comandos puede imponer restricciones a la longitud de la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, memory management and allocation has been
improved in a couple of points.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T041016Z" changeid="explorer">
        <seg>Además, la gestión de memoria y la asignación se ha mejorado en un par de puntos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chown LIST
X&lt;chown&gt; X&lt;owner&gt; X&lt;user&gt; X&lt;group&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170216Z" changeid="explorer">
        <seg>=item chown LISTA
X&lt;chown&gt; X&lt;owner&gt; X&lt;user&gt; X&lt;group&gt; X&lt;propietario&gt; X&lt;usuario&gt; X&lt;grupo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Waits for a particular child process to terminate and returns the pid of
the deceased process, or C&lt;-1&gt; if there is no such child process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espera que termine un proceso hijo en particular y devuelve el PID del proceso que ha fallecido, o C&lt;-1&gt; si no existe tal proceso hijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Should be</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T051100Z" changeid="explorer">
        <seg># Debería ser</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get a hexadecimal digit, or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para obtener un dígito hexadecimal o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#  5          6          7            8       9         10</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T165947Z" changeid="explorer">
        <seg>#  5          6          7            8       9         10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new copy is always a plain string, even if the input
string is an object or a tied variable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T031617Z" changeid="explorer">
        <seg>La nueva copia siempre será una cadena normal, incluso si la entrada es un objeto o una variable enlazada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$binary =~ s/\x00\x0F/\xFF\xF0/;  # for the brave :)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234630Z" changeid="explorer">
        <seg>$binario =~ s/\x00\x0F/\xFF\xF0/;  # para valientes :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On unpacking, bits are converted to a string of C&lt;0&gt;s and C&lt;1&gt;s.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T002556Z" changeid="explorer">
        <seg>Al desempaquetar, los bits son convertidos a una cadena de C&lt;0&gt; y C&lt;1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Paul Szabo has analysed and patched C&lt;suidperl&gt; to remove existing known
insecurities.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T103630Z" changeid="explorer">
        <seg>Paul Szabo ha analizado y parcheado C&lt;suidperl&gt; para eliminar los inseguridades conocidas en este momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takes the same flags as the system call of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toma las mismas banderas que la llamada al sistema del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\b [DMS]r  )           # but isn't a common abbreviation</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T025601Z" changeid="explorer">
        <seg>\b [DMS]r  )           # pero no es una abreviatura conocida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sysopen FILEHANDLE,FILENAME,MODE,PERMS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T012813Z" changeid="explorer">
        <seg>=item sysopen IDENTIFICADOR_ARCHIVO,ARCHIVO,MODO,PERMISOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an existing module B&lt;almost&gt; does what you want, consider writing a
patch, writing a subclass, or otherwise extending the existing module
rather than rewriting it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T014754Z" changeid="explorer">
        <seg>Si un ya existente módulo B&lt;casi&gt; hace lo que quiere, considere escribir un parche, escribir una subclase o, de otra manera, extienda el módulo actual en lugar de reescribirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invoking the regex engine in these blocks would make perl
unstable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T201934Z" changeid="explorer">
        <seg>Invocar el motor de expresiones regulares en estos bloques haría a perl inestable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item i
X&lt;/i&gt; X&lt;regex, case-insensitive&gt; X&lt;regexp, case-insensitive&gt;
X&lt;regular expression, case-insensitive&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222805Z" changeid="explorer">
        <seg>=item i
X&lt;/i&gt; X&lt;regex, case-insensitive&gt; X&lt;regexp, case-insensitive&gt; X&lt;regular expression, case-insensitive&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ -pthread]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ -pthread]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,11, 2) = 2   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,11, 2) = 2   ==    8388608 00000000000000000000000100000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So don't do that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que no lo haga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Support returning the I&lt;k&gt;th root directly</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033319Z" changeid="explorer">
        <seg>Asistencia en la devolución directa de la I&lt;k&gt;-ésima raíz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if there were a C&lt;continue&gt; block on the above, it would get
executed even on discarded lines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que si hubiera un bloque C&lt;continue&gt; a continuación del anterior, se ejecutaría incluso en las líneas descartadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has three main variable types: scalars, arrays, and hashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224803Z" changeid="explorer">
        <seg>En Perl hay tres tipos de variables principales: escalares, arrays y hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sound principle is to use only ranges
that begin from and end at either alphabets of equal case (a-e, A-E),
or digits (0-4).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un buen principio es el de usar rangos que sólo comiencen y terminen, en cualquier alfabeto, con un mismo tamaño de caja (a-e, A-E), o dígitos (0-4).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl columns of Randal L. Schwartz are available on the web at
http://www.stonehenge.com/merlyn/WebTechniques/ ,
http://www.stonehenge.com/merlyn/UnixReview/ , and
http://www.stonehenge.com/merlyn/LinuxMag/ .</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230825Z" changeid="explorer">
        <seg>Las columnas sobre Perl de Randal L. Schwartz están disponibles en Internet, en http://www.stonehenge.com/merlyn/WebTechniques/ , http://www.stonehenge.com/merlyn/UnixReview/ y http://www.stonehenge.com/merlyn/LinuxMag/ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function cannot be used on an entire array or hash to find out how
many elements these have.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función no puede utilizarse en un array o hash para averiguar cuántos elementos tienen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Builtin types have all uppercase names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tipos incluidos tienen todos sus nombres en mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;import&gt; is not a builtin; it's just an ordinary static method
call into the C&lt;Module&gt; package to tell the module to import the list of
features back into the current package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;import&gt; no es una orden interna; es sólo una llamada al método estático ordinario en el paquete C&lt;Módulo&gt; para indicar al módulo que importe la lista de características en el paquete actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item shutdown SOCKET,HOW
X&lt;shutdown&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200639Z" changeid="explorer">
        <seg>=item shutdown SOCKET,CÓMO
X&lt;shutdown&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; =&gt; &gt;&gt; operator is a synonym for the comma except that it causes
its left operand to be interpreted as a string if it begins with a letter
or underscore and is composed only of letters, digits and underscores.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador C&lt;&lt; =&gt; &gt;&gt; es un sinónimo de la coma, salvo que causa que su operando izquierdo debe interpretarse como una cadena si comienza con una letra o un subrayado y está exclusivamente integrado por letras, dígitos y subrayados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item DB_File</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015033Z" changeid="explorer">
        <seg>=item DB_File</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The file is included via the do-FILE
mechanism, which is essentially just a variety of C&lt;eval&gt; with the
caveat that lexical variables in the invoking script will be invisible
to the included code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El archivo es incluido a través del mecanismo do ARCHIVO, que es esencialmente lo mismo que una variedad de C&lt;eval&gt; con la advertencia de que las variables léxicas en la secuencia de comandos del programa serán invisibles para el código incluido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A zero-width positive look-ahead assertion.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T204558Z" changeid="explorer">
        <seg>Una aserción consiguiente positiva de ancho cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the Perlish post-condition way</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T182219Z" changeid="zipf">
        <seg># ahora con una condición posterior, al estilo Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is equivalent to C&lt;(?!)&gt;, but easier to read.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T143729Z" changeid="explorer">
        <seg>Es equivalente a C&lt;(?!)&gt;, pero más fácil de leer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print (...) interpreted as function at - line 1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print (...) interpreted as function at - line 1.
(print (...) interpretado como función en - línea 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are multiple cases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay múltiples casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the hook is an array reference, its first element must be a subroutine
reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el enganche es una referencia de array, su primer elemento debe ser una referencia a una subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;&lt; (?P&gt;NAME) &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003415Z" changeid="explorer">
        <seg>=item C&lt;&lt; (?P&gt;NOMBRE) &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override that with an explicit C&lt;last&gt; if you're only
interested in the first match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede invalidar esto con un explícito C&lt;last&gt; si solo está interesado en la primera coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%3\$d %d %d\n&quot;, 12, 34, 56;    # will print &quot;56 12 34\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%3\$d %d %d\n&quot;, 12, 34, 56;    # imprimirá &quot;56 12 34\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every variable type has its own namespace, as do several
non-variable identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada tipo de variable tiene su propio espacio de nombres, y ocurre igual con otros tipos de identificadores que no designan variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open STDOUT: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003824Z" changeid="explorer">
        <seg>or die &quot;No puedo abrir STDOUT: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># ASCII-based examples</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Ejemplo basados en ASCII</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Be aware&gt;
that calling exists on array values is deprecated and likely to be removed in
a future version of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;Queda avisado&gt; que borrar elementos de un array mediante delete() es una funcionalidad obsoleta y es probable que sea eliminada en una futura versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $tmp, &quot;+&gt;&quot;, undef) or die ...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $tmp, &quot;+&gt;&quot;, undef) or die ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What does CPAN/src/... mean?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225953Z" changeid="explorer">
        <seg>¿Qué significa CPAN/src/... ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During this search no attention is paid to the semantics of the construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Durante esta búsqueda no se presta atención a la semántica de la construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Complete rewrite.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031119Z" changeid="explorer">
        <seg>Reescritura completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can
see whether using C&lt;!&gt; makes any difference this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se puede ver si usando C&lt;!&gt; provoca alguna diferencia, de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with foreword by Larry Wall</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003447Z" changeid="explorer">
        <seg>con prólogo de Larry Wall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shutdown(SOCKET, 0);    # I/we have stopped reading data</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>shutdown(SOCKET, 0);    # Hemos dejado de leer datas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my($what,$where,$howmuch) = @_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my($que,$donde,$cuanto) = @_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the rule for zero-length
matches (see L&lt;/&quot;Repeated Patterns Matching a Zero-length Substring&quot;&gt;)
is modified somewhat, in that contents to the left of C&lt;\G&gt; are
not counted when determining the length of the match.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045500Z" changeid="explorer">
        <seg>Tenga en cuanto que la norma para las coincidencias de tamaño cero (vea L&lt;/&quot;Patrones repetidos coincidiendo con subcadenas de longitud cero&quot;&gt;) ha sido modificada en cierta medida, en que los contenidos a la izquierda de C&lt;\G&gt; no son tenidos en cuenta cuando se determina la longitud de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># SYNTAX ERROR HERE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ERROR DE SINTAXIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instead, it has C&lt;\Q&gt;, C&lt;\\&gt;, and C&lt;E&gt;, so the
result is the same as for C&lt;&quot;\\\\E&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>en cambio, tiene a C&lt;\Q&gt;, C&lt;\\&gt;, y C&lt;E&gt;, por lo que el resultado es el mismo que para C&lt;&quot;\\\\E&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Cygwin Perl can now be built with threads (C&lt;Configure -Duseithreads&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T182920Z" changeid="explorer">
        <seg>En Cygwin Perl ahora se puede construir con soporte de hilos de ejecución (C&lt;Configure -Duseithreads&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitstrings of any size may be manipulated by the bitwise operators
(C&lt;~ | &amp; ^&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cadenas de bits de cualquier tamaño pueden ser manipulados por los operadores binarios (C&lt;~ | &amp; ^&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $oldout, &quot;&gt;&amp;STDOUT&quot;)     or die &quot;Can't dup STDOUT: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T004439Z" changeid="explorer">
        <seg>open(my $oldout, &quot;&gt;&amp;STDOUT&quot;)     or die &quot;No puedo duplicar STDOUT: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Paul Marquess</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110608T190203Z" changeid="zipf">
        <seg>Paul Marquess</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ah, but what if you wanted a I&lt;two-dimensional slice&gt;, such as having
$x run from 4..8 and $y run from 7 to 12?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T194932Z" changeid="explorer">
        <seg>¡Ah!, pero ¿qué pasa si yo quisiera un I&lt;porción bidimensional&gt;, ¿cómo hacer que $x vaya de 4 al 8 y $y de 7 al 12?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All
proper perl installations have fully-accessible documentation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230250Z" changeid="explorer">
        <seg>Todas las instalaciones de perl ofrecen documentación totalmente accesible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At other times, you
might prefer to determine whether string data can be used numerically
by calling the POSIX::strtod() function or by inspecting your string
with a regular expression (as documented in L&lt;perlre&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras ocasiones, podría ser preferible determinar si una cadena de datos puede ser usada numéricamente llamando a la función POSIX::strtod() o inspeccionando la cadena con una expresión regular (las cuales están documentadas en L&lt;perlre&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't rely on the alarm causing the system call to
fail with C&lt;$!&gt; set to C&lt;EINTR&gt; because Perl sets up signal handlers to
restart system calls on some systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede confiar que la alarma que llama a la llamada del sistema falle y ponga C&lt;$!&gt; a C&lt;EINTR&gt; porque Perl activa gestores de señal para reiniciar llamadas al sistema en algunos sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;p&gt; and C&lt;P&gt; formats should be used with care.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los formatos C&lt;p&gt; y C&lt;P&gt; deben ser utilizados con cuidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like all Perl character operations, length() normally deals in logical
characters, not physical bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Al igual que todas las operaciones Perl, de caracteres, length() normalmente trata con caracteres lógicos, no bytes físicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The regexp engine is now more robust when given invalid utf8 input, as is
sometimes generated by buggy XS modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T210826Z" changeid="explorer">
        <seg>El motor regex es ahora más sólido cuando se le administra una entrada utf8 inválida, como a veces se genera por parte de módulos XS con errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that there is no comma after VERSION!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¡Tenga en cuenta que no hay ninguna coma después de VERSIÓN!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Richard Foley</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003252Z" changeid="explorer">
        <seg>Richard Foley</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use C&lt;pos()&gt; to know what is
the current position of matching within this string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T220716Z" changeid="explorer">
        <seg>También puede utilizar C&lt;pos()&gt; para saber cuál es la posición actual de coincidencia dentro de esa cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A backslash represents a backslash
unless followed by the delimiter or another backslash, in which case
the delimiter or backslash is interpolated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una barra invertida representa una barra invertida a menos que esté seguida por el delimitador u otra barra invertida, en cuyo caso el delimitador o la barra invertida son interpolados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The construct C&lt;eval { goto &amp;foo }&gt; is now disallowed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192033Z" changeid="explorer">
        <seg>La construcción C&lt;eval { goto &amp;foo }&gt; ya no está permitida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does not attempt to do titlecase mapping on initial letters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No intentará hacer un mapeo de mayúsculas con tilder en las letras iniciales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 5.8.0 the so-called &quot;safe signals&quot; were introduced.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T155519Z" changeid="explorer">
        <seg>En Perl 5.8.0 fue introducido el concepto llamado &quot;acceso a señales de forma segura&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations that require perl to read a process's list of groups, such as reads
of C&lt;$(&gt; and C&lt;$)&gt;, now dynamically allocate memory rather than using a
fixed sized array.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045350Z" changeid="explorer">
        <seg>Las operaciones que requiere perl para leer la lista de procesos agrupados, tales como lecturas de C&lt;$(&gt; y C&lt;$)&gt;, ahora es asignada dinámicamente la memoria en lugar de utilizar un array de tamaño fijo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sin</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>overload::constant 'qr' =&gt; \&amp;convert;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T002102Z" changeid="explorer">
        <seg>overload::constant 'qr' =&gt; \&amp;convertir;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl by default is very forgiving.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T000941Z" changeid="zipf">
        <seg>Por su diseño, Perl es un lenguaje muy indulgente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;SCALAR&gt; method is now available for tied hashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un método C&lt;SCALAR&gt; está ahora disponible para los hash enlazados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The L&lt;perlglossary&gt; manpage is a glossary of terms used in the Perl
documentation, technical and otherwise, kindly provided by O'Reilly Media,
inc.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T042112Z" changeid="explorer">
        <seg>La página de manual L&lt;perlglossary&gt; es un glosario de términos utilizados en la documentación de Perl, técnicos y otros, amablemente proporcionado por O'Reilly Media, inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return map {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T053109Z" changeid="explorer">
        <seg>return map {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@articles = sort {$a cmp $b} @files;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@articulos = sort {$a cmp $b} @archivos;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when( /\D/ )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225621Z" changeid="explorer">
        <seg>when( /\D/ )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ .= &lt;&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ .= &lt;&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Back before Perl had the XS system for connecting with C libraries,
programmers used to get library constants by reading through the C
header files.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234455Z" changeid="explorer">
        <seg>Mucho antes de que existiera en Perl el sistema XS para conectar bibliotecas C, los programadores tenían que leer los archivos de encabezado de C para obtener las constantes de biblioteca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $file (&quot;/share/prog/defaults.rc&quot;,
               &quot;$ENV{HOME}/.someprogrc&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043927Z" changeid="explorer">
        <seg>for $file (&quot;/share/prog/defaults.rc&quot;,
               &quot;$ENV{HOME}/.someprogrc&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>splain [-v] [-p] diag.out</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225507Z" changeid="explorer">
        <seg>splain [-v] [-p] diag.out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows a 2 level hash of hash
structure using anonymous hash references.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224956Z" changeid="explorer">
        <seg>En el ejemplo siguiente se muestra una estructura de hash de hashes de 2 niveles en la que se usan referencias de hash anónimas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1e10  when /Mona Lisa/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223503Z" changeid="explorer">
        <seg>1e10  when /Mona Lisa/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2: 'q', pos=8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2: 'q', pos=8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some internal code cleanup.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alguna limpieza interna de código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2: 'q', pos=5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2: 'q', pos=5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Various socket problems were fixed in mpeix.c.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Diversos problemas con socket fueron arreglados en mpeix.c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$in_header =   1  ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$en_cabecera =   1  ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>56 tests and 474 subtests skipped.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T005013Z" changeid="explorer">
        <seg>56 tests y 474 subtests omitidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlembed&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230949Z" changeid="explorer">
        <seg>Vea L&lt;perlembed&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>j	       intepret integer as C type &quot;intmax_t&quot; on Perl 5.14</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181613Z" changeid="explorer">
        <seg>j           interpreta un entero como un &quot;intmax_t&quot; del C en Perl 5.14</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;List::Util&gt; upgraded to version 1.18 (was 1.14)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032859Z" changeid="explorer">
        <seg>C&lt;List::Util&gt; actualizado a la versión 1.18 (era 1.14)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;The Perl Cookbook&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003440Z" changeid="explorer">
        <seg>=item I&lt;The Perl Cookbook&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, if
you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Del mismo modo, si dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Text::Wrap&gt; upgraded to version 2005.082401</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040113Z" changeid="explorer">
        <seg>C&lt;Text::Wrap&gt; actualizado a la versión 2005.082401</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you open a pipe on the command C&lt;-&gt; (that is, specify either C&lt;|-&gt; or C&lt;-|&gt;
with the one- or two-argument forms of C&lt;open&gt;), 
an implicit C&lt;fork&gt; is done, so C&lt;open&gt; returns twice: in the parent
process it returns the pid
of the child process, and in the child process it returns (a defined) C&lt;0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005643Z" changeid="explorer">
        <seg>Si abre una tubería en el comando C&lt;-&gt; (es decir, ya sea C&lt;|-&gt; o C&lt;-|&gt; con la forma de uno o dos argumentos de C&lt;open&gt;), entonces se crea un C&lt;fork&gt; implícito, y C&lt;open&gt; regresa dos veces: en el proceso padre devuelve el PID del proceso hijo, y el proceso hijo devuelve un (definido valor) C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrecharclass/Backslash sequences&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220452Z" changeid="explorer">
        <seg>Vea L&lt;perlrecharclass/Secuencias con contrabarra&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, while searching for terminating C&lt;/&gt;,
combinations of C&lt;\\&gt; and C&lt;\/&gt; are skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, mientras se busca por el C&lt;/&gt; final, las combinaciones de C&lt;\\&gt; y C&lt;\/&gt; son omitidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@part = @{$AoA[4]}[7..12];</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032607Z" changeid="explorer">
        <seg>@part = @{$AoA[4]}[7..12];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A thread exited while %d other threads were still running</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T001707Z" changeid="explorer">
        <seg>I&lt;A thread exited while %d other threads were still running&gt; (Un hilo de ejecución terminó mientras %d otros hilos seguían ejecutándose)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to pass switches into your script, you can use one of the
Getopts modules or put a loop on the front like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si desea pasar opciones en su programa, puede utilizar uno de los módulos Getopts o poner un bucle, al principio, de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only interpolation is removal of C&lt;\&gt; from pairs of C&lt;\\&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La única interpolación es la eliminación de C&lt;\&gt; a partir de pares de C&lt;\\&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $ref;  # prints HASH(0x80d3d5c)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T020201Z" changeid="explorer">
        <seg>print $ref;  # imprime HASH(0x80d3d5c)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^def/) { $def = 1; last SWITCH; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^def/) { $def = 1; last SWITCH; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (keys $obj-&gt;get_arrayref) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165312Z" changeid="explorer">
        <seg>for (keys $obj-&gt;get_arrayref) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is all
very above-board and honest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo esto trata sobre la honradez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$+&gt; returns whatever the last bracket match matched.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$+&gt; devuelve cualquiera que sea el último paréntesis de captura coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you turn on the C&lt;use re 'eval'&gt;, though, it is no longer secure,
so you should only do so if you are also using taint checking.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T223212Z" changeid="explorer">
        <seg>Si activa C&lt;use re 'eval'&gt;, sin embargo, ya no es seguro, por lo que debería usarlo solo si está utilizando comprobaciones pringosas (I&lt;taint&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of EXPR with the first character in uppercase
(titlecase in Unicode).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor de EXPR con el primer carácter en mayúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print HANDLE &quot;stuff $$\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print HANDLE &quot;algo $$\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This call is actually implemented in terms of recvfrom(2) system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta llamada está implementada actualmente en términos de la llamada del sistema recvfrom(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following efficiently counts the number of set bits in a bit vector:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A continuación, de manera eficiente, cuenta el número de bits establecidos en un vector de bits:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the # flag and a precision are given in the %o conversion,
the precision is incremented if it's necessary for the leading &quot;0&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando la bandera # y una precisión se dan en la conversión %o, la precisión es incrementada si es necesario para el &quot;0&quot; inicial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pragmata are now correctly propagated into (?{...}) constructions in regexps.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T110258Z" changeid="explorer">
        <seg>Pragmata ahora se propaga correctamente en construcciones (?{...}) en las expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then the sort operation provides list context for &lt;&gt;, which
will proceed to read every line available up to the end of file, and
pass that list of lines back to the sort routine, which will then
sort those lines and return them as a list to whatever the context
of the sort was.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004128Z" changeid="explorer">
        <seg>entonces la operación sort establece un contexto de lista para &lt;&gt;, el cual procede a leer todas las líneas disponibles hasta alcanzar el final del archivo, y envía de vuelta esa lista de líneas a la subrutina sort, que entonces ordena las líneas y las devuelve como una lista o lo que sea dependiendo de cuál sea el contexto en que esté sort.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?           Match 1 or 0 times</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042643Z" changeid="explorer">
        <seg>?	Coincide 1 o 0 veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is usually pretty
good about this, but some pathological cases might trigger this, such as
C&lt;$a///&gt; (is that C&lt;($a) / (//)&gt; or C&lt;$a // /&gt;?) and C&lt;print $fh //&gt;
(C&lt;print $fh(//&gt; or C&lt;print($fh //&gt;?).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl es, por lo general, bastante bueno sobre esto, pero algunos casos patológicos podrían dar lugar a esto, como en, C&lt;$a///&gt; (es C&lt;($a) / (//)&gt; o C&lt;$a // /&gt;?) y C&lt;print $fh //&gt; (C&lt;print $fh(//&gt; o C&lt;print($fh //&gt;?).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For those of you that choose to use the GNU General Public License,
my interpretation of the GNU General Public License is that no Perl
script falls under the terms of the GPL unless you explicitly put
said script under the terms of the GPL yourself.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T223511Z" changeid="explorer">
        <seg>Para aquellos de ustedes que decidan utilizar la Licencia Pública General GNU, mi interpretación de la Licencia Pública General GNU es que ningún script en Perl cae bajo los términos de la GPL a menos que usted mismo, explícitamente, ponga dicho script en los términos de la GPL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;ODBM_File&gt; upgraded to version 1.06</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033928Z" changeid="explorer">
        <seg>C&lt;ODBM_File&gt; actualizado a la versión 1.06</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>our $bar = 30; # declares $Bar::bar for rest of lexical scope</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>our $bar = 30; # declara $Bar::bar para el resto del ámbito léxico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; digits&quot;),       redo LOOP if /\G\d+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T205317Z" changeid="explorer">
        <seg>print(&quot; dígitos&quot;),	redo LOOP if /\G\d+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /(f)(i)/i;      # Doesn't match!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162505Z" changeid="explorer">
        <seg>&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /(f)(i)/i;      # ¡No coincide!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;canonpath&gt; on Unix still does B&lt;not&gt; collapse these sections, as
doing so would be incorrect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032119Z" changeid="explorer">
        <seg>Tenga en cuenta que C&lt;canonpath&gt; en Unix sigue B&lt;sin&gt; colapsar estas secciones, ya que, de hacerlo, sería incorrecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the prototype of a function as a string (or C&lt;undef&gt; if the
function has no prototype).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el prototipo de una función como una cadena (o C&lt;undef&gt; si la función no tiene ningún prototipo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such combinations can include alternatives, leading to a problem of choice:
if we match a regular expression C&lt;a|ab&gt; against C&lt;&quot;abc&quot;&gt;, will it match
substring C&lt;&quot;a&quot;&gt; or C&lt;&quot;ab&quot;&gt;?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T233813Z" changeid="explorer">
        <seg>Estas combinaciones pueden incluir alternativas, dando lugar a un problema de elección: ¿si tenemos una expresión regular C&lt;a|ab&gt; contra C&lt;&quot;abc&quot;&gt;, coincidirá con la subcadena C&lt;&quot;a&quot;&gt; o con la C&lt;&quot;ab&quot;&gt;?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, an C&lt;eof()&gt; after C&lt;&lt; &lt;&gt; &gt;&gt; has returned
end-of-file will assume you are processing another C&lt;@ARGV&gt; list,
and if you haven't set C&lt;@ARGV&gt;, will read input from C&lt;STDIN&gt;;
see L&lt;perlop/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma semejante, un C&lt;eof()&gt; después de que un C&lt;&lt; &lt;&gt; &gt;&gt; haya devuelto un fin-de-archivo asumirá que está procesando otra lista C&lt;@ARGV&gt;, y si no ha puesto un nuevo C&lt;@ARGV&gt;, leerá la entrada desde C&lt;STDIN&gt;; ver L&lt;perlop/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl51311delta	Perl changes in version 5.13.11</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141239Z" changeid="explorer">
        <seg>perl51311delta	Cambios en la versión 5.13.11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_MTIME;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_MTIME;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>seek($fh, 0, SEEK_END) or die &quot;Cannot seek - $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>seek($fh, 0, SEEK_END) or die &quot;No puedo posicionarme - $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The F&lt;Cross&gt; directory contains various files related to cross-compiling
Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014925Z" changeid="explorer">
        <seg>El directorio F&lt;Cross&gt; contiene varios archivos relacionados con la compilación multiplataforma de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you enable warnings,
you'll be notified of an uninitialized value whenever you treat
C&lt;undef&gt; as a string or a number.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ha activado los avisos (warnings), será notificado de un valor no inicializado cada vez que trate a C&lt;undef&gt; como si fuera una cadena o número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes differences between the 5.12.2 release and
the 5.12.3 release.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T225750Z" changeid="explorer">
        <seg>Este documento describe las diferencias entre la versión 5.12.2 y la versión 5.12.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When doing so the following
rules apply:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T005407Z" changeid="explorer">
        <seg>Al hacerlo se aplicarán las siguientes reglas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case you can do:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En este caso puede hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl program 2&gt;diag.out</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T011244Z" changeid="explorer">
        <seg>perl programa 2&gt;diag.out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exec</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T015030Z" changeid="explorer">
        <seg>=item exec</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T221118Z" changeid="explorer">
        <seg>&gt;x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item srand</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item srand</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So we have</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T152723Z" changeid="explorer">
        <seg>Por lo que tenemos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Definitions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Definiciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (values $hashref) { ... }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183822Z" changeid="explorer">
        <seg>for (values $hashref) { ... }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x  A null byte (a.k.a ASCII NUL, &quot;\000&quot;, chr(0))</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>x  Un byte nulo (es decir, ASCII NUL, &quot;\000&quot;, chr(0))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># foo eq &quot;\xe2\x92\xb6\xe2\x92\xb7\xe2\x92\xb8\xe2\x92\xb9&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># foo es &quot;\xe2\x92\xb6\xe2\x92\xb7\xe2\x92\xb8\xe2\x92\xb9&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir $foo    || die;	# (chdir $foo) || die</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir $foo    || die;	# (chdir $foo) || die</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the tangent operation, you may use the C&lt;Math::Trig::tan&gt;
function, or use the familiar relation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la operación tangente, puede usar la función C&lt;Math::Trig::tan&gt;, o usar la conocidad relación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make LDLOADLIBS=&quot;-lnet -lflock&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>make LDLOADLIBS=&quot;-lnet -lflock&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl combines (in the author's opinion, anyway) some of the best
features of C, B&lt;sed&gt;, B&lt;awk&gt;, and B&lt;sh&gt;, so people familiar with
those languages should have little difficulty with it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001010Z" changeid="explorer">
        <seg>Perl combina (en opinión del autor) algunas de las mejores características de C, B&lt;sed&gt;, B&lt;awk&gt; y B&lt;sh&gt;, por lo que las personas familiarizadas con estos lenguajes aprenderán Perl fácilmente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with EXPR      %ENV  environment</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224358Z" changeid="explorer">
        <seg>con EXPR          %ENV  entorno</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Pod::Perldoc</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Pod::Perldoc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ARGV[1] =~ tr/A-Z/a-z/;	# canonicalize to lower case ASCII</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T032354Z" changeid="explorer">
        <seg>$ARGV[1] =~ tr/A-Z/a-z/;	# transforma a minúsculas ASCII</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># uname</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214110Z" changeid="explorer">
        <seg># uname</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlpacktut	Perl pack() and unpack() tutorial</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000302Z" changeid="explorer">
        <seg>perlpacktut	Tutorial de pack() y unpack()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators can be overloaded for objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Muchos operadores pueden ser sobrecargados por objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mkdir 'tmp',   0777	or die &quot;can't mkdir $tmpdir/tmp: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>mkdir 'tmp',   0777	or die &quot;no puedo hacer mkdir $tmpdir/tmp: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_ISUID S_ISGID S_ISVTX S_ISTXT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_ISUID S_ISGID S_ISVTX S_ISTXT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Flavors of Perl numeric operations</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232854Z" changeid="explorer">
        <seg>=head1 Tipos de operaciones numéricas en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or, if you're lazy, just:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110403T233732Z" changeid="explorer">
        <seg>Si no le sobra energía, puede limitarse a escribir esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl informally
reserves lowercase module names for &quot;pragma&quot; modules like C&lt;integer&gt; and
C&lt;strict&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl, de forma informal, reserva nombres de módulos en minúscula para módulos &quot;pragma&quot; como C&lt;integer&gt; y C&lt;strict&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>c	Complement the SEARCHLIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>c	Complementa la LISTA_BÚSQUEDA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 1-56592-243-3 [2nd edition August 2003]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003449Z" changeid="explorer">
        <seg>ISBN 1-56592-243-3 [2ª edición - Agosto de 2003]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A few very small changes were made to the build process on VOS to better
support the platform.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230933Z" changeid="explorer">
        <seg>Algunos cambios muy pequeños se hicieron para el proceso de la construcción en VOS para mejorar el soporte en esta plataforma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When different groups within the same pattern have the same name, any reference
to that name assumes the leftmost defined group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110731T141510Z" changeid="explorer">
        <seg>Cuando diferentes grupos dentro del mismo patrón tienen el mismo nombre, cualquier referencia a ese nombre se supone que es al grupo definido que esté más a la izquierda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item each HASH
X&lt;each&gt; X&lt;hash, iterator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171522Z" changeid="explorer">
        <seg>=item each HASH
X&lt;each&gt; X&lt;hash, iterator&gt; X&lt;hash, iterador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supplying a C&lt;*&gt; for the repeat count
instead of a number means to use however many items are left, except for:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El suministro de un C&lt;*&gt; para el número de repeticiones en lugar de un número significa usar tantos elementos como queden, a excepción de:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're trying to develop an
@AoA array containing all these, here's the right way to do that:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está tratando de desarrollar un array @AoA conteniendo todo eso, esta es la manera correcta de hacerlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(NOTE: If
FILEHANDLE is a variable and the next token is a term, it may be
misinterpreted as an operator unless you interpose a C&lt;+&gt; or put
parentheses around the arguments.) If FILEHANDLE is omitted, prints to the
last selected (see L&lt;/select&gt;) output handle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T005119Z" changeid="explorer">
        <seg>(NOTA: Si IDENTIFICADOR_ARCHIVO es una variable y el siguiente símbolo es un término, puede ser mal interpretado como un operador a menos que se interponga un C&lt;+&gt; o poner entre paréntesis los argumentos.) Si IDENTIFICADOR_ARCHIVO se omite, se imprime al canal de salida seleccionado por última vez (vea L&lt;/select&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach LIST</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbs2000		Perl notes for POSIX-BC BS2000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlbs2000		Notas para POSIX-BC BS2000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pair of parentheses following it does not (necessarily)
delimit its argument.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T165115Z" changeid="explorer">
        <seg>Un par de paréntesis puestos a continuación no (necesariamente) delimitan su argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item say</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BUILDING PERL ON UTS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T213801Z" changeid="explorer">
        <seg>=head1 CONSTRUYENDO PERL EN UTS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item I&lt;Automating System Administration with Perl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003452Z" changeid="explorer">
        <seg>=item I&lt;Automating System Administration with Perl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlebcdic&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045838Z" changeid="explorer">
        <seg>L&lt;perlebcdic&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The
filehandles C&lt;stdin&gt;, C&lt;stdout&gt;, and C&lt;stderr&gt; will also work except
in packages, where they would be interpreted as local identifiers
rather than global.)  Additional filehandles may be created with
the open() function, amongst others.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014015Z" changeid="explorer">
        <seg>(Los identificadores de archivo C&lt;stdin&gt;, C&lt;stdout&gt;, y C&lt;stderr&gt; también funcionarán, excepto en paquetes en el que podrían ser interpretados como identificadores locales en lugar de globales). Identificadores de archivo adicionales pueden ser creados con la función open(), entre otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has been added to the core (version 1.39).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152306Z" changeid="explorer">
        <seg>Fue añadido al núcleo principal (versión 1.39).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the actual exit value, shift right by eight (see
below).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener el valor real de la salida, se debe desplazar ocho a la derecha (ver más abajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@contact = sort { find_records() } @key;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@contacto = sort { busca_registros() } @claves;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But the strict refs, vars, and subs are B&lt;not&gt; enforced
when using this false idiom.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T175144Z" changeid="explorer">
        <seg>Sin embargo, los strict refs, vars y subs B&lt;no&gt; estaban forzados cuando se utilizaba ese falso modismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are actually two varieties of null strings (sometimes referred
to as &quot;empty&quot; strings), a defined one and an undefined one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay en realidad dos tipos de cadenas nulas (a las que algunas veces nos referimos como cadenas &quot;vacías&quot;); una definida, y otra, indefinida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,10, 2) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,10, 2) = 1   ==    1048576 00000000000000000000100000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./Configure -Dusethreads -Duseithreads -Dusedevel -des</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>./Configure -Dusethreads -Duseithreads -Dusedevel -des</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 5.8.0 there were about 69000 separate tests in about 700 test files,
in Perl 5.8.1 there are about 77000 separate tests in about 780 test files.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T012057Z" changeid="explorer">
        <seg>En Perl 5.8.0 había alrededor de 69.000 pruebas distintas en alrededor de 700 archivos de prueba, en Perl 5.8.1 hay cerca de 77.000 pruebas distintas en alrededor de 780 archivos de prueba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can now be built to detect attempts to assign pathologically large chunks
of memory.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T103059Z" changeid="explorer">
        <seg>Perl ahora pueden ser compilado para que detecte los intentos de reservar bloques patológicamente grandes de memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, test using</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por último, pruebe con</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting $0 works again (with certain limitations that
Perl cannot do much about: see L&lt;perlvar/$0&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T233120Z" changeid="explorer">
        <seg>Estableciendo $0 funciona de nuevo (con ciertas limitaciones en las que Perl no ha podido hacer mucho al respecto: vea L&lt;perlvar/$0&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;CGI&gt; upgraded to version 3.15</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T024229Z" changeid="explorer">
        <seg>C&lt;CGI&gt; actualizado a la versión 3.15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 6, 2) = 2   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 6, 2) = 2   ==       8192 00000000000001000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of Perl's syntactic elements are B&lt;optional&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Muchos de los elementos sintácticos de Perl son B&lt;opcionales&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exists &amp;sub;    # OK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exists &amp;sub;    # OK</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>L&lt;perlfaq&gt; contains questions and answers related to many common
tasks, and often provides suggestions for good CPAN modules to use.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225615Z" changeid="explorer">
        <seg>L&lt;perlfaq&gt; contiene preguntas y respuestas relacionadas con muchas tareas comunes, y en muchos casos sugiere los módulos de CPAN adecuados para cada tarea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encode upgraded to version 2.08</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Encode actualizado a la versión 2.08</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T182757Z" changeid="explorer">
        <seg>}x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New Modules and Pragmata</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005418Z" changeid="explorer">
        <seg>=head2 Nuevos módulos y pragmas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldebug		Perl debugging</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000314Z" changeid="explorer">
        <seg>perldebug		Depuración</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise use a C&lt;foreach()&gt; loop or
the C&lt;system()&gt; function instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De otra forma, use un bucle C&lt;foreach()&gt; o la función C&lt;system()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise you create non-Y2K-compliant programs--and you wouldn't want
to do that, would you?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario está creando programas Y2K no compatibles -y usted no querría hacer eso, ¿verdad?-</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should also have received a copy of the GNU General Public License
along with this program in the file named &quot;Copying&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T223250Z" changeid="explorer">
        <seg>También debería haber recibido una copia de la Licencia Pública General GNU junto con este programa en el archivo llamado &quot;Copying&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;pop&gt; of an item from a
shared array reference no longer causes a leak.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T211539Z" changeid="explorer">
        <seg>A C&lt;pop&gt; de un elemento de una referencia compartida a un array ya no provoca fugas de memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It would be much better if you could ignore the NULL terminations issue
in the main application code and have a mechanism that automatically
added the terminating NULL to all keys and values whenever you write to
the database and have them removed when you read from the database.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111006T160001Z" changeid="zipf">
        <seg>Sería mucho mejor poder ignorar el problema de los caracteres NULL de terminación de cadena en el código principal de la aplicación y disponer de un mecanismo que agregue automáticamente un carácter NULL de terminación a todas las claves y todos los valores que se escriban en la base de datos, y lo elimine al leer de la base de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( condition ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002929Z" changeid="zipf">
        <seg>if ( condición ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mung($first) or die &quot;mung failed&quot;;  # Or here.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T000308Z" changeid="explorer">
        <seg>mung($first) or die &quot;mung falló&quot;;   # O aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;CPAN&gt; upgraded to version 1.76_02</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T025648Z" changeid="explorer">
        <seg>C&lt;CPAN&gt; actualizado a la versión 1.76_02</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FreeBSD has a bug where reading this
symlink sometimes returns an incorrect value
(see http://www.freebsd.org/cgi/query-pr.cgi?pr=35703 ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T150719Z" changeid="explorer">
        <seg>FreeBSD tiene un error en la lectura de estos enlaces simbólicos: a veces devuelve un valor incorrecto (vea http://www.freebsd.org/cgi/query-pr.cgi?pr=35703 ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, F&lt;find2perl&gt; translates C&lt;find&gt; commands to Perl equivalents which 
use the L&lt;File::Find|File::Find&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234229Z" changeid="explorer">
        <seg>Por último, F&lt;find2perl&gt; traduce comandos C&lt;find&gt; en sus equivalentes Perl, que usan el módulo L&lt;File::Find|File::Find&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because backticks do not affect standard error, use shell file descriptor
syntax (assuming the shell supports this) if you care to address this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como las comillas invertidas no afectan a la salida de error estándar, use la sintaxis del shell del descriptor de archivos (asumiendo que el shell soporte esto) si es que quiere tenerlo en cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below for more details
and see C&lt;sprintf(3)&gt; or C&lt;printf(3)&gt; on your system for an explanation of
the general principles.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver abajo para más detalles y ver C&lt;sprintf(3)&gt; o C&lt;printf(3)&gt; en su sistema para obtener una explicación de los principios generales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backreference to a named capture group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T003353Z" changeid="explorer">
        <seg>Contrareferencia a un grupo de captura con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $var = &quot;value&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $var = &quot;valor&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last example should print:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El último ejemplo debería imprimir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chops off the last character of a string and returns the character
chopped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recorta el último carácter de un string y devuelve el carácter recortado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature introduces three new keywords,
C&lt;given&gt;, C&lt;when&gt;, and C&lt;default&gt;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T194004Z" changeid="explorer">
        <seg>Esta característica introduce tres nuevas palabras clave, C&lt;given&gt;, C&lt;when&gt;, y C&lt;default&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IRWXO S_IROTH S_IWOTH S_IXOTH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_IRWXO S_IROTH S_IWOTH S_IXOTH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;WWWW&quot;,65,66,67,68);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;WWWW&quot;,65,66,67,68);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;seekdir&gt; also has the same caveats
about possible directory compaction as the corresponding system library
routine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;seekdir&gt; también tiene las mismas advertencias sobre la posible compactación del directorio como la correspondiente rutina del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the I&lt;characters&gt;: depending on the status of the socket, either
(8-bit) bytes or characters are received.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note los I&lt;caracteres&gt;: dependiendo del estado del socket, son leídos bytes (8-bit) o caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the tied array class
contains a package variable named C&lt;$NEGATIVE_INDICES&gt; which is set to
a true value, negative values will be passed to C&lt;FETCH&gt;, C&lt;STORE&gt;,
C&lt;EXISTS&gt;, and C&lt;DELETE&gt; unchanged.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T170614Z" changeid="explorer">
        <seg>Si la clase de array enlazado contiene una variable de paquete denominada C&lt;$NEGATIVE_INDICES&gt; que se establece a un valor real, los valores negativos serán pasados directamente a C&lt;FETCH&gt;, C&lt;STORE&gt;, C&lt;EXISTS&gt;, y C&lt;DELETE&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%d    a signed integer, in decimal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%d    un entero con signo, en decimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Text from a C&lt;&quot;#&quot;&gt; character until the end of the line is a comment,
and is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El texto desde un carácter C&lt;&quot;#&quot;&gt; hasta el fin de la línea es un comentario y es ignorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checks if the expression has been evaluated while executing directly
inside of the n-th capture group.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T195038Z" changeid="explorer">
        <seg>Comprueba si la expresión se ha evaluado mientras se ejecuta directamente en el interior del n-ésimo grupo de captura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the transliteration table is built at compile time, neither
the SEARCHLIST nor the REPLACEMENTLIST are subjected to double quote
interpolation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que la tabla de transliteración se construye en tiempo de compilación, ni la LISTA_BÚSQUEDA ni la LISTA_REEMPLAZO están sujetas a la interpolación del doble entrecomillado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect of C&lt;shift&gt; is considered highly experimental.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T181204Z" changeid="explorer">
        <seg>Este aspecto de C&lt;shift&gt; es considerado altamente experimental.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optimisation has been re-instated, and
the performance regression fixed.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153350Z" changeid="explorer">
        <seg>La optimización ha sido reinstalado, y arreglada la regresión de rendimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($Config{uselongdouble} eq &quot;define&quot;) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($Config{uselongdouble} eq &quot;define&quot;) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is a syntax error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es un error de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$nothing = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$nada = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>STDERR-&gt;autoflush(1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>STDERR-&gt;autoflush(1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's all!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¡Eso es todo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># if you run this in a job, do &quot;make test_notty&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># si ejecuta esto en un trabajo, haga &quot;make test_notty&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There, you use C&lt;srand($seed)&gt;, with the same C&lt;$seed&gt;
each time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183113Z" changeid="explorer">
        <seg>Allí, puede utilizar C&lt;srand($semilla)&gt;, con la misma C&lt;$semilla&gt; cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=secret stuff</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=material secreto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary &quot;&amp;&amp;&quot; performs a short-circuit logical AND operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Binario &quot;&amp;&amp;&quot; realiza una operación lógica AND abreviada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That number
gives the character's position in the character set encoding (indexed from 0).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T211202Z" changeid="explorer">
        <seg>Este número da la posición del carácter dentro de la codificación del conjunto de caracteres (comenzando en 0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because once upon a time, the argument to push() had to be be a
real array, not just a reference to one.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030659Z" changeid="explorer">
        <seg>Porque hubo un tiempo, en que el argumento de push() tenía que ser un array real, no sólo una referencia a un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://helpconsulting.net/visiperl/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225451Z" changeid="explorer">
        <seg>http://helpconsulting.net/visiperl/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use v5.6.1;     # compile time version check</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use v5.6.1;     # comprobación en tiempo de compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;cannot open &lt; input.txt: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T001002Z" changeid="explorer">
        <seg>or die &quot;cannot open &lt; input.txt: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\N{name}     [3]    named Unicode character or character sequence</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T185644Z" changeid="explorer">
        <seg>\N{nombre}	[3]	nombre car. o secuencia car. Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sets mode to
                                             # --w----r-T</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T043648Z" changeid="explorer">
        <seg>pone el modo a
                                             # --w----r-T</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, any file
containing a zero byte in the first block is considered a binary file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También, cualquier archivo conteniendo bytes cero en el primer bloque es considerado como un archivo binario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.irix - Perl version 5 on Irix systems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.irix - Perl version 5 on Irix systems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Originally, a script was a canned sequence of normally interactive
commands--that is, a chat script.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231711Z" changeid="explorer">
        <seg>Originalmente, un script era una secuencia cerrada de comandos normalmente interactivos (es decir, un script de chat).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl qw(:flock SEEK_END); # import LOCK_* and SEEK_END constants</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl qw(:flock SEEK_END); # importa constantes LOCK_* y SEEK_END</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the last element of LIST does not end in a newline, the current
script line number and input line number (if any) are also printed,
and a newline is supplied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el último elemento de LISTA no acaba en el carácter de nueva línea, se imprimen también el valor actual del número de línea y el actual número de línea de entrada (si existe), junto con un carácter de nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># this would print with a linebreak in the middle</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T230747Z" changeid="zipf">
        <seg># esto imprimirá un salto de línea en la mitad de la frase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no current package
(due to an empty C&lt;package;&gt; directive), __PACKAGE__ is the undefined
value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay paquete actual (debido a una directiva C&lt;package;&gt; vacía), __PACKAGE__ tiene el valor indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($foo, 21,  4) = 7;      # 'PerlPerlPer'
                                   # 'r' is &quot;\x72&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T052414Z" changeid="explorer">
        <seg>vec($foo, 21,  4) = 7;      # 'PerlPerlPer'
                                   # 'r' es &quot;\x72&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All operations above are performed simultaneously, left to right.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todas las operaciones anteriores se realizan simultáneamente, de izquierda a derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Win32.pm/Win32.xs has moved from the libwin32 module to core Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T104839Z" changeid="explorer">
        <seg>Win32.pm/Win32.xs se han trasladado desde el módulo libwin32 al núcleo de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accepts an incoming socket connect, just as accept(2) 
does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Acepta una conexión socket entrante, como lo hace la llamada del sistema accept(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $_;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225543Z" changeid="explorer">
        <seg>return $_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; alphanumeric&quot;), redo LOOP if /\G[\p{Alpha}\pN]+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030133Z" changeid="explorer">
        <seg>print(&quot; alfanumérico&quot;), redo LOOP if /\G[\p{Alpha}\pN]+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Other mathematical operators</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234032Z" changeid="explorer">
        <seg>=item Otros operadores matemáticos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$r = do {my @a; \$#a};</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T050807Z" changeid="explorer">
        <seg>$r = do {my @a; \$#a};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use integer;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use integer;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to make it more robust
it is recommended to start every program with the following lines:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224702Z" changeid="explorer">
        <seg>Sin embargo, para trabajar de manera más segura se recomienda iniciar cada programa con las líneas siguientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After reading this document, you ought to read L&lt;perlunifaq&gt; too.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235427Z" changeid="explorer">
        <seg>Después de leer este documento, debe leer L&lt;perlunifaq&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{3}                 matches exactly 3 of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230607Z" changeid="zipf">
        <seg>{3}                 detecta exactamente 3 coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlopentut&gt; for a kinder, gentler explanation of opening files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlopentut&gt; para una más amable, más suave explicación de apertura de los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Okay, that's I&lt;definitely&gt; enough hype.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001447Z" changeid="explorer">
        <seg>Entre otras...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perllol - Manipulating Arrays of Arrays in Perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perllol - Manipulación de array de array en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -MDateTime -le'print DateTime-&gt;today-&gt;doy'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>$ perl -MDateTime -le'print DateTime-&gt;today-&gt;doy'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read
more about pod in pod/perlpod.pod or the short summary in the
INSTALL file.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T215114Z" changeid="explorer">
        <seg>Puede leer más acerca pod/perlpod.pod o el resumen en el fichero INSTALL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;delete local EXPR&gt; construct localizes the deletion to the current
block at run time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La construcción C&lt;delete local EXPR&gt; localiza la eliminación al actual bloque en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$symlink_exists = eval { symlink(&quot;&quot;,&quot;&quot;); 1 };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$symlink_existe = eval { symlink(&quot;&quot;,&quot;&quot;); 1 };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No variable interpolation occurs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se produce interpolación de variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a real struct tm (on my system anyway)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># una auténtica struct tm (en mi sistema)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the two-argument (and one-argument) form, opening C&lt;&lt; &lt;- &gt;&gt; 
or C&lt;-&gt; opens STDIN and opening C&lt;&lt; &gt;- &gt;&gt; opens STDOUT.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T003125Z" changeid="explorer">
        <seg>En la forma de dos argumentos (y de un argumento), abriendo C&lt;&lt; &lt;- &gt;&gt; o C&lt;-&gt; abre STDIN, y abriendo C&lt;&lt; &gt;- &gt;&gt; abre STDOUT.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting C&lt;pos&gt; also resets the I&lt;matched with zero-length&gt; flag, described
under L&lt;perlre/&quot;Repeated Patterns Matching a Zero-length Substring&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T180344Z" changeid="explorer">
        <seg>Actualizando C&lt;pos&gt; también reinicializa la bandera I&lt;coincide con longitud cero&gt;, descrita en L&lt;perlre/&quot;Coincidiendo con patrones repetidos en una cadena de longitud cero&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;resolve&gt; function is called to generate a linearised ISA for the
given stash, using this MRO.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114319Z" changeid="explorer">
        <seg>La función C&lt;resolve&gt; es llamada para generar un ISA en línea para el esquema indicado, utilizando este MRO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So when
you use this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110819T095403Z" changeid="zipf">
        <seg>Así, cuando se ejecuta la siguiente instrucción:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns a list value consisting of the elements
of LIST in the opposite order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto de lista, devuelve una lista de valores consistente en los elementos de LISTA en el orden opuesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>down from the door where it began.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>detrás de la puerta que lo comenzó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If I&lt;sequence-item&gt; refers to a string type (C&lt;&quot;A&quot;&gt;, C&lt;&quot;a&quot;&gt;, or C&lt;&quot;Z&quot;&gt;),
the I&lt;length-item&gt; is the string length, not the number of strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si I&lt;secuencia-item&gt; se refiere a un tipo de cadena de caracteres (C&lt;&quot;A&quot;&gt;, C&lt;&quot;a&quot;&gt;, o C&lt;&quot;Z&quot;&gt;), la I&lt;longitud-item&gt; es la longitud de la cadena, no el número de cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are more Unicode encodings, but much of
the world has standardized on UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T234435Z" changeid="explorer">
        <seg>Hay otras codificaciones de Unicode, pero UTF-8 se está convirtiendo en la codificación estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here
are commonly expected conventions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Están son las convenciones más usadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl comes with a wide selection of builtin functions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110131T002819Z" changeid="zipf">
        <seg>Perl incluye una amplia selección de funciones y operadores integrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
0.9 cannot be represented by a native float, since the binary fraction
for 0.9 is infinite:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232508Z" changeid="explorer">
        <seg>Por ejemplo, 0.9 no se puede representar como un número de punto flotante nativo porque la fracción binaria correspondiente a 0.9 es infinita:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out the old STDERR:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intercambiar el STDOUT y STDERR de un comando para capturar el STDERR pero dejando que su STDOUT salga por el anterior STDERR:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$is_setuid     =  $mode &amp; S_ISUID;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$es_setuid     =  $modo &amp; S_ISUID;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval $search;        # this screams</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval $buscar;        # esto aúlla</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matches the best match for C&lt;S&gt; and only that.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T235916Z" changeid="explorer">
        <seg>Coincide con la mejor coincidencia de C&lt;S&gt; y sólo esa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;/l&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T165922Z" changeid="explorer">
        <seg>X&lt;/l&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endservent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endservent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the new binary is executed it will begin by executing
a C&lt;goto LABEL&gt; (with all the restrictions that C&lt;goto&gt; suffers).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando el nuevo binario es ejecutado, comenzará ejecutando un C&lt;goto ETIQUETA&gt; (con todas las restricciones que C&lt;goto&gt; padece).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and              []    character class  .  == [^\n]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224301Z" changeid="explorer">
        <seg>and              []    clase caracteres         .  == [^\n]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $i++ while $i &lt;= 10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $i++ while $i &lt;= 10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220653Z" changeid="explorer">
        <seg>Vea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>d_fchdir='define'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T134628Z" changeid="explorer">
        <seg>d_fchdir='define'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Algorithm::Permute;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225558Z" changeid="explorer">
        <seg>use Algorithm::Permute;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If NUMBER is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite NÚMERO, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Licensing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030943Z" changeid="explorer">
        <seg>=head2 Licencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can open a file for input or output using the C&lt;open()&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T182736Z" changeid="zipf">
        <seg>La función C&lt;open()&gt; abre un archivo para entrada o salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;DB_File&gt; upgraded to version 1.814</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030103Z" changeid="explorer">
        <seg>C&lt;DB_File&gt; actualizado a la versión 1.814</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item List::Util</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item List::Util</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/Version: *([0-9.]*)/) { $version = $1; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/Version: *([0-9.]*)/) { $version = $1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;aaaaab&quot; =~ /</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050227Z" changeid="explorer">
        <seg>&quot;aaaaab&quot; =~ /</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\Z  Match only at end of string, or before newline at the end</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T225745Z" changeid="explorer">
        <seg>\Z  Coincide solo con el final de la cadena, o antes de un nueva línea al final</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cc: &quot;/usr/include/sys/socket.h&quot;, line 504: warning 562:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003720Z" changeid="explorer">
        <seg>cc: &quot;/usr/include/sys/socket.h&quot;, line 504: warning 562:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exit</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exit 0 if $ans =~ /^[Xx]/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exit 0 if $ans =~ /^[Xx]/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or, more directly,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o, más directamente,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most systems do not bother to return anything useful in $timeleft, so
calling select() in scalar context just returns $nfound.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de los sistemas no se molestan en devolver nada útil en $tiempo_restante, así que llamando select() en contexto escalar sólo devuelve $n_encontrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New encoding C&lt;MIME-Header-ISO_2022_JP&gt; added</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T030913Z" changeid="explorer">
        <seg>Añadida nueva codificación C&lt;MIME-Header-ISO_2022_JP&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the core documentation intended for end users lives in
F&lt;pod/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014739Z" changeid="explorer">
        <seg>Toda la documentación principal para usuarios finales se encuentra en F&lt;pod/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpreter internals now support a far more memory efficient form of
inlineable constants.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T033234Z" changeid="explorer">
        <seg>Las funciones incorporadas del intérprete ahora soportan un formato de memoria mucho más eficiente de las constantes que se pueden insertar en la traza del código (I&lt;inline&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use C&lt;BE&lt;lt&gt;E&lt;gt&gt;&gt; for commands names like B&lt;cat&gt; or B&lt;grep&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use C&lt;BE&lt;lt&gt;E&lt;gt&gt;&gt; para nombres de comandos como B&lt;cat&gt; o B&lt;grep&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;Permissions are %04o\n&quot;, $mode &amp; 07777;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Permisos son %04o\n&quot;, $modo &amp; 07777;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a useful
optimization when you want to see only the first occurrence of
something in each file of a set of files, for instance.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es una optimización útil cuando se desea ver sólo la primera aparición de algo en cada archivo de un conjunto de archivos, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They include variables,
quote and quote-like operators, any expression in parentheses,
and any function whose arguments are parenthesized.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto incluye a las variables, comillas y operadores de comillas, cualquier expresión entre paréntesis, y cualquier función cuyos argumentos estén entre paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;do&gt; cannot read the file, it returns undef
and sets C&lt;$!&gt; to the error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T154857Z" changeid="explorer">
        <seg>Si C&lt;do&gt; no puede leer el archivo, devuelve undef y pone C&lt;$!&gt; al valor del error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of using the current Perl internals, Ponie aimed to create a
new one that would provide a translation path from Perl 5 to Perl 6
(or anything else that targets Parrot, actually).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230006Z" changeid="explorer">
        <seg>La idea de Ponie era renovar los componentes internos de Perl para traducir código Perl 5 a Perl 6 (o a cualquier otro lenguaje compatible con Parrot).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final sequence number
in a range has the string &quot;E0&quot; appended to it, which doesn't affect
its numeric value, but gives you something to search for if you want
to exclude the endpoint.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número de secuencia final en un rango tiene la cadena &quot;E0&quot; añadida, que no afecta a su valor numérico, pero le da algo para poder buscar si desea excluir el punto final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default { $nothing = 1; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>default { $nada = 1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getlogin
X&lt;getlogin&gt; X&lt;login&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173510Z" changeid="explorer">
        <seg>=item getlogin
X&lt;getlogin&gt; X&lt;login&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when( /^-?\d+\z/ )</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225621Z" changeid="explorer">
        <seg>when( /^-?\d+\z/ )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $SIG{'__DIE__'} =
              sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T044145Z" changeid="explorer">
        <seg>local $SIG{'__DIE__'} =
              sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These files contain information on who maintains which modules.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014822Z" changeid="explorer">
        <seg>En estos archivos se indica quién mantiene cada módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for propagating exceptions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para propagar excepciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolated scalars and arrays are converted internally to the C&lt;join&gt; and
C&lt;.&gt; catenation operations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Escalares interpolados y arrays son convertidos internamente a las operaciones de concatenación C&lt;join&gt; y C&lt;.&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the number is 256 (0x100, 0400) or above, Perl interprets
it as a Unicode code point and the result is the corresponding Unicode
character.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232413Z" changeid="explorer">
        <seg>Si el número es 256 (0x100, 0400) o superior, Perl lo interpreta como un punto de código Unicode y el resultado es el correspondiente carácter Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SCALAR will be grown or shrunk to the length actually read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESCALAR crecerá o se reducirá a la longitud de la lectura actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although strings and numbers
are considered pretty much the same thing for nearly all purposes,
references are strongly-typed, uncastable pointers with builtin
reference-counting and destructor invocation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque las cadenas y los números son consideradas prácticamente la misma cosa para la mayoría de los propósitos, las referencias son punteros no convertibles y fuertemente tipificados, que llevan un contador de referencias incorporado y una invocación al destructor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@array = split(/:/);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@array = split(/:/);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IFREG S_IFDIR S_IFLNK S_IFBLK S_IFCHR S_IFIFO S_IFSOCK S_IFWHT S_ENFMT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_IFREG S_IFDIR S_IFLNK S_IFBLK S_IFCHR S_IFIFO S_IFSOCK S_IFWHT S_ENFMT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the input string is longer than one described by the TEMPLATE,
the remainder of that input string is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la cadena de entrada es superior a lo descrito por la PLANTILLA, el resto de la cadena de entrada se ignora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $foo = 10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $foo = 10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;open&gt; upgraded to version 1.05</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T033952Z" changeid="explorer">
        <seg>C&lt;open&gt; actualizado a la versión 1.05</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are
responsible to make sure a string is pre-extended long enough to
receive any result that might be written into a string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es responsable de asegurarse de que una cadena sea pre-extendida el largo suficiente como para recibir cualquier resultado que pueda ser escrito en una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($who, $home)  = @ENV{&quot;USER&quot;, &quot;HOME&quot;};      # hash slice</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($quien, $home) = @ENV{&quot;USER&quot;, &quot;HOME&quot;};      # porción hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the Camel Book for why.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T002244Z" changeid="explorer">
        <seg>Consulte el &quot;Libro del Camello&quot; (en concreto, camello arábigo, o dromedario) para averiguar por qué.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;homer&quot;, &quot;marge&quot;, &quot;bart&quot; ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;homer&quot;, &quot;marge&quot;, &quot;bart&quot; ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;identifier, case sensitivity&gt;
X&lt;case&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;identifier, case sensitivity&gt; X&lt;case&gt; X&lt;identificador, sensible al tamaño de caja&gt; X&lt;tamaño de caja&gt; X&lt;mayúsculas y minúsculas&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now works better with directories where access rights are more
restrictive than usual.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T032242Z" changeid="explorer">
        <seg>Ahora funciona mejor con los directorios donde los derechos de acceso sean más restrictivos de lo habitual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a really hairy regular expression, use the C&lt;/x&gt; modifier and
put in some whitespace to make it look a little less like line noise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si tiene una expresión regular especialmente complicada, use el modificador C&lt;/x&gt; y ponga algunos espacios en blanco para que no parezca una línea telefónica con ruido de fondo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $file, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $archivo, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to position the file for C&lt;sysread&gt; or C&lt;syswrite&gt;, don't use
C&lt;seek&gt;, because buffering makes its effect on the file's read-write position
unpredictable and non-portable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110307T000442Z" changeid="explorer">
        <seg>Si desea posicionar el archivo para las funciones C&lt;sysread&gt; o C&lt;syswrite&gt;, no utilice C&lt;seek&gt;, porque hace impredecible y no portátil la posición de lectura/escritura del archivo a causa del efecto del búfer del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last if $i &gt; 20;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>last if $i &gt; 20;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl
bug database at http://rt.perl.org/rt3/ .  There may also be
information at http://www.perl.org/ , the Perl Home Page.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111008T005841Z" changeid="explorer">
        <seg>Si encuentra algo que piensa que es un error, podría verificar los artículos publicados recientemente en el grupo de noticias comp.lang.perl.misc y la base de datos de errores de perl en http://rt.perl.org/rt3/ . Hay también información en la página principal de Perl, http://www.perl.org/ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>means to use Unicode rules when pattern matching.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T165951Z" changeid="explorer">
        <seg>significa que use las reglas Unicode en la coincidencia de patrones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic linker flags have been tweaked for Solaris and OS X, which should
solve problems seen while building some XS modules.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las banderas del enlazador dinámico han sido modificados para Solaris y OS X, lo que debería solucionar los mismos problemas que aparecen en la construcción de algunos módulos XS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Haven't
checked this myself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No lo he comprobado por mí mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
used to raise a syntax error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035533Z" changeid="explorer">
        <seg>Esto se usaba para lanzar un error de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Warning: syntactical care is required when sorting the list returned from
a function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Advertencia: es requerido un cuidado sintáctico cuando se ordena la lista devuelta desde una función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>meta = HvMROMETA(stash);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T115223Z" changeid="explorer">
        <seg>meta = HvMROMETA(esquema);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl operators are documented in full in L&lt;perlop&gt;, but here are a few
of the most common ones:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225222Z" changeid="explorer">
        <seg>Encontrará información detallada sobre los operadores de Perl en L&lt;perlop&gt;; algunos de los más comunes son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hash represents a set of key/value pairs:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110129T234302Z" changeid="zipf">
        <seg>Un hash representa un conjunto de pares clave-valor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\cz      chr(26)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034632Z" changeid="explorer">
        <seg>\cz      chr(26)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Still far from perfect, but
maybe worth a try.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T031016Z" changeid="explorer">
        <seg>Todavía lejos de ser perfecto, pero quizás vale la pena intentarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$foo = pack(&quot;W4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$foo = pack(&quot;W4&quot;,0x24b6,0x24b7,0x24b8,0x24b9);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is mainly useful for constructing
bitmaps for C&lt;select&gt; and low-level POSIX tty-handling operations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es principalmente útil para construir bitmaps para C&lt;select&gt; y operaciones POSIX de bajo nivel sobre tty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Along with the Perl interpreter itself, the Perl distribution installs a
range of utilities on your system.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233213Z" changeid="explorer">
        <seg>Además del intérprete de Perl, la distribución de Perl incluye varias utilidades que se instalan en el sistema;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For much more detailed
information, please see the documentation for C&lt;stat&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información más detallada, por favor consulte la documentación de C&lt;stat&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;&lt;EOF                 here-doc            yes*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;&lt;EOF               doc-empotrado	  sí*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last LINE if /^$/;	# exit when done with header</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last LINEA if /^$/;	# salir cuando se termine la cabecera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may charge a reasonable copying fee for any distribution of this
Package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usted puede cobrar una cuota razonable por las copias por cualquier distribución de este Paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (my $i=0; $i&lt;20; $i++) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225615Z" changeid="explorer">
        <seg>for (my $i=0; $i&lt;20; $i++) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is done as a second pass, after variables are
interpolated, so that regular expressions may be incorporated into the
pattern from the variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se hace como un segundo paso, después de que las variables son interpoladas, así las expresiones regulares pueden ser incorporadas en patrones desde las variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlrun&gt; for
details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215001Z" changeid="explorer">
        <seg>Vea L&lt;perlrun&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This strangeness is
due to the underlying system calls' definitions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comportamiento tan extraño es debido a las definiciones subyacentes de las llamadas del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with 5.8.3 we intend to make more frequent maintenance releases,
with a smaller number of changes in each.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de 5.8.3 tenemos la intención de hacer el mantenimiento más frecuente, con un menor número de cambios en cada uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And C&lt;$^N&gt; contains whatever was matched by
the most-recently closed group (submatch).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y C&lt;$^N&gt; contiene aquello que coincidía con el más reciente grupo de captura (sub coincidencia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;4: got $1\n&quot; if $y =~ /^(\D*)(?!123)/;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T170252Z" changeid="explorer">
        <seg>print &quot;4: tenemos $1\n&quot; if $y =~ /^(\D*)(?!123)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, for
example, C&lt;(?-p)&gt; will warn when compiled under C&lt;use warnings&gt;;
C&lt;(?-d:...)&gt; and C&lt;(?dl:...)&gt; are fatal errors.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T194023Z" changeid="explorer">
        <seg>Así, por ejemplo, C&lt;(?-p)&gt; sacará una advertencia cuando sea compilada bajo C&lt;use warnings&gt;; C&lt;(?-d:...)&gt; y C&lt;(?dl:...)&gt; son errores fatales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resetting C&lt;&quot;A-Z&quot;&gt; is not recommended because you'll wipe out your
C&lt;@ARGV&gt; and C&lt;@INC&gt; arrays and your C&lt;%ENV&gt; hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El restablecimiento de C&lt;&quot;A-Z&quot;&gt; no es recomendable porque limpiará sus arrays C&lt;@ARGV&gt; y C&lt;@INC&gt; y su hash C&lt;%ENV&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step is performed over the finite
automaton that was generated during the previous pass.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este paso se realiza en el autómata finito que se generó durante la pasada anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;/x&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;/x&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most
handlers must therefore arrange to actually display the
warnings that they are not prepared to deal with, by calling C&lt;warn&gt;
again in the handler.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayoría de los controladores, por lo tanto, deben hacer los arreglos necesarios para mostrar las advertencias de las que no están preparados para hacer frente, llamando a C&lt;warn&gt; de nuevo en el controlador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;/r&gt; (non-destructive) option is used then it runs the
substitution on a copy of the string and instead of returning the
number of substitutions, it returns the copy whether or not a
substitution occurred.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030821Z" changeid="explorer">
        <seg>Si la opción C&lt;/r&gt; (no destructiva) es utilizada, entonces llevará a cabo la sustitución en una copia de la cadena y en lugar de devolver el número de sustituciones, devuelve la copia, haya o no ocurrido una sustitución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO, &quot;&lt; $file\0&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235413Z" changeid="explorer">
        <seg>open(FOO, &quot;&lt; $archivo\0&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@animals[0,1];                  # gives (&quot;camel&quot;, &quot;llama&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T213952Z" changeid="explorer">
        <seg>@animales[0,1];            # devuelve (&quot;camello&quot;, &quot;llama&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first character of the name tells you to what sort of data
structure it refers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer carácter del nombre nos dice a qué tipo de estructura de datos se está accediendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider... oh, never mind.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere... ¡oh!, olvídelo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getpwent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>implement IV/UV/NV/long double un/packing with j/J/F/D</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>implementar des/empaquetado de IV/UV/NV/long double con j/J/F/D</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, the default installation no longer breaks the
Apple-provided Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T183405Z" changeid="explorer">
        <seg>En otras palabras, la instalación por defecto ya no rompe el Perl proporcionado por Apple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @animals = (&quot;camel&quot;, &quot;llama&quot;, &quot;owl&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T185348Z" changeid="zipf">
        <seg>my @animales = (&quot;camello&quot;, &quot;llama&quot;, &quot;búho&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item keys ARRAY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item keys ARRAY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One bit.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231332Z" changeid="explorer">
        <seg>Un bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item socket SOCKET,DOMAIN,TYPE,PROTOCOL
X&lt;socket&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200811Z" changeid="explorer">
        <seg>=item socket SOCKET,DOMINIO,TIPO,PROTOCOLO
X&lt;socket&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 KNOWN PROBLEMS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 PROBLEMAS CONOCIDOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the C&lt;open&gt; pragma is no longer ignored for three-argument
opens.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045827Z" changeid="explorer">
        <seg>El valor del pragma C&lt;open&gt; ya no es ignorado por el open de tres argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlnetware 	Perl notes for NetWare</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlnetware 	Notas para NetWare</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example of backtracking:  Let's say you want to find the
word following &quot;foo&quot; in the string &quot;Food is on the foo table.&quot;:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T151527Z" changeid="explorer">
        <seg>Aquí hay un ejemplo de vuelta atrás: Digamos que quiere encontrar la palabra siguiente a &quot;come&quot; en la cadena &quot;En el Comedor Principal el niño come espinacas.&quot;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item x
X&lt;/x&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110213T222812Z" changeid="explorer">
        <seg>=item x
X&lt;/x&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl actually stands for Pathologically Eclectic Rubbish Lister, but
don't tell anyone I said that.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001839Z" changeid="explorer">
        <seg>En realidad Perl significa Pathologically Eclectic Rubbish Lister (Presentador de basura patológicamente ecléctico), pero nadie debe enterarse de esto :-).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = &quot;0644&quot;; chmod $mode, &quot;foo&quot;;      # !!!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = &quot;0644&quot;; chmod $modo, &quot;foo&quot;;      # !!!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as we know that if the final quote does not match, backtracking will not
help.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ya que sabemos que si la doble comilla final no coincide, no ayudará el dar marcha atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># prints xdogcatCainAbel</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># prints xdogcatCainAbel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will print out:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032354Z" changeid="explorer">
        <seg>imprimirá:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S_IREAD S_IWRITE S_IEXEC</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S_IREAD S_IWRITE S_IEXEC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the null filehandle uses the two argument form of L&lt;perlfunc/open&gt;
it interprets special characters, so if you have a script like this:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T014300Z" changeid="explorer">
        <seg>Dado que el identificador de archivo nulo utiliza el formato de dos argumentos de L&lt;perlfunc/open&gt;, interpreta los caracteres especiales, así que si tiene un script como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close ARGV if eof;             # reset $.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034207Z" changeid="explorer">
        <seg>close ARGV if eof;     # reinicia $.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information see L&lt;perlipc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información ver L&lt;perlipc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq8		System Interaction</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfaq8		Interacción con el sistema</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item qw/STRING/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item qw/STRING/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns C&lt;undef&gt; on error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013700Z" changeid="explorer">
        <seg>Devuelve C&lt;undef&gt; en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;User: &quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Usuario: &quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Document purpose, scope and target applications</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013909Z" changeid="explorer">
        <seg>Documente el propósito, ámbito y las aplicaciones objetivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = grep(!/^#/, @bar);    # weed out comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = grep(!/^#/, @bar);    # quitar los comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no match has
previously succeeded, this will (silently) act instead as a genuine
empty pattern (which will always match).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hubo una coincidencia exitosa, actuará (silenciosamente) como un verdadero patrón vacío (que siempre coincidirá con cualquier cadena).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>d   Use Unicode or native charset, as in 5.12 and earlier</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T225540Z" changeid="explorer">
        <seg>d	Usa conjunto de caracteres Unicode o nativo, como en 5.12 y anteriores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item C&lt;(?!pattern)&gt;
X&lt;(?!)&gt; X&lt;look-ahead, negative&gt; X&lt;lookahead, negative&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110327T210016Z" changeid="explorer">
        <seg>=item C&lt;(?!patrón)&gt;
X&lt;(?!)&gt; X&lt;consiguiente, negativo&gt; X&lt;consiguiente, negativo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{
          local $@; # protect existing $@
          eval { test_repugnancy() };
          # $@ =~ /nefarious/ and die $@; # Perl 5.14 and higher only
          $@ =~ /nefarious/ and $e = $@;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T161015Z" changeid="explorer">
        <seg>{
          local $@; # protege el actual $@
          eval { test_repugnancia() };
          # $@ =~ /infame/ and die $@; # solo en Perl 5.14 y superiores
          $@ =~ /infame/ and $e = $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same
PLAINTEXT and SALT will always return the same string, but there is no
(known) way to get the original PLAINTEXT from the hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los mismos TEXTOPLANO y SALTO siempre devolverán el mismo string, pero no hay una forma (conocida) de obtener el TEXTOPLANO original desde el hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the C-style operators that would have been written like this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con los operadores del estilo del C esto se hubiera escrito así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that GCC-2.95.x rev(DG/UX) knows the switch
-pthread which allows it to link correctly DG/UX's
-lthread library.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga en cuenta que GCC-2.95.x revisión DG/UX sabe de la opción -pthread, que le permite vincular correctamente la biblioteca -lthread de DG/UX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any exist,
they are bugs and reports are welcome.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001519Z" changeid="explorer">
        <seg>Si los hay, los errores e informes serán bienvenidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Sys::Syslog</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T014842Z" changeid="explorer">
        <seg>=item Sys::Syslog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my @array = qw( a b c );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225555Z" changeid="explorer">
        <seg>my @array = qw( a b c );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here it's more effective
to use minimal matching to make sure you get the text between a &quot;foo&quot;
and the first &quot;bar&quot; thereafter.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T155316Z" changeid="explorer">
        <seg>Aquí es más eficaz utilizar una coincidencia mínima para asegurarse de que obtiene el texto entre un &quot;mesa&quot; y el primer &quot;come&quot; después de él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treats the return value of the code block as the condition.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002931Z" changeid="explorer">
        <seg>Trata el valor de retorno del bloque de código como la condición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar values can be strings, integers or floating point numbers, and Perl
will automatically convert between them as required.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224818Z" changeid="explorer">
        <seg>Los valores escalares pueden ser cadenas, enteros o números de punto flotante, y Perl los convertirá de un tipo a otro cuando sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exceptions include C&lt;&quot;#&quot;&gt; inside a string or regular
expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Excepciones a esto son la inclusión de C&lt;&quot;#&quot;&gt; dentro de una cadena o una expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;% d&gt;',  12;   # prints &quot;&lt; 12&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;% d&gt;',  12;   # imprime &quot;&lt; 12&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+ - .                   for    (LIST) { }, for (a;b;c) { }</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224212Z" changeid="explorer">
        <seg>+ - .                   for    (LISTA) { }, for (a;b;c) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 1, 2) = 1   ==          4 00100000000000000000000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 1, 2) = 1   ==          4 00100000000000000000000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documented that C&lt;when()&gt; treats specially most of the filetest operators</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T152754Z" changeid="explorer">
        <seg>Documentado que C&lt;when()&gt; trata de forma especial a la mayoría de los operadores de prueba de fichero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns from a subroutine, C&lt;eval&gt;, or C&lt;do FILE&gt; with the value
given in EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Regresa de una subrutina, C&lt;eval&gt; o C&lt;do ARCHIVO&gt;, con el valor indicado en EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item closedir DIRHANDLE
X&lt;closedir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020209Z" changeid="explorer">
        <seg>=item closedir IDENTIFICADOR_DIR
X&lt;closedir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator makes that kind
of operation work on some other string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este operador hace que este tipo de operación trabaje en alguna otra cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\PP       [3]  Match non-P</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110302T223802Z" changeid="explorer">
        <seg>\PP	 [3]  Coincide con una no-P</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certain operations
search or modify the string $_ by default.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ciertas operaciones buscan o modifican la cadena $_ por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Using character classes</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113353Z" changeid="explorer">
        <seg>=head2 Usando clases carácter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is more than one argument in LIST, or if LIST is an array
with more than one value, calls execvp(3) with the arguments in LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay más de un argumento en LISTA, o si LISTA es un array con más de un valor, se llama a execvp(3) con los argumentos de LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;setlogsock()&gt; will now C&lt;croak()&gt; as documented.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T035251Z" changeid="explorer">
        <seg>C&lt;setlogsock()&gt; ahora hará C&lt;croak()&gt; tal como está documentado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Permissions: read, write, execute, for user, group, others.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Permisos: leer, escribir, ejecutar, por usuario, grupo, otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Juerd Waalboer &lt;#####@juerd.nl&gt;, with the help of many Perl Monks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Juerd Waalboer &lt;#####@juerd.nl&gt;, con la ayuda de muchos Perl Monks.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$line = readline(*STDIN);    # same thing</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$linea = readline(*STDIN);    # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/etc/games is no good, stopped at canasta line 123.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/etc/games no está bien, parado at canasta line 123.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;/u&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T173821Z" changeid="explorer">
        <seg>X&lt;/u&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll assume that there's a flat file in which
each line is a row and each word an element.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vamos a suponer que hay un archivo de texto plano en el que cada línea es una fila y cada palabra un elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may snoop on pending developments via the archives at
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/
and http://archive.develooper.com/perl5-porters@perl.org/
or the news gateway nntp://nntp.perl.org/perl.perl5.porters or
its web interface at http://nntp.perl.org/group/perl.perl5.porters ,
or read the faq at http://dev.perl.org/perl5/docs/p5p-faq.html ,
or you can subscribe to the mailing list by sending
perl5-porters-subscribe@perl.org a subscription request
(an empty message with no subject is fine).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T200405Z" changeid="explorer">
        <seg>Si desea curiosear los desarrollos pendientes, puede consultar el archivo mensajes de la lista de correo en 
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/ y http://archive.develooper.com/perl5-porters@perl.org/, o el grupo de noticias nntp://nntp.perl.org/perl.perl5.porters (también está disponible a través de una interfaz web en http://nntp.perl.org/group/perl.perl5.porters), o bien leer las preguntas más frecuentes en http://dev.perl.org/perl5/docs/p5p-faq.html. También puede suscribirse a la lista de correo enviando una solicitud de suscripción a 
perl5-porters-subscribe@perl.org (solo tiene que enviar un mensaje vacío sin asunto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting string is the concatenation of
the converted values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La cadena resultante es la concatenación de los valores convertidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi*/i;         # Doesn't match!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T162320Z" changeid="explorer">
        <seg>&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi*/i;         # ¡No coincide!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flags (except
C&lt;&quot;d&quot;&gt;) may follow the caret to override it.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T193426Z" changeid="explorer">
        <seg>Las banderas (excepto C&lt;&quot;d&quot;&gt;) pueden seguir al acento circunflejo para anular el efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this description is too low-level and makes you think
in terms of a particular implementation.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T234052Z" changeid="explorer">
        <seg>Sin embargo, esta descripción es de demasiado bajo nivel y te hace pensar en términos de una particular implementación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@fhlist) {
            vec($bits,fileno($_),1) = 1;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051332Z" changeid="explorer">
        <seg>for (@fhlist) {
            vec($bits,fileno($_),1) = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a filter has been installed with this method, it will be invoked
every time you write a key to a DBM database.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110812T144652Z" changeid="zipf">
        <seg>Si se ha instalado un filtro con este método, se invocará cada vez que se escriba una clave en una base de datos DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new file, F&lt;mathoms.c&gt;, has been added.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T041053Z" changeid="explorer">
        <seg>Un nuevo archivo, F&lt;mathoms.c&gt;, ha sido añadido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stat      localtime    caller         SPECIAL VARIABLES</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T224334Z" changeid="explorer">
        <seg>stat      localtime    caller            VARIABLES ESPECIALES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, inside C&lt;(?{BLOCK})&gt;, C&lt;(?# comment )&gt;, and
a C&lt;#&gt;-comment in a C&lt;//x&gt;-regular expression, no processing is
performed whatsoever.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por otra parte, dentro de C&lt;(?{BLOQUE})&gt;, C&lt;(?# comentario )&gt;, y un C&lt;#&gt;-comentario en una C&lt;//x&gt;-expresión regular, no se realiza ningún tipo de procesamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return code from the filter is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110819T095628Z" changeid="zipf">
        <seg>Se omite el código de retorno del filtro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a*&quot;, $type, $message)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>a*&quot;, $tipo, $mensaje)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The status is returned in C&lt;$?&gt;
and C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El estado se devuelve en C&lt;$?&gt; y C&lt;${^CHILD_ERROR_NATIVE}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;/d&gt;, C&lt;/u&gt;, C&lt;/a&gt;, and C&lt;/l&gt;, available starting in 5.14, are called
the character set modifiers; they affect the character set semantics
used for the regular expression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163646Z" changeid="explorer">
        <seg>C&lt;/d&gt;, C&lt;/u&gt;, C&lt;/a&gt;, y C&lt;/l&gt;, disponibles a partir de 5.14, son llamados modificadores del conjunto de caracteres; afectan a la semántica del conjunto de caracteres utilizado por la expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;useperlio&gt; is C&lt;define&gt;, you
have PerlIO; otherwise you don't.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T005252Z" changeid="explorer">
        <seg>Si C&lt;useperlio&gt; está C&lt;definido&gt;, tiene PerlIO activado; de lo contrario, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;\x{...}&gt; can't have spaces because hexadecimal
numbers don't have spaces in them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;\x{...}&gt; no puede tener espacios porque los números hexadecimales no contienen espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Care should be taken when using the C&lt;no VERSION&gt; form of C&lt;no&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T210647Z" changeid="explorer">
        <seg>Se debe tener cuidado cuando se usa la forma C&lt;no VERSIÓN&gt; de C&lt;no&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add perlpodspec</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadido perlpodspec</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: When called in list context, $isdst, the last value
returned by gmtime, is always C&lt;0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T164723Z" changeid="explorer">
        <seg>Nota: cuando se le llama en contexto lista, $isdst, el último valor devuelto por gmtime siempre es C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use warnings&gt; pragma (and the B&lt;-w&gt; switch) produces some 
lovely diagnostics.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001606Z" changeid="explorer">
        <seg>El pragma C&lt;use warnings&gt; (y el modificador B&lt;-w&gt;) produce algunos diagnósticos muy interesantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;PerlIO::scalar&gt; now works better with non-default C&lt;$/&gt; settings.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T045508Z" changeid="explorer">
        <seg>C&lt;PerlIO::scalar&gt; ahora funciona mejor con opciones no predeterminadas de C&lt;$/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*           Match 0 or more times</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T042630Z" changeid="explorer">
        <seg>*	Coincide con 0 o más veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you really wanted to do so, however, you could use
the construction C&lt;@{[ (some expression) ]}&gt;, but usually a simple
C&lt;(some expression)&gt; suffices.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si realmente quiere hacer eso, puede usar la construcción  C&lt;@{[ (una expresión) ]}&gt;, pero por lo general un simple C&lt;(una expresión)&gt; basta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For XS or embedding debugging purposes, if perl is compiled with
C&lt;-DDEBUG_LEAKING_SCALARS_FORK_DUMP&gt; in addition to
C&lt;-DDEBUG_LEAKING_SCALARS&gt; then a child process is C&lt;fork&gt;ed just before
global destruction, which is used to display the values of any scalars
found to have leaked at the end of global destruction.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T052702Z" changeid="explorer">
        <seg>Para XS o con fines de depuración embebida, si perl es compilado con C&lt;-DDEBUG_LEAKING_SCALARS_FORK_DUMP&gt;, además de C&lt;-DDEBUG_LEAKING_SCALARS&gt; entonces un proceso hijo es creado con C&lt;fork&gt; justo antes de la destrucción global, y es utilizado para mostrar los valores de cualquier escalar que sea encontrado y que tenga que ser eliminado al final de la destrucción global.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of packing can be achieved with
C&lt;pack(&quot;l!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este tipo de empaquetado se puede lograr con C&lt;pack(&quot;l!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then you can do a non-blocking wait for all pending zombie processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>entonces usted puede hacer una espera no bloqueante para todos los procesos zombie pendientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?&lt;ADRESS_PAT&gt;....)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T203517Z" changeid="explorer">
        <seg>(?&lt;DIRECCIÓN_PAT&gt;....)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If PARNO is preceded by a plus or minus sign then it is assumed
to be relative, with negative numbers indicating preceding capture groups
and positive ones following.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T212639Z" changeid="explorer">
        <seg>Si PARNO es precedido por un signo más o menos, entonces se asume que es relativo, con números negativos indicando grupos de captura anteriores, y con positivos a los posteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such
desperate behavior triggers a warning if you use the C&lt;use warnings&gt;
pragma or the B&lt;-w&gt; flag.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal desesperado comportamiento lanzará un aviso si usa el pragma C&lt;use warnings&gt; o la opción B&lt;-w&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Codewright</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item Codewright</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpretation of the file permission operators C&lt;-r&gt;, C&lt;-R&gt;,
C&lt;-w&gt;, C&lt;-W&gt;, C&lt;-x&gt;, and C&lt;-X&gt; is by default based solely on the mode
of the file and the uids and gids of the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La interpretación de los operadores de permisos de archivo C&lt;-r&gt;, C&lt;-R&gt;, C&lt;-w&gt;, C&lt;-W&gt;, C&lt;-x&gt; y C&lt;-X&gt; es por defecto basado sólamente en el modo del archivo y en los uid y gid del usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a lowercased version of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una versión de EXPR, en minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Darwin's First Name is &quot;, $scientists{&quot;Darwin&quot;}, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El nombre de Darwin &quot;, $cientificos{&quot;Darwin&quot;}, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using Module::Build, this will usually be:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024958Z" changeid="explorer">
        <seg>Al utilizar el Module::Build, suele ser así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allow files that start with C&lt;=head&gt; on the first line</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T034357Z" changeid="explorer">
        <seg>Permite que los archivos comiencen con un C&lt;=head&gt; en la primera línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Regular expressions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Expresiones regulares</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A package statement affects dynamic variables only, including those
you've used C&lt;local&gt; on, but I&lt;not&gt; lexical variables, which are created
with C&lt;my&gt;, C&lt;state&gt;, or C&lt;our&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T004750Z" changeid="explorer">
        <seg>Una instrucción package afecta sólo a las variables dinámicas, incluyendo las que haya usado con C&lt;local&gt;, pero I&lt;no&gt; a las variables léxicas, que son creadas con C&lt;my&gt;, C&lt;state&gt; o C&lt;our&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the CPAN FAQ at http://www.cpan.org/misc/cpan-faq.html for answers
to the most frequently asked questions about CPAN including how to
become a mirror.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230118Z" changeid="explorer">
        <seg>En la sección FAQ (preguntas más frecuentes) de CPAN (en http://www.cpan.org/misc/cpan-faq.html ) encontrará respuestas a las preguntas más frecuentes sobre CPAN (por ejemplo, cómo configurar un servidor reflejado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $SIG{ALARM} = sub { die &quot;Alarm!\n&quot; };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local $SIG{ALARM} = sub { die &quot;¡Alarma!\n&quot; };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;`STRING`&quot;&gt;
for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop/&quot;`STRING`&quot;&gt; para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the inclusion system
walks through @INC and encounters a subroutine, this subroutine gets
called with two parameters, the first a reference to itself, and the
second the name of the file to be included (e.g., &quot;F&lt;Foo/Bar.pm&gt;&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando el sistema de inclusión recorre C&lt;@INC&gt; y se encuentra con una subrutina, esta subrutina es llamada con dos parámetros; el primero, una referencia a sí mismo; y el segundo, el nombre del archivo que se incluirá (por ejemplo, &quot;F&lt;Foo/Bar.pm&gt;&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhaiku		Perl notes for Haiku</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlhaiku		Notas para Haiku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return true if successful, false on error.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014136Z" changeid="explorer">
        <seg>Devuelve verdadero si tuvo éxito, falso en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This isn't the case on EBCDIC platforms; see
L&lt;perlebcdic/OPERATOR DIFFERENCES&gt; for the complete list of what these
sequences mean on both ASCII and EBCDIC platforms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T205131Z" changeid="explorer">
        <seg>Este no es el caso en las plataformas EBCDIC; ver L&lt;perlebcdic/DIFERENCIAS EN LOS OPERADORES&gt; para ver la lista completa del significado de estas secuencias, tanto en las plataformas ASCII como en EBCDIC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Optimization of regular expressions
X&lt;regexp, optimization&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T010535Z" changeid="explorer">
        <seg>=item Optimización de expresiones regulares
X&lt;regexp, optimization&gt; X&lt;regexp, optimización&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{n}?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{n}?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's process, file, and text manipulation facilities make it
particularly well-suited for tasks involving quick prototyping, system
utilities, software tools, system management tasks, database access,
graphical programming, networking, and world wide web programming.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T195907Z" changeid="explorer">
        <seg>Las características de manipulación de texto, archivos y procesos que ofrece Perl lo convierten en un lenguaje especialmente adecuado para tareas que requieren crear rápidamente prototipos, utilidades del sistema, herramientas de software, tareas de administración de sistemas, acceso a bases de datos, programación gráfica, conexión a redes y programación web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str =~ /^\w/;       # Still a match!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T001248Z" changeid="explorer">
        <seg>$str =~ /^\w/;       # ¡Todavía coincide!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlport&gt; for notes on the portability of this construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport&gt; para notas sobre la portabilidad de esta construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 4) = 4   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 4) = 4   ==     262144 00000000000000000010000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;||&gt;, C&lt;//&gt; and C&lt;&amp;&amp;&gt; operators return the last value evaluated
(unlike C's C&lt;||&gt; and C&lt;&amp;&amp;&gt;, which return 0 or 1).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los operadores C&lt;||&gt;, C&lt;//&gt; y C&lt;&amp;&amp;&gt; devuelven el último valor evaluado (a diferencia de los operadores del C C&lt;||&gt; y C&lt;&amp;&amp;&gt;, que devuelve 0 o 1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uses the value of EXPR as a filename and executes the contents of the
file as a Perl script.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usa el valor de EXPR como el nombre de un archivo y ejecuta los contenidos del archivo como un script Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Exists\n&quot;    if exists $array[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Existe\n&quot;    if exists  $array[$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/Net/protoent...................ok</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214825Z" changeid="explorer">
        <seg>lib/Net/protoent...................ok</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When interactions between data are best represented by
overloaded operators</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T020019Z" changeid="explorer">
        <seg>Cuando las interacciones entre los datos están mejor representados por los operadores sobrecargados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>read-only hashes (user-level interface is Hash::Util)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>hashes de solo lectura (el interfaz de usuario es Hash::Util)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item t/io/perlio_open.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010005Z" changeid="explorer">
        <seg>=item t/io/perlio_open.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these cases perl will fall back to the old behaviour of using C's
argv[0] value for C&lt;$^X&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estos casos perl volverá al anterior comportamiento de usar el valor del C argv[0] para C&lt;$^X&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item B::Deparse</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015047Z" changeid="explorer">
        <seg>=item B::Deparse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More complex data types can be constructed using references, which allow
you to build lists and hashes within lists and hashes.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T224947Z" changeid="explorer">
        <seg>Se pueden crear tipos de datos más complejos mediante referencias, que permiten generar listas y hashes dentro de listas y hashes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run into trouble, it's quite
likely that someone else has already solved the problem you're
facing.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222332Z" changeid="explorer">
        <seg>Si tiene problemas, es muy probable que alguien ya haya resuelto el problema al que se está enfrentando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lists may be assigned to only when each element of the list
is itself legal to assign to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las listas pueden ser asignados a ella sólo cuando cada elemento de la lista en sí es legal para asignar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ make miniperl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ make miniperl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is just an ordinary
method (subroutine) defined (or inherited) by modules that wish to export
names to another module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es sólo un método (subrutina) ordinario definido (o heredado) por módulos que desean exportar nombres a otro módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Final: '$1', pos=&quot;,pos,&quot;\n&quot; if /\G(.)/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Final: '$1', pos=&quot;,pos,&quot;\n&quot; if /\G(.)/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any number of C&lt;(*PRUNE)&gt; assertions may be used in a pattern.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T010310Z" changeid="explorer">
        <seg>Se pueden usar cualquier número de aserciones C&lt;(*PRUNE)&gt; en un patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;&quot;\128&quot;&gt; in the ASCII character set
is equivalent to the two characters C&lt;&quot;\n8&quot;&gt;, but the warning C&lt;Illegal octal
digit '8' ignored&gt; will be thrown.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T210909Z" changeid="explorer">
        <seg>Por ejemplo, C&lt;&quot;\128&quot;&gt; en el juego de caracteres ASCII es equivalente a los dos caracteres C&lt;&quot;\n8&quot;&gt;, pero se mostrará la advertencia I&lt;Illegal octal digit '8' ignored&gt; (C&lt;Se ignora el carácter octal ilegal '8'&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &quot;?&quot; is
the delimiter, then a match-only-once rule applies,
described in C&lt;m?PATTERN?&gt; below.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T233038Z" changeid="explorer">
        <seg>Si &quot;?&quot; es el delimitador, entonces se aplica la regla coincide-solo-una-vez, descrito más abajo, en C&lt;?PATRÓN?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function behaves the same way under various pragmata, such as in a locale,
as L&lt;/lc&gt; does.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171126Z" changeid="explorer">
        <seg>Esta función se comporta de la misma manera bajo varios I&lt;pragma&gt;, como por ejemplo en una configuración regional, como lo hace L&lt;/lc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get dates with leading zeros.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para obtener fechas con ceros a la izquierda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($foo = $bar) =~ s/this/that/;	# copy first, then change</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T212955Z" changeid="explorer">
        <seg>($foo = $bar) =~ s/este/aquel/;		# primero copiar, luego cambiar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$AoA[$i] = @tmp;   # WRONG!</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T030031Z" changeid="explorer">
        <seg>$AoA[$i] = @tmp;   # ¡MAL!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The wandering prose riddled with jargon is
hard to fathom in several places.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T004014Z" changeid="explorer">
        <seg>La prosa errante llena de jerga es difícil de entender, en varios lugares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you still have concerns or difficulties understanding
my intent, feel free to contact me.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T224502Z" changeid="explorer">
        <seg>Si aún tiene dudas o dificultades para comprender mi intención, no dude en ponerse en contacto conmigo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># No direct -X operator counterpart, but for the first one</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># No tiene un operador -X parejo, pero para el primero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpretation of operations and values in Perl sometimes depends
on the requirements of the context around the operation or value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La interpretación de las operaciones y los valores en Perl depende a veces de las necesidades del contexto en el que se encuentra la operación o el valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The diagnostic output of Carp has been changed slightly, to add a space after
the comma between arguments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110922T102658Z" changeid="explorer">
        <seg>La salida de diagnóstico de Carp se ha cambiado un poco, para agregar un espacio después de la coma entre los argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed F&lt;libbsd&gt; for AIX 5L and 6.1.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153024Z" changeid="explorer">
        <seg>Eliminado F&lt;libbsd&gt; de AIX 5L y 6.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Miscellaneous</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T225219Z" changeid="zipf">
        <seg>=item Otros operadores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Jan Goyvaerts and Steven Levithan</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003520Z" changeid="explorer">
        <seg>Jan Goyvaerts y Steven Levithan</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;%2\$d %d %d\n&quot;, 12, 34;        # will print &quot;34 12 34\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;%2\$d %d %d\n&quot;, 12, 34;        # imprimirá &quot;34 12 34\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FUNCTION is a string starting with C&lt;CORE::&gt;, the rest is taken as a
name for a Perl builtin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si FUNCIÓN es una cadena que comienza con C&lt;CORE::&gt;, el resto es tomado como un nombre para una orden interna de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ee  Evaluate the right side as a string then eval the result.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T212757Z" changeid="explorer">
        <seg>ee	Evalúa el lado derecho como una cadena que es pasada por eval() para obtener el resultado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport/localtime&gt; for portability concerns.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport/localtime&gt; para las problemas sobre portabilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m{ \(
          (
            [^()]+           # x+
          |
            \( [^()]* \)
          )+</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050805Z" changeid="explorer">
        <seg>m{ \(
          (
            [^()]+		# x+
          |
            \( [^()]* \)
          )+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;ARTICLE&gt;) {...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;ARTICULO&gt;) {...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!perl -l</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050215Z" changeid="explorer">
        <seg>#!perl -l</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>utime $atime, $mtime, @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>utime $atime, $mtime, @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a
C&lt;(*MARK:NAME)&gt; was encountered while matching, then it is that position
which is used as the &quot;skip point&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T011437Z" changeid="explorer">
        <seg>Si se ha encontrado un C&lt;(*MARK:NOMBRE)&gt; durante la búsqueda, entonces es la posición que es utilizada como el &quot;punto de salto&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;spat&quot;&gt; or C&lt;2.18 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;spat&quot;&gt; oo C&lt;2.18 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Issuing a &quot;make test&quot; will run all the tests.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La ejecución de un &quot;make test&quot; ejecutará todas las pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item print FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011436Z" changeid="explorer">
        <seg>=item print IDENTIFICADOR_ARCHIVO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Foo.pm provides an implementation of the FOO protocol.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015046Z" changeid="explorer">
        <seg>&quot;Foo.pm proporciona una implementación del protocolo FOO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/readline&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220249Z" changeid="explorer">
        <seg>Vea L&lt;perlfunc/readline&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># matches in 5.8.x, doesn't match in 5.10.0</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T190944Z" changeid="explorer">
        <seg># coincide en 5.8.x, no coincide in 5.10.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Updated modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T015029Z" changeid="explorer">
        <seg>=head2 Módulos actualizados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TYPE is currently bound to the use of the C&lt;fields&gt; pragma,
and attributes are handled using the C&lt;attributes&gt; pragma, or starting
from Perl 5.8.0 also via the C&lt;Attribute::Handlers&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T172323Z" changeid="explorer">
        <seg>TIPO está vinculado al uso del pragma C&lt;fields&gt;, y los atributos se manejan con el pragma C&lt;attributes&gt;, o a partir de Perl 5.8.0 también a través del módulo C&lt;Attribute::Handlers&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tautologous boolean operators are still going to be optimized away.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T215637Z" changeid="explorer">
        <seg>Los operadores booleanos tautológicos tienen que ser optimizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @$ref_to_AoA, [ split ];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @$ref_to_AoA, [ split ];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc/&quot;SysV IPC&quot;&gt;,
C&lt;IPC::SysV&gt;, and the C&lt;IPC::Shareable&gt; module from CPAN.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T014205Z" changeid="explorer">
        <seg>Vea también L&lt;perlipc/&quot;SysV IPC&quot;&gt;, C&lt;IPC::SysV&gt;, y el módulo C&lt;IPC::Shareable&gt; en CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$b{EXTRA} = \%a;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225554Z" changeid="explorer">
        <seg>$b{EXTRA} = \%a;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add perlpacktut</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>añadido perlpacktut</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This zero-width pattern prunes the backtracking tree at the current point
when backtracked into on failure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110817T011226Z" changeid="explorer">
        <seg>Este patrón de ancho cero poda el árbol de vuelta atrás en el punto actual de cuando dio vuelta atrás a causa de un fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\b                  backspace         (BS)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T185949Z" changeid="explorer">
        <seg>\b		retroceso				(BS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;perlivp&gt; implements new option C&lt;-a&gt; and will not check for F&lt;*.ph&gt;
files by default any more.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T041957Z" changeid="explorer">
        <seg>C&lt;perlivp&gt; implementa la nueva opción C&lt;-a&gt;, y ya no buscará, por defecto, por archivos F&lt;*.ph&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're writing your own documentation in POD, the F&lt;podchecker&gt;
utility will look for errors in your markup.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T233530Z" changeid="explorer">
        <seg>Al redactar documentación POD puede usar la utilidad F&lt;podchecker&gt; para detectar errores de marcas POD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value of -1 in either position is interpreted by most
systems to leave that value unchanged.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un valor de -1 en cualquier posición es interpretado en la mayoría de los sistemas como que se deja el actual valor sin cambiar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has been fixed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto ha sido corregido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item map BLOCK LIST
X&lt;map&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T191337Z" changeid="explorer">
        <seg>=item map BLOQUE LISTA
X&lt;map&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But because
a quantifier (C&lt;\D*&gt;) has been used in the regular expression, the
search engine can backtrack and retry the match differently
in the hope of matching the complete regular expression.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T171007Z" changeid="explorer">
        <seg>Pero debido a que se ha utilizado un cuantificador (C&lt;\D*&gt;) en la expresión regular, el motor de búsqueda puede dar marcha atrás y volver a intentar la coincidencia de manera diferente con la esperanza de hacer coincidir la expresión regular completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's because $x is a simple scalar variable, but C&lt;$hash{key}&gt; is
not--it's a hash element.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se debe a que C&lt;$x&gt; es una variable escalar simple, pero C&lt;$hash{clave}&gt; no lo es: es un elemento de un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But see also
L&lt;Bitwise String Operators&gt;.)  However, C&lt;use integer&gt; still has meaning for
them.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220306Z" changeid="explorer">
        <seg>(Pero vea también L&lt;Operadores de bit en cadenas&gt;). Sin embargo, C&lt;use integer&gt; todavía tiene sentido para ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@chars = map(chr, @numbers);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T171521Z" changeid="explorer">
        <seg>@caracteres = map(chr, @numeros);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item package NAMESPACE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item package ESPACIO_NOMBRES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You
may sell such an object file as proprietary provided that you provide
or offer to provide the Perl source, as specified by the GNU General
Public License.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T224222Z" changeid="explorer">
        <seg>Usted puede vender como un código objeto como objeto propietario, siempre que usted proporcione u ofrezca una forma de proporcionar el código fuente de Perl, según lo especificado por la GNU General Public License.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 1-884777-79-1 [1st edition August 1999]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003615Z" changeid="explorer">
        <seg>ISBN 1-884777-79-1 [1ª edición - Agosto de 1999]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_, 4, 4) = 8   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_, 4, 4) = 8   ==     524288 00000000000000000001000000000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfaq2		Obtaining and Learning about Perl</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T000233Z" changeid="explorer">
        <seg>perlfaq2		Cómo obtener y aprender a utilizar Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ref</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item ref</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5.9.2 introduced a change so that assignments of C&lt;undef&gt; to a
scalar, or of an empty list to an array or a hash, were optimised out.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T035356Z" changeid="explorer">
        <seg>Perl 5.9.2 introducía un cambio para que las asignaciones de C&lt;undef&gt; a un escalar, o de una lista vacía a un array o un hash, fueran optimizadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not affected by
                   /s modifier</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T045037Z" changeid="explorer">
        <seg>No se ve afectado por el
                   modificador /s</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>native integer        --&gt; decimal string</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110825T113014Z" changeid="explorer">
        <seg>entero nativo         --&gt; cadena decimal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlobj&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlobj&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Groups are numbered with the leftmost open parenthesis being number 1, etc.  If
a group did not match, the associated backreference won't match either.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T001605Z" changeid="explorer">
        <seg>Los grupos son numerados siendo el paréntesis abierto más a la izquierda el número 1, etc. Si un grupo no se ha encontrado, la contrareferencia asociada no será inicializada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will also probe for C&lt;futimes&gt; and whether C&lt;sprintf&gt;
correctly returns the length of the formatted string, which will both be used
in perl 5.8.9.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T043304Z" changeid="explorer">
        <seg>También probará por C&lt;futimes&gt; y también por si C&lt;sprintf&gt; devuelve correctamente la longitud de la cadena formateada, que serán ambas usadas en perl 5.8.9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/warn&gt;, L&lt;perlvar&gt;, L&lt;warnings&gt; and L&lt;perllexwarn&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/warn&gt;, L&lt;perlvar&gt;, L&lt;warnings&gt; y L&lt;perllexwarn&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most important thing is to run your programs under the B&lt;-w&gt;
flag at all times.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo más importante es ejecutar siempre sus programas con la opción B&lt;-w&gt; puesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To read old I&lt;TPJ&gt; articles, see
http://www.ddj.com/ or brian d foy's index of online TPJ content
( http://www.perlmonks.org/index.pl?node_id=711609 ).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T230922Z" changeid="explorer">
        <seg>Para leer artículos antiguos de I&lt;TPJ&gt;, visite http://www.ddj.com/ o consulte el índice de contenido en línea de TPJ proporcionado por brian d foy ( http://www.perlmonks.org/index.pl?node_id=711609 ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, if the
object overloads the stringification or the numification operators, and
if overload fallback is active, it will be used instead, as usual.)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T185232Z" changeid="explorer">
        <seg>(Sin embargo, si el objeto sobrecarga la conversión en cadena de caracteres o los operadores de conversión en números, y si la sobrecarga de reserva está activa, será utilizada en su lugar, como de costumbre.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($Config{doublesize} == $Config{longdblsize}) &amp;&amp;
                print &quot;doubles are long doubles\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T051812Z" changeid="explorer">
        <seg>($Config{doublesize} == $Config{longdblsize}) &amp;&amp;
                print &quot;doubles son long doubles\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you've exhausted the documentation, please report bugs to us
using the 'perlbug' tool.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T222406Z" changeid="explorer">
        <seg>Una vez que haya agotado la documentación, por favor, infórmenos de los errores a través de la herramienta 'perlbug'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $i++;  # prints 0</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $i++;  # imprime 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ext/Devel/PPPort/t/ppphtest.t  #26913</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T053447Z" changeid="explorer">
        <seg>ext/Devel/PPPort/t/ppphtest.t  #26913</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$obj-&gt;do_something(&quot;wibble&quot;, &quot;text&quot;, 1024);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T021655Z" changeid="explorer">
        <seg>$obj-&gt;hacer_algo(&quot;wibble&quot;, &quot;texto&quot;, 1024);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would match the same as C&lt;/(Y) ( (X) \g3 \g1 )/x&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T002141Z" changeid="explorer">
        <seg>coincidiría igual que con C&lt;/(Y) ( (X) \g3 \g1 )/x&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Described in L&lt;perluniintro&gt;, L&lt;perllocale&gt; and L&lt;Locale::Maketext&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001413Z" changeid="explorer">
        <seg>Se describe en L&lt;perluniintro&gt;, L&lt;perllocale&gt; y L&lt;Locale::Maketext&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This points to a closed
subscription unarchived mailing list, which includes all the core
committers, who be able to help assess the impact of issues, figure out
a resolution, and help co-ordinate the release of patches to mitigate
or fix the problem across all platforms on which Perl is supported.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T052908Z" changeid="explorer">
        <seg>Esto apunta a una lista de correo de suscripción cerrada y no archivada, que incluye a todos los participantes principales, que podrán ayudar a evaluar el impacto de los problemas, encontrar una resolución, y ayudar a coordinar la liberación de parches para mitigar o solucionar el problema en todas las plataformas en las que Perl está soportado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @INC, Foo-&gt;new(...);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push @INC, Foo-&gt;new(...);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl583delta - what is new for perl v5.8.3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl583delta - Qué hay de nuevo para perl v5.8.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have to do anything with the number of bytes, it's probably best to move
that part to step 3, just after you've encoded the string.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T235235Z" changeid="explorer">
        <seg>Si necesita el número de bytes para algo, debe calcularlo en el paso 3, después de codificar la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core Perl modules</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030202Z" changeid="explorer">
        <seg>Módulos pertenecientes al núcleo de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a Bourne-like shell, this can be done as</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T002147Z" changeid="explorer">
        <seg>En un shell de la familia Bourne, esto se puede hacer así</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a precision obtained through C&lt;*&gt; is negative, it counts
as having no precision at all.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si una precisión obtenida a través de C&lt;*&gt; es negativa, se cuenta como no tener precisión en absoluto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;last&gt;, you have to be more elaborate:
X&lt;last&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T041229Z" changeid="explorer">
        <seg>Para C&lt;last&gt;, ha de ser un poco más elegante
X&lt;last&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Input and output functions
X&lt;I/O&gt; X&lt;input&gt; X&lt;output&gt; X&lt;dbm&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T201256Z" changeid="explorer">
        <seg>=item Funciones de Entrada y Salida
X&lt;I/O&gt; X&lt;input&gt; X&lt;output&gt; X&lt;dbm&gt; X&lt;entrada&gt; X&lt;salida&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$filename =~ s/(.*\.gz)\s*$/gzip -dc &lt; $1|/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$archivo =~ s/(.*\.gz)\s*$/gzip -dc &lt; $1|/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A filehandle, from which the file will be read.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011852Z" changeid="explorer">
        <seg>Un identificador de archivo, desde el cual, el archivo será leído.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is the same as C&lt;/u&gt;, except that C&lt;\d&gt;, C&lt;\s&gt;, C&lt;\w&gt;, and the
Posix character classes are restricted to matching in the ASCII range
only.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T211703Z" changeid="explorer">
        <seg>es lo mismo que C&lt;/u&gt;, excepto que C&lt;\d&gt;, C&lt;\s&gt;, C&lt;\w&gt;, y las clases carácter de Posix se limitan a coincidir solo dentro del rango del ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If EXPR happens to start off with C&lt;0x&gt;, interprets it as a
hex string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si EXPR comienza con C&lt;0x&gt;, se interpreta como una cadena en hexadecimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl584delta - what is new for perl v5.8.4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl584delta - what is new for perl v5.8.4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>THAT</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To capture a command's STDOUT but discard its STDERR:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para capturar el STDOUT de un comando pero descartar su STDERR:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Did we mention that you should definitely consider using the B&lt;-w&gt;
switch?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001705Z" changeid="explorer">
        <seg>No olvide que es muy importante utilizar el modificador B&lt;-w&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At any given time, exactly one of these modifiers is in effect.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T163708Z" changeid="explorer">
        <seg>En un momento determinado, solo uno de estos modificadores está en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 FILES</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T004026Z" changeid="explorer">
        <seg>=head1 ARCHIVOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($_ = &lt;STDIN&gt;) { print; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($_ = &lt;STDIN&gt;) { print; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SCALAR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SCALAR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the pattern uses a Unicode name (C&lt;\N{...}&gt;);  or</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110725T000726Z" changeid="explorer">
        <seg>el patrón utiliza un nombre Unicode (C&lt;\N{...}&gt;); o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
is not for the faint of heart, as they have to plug in at the C level.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110918T001144Z" changeid="explorer">
        <seg>Esto no es para los débiles de corazón, ya que tienen que conectar a nivel de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISBN 978-1-56592-699-8 [February 2000]</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T003527Z" changeid="explorer">
        <seg>ISBN 978-1-56592-699-8 [Febrero de 2000]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;match: &lt;$&amp;&gt;\n&quot; while 'foo' =~ m{ o?</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T230740Z" changeid="explorer">
        <seg>print &quot;coincidencia: &lt;$&amp;&gt;\n&quot; while 'foo' =~ m{ o?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the absolute value of the right operand (C&lt;abs($b)&gt;) is greater than
or equal to C&lt;(UV_MAX + 1)&gt;, &quot;%&quot; computes the floating-point remainder
C&lt;$r&gt; in the equation C&lt;($r = $a - $i*$b)&gt; where C&lt;$i&gt; is a certain
integer that makes C&lt;$r&gt; have the same sign as the right operand
C&lt;$b&gt; (B&lt;not&gt; as the left operand C&lt;$a&gt; like C function C&lt;fmod()&gt;)
and the absolute value less than that of C&lt;$b&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el valor absoluto del operando derecho (C&lt;abs($b)&gt;) es mayor o igual a C&lt;(UV_MAX + 1)&gt;, &quot;%&quot; computa el resto en punto flotante C&lt;$r&gt; en la ecuación C&lt;($r = $a - $i*$b)&gt; donde C&lt;$i&gt; es un cierto entero que hace que C&lt;$r&gt; tenga el mismo signo que el operando de la derecha C&lt;$b&gt; (B&lt;no&gt; como el operando izquierdo C&lt;$a&gt; como la función C C&lt;fmod()&gt;)
y el valor absoluto menor que el de C&lt;$b&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;RESTRICTION&gt;: The conversions marked with C&lt;(*)&gt; above involve steps
performed by the C compiler.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232846Z" changeid="explorer">
        <seg>B&lt;RESTRICCIÓN&gt;: las conversiones anteriores marcadas con C&lt;(*)&gt; implican pasos ejecutados por el compilador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@newAoA = splice_2D( \@AoA, 4 =&gt; 8, 7 =&gt; 12 );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T200350Z" changeid="explorer">
        <seg>@newAoA = splice_2D( \@AoA, 4 =&gt; 8, 7 =&gt; 12 );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}xg;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050238Z" changeid="explorer">
        <seg>}xg;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
exponential performance will make it appear that your program has
hung.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T214425Z" changeid="explorer">
        <seg>Este rendimiento exponencial le hará creer que su programa se ha bloqueado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>F&lt;prove&gt; is a command-line interface to the test-running functionality
of F&lt;Test::Harness&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T015859Z" changeid="explorer">
        <seg>F&lt;prove&gt; es una interfaz de línea de comandos de la funcionalidad de ejecución de pruebas de F&lt;Test::Harness&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special arrays C&lt;@-&gt; and C&lt;@+&gt; are no longer interpolated in regular
expressions.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T235923Z" changeid="explorer">
        <seg>Los arrays especiales C&lt;@-&gt; y C&lt;@+&gt; ya no son interpolados en las expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$string =~ $re;		# or used standalone</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cadena =~ $re;		# o usar de forma aislada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dbmopen(%HIST,'/usr/lib/news/history',0666);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dbmopen(%HIST,'/usr/lib/news/history',0666);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This introductory document does not aim to be complete.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T010454Z" changeid="explorer">
        <seg>Es un documento introductorio, no una guía completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing, but without any temps</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, pero sin usar ninguna variable temporal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are disallowed under C&lt;/l&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T165458Z" changeid="explorer">
        <seg>Éstos no se permiten bajo C&lt;/l&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Algorithm::Permute::permute {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225558Z" changeid="explorer">
        <seg>Algorithm::Permute::permute {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators can be combined with a C&lt;=&gt; as follows:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225256Z" changeid="explorer">
        <seg>Muchos operadores se pueden combinar con un signo C&lt;=&gt; de la manera siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general,
conversion from one form to another is transparent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, la conversión entre uno y otro tipo es transparente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\cb      chr(2)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T034627Z" changeid="explorer">
        <seg>\cb      chr(2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In place of a SUBNAME, you can provide a BLOCK as
an anonymous, in-line sort subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En lugar de un NOMBRE_SUB, puede proporcionar un BLOQUE como si fuera una subrutina de ordenación anónima.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DOMAIN, TYPE, and PROTOCOL are specified the same as
for the syscall of the same name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DOMINIO, TIPO, y PROTOCOLO son especificados de la misma manera que la llamada del sistema del mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a list may consist of any combination
of scalar arguments or list values; the list values will be included
in the list as if each individual element were interpolated at that
point in the list, forming a longer single-dimensional list value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal lista puede consistir en cualquier combinación de argumentos escalares o valores de lista; los valores de lista serán incluidos en la lista como si cada elemento individual fuera interpolado en ese punto en la lista, formando un largo y unidimensional valor de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;&lt; &lt;= &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;&lt; &lt;= &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item semctl ID,SEMNUM,CMD,ARG
X&lt;semctl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T200433Z" changeid="explorer">
        <seg>=item semctl ID,SEMNUM,CMD,ARG
X&lt;semctl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PATTERN may contain variables, which will be interpolated
every time the pattern search is evaluated, except
for when the delimiter is a single quote.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T233200Z" changeid="explorer">
        <seg>PATRÓN puede contener variables, que serán interpoladas cada vez que el patrón de búsqueda sea evaluado, a excepción de cuando el delimitador sea una comilla simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``	qx{}	      Command		  yes*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>``	qx{}	      Comando		  sí*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these loop constructs, the assigned value (whether assignment
is automatic or explicit) is then tested to see whether it is
defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estas construcciones de bucle, el valor asignado (tanto si la asignación es automática o explícita) es examinado para ver si está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ( /foo(.*)bar/ ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110823T154754Z" changeid="explorer">
        <seg>if ( /mesa(.*)come/ ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># 1            2         2  3        2     3     4</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110319T124758Z" changeid="explorer">
        <seg># 1            2         2  3        2     3     4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: C&lt;unlink&gt; will not attempt to delete directories unless you are
superuser and the B&lt;-U&gt; flag is supplied to Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota: C&lt;unlink&gt; no intentará eliminar directorios a menos que usted sea superusuario y la bandera B&lt;-U&gt; se suministre a Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item charnames</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015041Z" changeid="explorer">
        <seg>=item charnames</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function implementing the C&lt;&lt; &lt;EXPR&gt; &gt;&gt;
operator, but you can use it directly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es la función interna que implementa el operador C&lt;&lt; &lt;EXPR&gt; &gt;&gt;, pero puede usarla directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;echo @ARGV&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;echo @ARGV&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 );</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225458Z" changeid="explorer">
        <seg>10 );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Plain Old Comments (Not!)
X&lt;comment&gt; X&lt;line&gt; X&lt;#&gt; X&lt;preprocessor&gt; X&lt;eval&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110526T200306Z" changeid="explorer">
        <seg>=head2 Antiguos comentarios (¡Pero no tanto!)
X&lt;comment&gt; X&lt;line&gt; X&lt;#&gt; X&lt;preprocessor&gt; X&lt;eval&gt; X&lt;comentario&gt; X&lt;línea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a{EXTRA} = \%b;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225554Z" changeid="explorer">
        <seg>$a{EXTRA} = \%b;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Regular expressions and pattern matching
X&lt;regular expression&gt; X&lt;regex&gt; X&lt;regexp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110201T043542Z" changeid="explorer">
        <seg>=item Expresiones regulares y coincidencia de patroner
X&lt;regular expression&gt; X&lt;regex&gt; X&lt;regexp&gt; X&lt;expresión regular&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all child processes are
gone BeOS' waitpid(-1,...) returns 0 instead of -1 (as it should).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Después de que todos los procesos hijo hayan terminado, el waitpid(-1, ...) de BeOS devuelve 0 en lugar de -1 (como debería).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># (including lexicals) in $_ : First $1 is interpolated</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># (incluyendo léxicas) en $_ : Primero $1 es interpolado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of nanosleep(), if available, allows mixing subsecond sleeps with
alarms.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T175844Z" changeid="explorer">
        <seg>El uso de nanosleep(), si está disponible, permite la mezcla de lapsos en fracciones de segundo junto con las alarmas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($uno,$cinco,$quince) = (`uptime` =~ /(\d+\.\d+)/g);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Exists\n&quot;    if exists $hash{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Existe\n&quot;    if exists  $hash{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;overload&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T232424Z" changeid="explorer">
        <seg>Encontrará información detallada en L&lt;overload&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $ref-&gt;[$x][$y][$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $ref-&gt;[$x][$y][$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cases 1 and 2 above behave identically: they run the code contained in
the variable $x.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los casos 1 y 2 se comportan idénticamente: ejecutan el código contenido en la variable $x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improved documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Documentación mejorada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(&quot; UPPERCASE&quot;),    redo LOOP if /\G\p{Lu}+\b[,.;]?\s*/gc;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T030038Z" changeid="explorer">
        <seg>print(&quot; MAYÚSCULA&quot;),    redo LOOP if /\G\p{Lu}+\b[,.;]?\s*/gc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $a = &quot;\N{THAI CHARACTER SARA I}&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T011455Z" changeid="explorer">
        <seg>my $a = &quot;\N{THAI CHARACTER SARA I}&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} 0..$#old</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} 0..$#viejo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry and the Perl development team occasionally make changes to the
internal core of the language, but all possible efforts are made toward
backward compatibility.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T230236Z" changeid="explorer">
        <seg>Ocasionalmente, Larry y el equipo de desarrollo de Perl realizan cambios en los componentes internos del lenguaje, pero siempre se hace lo posible por mantener la compatibilidad con las versiones anteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another other case is where you need a cryptographically-strong
starting point rather than the generally acceptable default, which is based on
time of day, process ID, and memory allocation, or the F&lt;/dev/urandom&gt; device
if available.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T183329Z" changeid="explorer">
        <seg>Otro caso es donde necesitará un punto de partida criptográficamente más fuerte que el valor predeterminado generalmente aceptado, que se basa en la hora del día, ID del proceso, y la asignación de memoria, o el dispositivo F&lt;/dev/urandom&gt;, si está disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, thanks to Larry Wall, without whom none of this would be
necessary.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T010323Z" changeid="explorer">
        <seg>Finalmente, gracias a Larry Wall, sin el cual, nada de esto sería necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># parse mail messages</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># analizar mensajes de correo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 New Documentation</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Nueva documentación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item read FILEHANDLE,SCALAR,LENGTH</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T011612Z" changeid="explorer">
        <seg>=item read IDENTIFICADOR_ARCHIVO,ESCALAR,LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># In the main program</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># En el programa principal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;date&gt; X&lt;yesterday&gt; X&lt;DateTime&gt; X&lt;Date::Calc&gt; X&lt;Time::Local&gt;
X&lt;daylight saving time&gt; X&lt;day&gt; X&lt;Today_and_Now&gt; X&lt;localtime&gt;
X&lt;timelocal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225526Z" changeid="explorer">
        <seg>X&lt;date&gt; X&lt;yesterday&gt; X&lt;DateTime&gt; X&lt;Date::Calc&gt; X&lt;Time::Local&gt;
X&lt;daylight saving time&gt; X&lt;day&gt; X&lt;Today_and_Now&gt; X&lt;localtime&gt;
X&lt;timelocal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is an expression, the value is
taken as the name of the filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020051Z" changeid="explorer">
        <seg>Si IDENTIFICADOR_ARCHIVO es una expresión, el valor es tomado como el nombre del identificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, C&lt;@DB::args&gt; might have information from the
previous time C&lt;caller&gt; was called.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, C&lt;@DB::args&gt; podría tener información de la llamada a la anterior llamada a C&lt;caller&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/vec&gt; for information on how to manipulate individual bits
in a bit vector.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T220254Z" changeid="explorer">
        <seg>Vea L&lt;perlfunc/vec&gt; para obtener información sobre cómo manipular bits individuales de un vector de bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!/usr/bin/perl -T -w</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#!/usr/bin/perl -T -w</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options may exist at multiple protocol levels depending on the socket
type, but at least the uppermost socket level SOL_SOCKET (defined in the
C&lt;Socket&gt; module) will exist.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Opciones pueden existir en múltiples niveles de protocolo dependiendo del tipo de socket, pero al menos existirá el más alto nivel de socket SOL_SOCKET (definido en el módulo C&lt;Socket&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-defined subroutines may choose to care whether they are being
called in a void, scalar, or list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las subrutinas definidas por el usuario tienen la opción de considerar si están siendo llamadas en contexto vacío, escalar o de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reads or writes the System V shared memory segment ID starting at
position POS for size SIZE by attaching to it, copying in/out, and
detaching from it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lee o escribe en el segmento ID de memoria compartida System V a partir de la posición POSICIÓN para el tamaño TAMAÑO, añadiéndose a ella, copiando la entrada/salida, y desuniéndose de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides being used internally during the build process of the Encode
module, you can use F&lt;enc2xs&gt; to add your own encoding to perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T234602Z" changeid="explorer">
        <seg>F&lt;enc2xs&gt; se usa internamente durante el proceso de compilación del módulo Encode; también lo puede usar para agregar su propia codificación a perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some platforms (notably DOS-like ones), the shell may not be
capable of dealing with multiline commands, so putting newlines in
the string may not get you what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunas plataformas (especialmente las de tipo DOS), el shell quizás no pueda ser capaz de tratar con los comandos de múltiples líneas, así que poner saltos de línea quizás no le permita obtener lo que quiere.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of a symbolic link, if symbolic links are
implemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor de un enlace simbólico, si los enlaces simbólicos están implementados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Subscripts</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Subíndices</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has the information about
the modules (with their versions) included with each release of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T231206Z" changeid="explorer">
        <seg>Este módulo contiene información sobre los módulos (con sus versiones) incluidos en cada versión de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is applicable
to the third and fourth arguments of C&lt;sysread&gt;, for example.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T234058Z" changeid="explorer">
        <seg>Esto es aplicable, por ejemplo, a los argumentos tercero y el cuarto de C&lt;sysread&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item study</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item study</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may find the length
of array @days by evaluating C&lt;$#days&gt;, as in B&lt;csh&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede conocerse la longitud del array @días evaluando C&lt;$#días&gt;, como en B&lt;csh&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlre&gt; for further explanation on these.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlre&gt; para una explicación más detallada sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set ai sw=4</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225450Z" changeid="explorer">
        <seg>set ai sw=4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sequence   Value</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T204451Z" changeid="explorer">
        <seg>Secuencia  Valor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!   not</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110225T055533Z" changeid="explorer">
        <seg>!   not</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the commutativity breakage, code references are no longer
treated specially when appearing on the left of the C&lt;~~&gt; operator,
but like any vulgar scalar.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T221937Z" changeid="explorer">
        <seg>Debido a la rotura de la conmutatividad, las referencias a código ya no se tratan de forma especial cuando aparecen a la izquierda del operador C&lt;~~&gt;, sino que son tratadas como cualquier otro valor escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also
C&lt;POSIX::setsid()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215744Z" changeid="explorer">
        <seg>Vea también C&lt;POSIX::setsid()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CPAN stands for Comprehensive Perl Archive Network, a multi-gigabyte
archive replicated on hundreds of machines all over the world.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225958Z" changeid="explorer">
        <seg>CPAN es la sigla de Comprehensive Perl Archive Network, un repositorio que ocupa muchos gigabytes y está replicado en cientos de equipos del planeta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number after Perl (i.e. the 5 after Perl 5) is the major release
of the perl interpreter as well as the version of the language.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110627T004312Z" changeid="explorer">
        <seg>El número que va detrás de Perl (el 5 de Perl 5) es la versión principal del intérprete de Perl (es decir, perl), así como la versión del lenguaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># &quot;abcdefg\0\0\0\0\0\0\0&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># &quot;abcdefg\0\0\0\0\0\0\0&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may also be useful in places where the &quot;grab all you can, and do not
give anything back&quot; semantic is desirable.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T011110Z" changeid="explorer">
        <seg>También puede ser útil en lugares donde la semántica &quot;agarra todo lo que puedas, y no dar nada a cambio&quot; sea deseable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl -C0 -ne 'printf &quot;%v02X\n&quot;, $_ for unpack(&quot;U0A*&quot;, $_)'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T003621Z" changeid="explorer">
        <seg>perl -C0 -ne 'printf &quot;%v02X\n&quot;, $_ for unpack(&quot;C0A*&quot;, $_)'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a subroutine that does substring:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay una subrutina que parte cadenas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $logmessage = $_[0];                 # uncommon, and ugly</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110204T165728Z" changeid="zipf">
        <seg>my $mensaje_registro = $_[0];            # poco común (y poco estético)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BUILD</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>COMPILACIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$passwd,$uid,$gid,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($nombre,$contrasena,$uid,$gid,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negation of a true value by C&lt;!&gt; or C&lt;not&gt; returns a special false value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La negación del valor de verdadero con C&lt;!&gt; o C&lt;not&gt; devuelve un valor falso especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>THIS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ESTE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B  A bit string (descending bit order inside each byte).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B  Un cadena de bit (en orden de bit descendente dentro de cada byte).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously this blocking was in effect also for
programs executed from within Perl.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T232632Z" changeid="explorer">
        <seg>Anteriormente, este bloqueo se encontraba en vigor también para los programas ejecutados desde dentro de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recursion is of
unlimited depth.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001042Z" changeid="explorer">
        <seg>La profundidad de recursión es ilimitada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &gt; &gt;&gt; or C&lt;&lt; &lt; &gt;&gt; modifiers can only be used on floating-point
formats on big- or little-endian machines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los modificadores C&lt;&lt; &gt; &gt;&gt; o C&lt;&lt; &lt; &gt;&gt; solo pueden ser usados con formatos de punto flotante en máquinas con ordenación big-endian o little-endian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vec($_,24, 1) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vec($_,24, 1) = 1   ==   16777216 00000000000000000000000010000000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Math::Currency         for currency calculations</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T215157Z" changeid="explorer">
        <seg>Math::Currency		para cálculos monetarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perldgux - Perl under DG/UX.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perldgux - Perl bajo DG/UX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'unknown';</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T223513Z" changeid="explorer">
        <seg>'desconocido';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)* }x;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050243Z" changeid="explorer">
        <seg>)* }x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JAPH stands for &quot;Just another Perl hacker,&quot;, which Randal Schwartz used
to sign email and usenet messages starting in the late 1980s.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T231936Z" changeid="explorer">
        <seg>JAPH significa &quot;Just another Perl hacker&quot;. A finales de los ochenta, Randal Schwartz empezó a utilizar esta firma en mensajes de correo electrónico y usenet.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$arg = shift;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$arg = shift;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @HASH{keys %HASH};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @HASH{keys %HASH};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;There may be no
deprecation warning for v-strings&gt;, though: it is quite hard to detect when
v-strings are being used safely, and when they are not.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T010122Z" changeid="explorer">
        <seg>Sin embargo, B&lt;puede no haber advertencias con los v-strings&gt;: es muy difícil detectar cuándo los v-strings se están utilizando de forma segura, y cuándo no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$_ = &quot;ppooqppqq&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$_ = &quot;ppooqppqq&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $foo;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef $foo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatives are tried from left to right, so the first
alternative found for which the entire expression matches, is the one that
is chosen.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110917T223530Z" changeid="explorer">
        <seg>Las alternativas son procesadas de izquierda a derecha, de modo que la primera alternativa encontrada que coincida con toda la expresión, es la que es elegida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or for using call-by-named-parameter to complicated functions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o para utilizar llamadas con parámetros por nombre para funciones complicadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach ( @array ) {</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225554Z" changeid="explorer">
        <seg>foreach ( @array ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return $min if $min == $max;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225521Z" changeid="explorer">
        <seg>return $min if $min == $max;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using ExtUtils::MakeMaker, you can use &quot;make dist&quot; to create your
package.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T030901Z" changeid="explorer">
        <seg>Cuando se utiliza ExtUtils::MakeMaker, puede usar &quot;make dist&quot; para crear el paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DIRHANDLE may be an expression whose value can be used as an indirect
dirhandle, usually the real dirhandle name.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T020736Z" changeid="explorer">
        <seg>IDENTIFICADOR_DIR puede ser una expresión cuyo valor puede ser usado como un identificador de directorio indirecto, normalmente el nombre real del identificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[ &quot;fred&quot;, &quot;barney&quot; ],</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[ &quot;pedro&quot;, &quot;pablo&quot; ],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the following
will not match forever:
X&lt;\G&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, lo siguiente no coincidirá nunca:
X&lt;\G&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or how about sorted by key:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o de forma ordenada por la clave:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that myname() functions as a list operator, not as a unary operator;
so be careful to use C&lt;or&gt; instead of C&lt;||&gt; in this case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que minombre() funciona como un operador de lista, no como un operador unario; cuidado al usar C&lt;or&gt; en vez de C&lt;||&gt; en este caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;undef&gt; indicates
that the search position is reset (usually due to match failure, but
can also be because no match has yet been run on the scalar).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T175918Z" changeid="explorer">
        <seg>C&lt;undef&gt; indica que la posición de búsqueda se restablece (generalmente debido a un error de coincidencia, pero también puede ser porque aún no ha sido ejecutada la coincidencia sobre el escalar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An old feature of perl was that before C&lt;require&gt; or C&lt;use&gt; look for a
file with a F&lt;.pm&gt; extension, they will first look for a similar filename
with a F&lt;.pmc&gt; extension.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20111007T235405Z" changeid="explorer">
        <seg>Una vieja característica de perl antes de que C&lt;require&gt; o C&lt;use&gt; busquen por un archivo con una extensión F&lt;.pm&gt;, antes buscará por un nombre de archivo similar con una extensión F&lt;.pmc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@( = ('(','');</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225532Z" changeid="explorer">
        <seg>@( = ('(','');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Einstein&quot; =&gt; &quot;Albert&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;Einstein&quot; =&gt; &quot;Albert&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes to these modules
should be submitted to the maintainer of the CPAN module.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014501Z" changeid="explorer">
        <seg>Los cambios realizados en estos módulos deben enviarse al mantenedor del módulo de CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push @idx, uc($item);</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225600Z" changeid="explorer">
        <seg>push @idx, uc($item);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{3,6}               matches between 3 and 6 of the previous thing</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110130T230619Z" changeid="zipf">
        <seg>{3,6}               detecta entre 3 y 6 coincidencias de lo anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;mkdir()&gt; without arguments now defaults to C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T191920Z" changeid="explorer">
        <seg>C&lt;mkdir()&gt; sin argumentos ahora se refiere a C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These utilities help manage extra Perl modules that don't come with the perl
distribution.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110717T235023Z" changeid="explorer">
        <seg>Estas utilidades ayudan a administrar módulos Perl adicionales que no se incluyen en la distribución de perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>t/op/cmp.t</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T053459Z" changeid="explorer">
        <seg>t/op/cmp.t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $value (LIST) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $valor (LISTA) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of
processes successfully signaled (which is not necessarily the
same as the number actually killed).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de procesos señalados exitosamente (que no es necesariamente el mismo número de los llamados).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A warning
is emitted if the C&lt;use warnings&gt; pragma or the B&lt;-w&gt; command-line flag
(that is, the C&lt;$^W&gt; variable) was set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una advertencia es emitida si están activos el pragma C&lt;use warnings&gt; o la opción en línea de comandos B&lt;-w&gt; (es decir, la variable C&lt;$^W&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Pod::LaTeX</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110727T015244Z" changeid="explorer">
        <seg>=item Pod::LaTeX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
had been broken since version 5.10.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110605T230421Z" changeid="explorer">
        <seg>Esto se había roto desde la versión 5.10.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exceptions are substitution (s///)
and transliteration (y///) with the C&lt;/r&gt; (non-destructive) option,
which cause the B&lt;r&gt;eturn value to be the result of the substitution.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T184558Z" changeid="explorer">
        <seg>Las excepciones son las sustituciones (s///) y la transliteración (y///) con la opción C&lt;/r&gt; (no destructiva), que hace B&lt;r&gt;egresar como valor, el resultado de la sustitución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
unpack(), nybbles are converted to a string of hexadecimal digits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para unpack(), los nibles se convierten en una cadena de dígitos hexadecimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, it may
be a chain of identifiers, separated by C&lt;::&gt; (or by the slightly
archaic C&lt;'&gt;); all but the last are interpreted as names of packages,
to locate the namespace in which to look up the final identifier
(see L&lt;perlmod/Packages&gt; for details).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215233Z" changeid="explorer">
        <seg>En ciertos casos, puede ser una serie de identificadores separados por C&lt;::&gt; (o por el ligeramente arcaico C&lt;'&gt;); donde todos los identificadores menos el último se interpretan como nombres de paquetes que determinan el espacio de nombres en el que se buscará el identificador final (vea L&lt;perlmod/Packages&gt; para obtener los detalles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;say LIST&gt; is
simply an abbreviation for C&lt;{ local $\ = &quot;\n&quot;; print LIST }&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T011840Z" changeid="explorer">
        <seg>C&lt;say LISTA&gt; es simplemente una abreviatura de C&lt;{ local $\ = &quot;\n&quot;; print LISTA }&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If symbolic links are unimplemented on
your system, a normal C&lt;stat&gt; is done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los enlaces simbólicos no están implementados en su sistema, se hace un C&lt;stat&gt; normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;threads&gt; will now honour C&lt;no warnings 'threads'&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T040403Z" changeid="explorer">
        <seg>C&lt;threads&gt; ahora activará C&lt;no warnings 'threads'&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare L&lt;/split&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compare con L&lt;/split&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>push(@a,$x,$y)      splice(@a,@a,0,$x,$y)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>push(@a,$x,$y)      splice(@a,@a,0,$x,$y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perluniintro	Perl Unicode introduction</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perluniintro	Introducción a Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;JA&quot; | &quot;  ph\n&quot;;          	# prints &quot;japh\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;JA&quot; | &quot;  ph\n&quot;;          	# imprime &quot;japh\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$off, $width, $bits, $val, $res</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$despl, $ancho, $bits, $val, $res</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If package name is omitted, the C&lt;main&gt;
package as assumed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el nombre del paquete se omite, se asume que es C&lt;main&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has a mechanism for intermixing documentation with source code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl tiene un mecanismo para entremezclar documentación y código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;number, literal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;number, literal&gt; X&lt;número, literal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl5132delta	Perl changes in version 5.13.2</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T141438Z" changeid="explorer">
        <seg>perl5132delta	Cambios en la versión 5.13.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 $^X doesn't always contain a full path in FreeBSD</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 $^X no siempre contiene el camino completo en FreeBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to set the top-of-form format for more than one
output channel, you might do the following:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T013440Z" changeid="explorer">
        <seg>Por ejemplo, si tiene que fijar la parte superior del formato de un formulario para más de un canal de salida, puede hacer lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise arguments are
converted to floating point format and the floating point result is used.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T233910Z" changeid="explorer">
        <seg>De lo contrario, los argumentos se convierten al formato de punto flotante y se usa el resultado de punto flotante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a C&lt;foreach&gt; or a C&lt;given&gt;, a C&lt;default&gt; BLOCK acts like a C&lt;when&gt;
that's always true.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110726T232449Z" changeid="explorer">
        <seg>Dentro de un C&lt;foreach&gt; o un C&lt;given&gt;, un BLOQUE C&lt;default&gt; actúa como un C&lt;when&gt; que siempre es verdadero (siempre se ejecuta).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a regular expression match, i.e. C&lt;/REGEX/&gt; or C&lt;$foo =~ /REGEX/&gt;,
or a negated regular expression match (C&lt;!/REGEX/&gt; or C&lt;$foo !~ /REGEX/&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>una coincidencia con una expresión regular, es decir, C&lt;/REGEX/&gt; o C&lt;$foo =~ /REGEX/&gt;, o una negación de una coincidencia con una expresión regular (C&lt;!/REGEX/&gt; o C&lt;$foo !~ /REGEX/&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;string, literal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;string, literal&gt; X&lt;cadena, literal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to use long longs for the 64-bit integer type, in case you don't
have a 64-bit CPU.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110224T002856Z" changeid="explorer">
        <seg>para usar enteros largos para los tipos enteros de 64 bit, en caso de que no tenga una CPU de 64 bit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;last&gt; can be used to effect an early
exit out of such a block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, C&lt;last&gt; puede ser usado para salir prematuramente de este bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fcntl FILEHANDLE,FUNCTION,SCALAR
X&lt;fcntl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110718T010032Z" changeid="explorer">
        <seg>=item fcntl IDENTIFICADOR_ARCHIVO,FUNCIÓN,ESCALAR
X&lt;fcntl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#  0    1    2     3     4    5     6     7     8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#  0    1    2     3     4    5     6     7     8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this promotes action at a distance, this counterintuitive behavior
may be fixed in a future release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que provoca una acción extraña a gran distancia, este comportamiento no intuitivo puede ser arreglado en una futura distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, calling keys() in void context resets
the iterator with no other overhead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma particular, llamando a keys() en contexto nulo (void) resetea el iterador sin otro efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;undef&gt; is always treated as numeric, and in particular is changed
to C&lt;0&gt; before incrementing (so that a post-increment of an undef value
will return C&lt;0&gt; rather than C&lt;undef&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;undef&gt; es tratado siempre como numérico, y, en particular, es cambiado a C&lt;0&gt; antes de incrementar (de modo que un post-incremento de un valor undef devolverá C&lt;0&gt; en lugar de C&lt;undef&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The Triple-Dot Operator
X&lt;...&gt; X&lt;... operator&gt; X&lt;yada-yada operator&gt; X&lt;whatever operator&gt;
X&lt;triple-dot operator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T225050Z" changeid="explorer">
        <seg>=head2 El operador Triple Punto
X&lt;...&gt; X&lt;... operator&gt; X&lt;yada-yada operator&gt; X&lt;operador lo-que-sea&gt;
X&lt;operador triple punto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Name of the MRO, either in ISO-8859-1 or UTF-8.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T114042Z" changeid="explorer">
        <seg>Nombre de la MRO, ya sea en ISO-8859-1 o UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|| (gripe(), next LINE);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>|| (gripe(), next LINEA);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It prevents perl
from creating an empty scalar with every new typeglob.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T033831Z" changeid="explorer">
        <seg>Evita que perl cree un escalar vacío con cada nuevo typeglob.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't re-invent the wheel</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T013358Z" changeid="explorer">
        <seg>No vuelva a reinventar la rueda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For ease of access, the Perl manual has been split up into several sections.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para facilitar el acceso, el manual de perl se ha dividido en varias secciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\t                  tab               (HT, TAB)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T190008Z" changeid="explorer">
        <seg>\t		tab					(HT, TAB)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its rather blunt control of the
underlying algorithm may not persist into future Perls, but the
ability to characterize the input or output in implementation
independent ways quite probably will.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su contundente control del algoritmo subyacente quizás no persista en versiones futuras de Perl, pero la capacidad para caracterizar la entrada o salida en implementaciones independientes muy probablemente lo hará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the bottom of L&lt;perlfunc/&quot;open FILEHANDLE&quot;&gt;
for an example.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T023610Z" changeid="explorer">
        <seg>Ver la parte inferior de L&lt;perlfunc/&quot;open IDENTIFICADOR_ARCHIVO&quot;&gt; para un ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@b = (@a)[0,1];         # @b has no elements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@b = (@a)[0,1];         # @b no tiene elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An inner block may countermand this
by saying C&lt;no strict 'subs'&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un bloque interno puede revocar esto diciendo C&lt;no strict 'subs'&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because you have to
read a file to do the C&lt;-T&gt; test, on most occasions you want to use a C&lt;-f&gt;
against the file first, as in C&lt;next unless -f $file &amp;&amp; -T $file&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que tiene que leer el archivo para hacer el test C&lt;-T&gt;, en la mayoría de las ocasiones querrá usar primero C&lt;-f&gt;, como en C&lt;next unless -f $archivo &amp;&amp; -T $archivo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 DESIGNING AND WRITING YOUR MODULE</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T015552Z" changeid="explorer">
        <seg>=head1 DISEÑANDO Y ESCRIBIENDO SU MÓDULO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, C&lt;&quot;span&quot; ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por otra parte, C&lt;&quot;span&quot; ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
the personal note at the end of the README file in the perl source
distribution for more details.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110403T225056Z" changeid="explorer">
        <seg>Para obtener más información, consulte la nota personal que se incluye al final del archivo README de la distribución del código fuente de perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filename passed to the one- and two-argument forms of open() will
have leading and trailing whitespace deleted and normal
redirection characters honored.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110728T235127Z" changeid="explorer">
        <seg>Al nombre del archivo pasado a las formas de uno y dos argumentos de open() se le eliminarán los espacios en blanco iniciales y finales, y se activará la redirección por parte de los caracteres especiales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl
bug database at http://bugs.perl.org/.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted encuentra algo que piensa que es un error, podría verificar los artículos publicados recientemente en el grupo de noticias comp.lang.perl.misc y la base de datos de errores de perl en http://bugs.perl.org/.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;length undef&gt; now returns undef.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110706T005303Z" changeid="explorer">
        <seg>C&lt;length undef&gt; ahora devuelve undef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;/etc/games is no good, stopped&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;/etc/games no está bien, parado&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this and the following steps, the &quot;2&gt;&amp;1 | tee XXX.out&quot; records all
output from the process, which will be useful if anything unexpected
goes wrong.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T214716Z" changeid="explorer">
        <seg>En este y los siguientes pasos, el &quot;2&gt;&amp;1 | tee XXX.out&quot; registra toda la salida del proceso, que será útil si algo inesperado va mal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ones = (1) x 80;		# a list of 80 1's</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@unos = (1) x 80;		# una lista de 80 unos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is different from the C interfaces,
which return C&lt;-1&gt; on failure.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110404T001649Z" changeid="explorer">
        <seg>Esto es diferente de las interfaces en C, que devuelven C&lt;-1&gt; en caso de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any simple statement may optionally be followed by a I&lt;SINGLE&gt; modifier,
just before the terminating semicolon (or block ending).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110203T013020Z" changeid="explorer">
        <seg>Cualquier instrucción simple puede ser seguida opcionalmente por un I&lt;ÚNICO&gt; modificador, justo antes del punto y coma final (o del final del bloque).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return *FH;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return *FH;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ perl -MTime::Piece -le 'print localtime-&gt;mjd'</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225525Z" changeid="explorer">
        <seg>$ perl -MTime::Piece -le 'print localtime-&gt;mjd'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf '&lt;%e&gt;', 10;   # prints &quot;&lt;1.000000e+01&gt;&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf '&lt;%e&gt;', 10;   # imprime &quot;&lt;1.000000e+01&gt;&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Just another Perl hacker,&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110401T232004Z" changeid="explorer">
        <seg>print &quot;Just another Perl hacker,&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It didn't really fail to match anything.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No ha fallado al corresponder con cualquier cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$salida = `comando 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># require 5.14 for when as statement modifier</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T234626Z" changeid="explorer">
        <seg># requiere 5.14 para usar when como un modificador de instrucción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;feature&gt; pragma is used to enable new syntax that would break Perl's
backwards-compatibility with older releases of the language.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110617T192853Z" changeid="explorer">
        <seg>El pragma C&lt;feature&gt; se utiliza para activar una nueva sintaxis que rompe la compatibilidad Perl con versiones anteriores del lenguaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example showing the behavior for boundary cases:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí un ejemplo que muestra el comportamiento para los casos límite:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * F&lt;dist/&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T014423Z" changeid="explorer">
        <seg>=item * F&lt;dist/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I.e. do:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, haga:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pragma establishes an ISA relationship with base classes at compile
time.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110921T145418Z" changeid="explorer">
        <seg>Este pragma establece una relación ISA con clases base en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The file is created with permissions of C&lt;0666&gt;
modified by the process's C&lt;umask&gt; value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El archivo se crea con permisos de C&lt;0666&gt; modificados por el valor de C&lt;umask&gt; del proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head3 Character Classes and other Special Escapes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head3 Clase carácter y otros escapados especiales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;$_&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;$_&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows distribution authors to specify configuration prerequisites that
must be installed before running F&lt;Makefile.PL&gt; or F&lt;Build.PL&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T151810Z" changeid="explorer">
        <seg>Esto permite a los autores de la distribución especificar los requisitos previos de configuración que deben estar instalados antes de ejecutar F&lt;Makefile.PL&gt; o F&lt;Build.PL&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl test suite may still report some errors on the Hurd.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110822T020018Z" changeid="explorer">
        <seg>El conjunto de pruebas de Perl podría detectar errores en Hurd.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlhack		Perl hackers guide</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlhack		Guía para hackers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most text file processing
can be done a line at a time with Perl's looping constructs.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110301T225347Z" changeid="explorer">
        <seg>Gran parte de las tareas de procesamiento de archivos de texto se puede hacer de línea en línea con las estructuras de bucle de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It really does shift the @ARGV array and put the current filename
into the $ARGV variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Realmente, desplaza el array @ARGV y pone el nombre del archivo actual en la variable $ARGV.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://dickey.his.com/vile/vile.html</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>http://dickey.his.com/vile/vile.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is the character specified by the octal number between the braces.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110524T205613Z" changeid="explorer">
        <seg>El resultado es el carácter especificado por el número octal entre las llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp;  # avoid \n on last field</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T170141Z" changeid="explorer">
        <seg>chomp;  # evitar \n en el último campo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $out, &quot;&gt;&quot;,  &quot;output.txt&quot;) or die &quot;Can't open output.txt: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110228T031019Z" changeid="explorer">
        <seg>open(my $salida,   &quot;&gt;&quot;,  &quot;salida.txt&quot;)  or die &quot;No se puede abrir salida.txt: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is at the mercy of your machine's definitions of various
operations such as type casting, atof(), and floating-point
output with sprintf().</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T001717Z" changeid="explorer">
        <seg>Perl depende de las definiciones de hardware para diversas operaciones, como la conversión de tipos, atof() o la salida de números de punto flotante con sprintf().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>last LINE if /^$/;  # exit when done with header</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>last LINE if /^$/;  # salir cuando se termine la cabecera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is the character specified by the three-digit octal number in the
range 000 to 777 (but best to not use above 077, see next paragraph).</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T232159Z" changeid="explorer">
        <seg>El resultado es el carácter especificado por el número octal de tres dígitos en el rango 000 a 777 (pero es mejor no superar el 077, ver siguiente párrafo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item vector flag</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item vector de banderas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While some modules retain uppercase or hyphenated argument
keys for historical reasons or as a matter of personal style, most new
modules should use simple lower case keys.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022833Z" changeid="explorer">
        <seg>Si bien algunos módulos retienen los argumentos en mayúsculas o con guión por razones históricas o como una cuestión de estilo personal, la mayoría de los nuevos módulos deberían utilizar las claves escritas en minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item do EXPR
X&lt;do&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T171438Z" changeid="explorer">
        <seg>=item do EXPR
X&lt;do&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;C&lt;&lt; -&gt; &gt;&gt;&quot; is an infix dereference operator, just as it is in C
and C++.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;C&lt;&lt; -&gt; &gt;&gt;&quot; es un operador infijo de desreferencia, tal como es en C y C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exchanging signed integers between different platforms works only 
when all platforms store them in the same format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intercambiando enteros con signo entre distintas plataformas funciona sólo cuando todas las plataformas los almacenan en el mismo formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>no integer;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>no integer;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From each search string,
the rarest character is selected, based on some static frequency tables
constructed from some C programs and English text.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De cada cadena de búsqueda, se selecciona el carácter más raro, en función de algunas tablas de frecuencia estática construidas a partir de algunos programas en C y texto en Inglés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It refers to the pseudo file
formed from the files listed on the command line and accessed via the
C&lt;&lt; &lt;&gt; &gt;&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se refiere a un pseudo archivo formado por los archivos listados en la línea de comandos y accedidos vía el operador C&lt;&lt; &lt;&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hash{get_a_key_for($_)} = $_;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$hash{una_clave_para($_)} = $_;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which one you pick depends on which of these expressions better reflects
the above specification of comments.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110815T221950Z" changeid="explorer">
        <seg>El cuál escoger depende de cuál de estas expresiones refleja mejor la especificación anterior, de esos comentarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;when&gt; is analogous to the C&lt;case&gt; keyword in other languages.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T025140Z" changeid="explorer">
        <seg>C&lt;when&gt; es análogo a la palabra clave C&lt;case&gt;, de otros lenguajes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value is unaffected by any forward
declarations of C&lt;&amp;func&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto no es afectado por ninguna declaración posterior de C&lt;&amp;func&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;strict&gt; is highly recommended.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es muy recomendable usar C&lt;strict&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec { $args[0] } @args;  # safe even with one-arg list</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec { $args[0] } @args;  # seguro incluso con una lista de un argumento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step is listed for completeness only.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este paso está aquí descrito solo por completar la documentación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = ();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = ();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This prints</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110729T050341Z" changeid="explorer">
        <seg>Esto imprime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;flock&gt; is Perl's portable file-locking interface, although it locks
entire files only, not records.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T161402Z" changeid="explorer">
        <seg>C&lt;flock&gt; es el interfaz portable de Perl para e bloqueo de archivo, aunque sólo bloquea archivos enteros, no registros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be sure to trim your bug down
to a tiny but sufficient test case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Asegúrese de reducir la aparición del error en un programa que sea pequeño, pero suficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perl590delta&gt; for the differences between
5.8.0 and 5.9.0.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110710T215147Z" changeid="explorer">
        <seg>Vea L&lt;perl590delta&gt; para las diferencias entre 5.8.0 y 5.9.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The issue of whether to pass the arguments in a hash or a hashref is
largely a matter of personal style.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T022505Z" changeid="explorer">
        <seg>La cuestión de si se debe pasar los argumentos en un hash o una referencia a un hash es en gran medida una cuestión de estilo personal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item MicroEMACS</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225452Z" changeid="explorer">
        <seg>=item MicroEMACS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hints now supports versions 5.*.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T153128Z" changeid="explorer">
        <seg>Los consejos ahora son compatibles con las versiones 5.*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider this pattern:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T013304Z" changeid="explorer">
        <seg>Considere este patrón:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No interpolation is performed at this stage.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se realiza interpolación en esta etapa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This meant that trying to print, say,
chr(0xff), ended up printing the bytes 0xc3 0xbf.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110730T143906Z" changeid="explorer">
        <seg>Esto significaba que intentando imprimir, por ejemplo, chr(0xff), terminaba imprimiendo los bytes 0xc3 0xbf.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item make install</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110328T024929Z" changeid="explorer">
        <seg>=item make install</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 More precise warnings</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Advertencias más precisas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item grep BLOCK LIST
X&lt;grep&gt;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110202T173907Z" changeid="explorer">
        <seg>=item grep BLOQUE LISTA
X&lt;grep&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak reference creation is now I&lt;O(1)&gt; rather than I&lt;O(n)&gt;, courtesy of
Nicholas Clark.</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110402T042154Z" changeid="explorer">
        <seg>La creación de referencias débiles es ahora I&lt;O(1)&gt; en lugar de I&lt;O(n)&gt;, cortesía de Nicholas Clark.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://e-p-i-c.sf.net/</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110719T225450Z" changeid="explorer">
        <seg>http://e-p-i-c.sf.net/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 New support for Abstract namespace sockets</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110824T151910Z" changeid="explorer">
        <seg>=head2 Nuevo soporte para el espacio de nombres de los sockets Abstract</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\r                  return            (CR)</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110514T185959Z" changeid="explorer">
        <seg>\r		retorno					(CR)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cc: &quot;/usr/include/sys/socket.h&quot;, line 505: warning 562:</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110816T003736Z" changeid="explorer">
        <seg>cc: &quot;/usr/include/sys/socket.h&quot;, line 504: warning 562:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1  &quot;barney&quot;</seg>
      </tuv>
      <tuv lang="ES-ES" changedate="20110720T032544Z" changeid="explorer">
        <seg>1  &quot;pablo&quot;</seg>
      </tuv>
    </tu>
  </body>
</tmx>
