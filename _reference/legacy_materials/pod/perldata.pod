=head1 NOMBRE

perldata - Tipos de datos de Perl

=head1 DESCRIPCIÓN

=head2 Nombres de variable
X<variable, nombre> X<nombre de variable> X<tipo de dato> X<tipo>

Perl tiene tres estructuras de datos incorporadas al lenguaje:
Los escalares, los arrays de escalares, y los arrays
asociativos de escalares, también conocidos como "hashes".
Un escalar es una cadena de caracteres (de cualquier tamaño,
limitada únicamente por la memoria disponible), un número o
una referencia a algo (esto se tratará en L<perlref>). Los
arrays normales son listas ordenadas de escalares indexadas
por números, empezando por 0.  Los hashes son colecciones
no ordenadas de valores escalares indexadas por sus claves
asociadas, que son cadenas de caracteres.

A los valores se accede normalmente por su nombre, o a
través de una referencia con nombre. El primer símbolo del
nombre nos dice a qué tipo de estructura de datos se está
accediendo. El resto del nombre indica a qué valor particular
se accede.  Normalmente, este nombre es un I<identificador>,
es decir, una palabra que comienza por una letra o carácter
de subrayado y que contiene letras, caracteres de subrayado
o dígitos numéricos.  En ciertos casos, puede ser una serie
de identificadores separados por C<::> (o por el ligeramente
arcaico C<'>); donde todos los identificadores menos el último
se interpretan como nombres de paquetes que determinan el
espacio de nombres en el que se buscará el identificador final
(véase L<perlmod/Packages> para obtener más detalles). También,
es posible sustituir un simple identificador por una expresión
que produzca una referencia al valor en tiempo de ejecución.
Ésto se describe con mayor detalle más abajo y en L<perlref>.
X<identificador>

Perl también tiene su propias variables incorporadas cuyos
nombres no siguen estas reglas. Éstas tienen extraños nombres,
y por tanto no pueden colisionar accidentalmente con ninguna
de las variables normales que usted haya creado.  Las cadenas
que coinciden con las partes encerradas entre paréntesis de
una expresión regular se guardan con nombres que contienen
sólo dígitos después del C<$> (véase L<perlre> y L<perlop>).
Además, ciertas variables especiales que proporcionan acceso al
medio interno de Perl tienen nombres que contienen caracteres
de puntuación y caracteres de control. Éstas están documentadas
en L<perlvar>.
X<variable, incorporado>

Los valores escalares se nombran siempre con '$', incluso cuando
se accede a un escalar que es parte de un array o un hash.
El signo '$' funciona semánticamente como en español el artículo
"el", indicando que se espera un único valor.
X<scalar>

    $dias		# el simple valor escalar llamado "dias"
    $dias[28]		# el elemento número 29 del array @dias
    $dias{'Feb'}	# el valor 'Feb' del hash %dias
    $#dias		# el último índice del array @dias

Los arrays enteros (y las porciones de arrays o hashes)
son designados por '@', que funciona como los determinantes
"estos" o "esos" del español, indicando que se esperan
múltiples valores.
X<array>

    @dias		# ($dias[0], $dias[1],... $dias[n])
    @dias[3,4,5]	# igual que ($dias[3],$dias[4],$dias[5])
    @dias{'a','c'}	# igual que ($dias{'a'},$dias{'c'})

Los hashes enteros se designan por '%':
X<hash>

    %dias		#  (clave1, valor1, clave2, valor2 ...)

Además de lo anterior, las subrutinas se nombran empezando por
'&', aunque ésto es opcional cuando no provoque ambigüedad,
igual que el sujeto de una frase en español es a menudo
redundante cuando va implícito en el verbo, como en "(yo) tengo
lo que usted necesita".  Las entradas de la tabla de símbolos
pueden nombrarse empezando por '*', aunque aún no hace falta
que se preocupe por esto último (y quizá nunca deba hacerlo :-).

Cada tipo de variable tiene su propio espacio de nombres,
y ocurre igual con otros tipos de identificadores que no
designan variables.  Esto significa que usted puede, sin temor a
conflictos, utilizar el mismo nombre para una variable escalar,
un array o un hash --o, por la misma razón, para un manejador de
archivo, un manejador de directorio, el nombre de una subrutina,
un nombre de formato o una etiqueta.  Significa entonces que
$foo y @foo son dos variables distintas.  También significa
que $foo[1] es parte de @foo, no parte de $foo.  Ésto podría
parecer un poco extraño, pero está bien así, porque es extraño.
X<espacio de nombres>

Puesto que los nombres de variables siempre empiezan por '$',
'@', o '%', las palabras "reservadas", de hecho, no están
reservadas con respecto a nombres de variables.  Sí I<están>
reservadas, sin embargo, para las etiquetas y manejadores
de archivo, ya que éstos no tienen un carácter especial
al comienzo.  No se puede tener un manejador de archivo
llamado "log", por ejemplo.  Un consejo: es mejor escribir
C<open(LOG,'archlog')> que C<open(log,'archlog')>.  Utilizar
manejadores de archivo en mayúsculas mejora la legibilidad
de los programas y les protege de conflictos con futuras
palabras reservadas).  Las letras mayúsculas y minúsculas I<son>
distintas: "FOO", "Foo" y "foo" son todos nombres diferentes.
Los nombres que empiezan por una letra o el símbolo de subrayado
pueden incluir también dígitos y subrayados.
X<identificador, diferencia entre mayúsculas y minúsculas>
X<mayúsculas o minúsculas>

Es posible sustituir cualquier nombre alfanumérico por una
expresión que devuelva una referencia a un dato del tipo
apropiado.  Para una descripción de ésto, véase L<perlref>.

Los nombres que comienzan con un dígito, solamente pueden
incluir más dígitos.  Los nombres que no empiecen ni por letra,
ni subrayado, ni dígito, ni acento circunflejo (es decir,
un carácter de control) están limitados a un solo carácter,
como por ejemplo C<$%> o C<$$> (la mayoría de estos nombres de
un solo carácter tienen un significado predefinido para Perl.
Por ejemplo, C<$$> es el ID del proceso actual).

=head2 Contexto
X<contexto> X<contexto escalar> X<contexto de lista>

La interpretación de las operaciones y los valores en Perl
depende a veces de las necesidades del contexto en el que se
encuentra la operación o el valor.  Hay dos tipos principales de
contexto: de lista y escalar.  Ciertas operaciones devuelven
una lista de valores en contextos que esperan una lista,
y valores escalares en caso contrario (si ésto es cierto
para una determinada operación, entonces estará mencionado
en la documentación de esa operación).  En otras palabras,
Perl sobrecarga ciertas operaciones basándose en si el
valor de retorno esperado es singular o plural. Existen
algunas palabras en español que funcionan de esa manera, como
"crisis", "ciempiés" o "lunes", que actúan de singular o plural
dependiendo del contexto.

De forma recíproca, cualquier operación establece un contexto
escalar o un contexto de lista para cada uno de sus argumentos.
Por ejemplo, si se escribe

    int( <STDIN> )

la operación int (entero) establece un contexto escalar para
el operador <>, que responde leyendo una línea de STDIN y
enviándola de vuelta a la operación int, la cual entonces busca
el valor entero de esa línea y lo devuelve.  Por otra parte,
si se escribe

    sort( <STDIN> )

entonces la operación sort (ordenar) establece un contexto
de lista para <>, el cual procede a leer todas las líneas
disponibles hasta alcanzar el final del fichero, y envía de
vuelta esa lista de líneas a la subrutina sort, que entonces
ordena las líneas y las devuelve como una lista o lo que sea
dependiendo de cuál sea el contexto de sort.

La asignación es un poco especial en el sentido de que utiliza
su argumento de la izquierda para determinar el contexto
del argumento de la derecha.  La asignación a un escalar
evalúa lo que hay en el lado derecho en contexto escalar,
mientras que la asignación a un array o a un hash evalúa el
lado derecho en contexto de lista. La asignación a una lista
(o a una porción, que también es una lista después de todo)
también evalúa el lado derecho en contexto de lista.

Cuando se utiliza el pragma C<use warnings> o la opción de
Perl en la línea de órdenes B<-w>, pueden mostrarse avisos
sobre el uso inútil de constantes o funciones en "void context"
(contexto vacío). El contexto vacío significa simplemente que el
valor ha sido descartado, como en una instrucción que contenga
solamente C<"fred";> o C<getpwuid(0);>.  Además, también cuenta
como contexto escalar para las funciones que se preocupan de
saber si han sido llamadas en contexto de lista o no.

Las subrutinas definidas por el usuario tienen la opción
de considerar si están siendo llamadas en contexto vacío,
escalar o de lista. Sin embargo, la mayoría de las subrutinas
no necesitan encargarse de ello. Esto es porque ambos tipos,
escalares y listas, son automáticamente interpolados en listas.
Véase L<perlfunc/wantarray> para saber cómo se averiguaría
dinámicamente el contexto en el cual se llamó a una función.

=head2 Valores escalares
X<escalar> X<número> X<cadena> X<referencia>

Todo dato en Perl es un escalar, un array de escalares o un
hash de escalares. Un escalar puede contener un único valor
perteneciente a un tipo de entre tres distintos: Un número,
una cadena o una referencia. En general, la conversión entre
uno y otro tipo es transparente.  Aunque un escalar no puede
contener directamente múltiples valores, podría contener una
referencia a un array o un hash, los cuales a su vez sí que
pueden contener múltiples valores.

Los escalares no tienen que ser necesariamente una cosa o
la otra.  No hay ninguna forma de declarar que una variable
escalar sea de tipo "cadena", tipo "número", tipo "referencia"
o de cualquier otro. Debido a que la conversión de escalares
es automática, las operaciones que los devuelven no necesitan
tener en cuenta (y, de hecho, no pueden hacerlo), si quien ha
hecho la petición está esperando una cadena, un número o una
referencia.  Perl es un lenguaje polimórfico según el contexto,
cuyos escalares pueden ser cadenas, números o referencias
(las cuales incluyen a los objetos). Aunque las cadenas y los
números son consideradas prácticamente la misma cosa para la
mayoría de los propósitos, las referencias son punteros no
convertibles y fuertemente tipados, que llevan un contador de
referencias incorporado y una invocación al destructor.

Un valor escalar se interpreta como VERDADERO, en el sentido
Booleano, si no es la cadena nula ni el número 0 (ni su cadena
equivalente "0"). El contexto Booleano es simplemente un tipo
especial de contexto escalar para el cual ni siquiera se llega
a realizar alguna conversión a cadena o a número.
X<booleano> X<bool> X<verdadero> X<falso> X<verdad>

Hay en realidad dos tipos de cadenas nulas (a las que algunas
veces nos referimos como cadenas "vacías"); una definida y otra
no definida.  La versión definida es simplemente una cadena de
longitud cero, tal como C<"">. La versión no definida es el
valor que indica que no existe ningún valor real para algo,
como cuando hubo un error, se alcanzó el fin de fichero, o
cuando se hace referencia a una variable o un elemento de array
o hash no inicializados.  Aunque en las versiones antiguas de
Perl, un escalar no definido podía llegar a ser definido la
primera vez que se usaba en cualquier lugar que esperase un
valor definido, esto no va a ocurrir más, excepto en los raros
casos de "autovivificación" que se explican en L<perlref>.
Se puede usar el operador defined() para determinar si un
valor escalar está definido (esto no tiene significado si se
aplica a arrays o hashes), y el operador undef() para producir
un valor no definido.
X<definido> X<no definido> X<undef> X<nulo> X<cadena, nulo>

Para saber si una cadena dada es un número válido distinto de
cero, a veces es suficiente con compararlo con el 0 numérico y
también con el "0" léxico (aunque esto provocará advertencias
si los avisos están activados). Esto es porque las cadenas que
no son números cuentan como 0, igual que se comportan en B<awk>:

    if ($cad == 0 && $cad ne "0")  {
	warn "Eso no parece un número";
    }

Este método podría ser mejor porque de otro modo no se tratarán
apropiadamente las notaciones IEEE como C<Nan> o C<Infinity>.
En otras ocasiones, podría ser preferible determinar si una
cadena de datos puede ser usada numéricamente llamando a la
función POSIX::strtod() o inspeccionando la cadena con una
expresión regular (las cuales están documentadas en L<perlre>).

    warn "tiene no dígitos"     if     /\D/;
    warn "no es número natural" unless /^\d+$/;             # rechaza -3
    warn "no es un entero"      unless /^-?\d+$/;           # rechaza +3
    warn "no es un entero"      unless /^[+-]?\d+$/;
    warn "no es un número real" unless /^-?\d+\.?\d*$/;     # rechaza .2
    warn "no es un número real" unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;
    warn "no es un flotante de C"
	unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;

La longitud de un array es un valor escalar. Puede conocerse
la longitud del array @dias evaluando C<$#dias>, como en
B<csh>.  Sin embargo, esto no es la longitud del array, sino
el subíndice del último elemento, que es un valor distinto ya
que ordinariamente hay un elemento número 0. Asignar un valor
a C<$#dias> cambia realmente la longitud del array. Acortar un
array de esta forma destruye los valores involucrados. Alargar
un array que ha sido acortado previamente no permite recuperar
los valores que había en esos elementos (así solía hacerse en
Perl 4, aunque aunque tuvimos que cambiarlo para asegurar que
los destructores eran llamados cuando se esperaba).
X<$#> X<array, longitud>

También se puede ganar una minúscula cantidad de eficiencia
pre-extendiendo un array que va a hacerse grande. También
se puede extender un array asignando a un elemento que esté
más allá del final del array. Puede truncarse un array para
dejarlo vacío asignando la lista nula () a él. Las siguientes
instrucciones son equivalentes:

    @loquesea = ();
    $#loquesea = -1;

Si se evalúa un array en un contexto escalar, éste devuelve
la longitud del array (nótese que esto no es cierto para las
listas, que devuelven el último valor, como el operador coma
de C, y tampoco para las funciones incorporadas, que devuelven
lo que les parezca mejor devolver). Lo siguiente es siempre
verdadero:
X<array, longitud>

    scalar(@loquesea) == $#loquesea - $[ + 1;

La versión 5 de Perl cambió la semántica de C<$[>: Los archivos
que no asignen un valor a C<$[> no necesitan preocuparse nunca
más de si otro archivo ha cambiado su valor (en otras palabras,
el uso de C<$[> está desaconsejado). Por ello, en general, se
puede asumir que
X<$[>

    scalar(@loquesea) == $#loquesea + 1;

Algunos programadores eligen usar una conversión explícita
para que no haya ninguna duda:

    $num_elementos = scalar(@loquesea);

Si se evalúa un hash en contexto escalar, devuelve falso si el hash
está vacío. Si tiene algún par clave/valor, devuelve verdadero; Más
exactamente, el valor devuelto es una cadena que consiste en el número
de cajones utilizados y el número de cajones reservados, separados por
una barra. Esto es útil solamente para conocer si el algoritmo interno de
los hashes está teniendo un bajo rendimiento sobre un conjunto de datos.
Por ejemplo, supóngase que se insertan 10.000 valores en un hash,
pero al evaluar el %HASH en contexto escalar nos devuelve C<"1/16">, lo
cual significa que sólo una de cada dieciséis unidades ha sido tocada,
y se sabe que contiene todos los 10.000 elementos. Se supone que esto
no debe ocurrir.
X<hash, contexto escalar> X<hash, cajón> X<cajón>

Se puede pre-reservar espacio para un hash asignando a la función
keys(). Esto redondea el número de cajones reservados a la siguiente
potencia de dos:

    keys(%usuarios) = 1000;		# reserva 1024 cajones

=head2 Constructores de valores escalares
X<escalar, literal> X<escalar, constante>

=head3 Cadenas de versión

=head3 Literales especiales

=head3 Palabras sueltas

=head3 Delimitador para unir arrays

=head2 Constructores de valores de lista

=head2 Subíndices

=head2 Porciones

=head2 Tipos globales y Manejadores de archivo

=head1 VÉASE TAMBIÉN

Véase L<perlvar> para una descripción de las variables incorporadas de
Perl y un discusión sobre nombres de variables válidos. Véase L<perlref>,
L<perlsub> y L<perlmod/"Tablas de símbolos"> para obtener más información
sobre tipos globales y la sintaxis C<*foo{ALGO}>.

=head1 TRADUCCIÓN

=head2 TRADUCTOR

  Traducción a cargo de Carlos Rica <jasampler@sourceforge.net>

