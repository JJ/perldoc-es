=head1 NOMBRE
X<sintaxis>

perlsyn - Sintaxis Perl

=head1 DESCRIPCIÓN

Un programa Perl consiste en una secuencia de declaraciones y sentencias
que se ejecutan de arriba a abajo.  Bucles, subrutinas y otras estructuras
de control le permiten saltar a lo largo del código.

Perl es un lenguaje de B<forma libre>, puede formatearlo y sangrarlo como
quiera.  El espacio en blanco sirve para separar tokens, a diferencia de
lenguajes como Python donde es una parte importante de la sintaxis.

Muchos de los elementos sintácticos de Perl son B<opcionales>.  En vez de
obligarle a poner paréntesis en todas las llamadas de función y declarar
cada variable, puede, a menudo, dejar algunos elementos de forma explícita
y Perl intentará adivinar lo que quiere decir.  Esto es conocido como B<Do
What I Mean> (haz lo que digo), abreviado como B<DWIM>.  Permite a los
programadores ser B<perezosos> y codificar en un estilo en que se
encuentran más cómodos.

Perl B<toma prestada sintaxis> y conceptos de muchos lenguajes: awk, sed,
C, Bourne Shell, Smalltalk, Lisp e incluso inglés.  Otros lenguajes han
tomado prestada la sintaxis de Perl, particularmente sus extensiones de
expresiones regulares.  Así que si ha programado en otro lenguaje verá
partes en Perl que le serán familiares.  A menudo funcionan de la misma
forma, pero mire L<perltrap> para ver en cómo difieren.

=head2 Declaraciones
X<declaración> X<undef> X<indefinido> X<no inicializado>

Los únicos elementos que necesita declarar en Perl son los informes y las
subrutinas (y algunas veces ni siquiera las subrutinas).  Una variable
almacena el valor indefinido (C<undef>) hasta que le es asignado un valor
definido, que es cualquier otra cosa que no sea C<undef>.  Cuando se usa
como un número, C<undef> es tratado como C<0>; cuando se usa como una
cadena de caracteres (I<string>), se trata como el string vacío, C<"">; y
cuando se usa como una referencia que no ha sido asignada, es tratado como
un error.  Si ha activado los avisos (warnings), será notificado de un
valor no inicializado cuando trate C<undef> como un string o número. 
Bueno, normalmente.  En contextos booleanos, como en:

    my $a;
    if ($a) {}

están exentos de los avisos (porque se fijan en el valor de verdad en vez
de ver si está definido).  Operadores como C<++>, C<-->, C<+=>, C<-=> y
C<.=>, que operan sobre valores no definidos como en:

    my $a;
    $a++;

están también exentos de tales avisos.

Una declaración puede ponerse en  cualquier sitio, como si fuera una
sentencia, pero no tiene efecto en la ejecución de las secuencias de
sentencias; todas las declaraciones toman efecto en tiempo de compilación.
 Típicamente, todas las declaraciones se ponen al comienzo o al final del
script.  Sin embargo, si está usando variables privadas de un contexto
local creadas con C<my()>, deberá asegurarse que su definición de formato
o subrutina están dentro del mismo bloque que el C<my> si quiere acceder a
estas variables privadas.

Declarar una subrutina permite que su nombre sea usado como si fuera un
operador de lista desde el punto de vista del programa.  Puede declarar
una subrutina sin definirla diciendo C<sub nombre>, como: X<subrutina,
declaración>

    sub minombre;
    $yo = minombre $0 		or die "no puedo obtener minombre";

Note que minombre() funciona como un operador de lista, no como un
operador unario; cuidado al usar C<or> en vez de C<||> en este caso.  Sin
embargo, si declara la subrutina como C<sub minombre ($)>, entonces
C<minombre> funcionará como un operador unario, así que servirán tanto
C<or> como C<||>.

Las declaraciones de subrutinas pueden cargarse también con la sentencia
C<require> o cargadas e importadas en su espacio de nombres con la
sentencia C<use>.
Ver L<perlmod> para detalles sobre esto.

Una secuencia de sentencias pueden contener declaraciones de variables de
ámbito léxico (privado), pero aparte de declarar un nombre de variable, la
declaración actúa como una sentencia normal y es elaborada dentro de la
secuencia de sentencias como si fuera una sentencia normal.  Esto
significa que tiene efectos tanto en tiempo de compilación como en tiempo
de ejecución.

=head2 Comentarios
X<comentario> X<#>

El texto desde un carácter C<"#"> hasta el fin de la línea es un
comentario y es ignorado.  Excepciones a esto son la inclusión de C<"#">
dentro de un string o una expresión regular.

=head2 Sentencias simples
X<sentencia> X<punto y coma> X<expresión> X<;>

La única clase de sentencia simple que existe es una expresión evaluada
por sus efectos colaterales.  Cada sentencia simple debe terminarse en un
punto y coma excepto si es la última sentencia de un bloque, en cuyo caso
el punto y coma es opcional.  (Un punto y coma es aún así recomendable si
el bloque tiene más de una línea, porque, eventualmente, puede añadir
alguna línea más). Note que algunos operadores como C<eval {}> y C<do {}>
parecen sentencias compuestas, pero no lo son (son sólo TÉRMINOS en una
expresión) y es necesario una terminación explícita si se usa como el
último punto de una sentencia.

=head2 Verdad y Falsedad
X<verdad> X<falsedad> X<true> X<false> X<!> X<not> X<negación> X<0>

El número 0, las cadenas C<'0'> y C<''>, la cadena vacía C<()> y C<undef>
son todos falsos en contexto booleano. Todos los otros valores son
verdadero.
La negación del valor de verdadero con C<!> o C<not> devuelve un valor
falso especial.
Cuando es evaluado como cadena es tratado como C<''>, pero como número es
tratado como 0.

=head2 Modificadores de sentencias
X<modificador de sentencias> X<modificador> X<if> X<unless> X<while>
X<until> X<foreach> X<for>

Cualquier sentencia simple puede ser seguida opcionalmente por un I<ÚNICO>
modificador, justo antes del punto y coma final (o del final del bloque). 
Los posibles modificadores son:

    if EXPR
    unless EXPR
    while EXPR
    until EXPR
    foreach LISTA

La C<EXPR> siguiente al modificador es referida como "condición".
Su verdad o falsedad determina como se comportará el modificador.

C<if> ejecuta la sentencia una vez I<sí> y sólo si la condición es
verdadera.  C<unless> es el opuesto, ejecuta la sentencia si la condición
I<no es> verdadera (e.d., si la condición es falsa).

    print "El perro Basset tiene largas orejas" if length $oreja >= 10;
    vete_fuera() and juega() unless $esta_lloviendo;

El modificador C<foreach> es un iterador: ejecuta la sentencia una vez por
cada elemento en la LISTA (con C<$_> asociado a cada elemento en cada
iteración).

    print "Hola $_!\n" foreach qw(mundo Dolly enfermera);

C<while> repite la sentencia I<mientras> la condición sea cierta.
C<until> hace lo opuesto, repite la sentencia I<hasta> que la condición
sea verdadera (o mientras la condición sea falsa):

    # Estas dos líneas cuentas de 0 a 10.
    print $i++ while $i <= 10;
    print $j++ until $j >  10;

Los modificadores C<while> u C<until> tienen la usual semántica de los
"bucles C<while>" (la condición se evalúa primero), excepto cuando se
aplica a un bloque C<do> (o a la depreciada sentencia subrutina C<do>), en
cuyo caso el bloque se ejecuta una vez antes de sea evaluada la condición. 
De esa manera puede escribir bucles como este:

    do {
	$linea = <STDIN>;
	...
    } until $linea  eq ".\n";

Ver L<perlfunc/do>.  Note también que las sentencias de control de bucles
descritas más adelante I<NO> funcionarán con esta construcción, porque los
modificadores no toman etiquetas de bucle.  Lo sentimos.  Siempre puede
poner otro bloque dentro de él  (para C<next>) o alrededor de él (para
C<last>) para hacer esta suerte de cosas.
Para C<next>, solamente doble las llaves: 
X<next> X<last> X<redo>

    do {{
	next if $x == $y;
	# hacer algo aquí
    }} until $x++ > $z;

Para C<last>, tiene que ser un poco más elaborado:
X<last>

    BUCLE: { 
	    do {
		last if $x = $y**2;
		# hacer algo aquí
	    } while $x++ <= $z;
    }

B<NOTA:> El comportamiento de una sentencia C<my> modificada con una
sentencia de modificador condicional o construcción de bucle (p.e. C<my $x
if ...>) es B<indefinido>.  El valor de la variable C<my> puede ser
C<undef>, cualquier valor anteriormente asignado , o posiblemente
cualquier otra cosa.  No confíe en él.  Futuras versiones de perl pueden
hacer algo diferente de la versión de perl que esté probando.  Here be
dragons[1].
X<my>

=head2 Sentencias compuestas
X<sentencia, compuesta> X<bloque> X<llave, paréntesis> X<corchete>
X<{> X<}> X<if> X<unless> X<while> X<until> X<foreach> X<for> X<continue>

En Perl, una secuencia de sentencias que define un ámbito se llama un
bloque.
Algunas veces un bloque está delimitado por el fichero que lo contiene (en
el caso de un fichero requerido, o el programa entero) y otras veces un
bloque está delimitado por la extensión de un string (en el caso de un
eval).

Pero generalmente, un bloque está delimitado por llaves.
Llamaremos a esta construcción sintáctica un BLOQUE.

Las siguientes sentencias compuestas pueden ser usadas para controlar el
flujo:

    if (EXPR) BLOQUE
    if (EXPR) BLOQUE else BLOQUE
    if (EXPR) BLOQUE elsif (EXPR) BLOQUE ... else BLOQUE
    ETIQUETA while (EXPR) BLOQUE
    ETIQUETA while (EXPR) BLOQUE continue BLOQUE
    ETIQUETA until (EXPR) BLOQUE
    ETIQUETA until (EXPR) BLOQUE continue BLOQUE
    ETIQUETA for (EXPR; EXPR; EXPR) BLOQUE
    ETIQUETA foreach VAR (LISTA) BLOQUE
    ETIQUETA foreach VAR (LISTA) BLOQUE continue BLOQUE
    ETIQUETA BLOQUE continue BLOQUE

Note que, a diferencia del C y Pascal, están definidas en términos de
BLOQUES, no sentencias.  Esto significa que las llaves son I<necesarias>
--no se permiten sentencias sueltas.  Si quiere escribir condicionales sin
llaves hay varias formas de hacerlo.  Todo lo siguiente hace lo mismo:

    if (!open(FOO)) { die "No puedo abrir $FOO: $!"; }
    die "No puedo abrir $FOO: $!" unless open(FOO);
    open(FOO) or die "No puedo abrir $FOO: $!";	# ¡FOO o quieto!
    open(FOO) ? 'hola mama' : die "No puedo abrir $FOO: $!";
			# Un poco exótico, este último

La sentencia C<if> es sencilla.  Como los BLOQUES están siempre rodeados
de llaves, nunca hay ambigüedad sobre dónde van el C<if> y el C<else>.  Si
usa C<unless> en lugar de C<if>, el sentido del test es invertido.

La sentencia C<while> ejecuta el bloque mientras la expresión sea
verdadera (no evalúe al string nulo C<""> o C<0> o C<"0">).
La sentencia C<until> ejecuta el bloque mientras la expresión sea falsa.
La ETIQUETA es opcional, y si está presente, consiste en un identificador
seguido por el carácter dos puntos.  La ETIQUETA identifica el bucle para
las sentencias de control de bucle C<next>, C<last> y C<redo>.
Si la ETIQUETA se omite, las sentencias de control de bucle se refieren al
bucle más interior en que se encuentren.  Así se puede implementar
dinámicamente una retrollamada a la pila de llamadas en tiempo real para
encontrar la ETIQUETA.  Tal desesperado comportamiento lanzará un aviso si
usa el pragma C<use warnings> o la opción B<-w>.

Si existe un BLOQUE C<continue>, siempre es ejecutado justo antes de que
la condición sea evaluada de nuevo.  Así, puede ser usada para incrementar
una variable de bucle, incluso cuando la iteración ha sido cortada vía la
sentencia C<next>.

=head2 Control de bucles
X<control de bucles> X<bucle, control> X<next> X<last> X<redo> X<continue>

El comando C<next> inicia la siguiente iteración del bucle:

    LINEA: while (<STDIN>) {
	next LINEA if /^#/;	# desecha los comentarios
	...
    }

El comando C<last> sale inmediatamente del bucle en cuestión.  El bloque
C<continue>, si está, no es ejecutado:

    LINEA: while (<STDIN>) {
	last LINEA if /^$/;	# salir cuando se termine la cabecera
	...
    }

El comando C<redo> reinicia la iteración sin evaluar de nuevo la
condición.  El bloque C<continue>, si está, no es ejecutado:
Este comando se usa normalmente por los programas que quieren mentirse a
sí mismos sobre lo que fue introducido.

Por ejemplo, cuando se procesa un fichero como F</etc/termcap>.
Si las líneas de entrada acaban en contra barras para indicar
continuación, querrá saltarlo y obtener el siguiente registro.

    while (<>) {
	chomp;
	if (s/\\$//) {
	    $_ .= <>;
	    redo unless eof();
	}
	# ahora procesar $_
    }

que es la versión corta de la versión más explícita:

    LINEA: while (defined($linea = <ARGV>)) {
	chomp($linea);
	if ($linea =~ s/\\$//) {
	    $linea .= <ARGV>;
	    redo LINEA unless eof(); # not eof(ARGV)!
	}
	# ahora procesar $linea
    }

Note que si existiese un bloque C<continue> en el código de arriba, sería
ejecutado sólo en las líneas descartadas por la expresión regular (debido
a que redo salta el bloque continue). Un bloque continue se usa a menudo
para resetear contadores de línea o patrones de un sólo uso:

    # inspirado por :1,$g/fred/s//WILMA/
    while (<>) {
	?(pedro)?    && s//WILMA $1 WILMA/;
	?(pablo)?  && s//BETTY $1 BETTY/;
	?(homer)?   && s//MARGE $1 MARGE/;
    } continue {
	print "$ARGV $.: $_";
	close ARGV  if eof();		# resetea $.
	reset	    if eof();		# resetea ?patrón?
    }

Si la palabra C<while> se reemplaza por la palabra C<until>, el sentido
del test se invierte, pero la condición es testeada siempre antes de la
primera iteración.

Las sentencias de control de bucle no funcionan en un C<if> o C<unless>,
porque no son bucles.  Aunque puede doblar las llaves para crearlos.

    if (/patrón/) {{
	last if /pedro/;
	next if /pablo/; # el mismo efecto que "last", pero no se ve muy claro
	# hacer algo aquí
    }}

Esto es causado por el hecho de que un bloque por sí mismo actúa como un
bucle que se ejecuta una vez, ver L<"BLOQUES básicos y sentencias
Switch">.

La forma C<while/if BLOQUE BLOQUE>, disponible en Perl 4, ya no lo está.  
Reemplace cada ocurrencia de C<if BLOQUE> por C<if (do BLOQUE)>.

=head2 Bucles For
X<for> X<foreach>

El estilo C del bucle C<for> trabaja como el correspondiente bucle
C<while>; esto quiere decir:

    for ($i = 1; $i < 10; $i++) {
	...
    }

es lo mismo que esto:

    $i = 1;
    while ($i < 10) {
	...
    } continue {
	$i++;
    }

Hay una pequeña diferencia: si hay variables declaradas con C<my> en la
sección de inicialización del C<for>, el ámbito léxico de estas variables
es exactamente el bucle C<for> (el cuerpo del bucle y las secciones de
control).
X<my>

Además del recorrido indexado de arrays, C<for> puede prestarse a otras
interesantes aplicaciones.  Aquí hay una que evita el problema al testear
explícitamente por el fin de fichero en un descriptor de fichero
interactivo, provocando que su programa parezca que se queda colgado.
X<eof> X<end-of-file> X<fin de fichero>

    $en_un_tty = -t STDIN && -t STDOUT;
    sub prompt { print "¿si? " if $en_un_tty }
    for ( prompt(); <STDIN>; prompt() ) {
	# hacer algo
    }

Usando C<readline> (o el operador C<< <EXPR> >>) como la condición de un
bucle C<for> es la forma corta de lo siguiente.  Este comportamiento es el
mismo que en la condición de un bucle C<while>.
X<readline> X<< <> >>

    for ( prompt(); defined( $_ = <STDIN> ); prompt() ) {
        # hacer algo
    }

=head2 Bucles Foreach
X<for> X<foreach>

El bucle C<foreach> itera sobre los valores de una lista normal y pone la
variable VAR a cada uno de los elementos de la lista.  Si la variable es
precedida por la palabra clave C<my>, entonces su ámbito es léxicamente
local y por eso es visible sólo dentro del bucle.  Dicho de otra forma, la
variable es implícitamente local al bucle y recupera su valor anterior
saliendo del bucle.  Si la variable fue anteriormente declarada con C<my>,
usa esta variable en vez de la global, pero sigue siendo local en el
bucle.  Esta forma implícita de ser local ocurre I<solamente> en un bucle
C<foreach>.
X<my> X<local>

La palabra clave C<foreach> es realmente un sinónimo de la palabra clave
C<for>, así que puede usar C<foreach> por legibilidad o C<for> por
brevedad.  (O porque el shell Bourne le es más familiar que el I<csh>,
escribir C<for> le es más natural).  Si VAR se omite, C<$_> se inicializa
a cada valor.
X<$_>

Si cualquier elemento de LISTA es un I<lvalue> (un valor que puede ponerse
en el lado izquierdo de una expresión de asignación), puede modificarlo
modificando VAR dentro del bucle.  Recíprocamente, si cualquier elemento
de LISTA NOT es un I<lvalue>, cualquier intento de modificar este elemento
fallará (provocará un error).  En otras palabras, la variable índice del
bucle C<foreach> es implícitamente un alias de cada elemento de la lista
sobre la que estás iterando.
X<alias>

Si cualquier parte de la LISTA es un array, C<foreach> quedará confundido
si añade o quita elementos dentro del cuerpo del bucle, por ejemplo al
usar C<splice>.   Así que no lo haga.
X<splice>

C<foreach> probablemente no hará lo esperado si VAR está enlazada a otra
variable especial.   No haga esto tampoco.

Ejemplos:

    for (@array) { s/foo/bar/ }

    for my $elemento (@elementos) {
	$elemento *= 2;
    }

    for $cuenta_atras (10,9,8,7,6,5,4,3,2,1,'BOOM') {
	print $cuenta_atras, "\n"; sleep(1);
    }

    for (1..15) { print "Feliz Navidad\n"; }

    foreach $item (split(/:[\\\n:]*/, $ENV{TERMCAP})) {
	print "Item: $item\n";
    }

Aquí hay un ejemplo de cómo un programador de C codificaría un algoritmo
particular en Perl:

    for (my $i = 0; $i < @array1; $i++) {
	for (my $j = 0; $j < @array2; $j++) {
	    if ($array1[$i] > $array2[$j]) {
		last; # No puede volver al bucle más exterior :-(
	    }
	    $array1[$i] += $array2[$j];
	}
	# Aquí es donde lleva el 'last'
    }

Y aquí está cómo un programador de Perl, más cómodo con el lenguaje, puede
hacer:

    EXTERNO: for my $wid (@array1) {
    INTERNO:   for my $jet (@array2) {
		next EXTERNO if $wid > $jet;
		$wid += $jet;
	     }
	  }

¿Ha visto que es mucho más fácil?  Es más limpio, seguro y rápido.  Es más
limpio porque es menos ruidoso.  Es más seguro porque si se añade nuevo
código entre los bucles interno y externo, ese nuevo código no será
ejecutado accidentalmente.  El C<next> explícitamente itera sobre el otro
bucle en vez de meramente terminar el interno.  Y es más rápido porque
Perl ejecuta un sentencia C<foreach> más rápidamente que su equivalente en
un bucle C<for>.

=head2 BLOQUES Básicos y Sentencias Switch
X<switch> X<bloque> X<case>

Un BLOQUE por sí mismo (etiquetado o no) es semánticamente equivalente a
un bucle que se ejecuta una vez.   Así que puede usar cualquiera de las
sentencias de control de bucle dentro de él para salir o reiniciarlo. 
(Note que esto I<NO> es verdad en C<eval{}>, C<sub{}>, y contrariamente a
la creencia popular, bloques C<do{}>, que I<NO> cuentan como bucles). El
bloque C<continue> es opcional.

La construcción BLOQUE es particularmente bonita para hacer estructuras
I<case>.

    SWITCH: {
	if (/^abc/) { $abc = 1; last SWITCH; }
	if (/^def/) { $def = 1; last SWITCH; }
	if (/^xyz/) { $xyz = 1; last SWITCH; }
	$nada = 1;
    }

No existe una sentencia oficial C<switch> en Perl, porque existen varias
formas de escribir algo equivalente.

Sin embargo, uno puede obtener switch y case usando Perl 5.8 y superior
usando la extensión Switch y diciendo:

	use Switch;

después del cual ya se tiene switch y case.  No es tan rápido como se
espera porque realmente no forma parte del lenguaje (se hace usando
filtros del código fuente) pero está disponible y es muy flexible.

Además de la construcción del BLOQUE anterior, puede escribir esto

    SWITCH: {
	$abc = 1, last SWITCH  if /^abc/;
	$def = 1, last SWITCH  if /^def/;
	$xyz = 1, last SWITCH  if /^xyz/;
	$nada = 1;
    }

(No es tan extraño como parece una vez que se de cuenta de que puede usar
"operadores" de control de bucle dentro de una expresión.  Esto es
solamente el operador coma en contexto escalar.  Ver L<perlop/"Operador
Coma">).

o

    SWITCH: {
	/^abc/ && do { $abc = 1; last SWITCH; };
	/^def/ && do { $def = 1; last SWITCH; };
	/^xyz/ && do { $xyz = 1; last SWITCH; };
	$nada = 1;
    }

o formateado para que se parezca a una sentencia C<switch> más "limpia":

    SWITCH: {
	/^abc/ 	    && do {
			    $abc = 1;
			    last SWITCH;
		       };

	/^def/ 	    && do {
			    $def = 1;
			    last SWITCH;
		       };

	/^xyz/ 	    && do {
			    $xyz = 1;
			    last SWITCH;
		        };
	$nada = 1;
    }

o

    SWITCH: {
	/^abc/ and $abc = 1, last SWITCH;
	/^def/ and $def = 1, last SWITCH;
	/^xyz/ and $xyz = 1, last SWITCH;
	$nada = 1;
    }

o incluso, horror,

    if (/^abc/)
	{ $abc = 1 }
    elsif (/^def/)
	{ $def = 1 }
    elsif (/^xyz/)
	{ $xyz = 1 }
    else
	{ $nada = 1 }

Un modismo común para una sentencia C<switch> es aliando la asignación
temporal de C<$_> en un bucle C<foreach> para realizar el emparejamiento:

    SWITCH: for ($donde) {
		/En tarjetas/     && do { push @flags, '-e'; last; };
		/Cualquiera/      && do { push @flags, '-h'; last; };
		/En cartones/     && do {                    last; };
		die "valor desconocido para la variable donde: `$donde'";
	    }

Otra interesando aproximación a una sentencia C<switch> es organizar un
bloque C<do> para que devuelva el valor apropiado:

    $acceso_modo = do {
	if     ($flag & O_RDONLY) { "r" }	# XXX: ¿esto no es 0?
	elsif  ($flag & O_WRONLY) { ($flag & O_APPEND) ? "a" : "w" }
	elsif  ($flag & O_RDWR)   {
	    if ($flag & O_CREAT)  { "w+" }
	    else                  { ($flag & O_APPEND) ? "a+" : "r+" }
	}
    };

O 

        print do {
            ($flags & O_WRONLY) ? "sólo escritura"      :
            ($flags & O_RDWR)   ? "lectura-escritura"   :
                                  "solo-lectura";
        };

O si está seguro de que todas las clausulas C<&&> son verdaderas, puede
usar algo como esto, con "switches" en el valor de la variable de entorno
C<HTTP_USER_AGENT>.

    #!/usr/bin/perl 
    # Elige el fichero de la jerga según el navegador utilizado
    $dir = 'http://www.wins.uva.nl/~mes/jargon';
    for ($ENV{HTTP_USER_AGENT}) { 
	$pagina  =    /Mac/            && 'm/Macintrash.html'
		 || /Win(dows )?NT/  && 'e/evilandrude.html'
		 || /Win|MSIE|WebTV/ && 'm/MicroslothWindows.html'
		 || /Linux/          && 'l/Linux.html'
		 || /HP-UX/          && 'h/HP-SUX.html'
		 || /SunOS/          && 's/ScumOS.html'
		 ||                     'a/AppendixB.html';
    }
    print "Location: $dir/$pagina\015\012\015\012";

Esta clase de sentencia switch sólo funciona cuando sabe que las clausulas
C<&&> serán verdaderas.  Si no es así, el ejemplo anterior de C<?:> debe
ser usado.

Podría también considerar escribir un hash de referencias a subrutinas
para sintetizar una sentencia C<switch>.

=head2 Goto
X<goto>

Aunque no sea muy querido, Perl soporta la sentencia C<goto>.  Existen
tres formas: C<goto>-ETIQUETA, C<goto>-EXPR y C<goto>-&NOMBRE.  La
ETIQUETA de un bucle no es realmente un destino válido para un C<goto>;
sólo es el nombre del bucle.

La forma C<goto>-ETIQUETA busca la sentencia etiquetada con ETIQUETA y
continua la ejecución desde allí.  No puede ser usado en ninguna
construcción que requiera inicialización, como una subrutina o un bucle
C<foreach>.  Tampoco puede ir en una construcción que esté optimizada. 
Puede ser utilizada para ir a casi cualquier sitio que esté dentro del
ámbito dinámico. incluyendo fuera de las subrutinas, pero es usualmente
mucho mejor otras construcciones como C<last> o C<die>.  El autor de Perl
nunca ha sentido la necesidad de usar esta forma de C<goto> (en Perl,
desde luego. C es otra historia).

La forma C<goto>-EXPR espera un nombre de etiqueta, cuyo ámbito será
resuelto dinámicamente.  Esto permite crear C<goto> calculados como en
FORTRAN, pero no está necesariamente recomendado si usted está optimizando
durante el mantenimiento:

    goto(("FOO", "BAR", "GLARCH")[$i]);

La forma C<goto>-&NOMBRE es altamente mágica y sustituye a una llamada a
una subrutina con nombre desde la actual subrutina que se está ejecutando.
 Esto se usa por subrutinas C<AUTOLOAD()> que desean cargar otra subrutina
y fingen que esta otra subrutina ha sido llamada en primer lugar (excepto
que cualquier modificación a C<@_> en la subrutina actual se propaga a la
otra). Después del C<goto>, ni siquiera C<caller()> será capaz de decir
qué rutina fue llamada en primer lugar.

En casi todos los casos como este, es usualmente una mejor, mejor idea,
usar los mecanismos de control de flujo de C<next>, C<last> o C<redo> en
vez de recurrir a C<goto>.  Para ciertas aplicaciones, la pareja C<eval{}>
y C<die()> puede ser un prudente planteamiento para el procesamiento de
excepciones.

=head2 POD: Documentación Embebida
X<POD> X<documentación>

Perl tiene un mecanismo para entremezclar documentación y código fuente.
Mientras que él espera el comienzo de una nueva sentencia, si el
compilador encuentra una línea que comienza con un signo de igual y una
palabra, como esta

    =head1 Aquí serán los Pods!

Entonces este texto y el siguiente hasta incluir una línea que comience
por C<=cut> será ignorada.  El formato del texto intermedio está descrito
en L<perlpod>.

Esto le permite entremezclar código fuente y texto de la documentación
libremente, como por ejemplo

    =item snazzle($)

    La función snazzle() se convertirá en la más espectacular
    forma que pueda posiblemente imaginar, incluyendo
    pirotecnia cibernética.

    =cut devuelta al compilador, lejos de este material pod!

    sub snazzle($) {
	my $cosita = shift;
	.........
    }

Note que los traductores pod suelen mirar sólo en los párrafos que
comiencen por una directiva pod (hace el parseo más fácil), mientras que
el compilador realmente sabe mirar por las secuencias pod incluso en el
medio de un párrafo.  Esto significa que el siguiente material secreto
será ignorado tanto por el compilador como por los traductores.

    $a=3;
    =material secreto
     warn "Ni POD ni CÓDIGO!?"
    =cut regreso
    print "tengo $a\n";

Probablemente no se dará cuenta de que el C<warn()> ha sido comentado para
siempre.
No todos los traductores pod están bien entrenados a este respecto y quizá
el compilador sea más quisquilloso.

Uno puede también usar directivas pod para comentar, de forma rápida, una
sección de código.

=head2 Comentarios a la vieja usanza
X<comentario> X<línea> X<#> X<preprocesador> X<eval>

Perl puede procesar directivas como lo hace el preprocesador de C.  Usando
esto, uno puede controlar la idea que tiene Perl de los nombres de
archivos y número de líneas un los mensajes de avisos y errores
(especialmente para los strings procesados con C<eval()>).  La sintaxis de
este mecanismo es el mismo que para la mayoría de preprocesadores de C:
coincide con la expresión regular

    # ejemplo: '# line 42 "nuevo_fichero.plx"'
    /^\#   \s*
      line \s+ (\d+)   \s*
      (?:\s("?)([^"]+)\2)?  \s*
     $/x

con C<$1> siendo el número de línea para la línea siguiente y C<$3> siendo
el nombre de fichero opcional (especificado con o sin comillas).

Existe obviamente un problema con esta directiva: los I<debuggers> y
perfiladores sólo mostrarán la última línea del código fuente que aparece
en un número de línea en particular de un determinado fichero.  Hay que
tener cuidado para no causar colisiones de números de línea en el código
que pretendas debuggear más tarde.

Aquí hay algunos ejemplos que será capaz de escribir en la línea de
comandos del shell:

    % perl
    # line 200 "bzzzt"
    # el `#' en la línea anterior debe ser el primer carácter de la línea
    die 'foo';
    __END__
    foo at bzzzt line 201.

    % perl
    # line 200 "bzzzt"
    eval qq[\n#line 2001 ""\ndie 'foo']; print $@;
    __END__
    foo at - line 2001.

    % perl
    eval qq[\n#line 200 "foo bar"\ndie 'foo']; print $@;
    __END__
    foo at foo bar line 200.

    % perl
    # line 345 "goop"
    eval "\n#line " . __LINE__ . ' "' . __FILE__ ."\"\ndie 'foo'";
    print $@;
    __END__
    foo at goop line 345.

=cut

=head1 TRADUCCIÓN

=head2 TRADUCTOR

	Traducción a cargo de Joaquín Ferrero <joaquinferrero@sourceforge.net>

=head2 REVISOR

	Revisión a cargo de 

=cut
