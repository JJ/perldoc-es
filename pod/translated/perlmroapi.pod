=head1 NOMBRE

perlmroapi - Interfaz de complementos: resolución de métodos

=head1 DESCRIPCIÓN

A partir de Perl 5.10.1 existe una nueva interfaz para la conexión y orden del método de resolución aparte del predeterminado (buscar primero en profundidad lineal).
El método de resolución de orden C3 añadido en 5.10.0 se ha re-implementado como un complemento, sin cambiar su interfaz del espacio Perl.

Cada complemento debe registrarse con C<Perl_mro_register> proporcionando la siguiente estructura

    struct mro_alg {
        AV *(*resolve)(pTHX_ HV *stash, U32 level);
        const char *nombre;
        U16 length;
        U16 kflags;
        U32 hash;
    };

=over 4

=item resolve

Puntero a la función de linealización, descrita a continuación.

=item nombre

Nombre de la MRO, ya sea en ISO-8859-1 o UTF-8.

=item length

Longitud del nombre.

=item kflags

Si el nombre se da en UTF-8, ponga esto en C<HVhek_UTF8>. El valor es pasado directamente como el parámetro I<kflags> a C<hv_common()>.

=item hash

Un valor de hash calculado previamente para el nombre del MRO, o 0.

=back

=head1 Retrollamadas

La función C<resolve> es llamada para generar un ISA en línea para el esquema indicado, utilizando este MRO. Es llamado con un puntero al esquema, y un I<nivel> de 0. El núcleo siempre pone <nivel> a 0 cuando se llama a la función - el parámetro es proporcionado para permitir su implementación para realizar un seguimiento profundo si es necesario que se llame a sí mismo.

La función debe devolver una referencia a una array que contiene las clases padres en orden. Los nombres de las clases deben ser el resultado de la llamada C<HvENAME()> en el esquema. En los casos donde C<HvENAME()> devuelve un valor nulo, en su lugar se debe usar C<HvNAME()>.

El llamador es responsable de incrementar el contador de referencias del array devuelto si se quiere mantener la estructura. Por lo tanto, si ha creado un valor temporal que se mantiene sin puntero a C<sv_2mortal()>, asegúrese de que se elimina de forma correcta. Si tiene cacheado su valor de retorno, entonces devuelva un puntero a él sin tener que cambiar el contador de referencias.

=head1 Cacheado

Calcular MRO puede ser costoso. La implementación proporciona una memoria caché, en el que puede almacenar un único C<SV *>, o cualquier cosa que se puede convertir a C<SV *>, como un C<AV *>. Para leer su valor privado, use la macro C<MRO_GET_PRIVATE_DATA()>, pasándole la estructura C<mro_meta> del esquema, y un puntero a la estructura C<mro_alg>:

    meta = HvMROMETA(esquema);
    private_sv = MRO_GET_PRIVATE_DATA(meta, &my_mro_alg);

Para establecer el valor privado, llame a C<Perl_mro_set_private_data()>:

    Perl_mro_set_private_data(aTHX_ meta, &c3_alg, private_sv);

El caché privado de datos se apropiará de una referencia a private_sv, de la misma manera que C<hv_store()> toma la propiedad de una referencia al valor que usted le pasa.

=head1 Ejemplos

Para ver ejemplos de las implementaciones de MRO, vea C<S_mro_get_linear_isa_c3()> y la sección C<BOOT:> de F<mro/mro.xs>, y C<S_mro_get_linear_isa_dfs()> en F<mro.c>

=head1 AUTORES

La aplicación de la C3 MRO y la capacidad de intercambiar MRO en el núcleo de Perl fue escrito por Brandon L Black. Nicholas Clark creó el interfaz enchufable, la implementación refactorizada de Brandon para trabajar con él, y escribió este documento.

=cut
