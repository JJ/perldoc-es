<html>
<head>
<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=UTF-8'>
<style>
.file .fileheader { color: #888; }
.file .hunk ins   { color: #060; font-weight: bold; }
.file .hunk del   { color: #b22; font-weight: bold; }
</style>
</head>
<title>Word-oriented POD comparison</title>
<body>

<h1>Comparison results for perlhacktut.pod</h1>
</br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>perlhacktut - Tutorial de creación de una revisión sencilla de código C</br>
<span style='color:red'><b>REVIEWER:</b></span></br>perlhacktut - Tutorial de creación de un parche sencillo de código C</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">perlhacktut - Tutorial de creaci&oacute;n de </span><span class="hunk"><del>una revisi&oacute;n sencilla </del><ins>un parche sencillo </ins></span><span class="hunk">de c&oacute;digo C</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Este documento le lleva a través del ejemplo de un parche simple.</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Este documento describe la creación de un parche sencillo.</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">Este documento </span><span class="hunk"><del>le lleva a trav&eacute;s del ejemplo </del><ins>describe la creaci&oacute;n </ins></span><span class="hunk">de un parche </span><span class="hunk"><del>simple</del><ins>sencillo</ins></span><span class="hunk">.</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Si todavía no ha leído L(perlhack), ¡es lo primero que debe de hacer! También debería leer L(perlsource).</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Si todavía no ha leído L(perlhack), es lo primero que debe hacer. También debería leer L(perlsource).</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">Si todav&iacute;a no ha le&iacute;do L(perlhack), </span><span class="hunk"><del>&iexcl;</del></span><span class="hunk">es lo primero que debe </span><span class="hunk"><del>de </del></span><span class="hunk">hacer</span><span class="hunk"><del>! </del><ins>. </ins></span><span class="hunk">Tambi&eacute;n deber&iacute;a leer L(perlsource).</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Una vez que haya terminado, eche a continuación un vistazo a L(perlhacktips).</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Por último, consulte L(perlhacktips).</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"><del>Una vez que haya terminado</del><ins>Por &uacute;ltimo</ins></span><span class="hunk">, </span><span class="hunk"><del>eche a continuaci&oacute;n un vistazo a </del><ins>consulte </ins></span><span class="hunk">L(perlhacktips).</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>=head1 EJEMPLO DE REVISIÓN SENCILLA</br>
<span style='color:red'><b>REVIEWER:</b></span></br>=head1 EJEMPLO DE PARCHE SENCILLO</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">=head1 EJEMPLO DE </span><span class="hunk"><del>REVISI&Oacute;N SENCILLA</del><ins>PARCHE SENCILLO</ins></span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Construiremos un simple parche de principio a fin.</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Vamos a crear un parche sencillo de principio a fin.</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"><del>Construiremos </del><ins>Vamos a crear </ins></span><span class="hunk">un </span><span class="hunk"><del>simple </del></span><span class="hunk">parche </span><span class="hunk"><ins>sencillo </ins></span><span class="hunk">de principio a fin.</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Aquí hay algo que Larry propuso: si C(U)es el primer formato activo durante una C(pack), (por ejemplo, C(pack "U3C8", @stuff)) entonces la cadena resultante debe ser entendida como que está en codificación UTF-8.</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Para ello, nos ocuparemos de implementar algo que propuso Larry: si el primer formato activo en una instrucción C(pack) es C(U) (por ejemplo, C(pack "U3C8", @algo)), entonces la cadena resultante debería tratarse como codificada en UTF-8.</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"><del>Aqu&iacute; hay </del><ins>Para ello, nos ocuparemos de implementar </ins></span><span class="hunk">algo que </span><span class="hunk"><del>Larry propuso</del><ins>propuso Larry</ins></span><span class="hunk">: si </span><span class="hunk"><del>C(U)es </del></span><span class="hunk">el primer formato activo </span><span class="hunk"><del>durante </del><ins>en </ins></span><span class="hunk">una </span><span class="hunk"><ins>instrucci&oacute;n </ins></span><span class="hunk">C(pack</span><span class="hunk"><del>), </del><ins>) es C</ins></span><span class="hunk">(</span><span class="hunk"><ins>U) (</ins></span><span class="hunk">por ejemplo, C(pack &quot;U3C8&quot;, @</span><span class="hunk"><del>stuff)) </del><ins>algo)), </ins></span><span class="hunk">entonces la cadena resultante </span><span class="hunk"><del>debe ser entendida </del><ins>deber&iacute;a tratarse </ins></span><span class="hunk">como </span><span class="hunk"><del>que est&aacute; </del><ins>codificada </ins></span><span class="hunk">en </span><span class="hunk"><del>codificaci&oacute;n </del></span><span class="hunk">UTF-8.</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Si está trabajando con un clon del repositorio git de Perl, tendrá que crear una rama para incorporar sus cambios. Esto hará que la creación de un parche sea mucho más simple. Vea L(perlgit) para obtener detalles sobre cómo hacer esto.</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Si trabaja con un clon del repositorio git de Perl, tendrá que crear una rama para incorporar sus cambios. Esto facilitará la creación de parches. Encontrará más información en L(perlgit).</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">Si </span><span class="hunk"><del>est&aacute; trabajando </del><ins>trabaja </ins></span><span class="hunk">con un clon del repositorio git de Perl, tendr&aacute; que crear una rama para incorporar sus cambios. Esto </span><span class="hunk"><del>har&aacute; que </del><ins>facilitar&aacute; </ins></span><span class="hunk">la creaci&oacute;n de </span><span class="hunk"><del>un parche sea mucho m&aacute;s simple</del><ins>parches</ins></span><span class="hunk">. </span><span class="hunk"><del>Vea </del><ins>Encontrar&aacute; m&aacute;s informaci&oacute;n en </ins></span><span class="hunk">L(perlgit</span><span class="hunk"><del>) para obtener detalles sobre c&oacute;mo hacer esto.</del><ins>).</ins></span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>=head2 Escribir la revisión</br>
<span style='color:red'><b>REVIEWER:</b></span></br>=head2 Escribir el parche</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">=head2 Escribir </span><span class="hunk"><del>la revisi&oacute;n</del><ins>el parche</ins></span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>¿Cómo nos preparamos para arreglar esto? En primer lugar, localizamos el código en cuestión: la función C(pack) sucede en tiempo de ejecución, por lo que va a estar en uno de los archivos F(pp). Lo más seguro, C(pp_pack) que está en F(pp.c). Puesto que vamos a estar alterando este archivo, vamos a copiarlo a F(pp.c~).</br>
<span style='color:red'><b>REVIEWER:</b></span></br>¿Cómo nos preparamos para corregir esto? Primero tenemos que buscar el código en cuestión. La función C(pack) se usa en tiempo de ejecución, por lo que estará en uno de los archivos F(pp). Como sospechábamos, C(pp_pack) está en F(pp.c). Puesto que vamos a modificar este archivo, antes creamos una copia y le asignamos el nombre F(pp.c~).</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">&iquest;C&oacute;mo nos preparamos para </span><span class="hunk"><del>arreglar </del><ins>corregir </ins></span><span class="hunk">esto? </span><span class="hunk"><del>En primer lugar, localizamos </del><ins>Primero tenemos que buscar </ins></span><span class="hunk">el c&oacute;digo en cuesti&oacute;n</span><span class="hunk"><del>: la </del><ins>. La </ins></span><span class="hunk">funci&oacute;n C(pack) </span><span class="hunk"><del>sucede </del><ins>se usa </ins></span><span class="hunk">en tiempo de ejecuci&oacute;n, por lo que </span><span class="hunk"><del>va a estar </del><ins>estar&aacute; </ins></span><span class="hunk">en uno de los archivos F(pp). </span><span class="hunk"><del>Lo m&aacute;s seguro</del><ins>Como sospech&aacute;bamos</ins></span><span class="hunk">, C(pp_pack) </span><span class="hunk"><del>que </del></span><span class="hunk">est&aacute; en F(pp.c). Puesto que vamos a </span><span class="hunk"><del>estar alterando </del><ins>modificar </ins></span><span class="hunk">este archivo, </span><span class="hunk"><del>vamos a copiarlo a </del><ins>antes creamos una copia y le asignamos el nombre </ins></span><span class="hunk">F(pp.c~).</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>[Bueno, cuando se escribió este manual era en F(pp.c). Ahora se ha escindido de C(pp_unpack) en su propio archivo, F(pp_pack.c)]</br>
<span style='color:red'><b>REVIEWER:</b></span></br>[Bueno, estaba en F(pp.c) en el momento de redactar este tutorial. Ahora se ha escindido de C(pp_unpack) en su propio archivo, F(pp_pack.c)]</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">[Bueno, </span><span class="hunk"><del>cuando se escribi&oacute; este manual era </del><ins>estaba </ins></span><span class="hunk">en F(pp.c</span><span class="hunk"><del>). </del><ins>) en el momento de redactar este tutorial. </ins></span><span class="hunk">Ahora se ha escindido de C(pp_unpack) en su propio archivo, F(pp_pack.c)]</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Ahora vamos a mirar por encima C(pp_pack): tenemos un patrón en C(pat), y luego un bucle sobre el patrón, teniendo cada carácter de formato a su vez en C(datum_type). Luego, para cada formato de caracteres posible, nos comemos los otros argumentos en el patrón (un campo de ancho, un asterisco, y así sucesivamente) y convertir el fragmento de entrada siguiente en el formato especificado, añadiéndolo a la salida de SV C(cat).</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Echemos un vistazo a C(pp_pack): tenemos un patrón en C(pat) y un bucle que recorre el patrón y pasa de uno en uno los caracteres de formato a C(datum_type). Luego, para cada carácter de formato posible, se consumen los demás argumentos del patrón (un ancho de campo, un asterisco, etc.) y se convierte el siguiente fragmento de entrada al formato especificado, agregándolo al SV de salida, C(cat).</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"><del>Ahora vamos </del><ins>Echemos un vistazo </ins></span><span class="hunk">a </span><span class="hunk"><del>mirar por encima </del></span><span class="hunk">C(pp_pack): tenemos un patr&oacute;n en C(pat</span><span class="hunk"><del>), </del><ins>) </ins></span><span class="hunk">y </span><span class="hunk"><del>luego </del></span><span class="hunk">un bucle </span><span class="hunk"><del>sobre </del><ins>que recorre </ins></span><span class="hunk">el </span><span class="hunk"><del>patr&oacute;n, teniendo cada car&aacute;cter </del><ins>patr&oacute;n y pasa </ins></span><span class="hunk">de </span><span class="hunk"><ins>uno en uno los caracteres de </ins></span><span class="hunk">formato a </span><span class="hunk"><del>su vez en </del></span><span class="hunk">C(datum_type). Luego, para cada </span><span class="hunk"><del>formato </del><ins>car&aacute;cter </ins></span><span class="hunk">de </span><span class="hunk"><del>caracteres </del><ins>formato </ins></span><span class="hunk">posible, </span><span class="hunk"><del>nos comemos </del><ins>se consumen </ins></span><span class="hunk">los </span><span class="hunk"><del>otros </del><ins>dem&aacute;s </ins></span><span class="hunk">argumentos </span><span class="hunk"><del>en el </del><ins>del </ins></span><span class="hunk">patr&oacute;n (un </span><span class="hunk"><del>campo </del><ins>ancho </ins></span><span class="hunk">de </span><span class="hunk"><del>ancho</del><ins>campo</ins></span><span class="hunk">, un asterisco, </span><span class="hunk"><ins>etc.) </ins></span><span class="hunk">y </span><span class="hunk"><del>as&iacute; sucesivamente) y convertir </del><ins>se convierte </ins></span><span class="hunk">el </span><span class="hunk"><ins>siguiente </ins></span><span class="hunk">fragmento de entrada </span><span class="hunk"><del>siguiente en el </del><ins>al </ins></span><span class="hunk">formato especificado, </span><span class="hunk"><del>a&ntilde;adi&eacute;ndolo a la salida de </del><ins>agreg&aacute;ndolo al </ins></span><span class="hunk">SV </span><span class="hunk"><ins>de salida, </ins></span><span class="hunk">C(cat).</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>¿Cómo sabemos si el C(U) es el primer formato en el C(pat)? Bueno, si tenemos un puntero al comienzo de C(pat) entonces, si vemos un C(U) podemos comprobar si aún estamos al inicio de la cadena. Así pues, aquí es donde se establece C(pat):</br>
<span style='color:red'><b>REVIEWER:</b></span></br>¿Cómo sabemos si la C(U) es el primer formato en C(pat)? Si tenemos un puntero al comienzo de C(pat) y vemos una C(U), podemos comprobar si aún estamos en el principio de la cadena. Aquí es donde se establece C(pat):</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">&iquest;C&oacute;mo sabemos si </span><span class="hunk"><del>el </del><ins>la </ins></span><span class="hunk">C(U) es el primer formato en </span><span class="hunk"><del>el </del></span><span class="hunk">C(pat)? </span><span class="hunk"><del>Bueno, si </del><ins>Si </ins></span><span class="hunk">tenemos un puntero al comienzo de C(pat) </span><span class="hunk"><del>entonces, si </del><ins>y </ins></span><span class="hunk">vemos </span><span class="hunk"><del>un </del><ins>una </ins></span><span class="hunk">C(U</span><span class="hunk"><del>) </del><ins>), </ins></span><span class="hunk">podemos comprobar si a&uacute;n estamos </span><span class="hunk"><del>al inicio </del><ins>en el principio </ins></span><span class="hunk">de la cadena. </span><span class="hunk"><del>As&iacute; pues, aqu&iacute; </del><ins>Aqu&iacute; </ins></span><span class="hunk">es donde se establece C(pat):</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Vamos a tener otro puntero de cadena:</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Tendremos ahí otro puntero de cadena:</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"><del>Vamos a tener </del><ins>Tendremos ah&iacute; </ins></span><span class="hunk">otro puntero de cadena:</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Y justo antes de empezar el bucle, vamos a establecer C(patcopy) al comienzo de C(pat):</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Justo antes de empezar el bucle, se establece C(patcopy) como comienzo de C(pat):</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"><del>Y justo </del><ins>Justo </ins></span><span class="hunk">antes de empezar el bucle, </span><span class="hunk"><del>vamos a establecer </del><ins>se establece </ins></span><span class="hunk">C(patcopy) </span><span class="hunk"><del>al </del><ins>como </ins></span><span class="hunk">comienzo de C(pat):</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Ahora bien, si vemos una C(U) que se encontraba al principio de la cadena, activamos la bandera C(UTF8) para la salida SV C(cat):</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Ahora bien, si vemos una C(U) al principio de la cadena, activamos la marca C(UTF8) para el SV de salida, C(cat):</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">Ahora bien, si vemos una C(U) </span><span class="hunk"><del>que se encontraba </del></span><span class="hunk">al principio de la cadena, activamos la </span><span class="hunk"><del>bandera </del><ins>marca </ins></span><span class="hunk">C(UTF8) para </span><span class="hunk"><del>la salida </del><ins>el </ins></span><span class="hunk">SV </span><span class="hunk"><ins>de salida, </ins></span><span class="hunk">C(cat):</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>¡Recuerde que tiene que ser C(patcopy+1) porque el primer carácter de la cadena es el C(U) que fue ingerido en C(datumtype)!</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Recuerde que tiene que ser C(patcopy+1),  ya que el primer carácter de la cadena es la C(U) consumida por C(datumtype).</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"><del>&iexcl;</del></span><span class="hunk">Recuerde que tiene que ser C(patcopy+1</span><span class="hunk"><del>) porque </del><ins>),  ya que </ins></span><span class="hunk">el primer car&aacute;cter de la cadena es </span><span class="hunk"><del>el </del><ins>la </ins></span><span class="hunk">C(U) </span><span class="hunk"><del>que fue ingerido en </del><ins>consumida por </ins></span><span class="hunk">C(datumtype</span><span class="hunk"><del>)!</del><ins>).</ins></span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Vaya, nos olvidamos de una cosa: ¿qué pasa si hay espacios al inicio del patrón? C(pack("  U*", @stuff)) tendrá C(U) como primer carácter activo, aunque no es lo primero en el patrón. En este caso, tenemos que avanzar C(patcopy) junto con C(pat) cuando veamos espacios:</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Vaya, nos olvidamos de una cosa: ¿qué pasa si hay espacios al principio del patrón? C(pack("  U*", @algo)) tendrá C(U) como primer carácter activo, pero no es el primer carácter del patrón. En este caso, tenemos que incrementar C(patcopy) junto con C(pat) cuando veamos espacios:</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">Vaya, nos olvidamos de una cosa: &iquest;qu&eacute; pasa si hay espacios al </span><span class="hunk"><del>inicio </del><ins>principio </ins></span><span class="hunk">del patr&oacute;n? C(pack(&quot;  U*&quot;, @</span><span class="hunk"><del>stuff</del><ins>algo</ins></span><span class="hunk">)) tendr&aacute; C(U) como primer car&aacute;cter activo, </span><span class="hunk"><del>aunque </del><ins>pero </ins></span><span class="hunk">no es </span><span class="hunk"><del>lo primero en </del></span><span class="hunk">el </span><span class="hunk"><ins>primer car&aacute;cter del </ins></span><span class="hunk">patr&oacute;n. En este caso, tenemos que </span><span class="hunk"><del>avanzar </del><ins>incrementar </ins></span><span class="hunk">C(patcopy) junto con C(pat) cuando veamos espacios:</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>necesita convertirse en</br>
<span style='color:red'><b>REVIEWER:</b></span></br>debe convertirse en</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"><del>necesita </del><ins>debe </ins></span><span class="hunk">convertirse en</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>OK. Esa es la parte C terminada. Ahora tenemos que hacer dos cosas adicionales antes de que este parche quede listo para enviarse: hemos cambiado el comportamiento de Perl, por lo que debe documentar el cambio. También debe proporcionar algunas pruebas de regresión para asegurarnos de que nuestro parche funciona y no crea un error en otro lugar a lo largo de la línea.</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Muy bien. Ya hemos corregido el código C. Ahora tenemos que hacer dos cosas más para terminar de preparar el parche: hemos cambiado el comportamiento de Perl, por lo que debemos documentar el cambio. También tenemos que proporcionar pruebas de regresión adicionales para asegurarnos de que nuestro parche funciona y no crea ningún error en otro lugar.</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"><del>OK</del><ins>Muy bien</ins></span><span class="hunk">. </span><span class="hunk"><del>Esa es la parte C terminada</del><ins>Ya hemos corregido el c&oacute;digo C</ins></span><span class="hunk">. Ahora tenemos que hacer dos cosas </span><span class="hunk"><del>adicionales antes de que este parche quede listo </del><ins>m&aacute;s </ins></span><span class="hunk">para </span><span class="hunk"><del>enviarse</del><ins>terminar de preparar el parche</ins></span><span class="hunk">: hemos cambiado el comportamiento de Perl, por lo que </span><span class="hunk"><del>debe </del><ins>debemos </ins></span><span class="hunk">documentar el cambio. Tambi&eacute;n </span><span class="hunk"><del>debe </del><ins>tenemos que </ins></span><span class="hunk">proporcionar </span><span class="hunk"><del>algunas </del></span><span class="hunk">pruebas de regresi&oacute;n </span><span class="hunk"><ins>adicionales </ins></span><span class="hunk">para asegurarnos de que nuestro parche funciona y no crea </span><span class="hunk"><del>un </del><ins>ning&uacute;n </ins></span><span class="hunk">error en otro </span><span class="hunk"><del>lugar a lo largo de la l&iacute;nea</del><ins>lugar</ins></span><span class="hunk">.</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>=head2 Probar la revisión</br>
<span style='color:red'><b>REVIEWER:</b></span></br>=head2 Comprobar el parche</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">=head2 </span><span class="hunk"><del>Probar la revisi&oacute;n</del><ins>Comprobar el parche</ins></span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Las pruebas de regresión para cada operador se encuentran en F(t/op/), por lo que hacemos una copia de F(t/op/pack.t) en F(t/op/pack.t~). Ahora podemos agregar nuestras pruebas al final. En primer lugar, comprobaremos que C(U) crea realmentne cadenas Unicode.</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Las pruebas de regresión para cada operador se encuentran en F(t/op/), así que hacemos una copia de F(t/op/pack.t) en F(t/op/pack.t~). Ahora podemos agregar nuestras pruebas al final. En primer lugar, comprobaremos que C(U) crea realmente cadenas Unicode.</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">Las pruebas de regresi&oacute;n para cada operador se encuentran en F(t/op/), </span><span class="hunk"><del>por lo </del><ins>as&iacute; </ins></span><span class="hunk">que hacemos una copia de F(t/op/pack.t) en F(t/op/pack.t~). Ahora podemos agregar nuestras pruebas al final. En primer lugar, comprobaremos que C(U) crea </span><span class="hunk"><del>realmentne </del><ins>realmente </ins></span><span class="hunk">cadenas Unicode.</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>t/op/pack.t tiene una función ok() sensible, pero si no podemos usarla, lo haremos con t/test.pl.</br>
<span style='color:red'><b>REVIEWER:</b></span></br>t/op/pack.t tiene una función ok() adecuada, pero si no la tuviera, podríamos usar la de t/test.pl.</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">t/op/pack.t tiene una funci&oacute;n ok() </span><span class="hunk"><del>sensible</del><ins>adecuada</ins></span><span class="hunk">, pero si no </span><span class="hunk"><del>podemos usarla</del><ins>la tuviera</ins></span><span class="hunk">, </span><span class="hunk"><del>lo haremos con </del><ins>podr&iacute;amos usar la de </ins></span><span class="hunk">t/test.pl.</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>podemos escribir una prueba más sensible (vea L(Test::More) para una explicación completa de is() y otras funciones de prueba).</br>
<span style='color:red'><b>REVIEWER:</b></span></br>podemos escribir una prueba más apropiada (en L(Test::More) encontrará una descripción completa de is() y otras funciones para realizar pruebas):</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">podemos escribir una prueba m&aacute;s </span><span class="hunk"><del>sensible </del><ins>apropiada </ins></span><span class="hunk">(</span><span class="hunk"><del>vea </del><ins>en </ins></span><span class="hunk">L(Test::More) </span><span class="hunk"><del>para </del><ins>encontrar&aacute; </ins></span><span class="hunk">una </span><span class="hunk"><del>explicaci&oacute;n </del><ins>descripci&oacute;n </ins></span><span class="hunk">completa de is() y otras funciones </span><span class="hunk"><del>de prueba).</del><ins>para realizar pruebas):</ins></span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Ahora vamos a probar que también es correcto para el asunto del espacio al comienzo:</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Ahora comprobamos que la comprobación de espacio inicial es correcta:</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">Ahora </span><span class="hunk"><del>vamos a probar </del><ins>comprobamos </ins></span><span class="hunk">que </span><span class="hunk"><del>tambi&eacute;n es correcto para el asunto del </del><ins>la comprobaci&oacute;n de </ins></span><span class="hunk">espacio </span><span class="hunk"><del>al comienzo</del><ins>inicial es correcta</ins></span><span class="hunk">:</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Y finalmente vamos a comprobar que no creamos cadenas Unicode si C(U) B(no) es el primer formato activo:</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Por último, vamos a comprobar que no creamos cadenas Unicode si C(U) B(no) es el primer formato activo:</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"><del>Y finalmente </del><ins>Por &uacute;ltimo, </ins></span><span class="hunk">vamos a comprobar que no creamos cadenas Unicode si C(U) B(no) es el primer formato activo:</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>                                       "U* no es primero, luego no es Unicode" );</br>
<span style='color:red'><b>REVIEWER:</b></span></br>                                       "U* no aparece al principio, luego no es Unicode" );</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">                                       &quot;U* no </span><span class="hunk"><del>es primero</del><ins>aparece al principio</ins></span><span class="hunk">, luego no es Unicode&quot; );</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>No hay que olvidarse de cambiar el número de pruebas que aparece en la parte superior, o el comprobador automatizado quedará confundido. Esto se verá así:</br>
<span style='color:red'><b>REVIEWER:</b></span></br>No hay que olvidarse de actualizar el número de pruebas especificado al principio del código, para que el programa de ejecución automática de pruebas no se confunda. Será algo así:</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">No hay que olvidarse de </span><span class="hunk"><del>cambiar </del><ins>actualizar </ins></span><span class="hunk">el n&uacute;mero de pruebas </span><span class="hunk"><del>que aparece en la parte superior</del><ins>especificado al principio del c&oacute;digo</ins></span><span class="hunk">, </span><span class="hunk"><del>o </del><ins>para que </ins></span><span class="hunk">el </span><span class="hunk"><del>comprobador automatizado quedar&aacute; confundido. Esto </del><ins>programa de ejecuci&oacute;n autom&aacute;tica de pruebas no </ins></span><span class="hunk">se </span><span class="hunk"><del>ver&aacute; </del><ins>confunda. Ser&aacute; algo </ins></span><span class="hunk">as&iacute;:</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>o así:</br>
<span style='color:red'><b>REVIEWER:</b></span></br>o bien:</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">o </span><span class="hunk"><del>as&iacute;</del><ins>bien</ins></span><span class="hunk">:</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Ahora compilamos Perl, y lo ejecutamos a través de la serie de pruebas. Nuestras nuevas pruebas pasan correctamente, ¡Hurra!</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Ahora compilamos Perl y ejecutamos la serie de pruebas. ¡Pruebas nuevas superadas! ¡Viva!</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">Ahora compilamos </span><span class="hunk"><del>Perl, </del><ins>Perl </ins></span><span class="hunk">y </span><span class="hunk"><del>lo </del></span><span class="hunk">ejecutamos </span><span class="hunk"><del>a trav&eacute;s de </del></span><span class="hunk">la serie de pruebas. </span><span class="hunk"><del>Nuestras </del><ins>&iexcl;Pruebas </ins></span><span class="hunk">nuevas </span><span class="hunk"><del>pruebas pasan correctamente, </del><ins>superadas! </ins></span><span class="hunk">&iexcl;</span><span class="hunk"><del>Hurra</del><ins>Viva</ins></span><span class="hunk">!</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Por último, la documentación. El trabajo nunca está terminado hasta que el papeleo se acaba, así que vamos a describir el cambio que acaba de hacer. El lugar relevante es F(pod/perlfunc.pod); de nuevo, hacemos una copia, y luego vamos a insertar este texto en la descripción de C(pack):</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Por último, falta la documentación. Para acabar el trabajo no queda más remedio que ocuparse del papeleo, así que vamos a describir el cambio que acabamos de hacer. El lugar correspondiente es F(pod/perlfunc.pod). Una vez más, hacemos antes una copia de seguridad y después insertamos el texto siguiente en la descripción de C(pack):</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">Por &uacute;ltimo, </span><span class="hunk"><ins>falta </ins></span><span class="hunk">la documentaci&oacute;n. </span><span class="hunk"><del>El </del><ins>Para acabar el </ins></span><span class="hunk">trabajo </span><span class="hunk"><del>nunca est&aacute; terminado hasta </del><ins>no queda m&aacute;s remedio </ins></span><span class="hunk">que </span><span class="hunk"><del>el papeleo se acaba</del><ins>ocuparse del papeleo</ins></span><span class="hunk">, as&iacute; que vamos a describir el cambio que </span><span class="hunk"><del>acaba </del><ins>acabamos </ins></span><span class="hunk">de hacer. El lugar </span><span class="hunk"><del>relevante </del><ins>correspondiente </ins></span><span class="hunk">es F(pod/perlfunc.pod</span><span class="hunk"><del>); de nuevo</del><ins>). Una vez m&aacute;s</ins></span><span class="hunk">, hacemos </span><span class="hunk"><ins>antes </ins></span><span class="hunk">una </span><span class="hunk"><del>copia, </del><ins>copia de seguridad </ins></span><span class="hunk">y </span><span class="hunk"><del>luego vamos a insertar este </del><ins>despu&eacute;s insertamos el </ins></span><span class="hunk">texto </span><span class="hunk"><ins>siguiente </ins></span><span class="hunk">en la descripci&oacute;n de C(pack):</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br> Si el patrón comienza con una C(U), la cadena resultante será tratada</br>
<span style='color:red'><b>REVIEWER:</b></span></br> Si el patrón comienza con una C(U), la cadena resultante se tratará</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"> Si el patr&oacute;n comienza con una C(U), la cadena resultante </span><span class="hunk"><del>ser&aacute; tratada</del><ins>se tratar&aacute;</ins></span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br> como codificada en UTF-8 Unicode. Puede forzar una codificación UTF-8 en una cadena</br>
<span style='color:red'><b>REVIEWER:</b></span></br> como caracteres Unicode codificados en UTF-8. Puede forzar la aplicación de una codificación UTF-8 en una cadena</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"> como </span><span class="hunk"><del>codificada </del><ins>caracteres Unicode codificados </ins></span><span class="hunk">en UTF-</span><span class="hunk"><del>8 Unicode</del><ins>8</ins></span><span class="hunk">. Puede forzar </span><span class="hunk"><ins>la aplicaci&oacute;n de </ins></span><span class="hunk">una codificaci&oacute;n UTF-8 en una cadena</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br> con una C(U0) inicial, y los bytes que siguen se interpretarán como</br>
<span style='color:red'><b>REVIEWER:</b></span></br> con C(U0) al principio, y los bytes que siguen se interpretarán como</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"> con </span><span class="hunk"><del>una </del></span><span class="hunk">C(U0) </span><span class="hunk"><del>inicial</del><ins>al principio</ins></span><span class="hunk">, y los bytes que siguen se interpretar&aacute;n como</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br> su patrón con C(C0) (o cualquier otra cosa) para forzar a Perl a no codificar en UTF-8</br>
<span style='color:red'><b>REVIEWER:</b></span></br> el patrón con C(C0) (o cualquier otra cosa) para evitar que Perl fuerce la codificación en UTF-8</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"> </span><span class="hunk"><del>su </del><ins>el </ins></span><span class="hunk">patr&oacute;n con C(C0) (o cualquier otra cosa) para </span><span class="hunk"><del>forzar a </del><ins>evitar que </ins></span><span class="hunk">Perl </span><span class="hunk"><del>a no codificar </del><ins>fuerce la codificaci&oacute;n </ins></span><span class="hunk">en UTF-8</span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br> su cadena, y luego continúe con una C(U*) más adelante en su</br>
<span style='color:red'><b>REVIEWER:</b></span></br> de la cadena, y luego continuar con C(U*) en algún lugar del</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk"> </span><span class="hunk"><del>su </del><ins>de la </ins></span><span class="hunk">cadena, y luego </span><span class="hunk"><del>contin&uacute;e </del><ins>continuar </ins></span><span class="hunk">con </span><span class="hunk"><del>una </del></span><span class="hunk">C(U*) </span><span class="hunk"><del>m&aacute;s adelante </del></span><span class="hunk">en </span><span class="hunk"><del>su</del><ins>alg&uacute;n lugar del</ins></span></div></br>
<span style='color:blue'><b>TRANSLATOR:</b></span></br>Vea L(perlhack) para obtener más información sobre cómo presentar este parche.</br>
<span style='color:red'><b>REVIEWER:</b></span></br>Vea L(perlhack) para obtener más información sobre cómo enviar este parche.</br>
<span style='color:blueviolet'><b>CHANGES:</b></span></br><div class="file"><span class="hunk">Vea L(perlhack) para obtener m&aacute;s informaci&oacute;n sobre c&oacute;mo </span><span class="hunk"><del>presentar </del><ins>enviar </ins></span><span class="hunk">este parche.</span></div></br>
