<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="1.6.1"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME
X&lt;function&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 NOMBRE
X&lt;función&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlfunc - Perl builtin functions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlfunc - Funciones incluídas en Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 DESCRIPTION</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 DESCRIPCIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions in this section can serve as terms in an expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las funciones de esta sección pueden servir como términos en una expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They fall into two major categories: list operators and named unary
operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se agrupan en dos categorías principales: operadores de listas y operadores unarios con nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These differ in their precedence relationship with a
following comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Difieren en su relación de precedencia cuando son seguidos por una coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See the precedence table in L&lt;perlop&gt;.)  List
operators take more than one argument, while unary operators can never
take more than one argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver la tabla de precedencia en L&lt;perlop&gt;.)  Los operadores de listas toman más de un argumento, mientras que los operadores unarios nunca toman más de un argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, a comma terminates the argument of
a unary operator, but merely separates the arguments of a list
operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, una coma determina al argumento de un operador unario, pero sólo sirve de separación entre argumentos en un operador de listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A unary operator generally provides a scalar context to its
argument, while a list operator may provide either scalar or list
contexts for its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un operador unario generalmente proveé de un contexto escalar a su argumento, mientras que un operador de listas puede proveer tanto de un contexto escalar como un contexto de lista, a sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it does both, the scalar arguments will
be first, and the list argument will follow.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si aparecen ambos, los argumentos escalares van antes que los argumentos de listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that there can ever
be only one such list argument.)  For instance, splice() has three scalar
arguments followed by a list, whereas gethostbyname() has four scalar
arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Note aquí que sólo puede aparecer un argumento de lista). Por ejemplo, splice() tiene tres argumentos escalares seguidos por una lista, mientras que gethostbyname() tiene cuatro argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the syntax descriptions that follow, list operators that expect a
list (and provide list context for the elements of the list) are shown
with LIST as an argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En las descripciones sintácticas que siguen a continuación, los operadores de listas que esperan una lista (y proveen de un contexto lista para los elementos de la lista) se muestran con un argumento así: LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a list may consist of any combination
of scalar arguments or list values; the list values will be included
in the list as if each individual element were interpolated at that
point in the list, forming a longer single-dimensional list value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal lista puede consistir en cualquier combinación de argumentos escalares o valores de lista; los valores de lista serán incluidos en la lista como si cada elemento individual fuera interpolado en ese punto en la lista, formando un largo y unidimensional valor de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Commas should separate elements of the LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las comas deberían separar elementos de la LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any function in the list below may be used either with or without
parentheses around its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier función en la lista de abajo puede ser usada tanto con paréntesis como sin ellos alrededor de sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The syntax descriptions omit the
parentheses.)  If you use the parentheses, the simple (but occasionally
surprising) rule is this: It I&lt;looks&gt; like a function, therefore it I&lt;is&gt; a
function, and precedence doesn't matter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Las descripciones sintácticas omiten los paréntesis). Si usa los paréntesis, la simple (pero ocasionalmente sorprendente) regla es esta: Si I&lt;se parece&gt; a una función, por eso I&lt;es&gt; una función y la precedencia no importará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise it's a list
operator or unary operator, and precedence does matter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De lo contrario es un operador de lista u operador unario, y la precedencia sí importa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And whitespace
between the function and left parenthesis doesn't count--so you need to
be careful sometimes:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y el espacio en blanco entre la función y el paréntesis izquierdo no cuenta, por lo que deberá tener cuidado algunas veces:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print 1+2+4;	# Prints 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print 1+2+4;	# Imprime 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print(1+2) + 4;	# Prints 3.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print(1+2) + 4;	# Imprime 3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print (1+2)+4;	# Also prints 3!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print (1+2)+4;	# ¡También imprime 3!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print +(1+2)+4;	# Prints 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print +(1+2)+4;	# Imprime 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print ((1+2)+4);	# Prints 7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print ((1+2)+4);	# Imprime 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run Perl with the B&lt;-w&gt; switch it can warn you about this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si corre Perl con la opción B&lt;-w&gt; le avisará sobre todo esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example, the third line above produces:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, la tercera línea de arriba produce:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print (...) interpreted as function at - line 1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print (...) interpreted as function at - line 1.
(print (...) interpretado como función en - línea 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Useless use of integer addition in void context at - line 1.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Useless use of integer addition in void context at - line 1.
(Inútil uso de suma de enteros en contexto void en - línea 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A few functions take no arguments at all, and therefore work as neither
unary nor list operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Unas pocas funciones no toman ningún argumento, por lo que funcionan tando como operadores unarios como operadores de lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include such functions as C&lt;time&gt;
and C&lt;endpwent&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas incluyen funciones como C&lt;time&gt; y C&lt;endpwent&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;time+86_400&gt; always means
C&lt;time() + 86_400&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;time+86_400&gt; siempre significa C&lt;time() + 86_400&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For functions that can be used in either a scalar or list context,
nonabortive failure is generally indicated in a scalar context by
returning the undefined value, and in a list context by returning the
null list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para funciones que pueden ser usadas tanto en contexto escalar como en lista, un fallo no abortivo es indicado generalmente devolviendo el valor indefinido, y en contexto lista devolviendo la lista nula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember the following important rule: There is B&lt;no rule&gt; that relates
the behavior of an expression in list context to its behavior in scalar
context, or vice versa.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recuerde la siguiente regla importante: B&lt;No hay regla&gt; que relacione el comportamiento de una expresión en contexto lista a su comportamiento en contexto escalar, o viceversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It might do two totally different things.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacer dos cosas totalmente diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator and function decides which sort of value it would be most
appropriate to return in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada operador y función decide qué clase de valor será más apropiado para devolver en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators return the
length of the list that would have been returned in list context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven la longitud de la lista que se hubiera devuelto en contexto lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some
operators return the first value in the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven el primer valor de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators return the
last value in the list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven el último valor de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators return a count of successful
operations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunos operadores devuelven una cuenta del número de operaciones exitosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, they do what you want, unless you want
consistency.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, ellos hacen lo que usted busca, a menos que busque la coherencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;context&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;contexto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A named array in scalar context is quite different from what would at
first glance appear to be a list in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un array con nombre en contexto escalar es muy diferente de lo que en un primer vistazo pudiera ser una lista en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't get a list
like C&lt;(1,2,3)&gt; into being in scalar context, because the compiler knows
the context at compile time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede conseguir que una lista como C&lt;(1,2,3)&gt; se convierta en contexto escalar porque el compilador conoce el contexto en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It would generate the scalar comma operator
there, not the list construction version of the comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Generará aquí el operador coma, no la versión de construcción de listas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means it
was never a list to start with.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que nunca será una lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, functions in Perl that serve as wrappers for system calls
of the same name (like chown(2), fork(2), closedir(2), etc.) all return
true when they succeed and C&lt;undef&gt; otherwise, as is usually mentioned
in the descriptions below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, funciones en Perl que sirven como envoltorios para llamadas al sistema del mismo nombre (como  chown(2), fork(2), closedir(2), etc.) todas ellas devuelven verdadero cuando tienen éxito y C&lt;undef&gt; en otro caso, como se menciona en las descripciones de más abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is different from the C interfaces,
which return C&lt;-1&gt; on failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es diferente de las interfaces C, que devuelven C&lt;-1&gt; en caso de fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exceptions to this rule are C&lt;wait&gt;,
C&lt;waitpid&gt;, and C&lt;syscall&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Excepciones a esta regla son C&lt;wait&gt;, C&lt;waitpid&gt; y C&lt;syscall&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System calls also set the special C&lt;$!&gt;
variable on failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llamadas al sistema también actualizan la variable especial C&lt;$!&gt; en caso de fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other functions do not, except accidentally.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otras funciones no, excepto accidentalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Perl Functions by Category
X&lt;function&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Funciones Perl por Categoría
X&lt;función&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are Perl's functions (including things that look like
functions, like some keywords and named operators)
arranged by category.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí están las funciones Perl (incluyen cosas que parecen funciones, como algunas palabras clave y operadores con nombre) agrupados por categoría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some functions appear in more
than one place.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas funciones aparecen en más de un sitio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over 4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=over 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for SCALARs or strings
X&lt;scalar&gt; X&lt;string&gt; X&lt;character&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones para ESCALARES o strings
X&lt;escalar&gt; X&lt;string&gt; X&lt;carácter&gt; X&lt;caracteres&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;chomp&gt;, C&lt;chop&gt;, C&lt;chr&gt;, C&lt;crypt&gt;, C&lt;hex&gt;, C&lt;index&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;,
C&lt;length&gt;, C&lt;oct&gt;, C&lt;ord&gt;, C&lt;pack&gt;, C&lt;q/STRING/&gt;, C&lt;qq/STRING/&gt;, C&lt;reverse&gt;,
C&lt;rindex&gt;, C&lt;sprintf&gt;, C&lt;substr&gt;, C&lt;tr///&gt;, C&lt;uc&gt;, C&lt;ucfirst&gt;, C&lt;y///&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;chomp&gt;, C&lt;chop&gt;, C&lt;chr&gt;, C&lt;crypt&gt;, C&lt;hex&gt;, C&lt;index&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;,
C&lt;length&gt;, C&lt;oct&gt;, C&lt;ord&gt;, C&lt;pack&gt;, C&lt;q/STRING/&gt;, C&lt;qq/STRING/&gt;, C&lt;reverse&gt;,
C&lt;rindex&gt;, C&lt;sprintf&gt;, C&lt;substr&gt;, C&lt;tr///&gt;, C&lt;uc&gt;, C&lt;ucfirst&gt;, C&lt;y///&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Regular expressions and pattern matching
X&lt;regular expression&gt; X&lt;regex&gt; X&lt;regexp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Expresiones Regulares y coincidencia de patrones
X&lt;expresión regular&gt; X&lt;regex&gt; X&lt;regexp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;m//&gt;, C&lt;pos&gt;, C&lt;quotemeta&gt;, C&lt;s///&gt;, C&lt;split&gt;, C&lt;study&gt;, C&lt;qr//&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;m//&gt;, C&lt;pos&gt;, C&lt;quotemeta&gt;, C&lt;s///&gt;, C&lt;split&gt;, C&lt;study&gt;, C&lt;qr//&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Numeric functions
X&lt;numeric&gt; X&lt;number&gt; X&lt;trigonometric&gt; X&lt;trigonometry&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones Numéricas
X&lt;numérico&gt; X&lt;numérica&gt; X&lt;número&gt; X&lt;trigonométrico&gt; X&lt;trigonometría&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;abs&gt;, C&lt;atan2&gt;, C&lt;cos&gt;, C&lt;exp&gt;, C&lt;hex&gt;, C&lt;int&gt;, C&lt;log&gt;, C&lt;oct&gt;, C&lt;rand&gt;,
C&lt;sin&gt;, C&lt;sqrt&gt;, C&lt;srand&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;abs&gt;, C&lt;atan2&gt;, C&lt;cos&gt;, C&lt;exp&gt;, C&lt;hex&gt;, C&lt;int&gt;, C&lt;log&gt;, C&lt;oct&gt;, C&lt;rand&gt;,
C&lt;sin&gt;, C&lt;sqrt&gt;, C&lt;srand&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for real @ARRAYs
X&lt;array&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones para @ARRAY verdaderos
X&lt;array&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;pop&gt;, C&lt;push&gt;, C&lt;shift&gt;, C&lt;splice&gt;, C&lt;unshift&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;pop&gt;, C&lt;push&gt;, C&lt;shift&gt;, C&lt;splice&gt;, C&lt;unshift&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for list data
X&lt;list&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones para listas de datos
X&lt;lista&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;grep&gt;, C&lt;join&gt;, C&lt;map&gt;, C&lt;qw/STRING/&gt;, C&lt;reverse&gt;, C&lt;sort&gt;, C&lt;unpack&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;grep&gt;, C&lt;join&gt;, C&lt;map&gt;, C&lt;qw/STRING/&gt;, C&lt;reverse&gt;, C&lt;sort&gt;, C&lt;unpack&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for real %HASHes
X&lt;hash&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones para %HASH verdaderos
X&lt;hash&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;delete&gt;, C&lt;each&gt;, C&lt;exists&gt;, C&lt;keys&gt;, C&lt;values&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;delete&gt;, C&lt;each&gt;, C&lt;exists&gt;, C&lt;keys&gt;, C&lt;values&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Input and output functions
X&lt;I/O&gt; X&lt;input&gt; X&lt;output&gt; X&lt;dbm&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones de entrada y salida
X&lt;I/O&gt; X&lt;input&gt; X&lt;output&gt; X&lt;dbm&gt; X&lt;entrada&gt; X&lt;salida&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;binmode&gt;, C&lt;close&gt;, C&lt;closedir&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;die&gt;, C&lt;eof&gt;,
C&lt;fileno&gt;, C&lt;flock&gt;, C&lt;format&gt;, C&lt;getc&gt;, C&lt;print&gt;, C&lt;printf&gt;, C&lt;read&gt;,
C&lt;readdir&gt;, C&lt;rewinddir&gt;, C&lt;seek&gt;, C&lt;seekdir&gt;, C&lt;select&gt;, C&lt;syscall&gt;,
C&lt;sysread&gt;, C&lt;sysseek&gt;, C&lt;syswrite&gt;, C&lt;tell&gt;, C&lt;telldir&gt;, C&lt;truncate&gt;,
C&lt;warn&gt;, C&lt;write&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;binmode&gt;, C&lt;close&gt;, C&lt;closedir&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;die&gt;, C&lt;eof&gt;,
C&lt;fileno&gt;, C&lt;flock&gt;, C&lt;format&gt;, C&lt;getc&gt;, C&lt;print&gt;, C&lt;printf&gt;, C&lt;read&gt;,
C&lt;readdir&gt;, C&lt;rewinddir&gt;, C&lt;seek&gt;, C&lt;seekdir&gt;, C&lt;select&gt;, C&lt;syscall&gt;,
C&lt;sysread&gt;, C&lt;sysseek&gt;, C&lt;syswrite&gt;, C&lt;tell&gt;, C&lt;telldir&gt;, C&lt;truncate&gt;,
C&lt;warn&gt;, C&lt;write&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for fixed length data or records</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones para datos de longitud fija o registros</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;pack&gt;, C&lt;read&gt;, C&lt;syscall&gt;, C&lt;sysread&gt;, C&lt;syswrite&gt;, C&lt;unpack&gt;, C&lt;vec&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;pack&gt;, C&lt;read&gt;, C&lt;syscall&gt;, C&lt;sysread&gt;, C&lt;syswrite&gt;, C&lt;unpack&gt;, C&lt;vec&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for filehandles, files, or directories
X&lt;file&gt; X&lt;filehandle&gt; X&lt;directory&gt; X&lt;pipe&gt; X&lt;link&gt; X&lt;symlink&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Functones para manejadores de archivos, ficheros o directorios
X&lt;fichero&gt; X&lt;manejador&gt; X&lt;directorio&gt; X&lt;pipe&gt; X&lt;link&gt; X&lt;symlink&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;-I&lt;X&gt;&gt;, C&lt;chdir&gt;, C&lt;chmod&gt;, C&lt;chown&gt;, C&lt;chroot&gt;, C&lt;fcntl&gt;, C&lt;glob&gt;,
C&lt;ioctl&gt;, C&lt;link&gt;, C&lt;lstat&gt;, C&lt;mkdir&gt;, C&lt;open&gt;, C&lt;opendir&gt;,
C&lt;readlink&gt;, C&lt;rename&gt;, C&lt;rmdir&gt;, C&lt;stat&gt;, C&lt;symlink&gt;, C&lt;sysopen&gt;,
C&lt;umask&gt;, C&lt;unlink&gt;, C&lt;utime&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;-I&lt;X&gt;&gt;, C&lt;chdir&gt;, C&lt;chmod&gt;, C&lt;chown&gt;, C&lt;chroot&gt;, C&lt;fcntl&gt;, C&lt;glob&gt;,
C&lt;ioctl&gt;, C&lt;link&gt;, C&lt;lstat&gt;, C&lt;mkdir&gt;, C&lt;open&gt;, C&lt;opendir&gt;,
C&lt;readlink&gt;, C&lt;rename&gt;, C&lt;rmdir&gt;, C&lt;stat&gt;, C&lt;symlink&gt;, C&lt;sysopen&gt;,
C&lt;umask&gt;, C&lt;unlink&gt;, C&lt;utime&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to the control flow of your Perl program
X&lt;control flow&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Palabras clave relativas al control de flujo de su programa Perl
X&lt;control de flujo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;caller&gt;, C&lt;continue&gt;, C&lt;die&gt;, C&lt;do&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;exit&gt;,
C&lt;goto&gt;, C&lt;last&gt;, C&lt;next&gt;, C&lt;redo&gt;, C&lt;return&gt;, C&lt;sub&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;caller&gt;, C&lt;continue&gt;, C&lt;die&gt;, C&lt;do&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;exit&gt;,
C&lt;goto&gt;, C&lt;last&gt;, C&lt;next&gt;, C&lt;redo&gt;, C&lt;return&gt;, C&lt;sub&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to scoping</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Palabras clave relacionadas con el ámbito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;caller&gt;, C&lt;import&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;, C&lt;package&gt;, C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;caller&gt;, C&lt;import&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;, C&lt;package&gt;, C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Miscellaneous functions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones Varias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;defined&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;formline&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;, C&lt;reset&gt;,
C&lt;scalar&gt;, C&lt;undef&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;defined&gt;, C&lt;dump&gt;, C&lt;eval&gt;, C&lt;formline&gt;, C&lt;local&gt;, C&lt;my&gt;, C&lt;our&gt;, C&lt;reset&gt;,
C&lt;scalar&gt;, C&lt;undef&gt;, C&lt;wantarray&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions for processes and process groups
X&lt;process&gt; X&lt;pid&gt; X&lt;process id&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones para procesos y grupos de procesos
X&lt;proceso&gt; X&lt;pid&gt; X&lt;proceso id&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;alarm&gt;, C&lt;exec&gt;, C&lt;fork&gt;, C&lt;getpgrp&gt;, C&lt;getppid&gt;, C&lt;getpriority&gt;, C&lt;kill&gt;,
C&lt;pipe&gt;, C&lt;qx/STRING/&gt;, C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;sleep&gt;, C&lt;system&gt;,
C&lt;times&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;alarm&gt;, C&lt;exec&gt;, C&lt;fork&gt;, C&lt;getpgrp&gt;, C&lt;getppid&gt;, C&lt;getpriority&gt;, C&lt;kill&gt;,
C&lt;pipe&gt;, C&lt;qx/STRING/&gt;, C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;sleep&gt;, C&lt;system&gt;,
C&lt;times&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to perl modules
X&lt;module&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Palabras clave relacionadas con módulos perl
X&lt;módulo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;do&gt;, C&lt;import&gt;, C&lt;no&gt;, C&lt;package&gt;, C&lt;require&gt;, C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;do&gt;, C&lt;import&gt;, C&lt;no&gt;, C&lt;package&gt;, C&lt;require&gt;, C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Keywords related to classes and object-orientedness
X&lt;object&gt; X&lt;class&gt; X&lt;package&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Palabras clave relacionadas a clases y orientado a objetos
X&lt;objeto&gt; X&lt;clase&gt; X&lt;package&gt; X&lt;paquete&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;bless&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;package&gt;, C&lt;ref&gt;, C&lt;tie&gt;, C&lt;tied&gt;,
C&lt;untie&gt;, C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;bless&gt;, C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;package&gt;, C&lt;ref&gt;, C&lt;tie&gt;, C&lt;tied&gt;,
C&lt;untie&gt;, C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Low-level socket functions
X&lt;socket&gt; X&lt;sock&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones de socket de bajo nivel
X&lt;socket&gt; X&lt;sock&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;accept&gt;, C&lt;bind&gt;, C&lt;connect&gt;, C&lt;getpeername&gt;, C&lt;getsockname&gt;,
C&lt;getsockopt&gt;, C&lt;listen&gt;, C&lt;recv&gt;, C&lt;send&gt;, C&lt;setsockopt&gt;, C&lt;shutdown&gt;,
C&lt;socket&gt;, C&lt;socketpair&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;accept&gt;, C&lt;bind&gt;, C&lt;connect&gt;, C&lt;getpeername&gt;, C&lt;getsockname&gt;,
C&lt;getsockopt&gt;, C&lt;listen&gt;, C&lt;recv&gt;, C&lt;send&gt;, C&lt;setsockopt&gt;, C&lt;shutdown&gt;,
C&lt;socket&gt;, C&lt;socketpair&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item System V interprocess communication functions
X&lt;IPC&gt; X&lt;System V&gt; X&lt;semaphore&gt; X&lt;shared memory&gt; X&lt;memory&gt; X&lt;message&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones de comunicación de interprocesos System V
X&lt;IPC&gt; X&lt;System V&gt; X&lt;semáforo&gt; X&lt;memoria compartida&gt; X&lt;memoria&gt; X&lt;mensaje&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;, C&lt;msgsnd&gt;, C&lt;semctl&gt;, C&lt;semget&gt;, C&lt;semop&gt;,
C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;, C&lt;shmwrite&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;, C&lt;msgsnd&gt;, C&lt;semctl&gt;, C&lt;semget&gt;, C&lt;semop&gt;,
C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;, C&lt;shmwrite&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Fetching user and group info
X&lt;user&gt; X&lt;group&gt; X&lt;password&gt; X&lt;uid&gt; X&lt;gid&gt;  X&lt;passwd&gt; X&lt;/etc/passwd&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Obteniendo información del usuario y grupo
X&lt;usuario&gt; X&lt;grupo&gt; X&lt;password&gt; X&lt;contraseña&gt; X&lt;uid&gt; X&lt;gid&gt;  X&lt;passwd&gt; X&lt;/etc/passwd&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;endgrent&gt;, C&lt;endhostent&gt;, C&lt;endnetent&gt;, C&lt;endpwent&gt;, C&lt;getgrent&gt;,
C&lt;getgrgid&gt;, C&lt;getgrnam&gt;, C&lt;getlogin&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;,
C&lt;getpwuid&gt;, C&lt;setgrent&gt;, C&lt;setpwent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;endgrent&gt;, C&lt;endhostent&gt;, C&lt;endnetent&gt;, C&lt;endpwent&gt;, C&lt;getgrent&gt;,
C&lt;getgrgid&gt;, C&lt;getgrnam&gt;, C&lt;getlogin&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;,
C&lt;getpwuid&gt;, C&lt;setgrent&gt;, C&lt;setpwent&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Fetching network info
X&lt;network&gt; X&lt;protocol&gt; X&lt;host&gt; X&lt;hostname&gt; X&lt;IP&gt; X&lt;address&gt; X&lt;service&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Obteniendo información de la red
X&lt;network&gt; X&lt;red&gt; X&lt;protocolo&gt; X&lt;host&gt; X&lt;hostname&gt; X&lt;IP&gt; X&lt;dirección&gt; X&lt;servicio&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;endprotoent&gt;, C&lt;endservent&gt;, C&lt;gethostbyaddr&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getprotobyname&gt;, C&lt;getprotobynumber&gt;, C&lt;getprotoent&gt;,
C&lt;getservbyname&gt;, C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;sethostent&gt;,
C&lt;setnetent&gt;, C&lt;setprotoent&gt;, C&lt;setservent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;endprotoent&gt;, C&lt;endservent&gt;, C&lt;gethostbyaddr&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getprotobyname&gt;, C&lt;getprotobynumber&gt;, C&lt;getprotoent&gt;,
C&lt;getservbyname&gt;, C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;sethostent&gt;,
C&lt;setnetent&gt;, C&lt;setprotoent&gt;, C&lt;setservent&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Time-related functions
X&lt;time&gt; X&lt;date&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones relacionadas con el Tiempo
X&lt;tiempo&gt; X&lt;fecha&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;gmtime&gt;, C&lt;localtime&gt;, C&lt;time&gt;, C&lt;times&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;gmtime&gt;, C&lt;localtime&gt;, C&lt;time&gt;, C&lt;times&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions new in perl5
X&lt;perl5&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones nuevas en perl5
X&lt;perl5&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;abs&gt;, C&lt;bless&gt;, C&lt;chomp&gt;, C&lt;chr&gt;, C&lt;exists&gt;, C&lt;formline&gt;, C&lt;glob&gt;,
C&lt;import&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;, C&lt;map&gt;, C&lt;my&gt;, C&lt;no&gt;, C&lt;our&gt;, C&lt;prototype&gt;,
C&lt;qx&gt;, C&lt;qw&gt;, C&lt;readline&gt;, C&lt;readpipe&gt;, C&lt;ref&gt;, C&lt;sub*&gt;, C&lt;sysopen&gt;, C&lt;tie&gt;,
C&lt;tied&gt;, C&lt;uc&gt;, C&lt;ucfirst&gt;, C&lt;untie&gt;, C&lt;use&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;abs&gt;, C&lt;bless&gt;, C&lt;chomp&gt;, C&lt;chr&gt;, C&lt;exists&gt;, C&lt;formline&gt;, C&lt;glob&gt;,
C&lt;import&gt;, C&lt;lc&gt;, C&lt;lcfirst&gt;, C&lt;map&gt;, C&lt;my&gt;, C&lt;no&gt;, C&lt;our&gt;, C&lt;prototype&gt;,
C&lt;qx&gt;, C&lt;qw&gt;, C&lt;readline&gt;, C&lt;readpipe&gt;, C&lt;ref&gt;, C&lt;sub*&gt;, C&lt;sysopen&gt;, C&lt;tie&gt;,
C&lt;tied&gt;, C&lt;uc&gt;, C&lt;ucfirst&gt;, C&lt;untie&gt;, C&lt;use&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* - C&lt;sub&gt; was a keyword in perl4, but in perl5 it is an
operator, which can be used in expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>* - C&lt;sub&gt; era una palabra clave en perl4, pero en perl5 es un operador, por lo cual puede ser usado con paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item Functions obsoleted in perl5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item Funciones obsoletas en perl5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;dbmclose&gt;, C&lt;dbmopen&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;dbmclose&gt;, C&lt;dbmopen&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=back</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Portability
X&lt;portability&gt; X&lt;Unix&gt; X&lt;portable&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Portabilidad
X&lt;portabilidad&gt; X&lt;adaptación&gt; X&lt;Unix&gt; X&lt;portable&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl was born in Unix and can therefore access all common Unix
system calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl nació en Unix y por eso puede acceder a todas las llamadas normales del sistema Unix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In non-Unix environments, the functionality of some
Unix system calls may not be available, or details of the available
functionality may differ slightly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En entornos no Unix, la funcionalidad de algunas llamadas del sistema Unix pueden no estar disponibles, o los detalles de la funcionalidad disponible diferir ligeramente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl functions affected
by this are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las funciones Perl afectadas por esto son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;-X&gt;, C&lt;binmode&gt;, C&lt;chmod&gt;, C&lt;chown&gt;, C&lt;chroot&gt;, C&lt;crypt&gt;,
C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;dump&gt;, C&lt;endgrent&gt;, C&lt;endhostent&gt;,
C&lt;endnetent&gt;, C&lt;endprotoent&gt;, C&lt;endpwent&gt;, C&lt;endservent&gt;, C&lt;exec&gt;,
C&lt;fcntl&gt;, C&lt;flock&gt;, C&lt;fork&gt;, C&lt;getgrent&gt;, C&lt;getgrgid&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getlogin&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getppid&gt;, C&lt;getpgrp&gt;, C&lt;getpriority&gt;, C&lt;getprotobynumber&gt;,
C&lt;getprotoent&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;, C&lt;getpwuid&gt;,
C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;getsockopt&gt;, C&lt;glob&gt;, C&lt;ioctl&gt;,
C&lt;kill&gt;, C&lt;link&gt;, C&lt;lstat&gt;, C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;,
C&lt;msgsnd&gt;, C&lt;open&gt;, C&lt;pipe&gt;, C&lt;readlink&gt;, C&lt;rename&gt;, C&lt;select&gt;, C&lt;semctl&gt;,
C&lt;semget&gt;, C&lt;semop&gt;, C&lt;setgrent&gt;, C&lt;sethostent&gt;, C&lt;setnetent&gt;,
C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;setprotoent&gt;, C&lt;setpwent&gt;,
C&lt;setservent&gt;, C&lt;setsockopt&gt;, C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;,
C&lt;shmwrite&gt;, C&lt;socket&gt;, C&lt;socketpair&gt;,
C&lt;stat&gt;, C&lt;symlink&gt;, C&lt;syscall&gt;, C&lt;sysopen&gt;, C&lt;system&gt;,
C&lt;times&gt;, C&lt;truncate&gt;, C&lt;umask&gt;, C&lt;unlink&gt;,
C&lt;utime&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;-X&gt;, C&lt;binmode&gt;, C&lt;chmod&gt;, C&lt;chown&gt;, C&lt;chroot&gt;, C&lt;crypt&gt;,
C&lt;dbmclose&gt;, C&lt;dbmopen&gt;, C&lt;dump&gt;, C&lt;endgrent&gt;, C&lt;endhostent&gt;,
C&lt;endnetent&gt;, C&lt;endprotoent&gt;, C&lt;endpwent&gt;, C&lt;endservent&gt;, C&lt;exec&gt;,
C&lt;fcntl&gt;, C&lt;flock&gt;, C&lt;fork&gt;, C&lt;getgrent&gt;, C&lt;getgrgid&gt;, C&lt;gethostbyname&gt;,
C&lt;gethostent&gt;, C&lt;getlogin&gt;, C&lt;getnetbyaddr&gt;, C&lt;getnetbyname&gt;, C&lt;getnetent&gt;,
C&lt;getppid&gt;, C&lt;getpgrp&gt;, C&lt;getpriority&gt;, C&lt;getprotobynumber&gt;,
C&lt;getprotoent&gt;, C&lt;getpwent&gt;, C&lt;getpwnam&gt;, C&lt;getpwuid&gt;,
C&lt;getservbyport&gt;, C&lt;getservent&gt;, C&lt;getsockopt&gt;, C&lt;glob&gt;, C&lt;ioctl&gt;,
C&lt;kill&gt;, C&lt;link&gt;, C&lt;lstat&gt;, C&lt;msgctl&gt;, C&lt;msgget&gt;, C&lt;msgrcv&gt;,
C&lt;msgsnd&gt;, C&lt;open&gt;, C&lt;pipe&gt;, C&lt;readlink&gt;, C&lt;rename&gt;, C&lt;select&gt;, C&lt;semctl&gt;,
C&lt;semget&gt;, C&lt;semop&gt;, C&lt;setgrent&gt;, C&lt;sethostent&gt;, C&lt;setnetent&gt;,
C&lt;setpgrp&gt;, C&lt;setpriority&gt;, C&lt;setprotoent&gt;, C&lt;setpwent&gt;,
C&lt;setservent&gt;, C&lt;setsockopt&gt;, C&lt;shmctl&gt;, C&lt;shmget&gt;, C&lt;shmread&gt;,
C&lt;shmwrite&gt;, C&lt;socket&gt;, C&lt;socketpair&gt;,
C&lt;stat&gt;, C&lt;symlink&gt;, C&lt;syscall&gt;, C&lt;sysopen&gt;, C&lt;system&gt;,
C&lt;times&gt;, C&lt;truncate&gt;, C&lt;umask&gt;, C&lt;unlink&gt;,
C&lt;utime&gt;, C&lt;wait&gt;, C&lt;waitpid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about the portability of these functions, see
L&lt;perlport&gt; and other available platform-specific documentation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información sobre la portabilidad de estas funciones, ver L&lt;perlport&gt; y otra documentación específica de la plataforma que esté disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Alphabetical Listing of Perl Functions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Listado alfabético de las funciones Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=over 8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=over 8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X FILEHANDLE
X&lt;-r&gt;X&lt;-w&gt;X&lt;-x&gt;X&lt;-o&gt;X&lt;-R&gt;X&lt;-W&gt;X&lt;-X&gt;X&lt;-O&gt;X&lt;-e&gt;X&lt;-z&gt;X&lt;-s&gt;X&lt;-f&gt;X&lt;-d&gt;X&lt;-l&gt;X&lt;-p&gt;
X&lt;-S&gt;X&lt;-b&gt;X&lt;-c&gt;X&lt;-t&gt;X&lt;-u&gt;X&lt;-g&gt;X&lt;-k&gt;X&lt;-T&gt;X&lt;-B&gt;X&lt;-M&gt;X&lt;-A&gt;X&lt;-C&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item -X MANEJADOR
X&lt;-r&gt;X&lt;-w&gt;X&lt;-x&gt;X&lt;-o&gt;X&lt;-R&gt;X&lt;-W&gt;X&lt;-X&gt;X&lt;-O&gt;X&lt;-e&gt;X&lt;-z&gt;X&lt;-s&gt;X&lt;-f&gt;X&lt;-d&gt;X&lt;-l&gt;X&lt;-p&gt;
X&lt;-S&gt;X&lt;-b&gt;X&lt;-c&gt;X&lt;-t&gt;X&lt;-u&gt;X&lt;-g&gt;X&lt;-k&gt;X&lt;-T&gt;X&lt;-B&gt;X&lt;-M&gt;X&lt;-A&gt;X&lt;-C&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item -X EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item -X</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item -X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A file test, where X is one of the letters listed below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un test de fichero, donde X es una de las letras listadas abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This unary
operator takes one argument, either a filename or a filehandle, and
tests the associated file to see if something is true about it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este operador unario toma un argumento, un nombre de fichero o un manejador, y testea el fichero asociado para ver si algo sobre él es cierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
argument is omitted, tests C&lt;$_&gt;, except for C&lt;-t&gt;, which tests STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el argumento está omitido, se testea C&lt;$_&gt;, excepto para C&lt;-t&gt;, que testea STDIN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise documented, it returns C&lt;1&gt; for true and C&lt;''&gt; for false, or
the undefined value if the file doesn't exist.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras no se diga lo contrario, devuelve C&lt;1&gt; para verdadero y C&lt;''&gt; para falso, o el valor indefinido si el fichero no existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Despite the funny
names, precedence is the same as any other named unary operator, and
the argument may be parenthesized like any other unary operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A pesar de los nombres graciosos, la precedencia es la misma que en cualquier otro operador unario y el argumento puede ser rodeado por paréntesis como cualquier otro operador unario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
operator may be any of:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador puede ser cualquier de:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-r	File is readable by effective uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-r	Fichero es leíble por el uid/gid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-w	File is writable by effective uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-w	Fichero es escribible por el uid/gid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-x	File is executable by effective uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-x	Fichero es ejecutable por el uid/gid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-o	File is owned by effective uid.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-o	Fichero es propiedad del uid en vigor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-R	File is readable by real uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-R	Fichero es leíble por el uid/gid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-W	File is writable by real uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-W	Fichero es escribible por el uid/gid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-X	File is executable by real uid/gid.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-X	Fichero es ejecutable por el uid/gid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-O	File is owned by real uid.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-O	Fichero es propiedad del uid real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-e	File exists.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-e	Fichero existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-z	File has zero size (is empty).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-z	Fichero tiene tamaño cero (está vacío).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-s	File has nonzero size (returns size in bytes).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-s	Fichero no tiene tamaño cero (devuelve el tamaño en bytes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-f	File is a plain file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-f	Fichero es un fichero normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-d	File is a directory.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-d	Fichero es un directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-l	File is a symbolic link.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-l	Fichero es un enlace simbólico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-p	File is a named pipe (FIFO), or Filehandle is a pipe.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-p	Fichero es una tubería con nombre (FIFO), o el manejador es una tubería.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-S	File is a socket.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-S	Fichero es un socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-b	File is a block special file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-b	Fichero es un archivo especial por bloques.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-c	File is a character special file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-c	Fichero es un archivo especial de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-t	Filehandle is opened to a tty.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-t	Manejador está abierto a una tty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-u	File has setuid bit set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-u	Fichero tiene puesto el bit setuid.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-g	File has setgid bit set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-g	Fichero tiene puesto el bit setgid.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-k	File has sticky bit set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-k	Fichero tiene puesto el bit sticky.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-T	File is an ASCII text file (heuristic guess).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-T	Fichero es un fichero de texto ASCII (suposición heurística).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-B	File is a &quot;binary&quot; file (opposite of -T).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-B	Fichero es un archivo &quot;binario&quot; (opuesto de -T).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-M	Script start time minus file modification time, in days.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-M	Tiempo de modificación del fichero menos el tiempo de arranque del script, en días.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-A	Same for access time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-A	Lo mismo para el tiempo de acceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-C	Same for inode change time (Unix, may differ for other platforms)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-C	Lo mismo para el cambio de la fecha del inodo (Unix, puede diferir en otras plataformas)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;&gt;) {
	chomp;
	next unless -f $_;	# ignore specials
	#...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;&gt;) {
	chomp;
	next unless -f $_;	# ignora especiales
	#...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpretation of the file permission operators C&lt;-r&gt;, C&lt;-R&gt;,
C&lt;-w&gt;, C&lt;-W&gt;, C&lt;-x&gt;, and C&lt;-X&gt; is by default based solely on the mode
of the file and the uids and gids of the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La interpretación de los operadores de permisos de fichero C&lt;-r&gt;, C&lt;-R&gt;, C&lt;-w&gt;, C&lt;-W&gt;, C&lt;-x&gt; y C&lt;-X&gt; es por defecto basado sólamente en el modo del fichero y en los uid y gid del usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may be other
reasons you can't actually read, write, or execute the file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede haber otras razones por las que no pueda leer, escribir o ejecutar un fichero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such
reasons may be for example network filesystem access controls, ACLs
(access control lists), read-only filesystems, and unrecognized
executable formats.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esas razones pueden ser por ejemplo controles de acceso a sistemas de ficheros en red, ACL (listas de control de acceso), sistemas de ficheros de sólo lectura y formatos de ejecutables no reconocibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that, for the superuser on the local filesystems, the C&lt;-r&gt;,
C&lt;-R&gt;, C&lt;-w&gt;, and C&lt;-W&gt; tests always return 1, and C&lt;-x&gt; and C&lt;-X&gt; return 1
if any execute bit is set in the mode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También note que, para el superusuario en el sistema de ficheros local, los test C&lt;-r&gt;, C&lt;-R&gt;, C&lt;-w&gt; y C&lt;-W&gt; siempre devuelven 1, y C&lt;-x&gt; y C&lt;-X&gt; devuelven 1 si cualquier bit de ejecución está puesto en el modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scripts run by the superuser
may thus need to do a stat() to determine the actual mode of the file,
or temporarily set their effective uid to something else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Scripts ejecutados por el superusuario pueden necesitar hacer un stat() para determinar el modo actual del fichero, o temporalmente poner su uid efectivo a otro valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using ACLs, there is a pragma called C&lt;filetest&gt; that may
produce more accurate results than the bare stat() mode bits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está usando ACL, hay un pragma llamado C&lt;filetest&gt; que puede producir resultados más precisos que los simples bits de modo de stat().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When under the C&lt;use filetest 'access'&gt; the above-mentioned filetests
will test whether the permission can (not) be granted using the
access() family of system calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando esté bajo 'acceso' por &lt;use filetest&gt; los test de fichero mencionados arriba testearán cuándo los permisos pueden (o no) ser concedidos usando la familia de llamadas del sistema access().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that the C&lt;-x&gt; and C&lt;-X&gt; may
under this pragma return true even if there are no execute permission
bits set (nor any extra execute permission ACLs).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También note que C&lt;-x&gt; y C&lt;-X&gt; pueden bajo este pragma devolver valores verdaderos incluso si los bits de permiso de ejecución no están puestos (ni cualquier permiso ACL extra de ejecución).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This strangeness is
due to the underlying system calls' definitions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comportamiento tan extraño es debido a las definiciones subyacentes de las llamadas del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read the
documentation for the C&lt;filetest&gt; pragma for more information.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lea la documentación para el pragma C&lt;filetest&gt; para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;-s/a/b/&gt; does not do a negated substitution.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;-s/a/b/&gt; no realiza una substitución negada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Saying
C&lt;-exp($foo)&gt; still works as expected, however--only single letters
following a minus are interpreted as file tests.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Diciendo C&lt;-exp($foo)&gt; todavía funciona como se espera; sólo letras sueltas siguiendo a un menos son interpretadas como test de ficheros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;-T&gt; and C&lt;-B&gt; switches work as follows.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las opciones C&lt;-T&gt; y C&lt;-B&gt; funcionan como sigue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first block or so of the
file is examined for odd characters such as strange control codes or
characters with the high bit set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer bloque o así del fichero es examinado para buscar extraños caracteres como códigos de control o caracteres con el bit alto puesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If too many strange characters (&gt;30%)
are found, it's a C&lt;-B&gt; file; otherwise it's a C&lt;-T&gt; file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se encuentran demasiados caracteres extraños (&gt;30%), es un fichero C&lt;-B&gt;; de lo contrario es un fichero C&lt;-T&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, any file
containing null in the first block is considered a binary file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También, cualquier fichero conteniendo caracteres nulos en el primer bloque son considerados ficheros binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;-T&gt;
or C&lt;-B&gt; is used on a filehandle, the current IO buffer is examined
rather than the first block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;-T&gt; o C&lt;-B&gt; se usan con un manejador, el buffer actual de IO es examinado en vez del primer bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both C&lt;-T&gt; and C&lt;-B&gt; return true on a null
file, or a file at EOF when testing a filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ambos C&lt;-T&gt; y C&lt;-B&gt; devuelven verdadero en un fichero nulo o en un fichero en el EOF (fin de fichero) cuando se testee un manejador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because you have to
read a file to do the C&lt;-T&gt; test, on most occasions you want to use a C&lt;-f&gt;
against the file first, as in C&lt;next unless -f $file &amp;&amp; -T $file&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que tiene que leer el fichero para hacer el test C&lt;-T&gt;, en la mayoría de las ocasiones querrá usar primero C&lt;-f&gt;, como enC&lt;next unless -f $fichero &amp;&amp; -T $fichero&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any of the file tests (or either the C&lt;stat&gt; or C&lt;lstat&gt; operators) are given
the special filehandle consisting of a solitary underline, then the stat
structure of the previous file test (or stat operator) is used, saving
a system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si a cualquiera de los test de fichero (o los operadores C&lt;stat&gt; o C&lt;lstat&gt;) se les da el manejador de fichero especial consistente en un solitario subrayado (guión bajo), entonces se usa la estructura stat del fichero del test anterior (u operador stat), ahorrando una llamada del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This doesn't work with C&lt;-t&gt;, and you need to remember
that lstat() and C&lt;-l&gt; will leave values in the stat structure for the
symbolic link, not the real file.)  (Also, if the stat buffer was filled by
an C&lt;lstat&gt; call, C&lt;-T&gt; and C&lt;-B&gt; will reset it with the results of C&lt;stat _&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto no funciona con  C&lt;-t&gt; y necesita recordar que lstat() y C&lt;-l&gt; dejarán valores en la estructura stat para el enlace simbólico, no el fichero real).  (También, si el buffer stat se rellenó con una llamada C&lt;lstat&gt;, C&lt;-T&gt; y C&lt;-B&gt; serán reinicializados con los resultados de C&lt;stat _&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Can do.\n&quot; if -r $a || -w _ || -x _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Puedo hacerlo.\n&quot; if -r $a || -w _ || -x _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stat($filename);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>stat($nombre_de_fichero);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Readable\n&quot; if -r _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Leíble\n&quot; if -r _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Writable\n&quot; if -w _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Escribible\n&quot; if -w _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Executable\n&quot; if -x _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Ejecutable\n&quot; if -x _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Setuid\n&quot; if -u _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Setuid\n&quot; if -u _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Setgid\n&quot; if -g _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Setgid\n&quot; if -g _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Sticky\n&quot; if -k _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Sticky\n&quot; if -k _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Text\n&quot; if -T _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Texto\n&quot; if -T _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Binary\n&quot; if -B _;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Binario\n&quot; if -B _;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item abs VALUE
X&lt;abs&gt; X&lt;absolute&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item abs VALOR
X&lt;abs&gt; X&lt;absoluto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item abs</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item abs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the absolute value of its argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor absoluto del argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VALUE is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite VALOR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item accept NEWSOCKET,GENERICSOCKET
X&lt;accept&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item accept NUEVOSOCKET,SOCKETGENÉRICO
X&lt;accept&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accepts an incoming socket connect, just as the accept(2) system call
does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Acepta un conexión socket entrante, como lo hace la llamada del sistema accept(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the packed address if it succeeded, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la dirección empaquetada si ha tenido éxito, de lo contrario, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example in L&lt;perlipc/&quot;Sockets: Client/Server Communication&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el ejemplo en L&lt;perlipc/&quot;Sockets: Comunicación Cliente/Servidor&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor, as determined by the
value of $^F.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soportan la bandera cerrar-en-ejecución sobre ficheros, la bandera será puesta para el nuevo descriptor de fichero abierto, determinado por el valor de $^F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/$^F&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/$^F&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item alarm SECONDS
X&lt;alarm&gt;
X&lt;SIGALRM&gt;
X&lt;timer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item alarm SEGUNDOS
X&lt;alarm&gt;
X&lt;SIGALRM&gt;
X&lt;timer&gt; X&lt;temporizador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item alarm</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item alarm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arranges to have a SIGALRM delivered to this process after the
specified number of wallclock seconds has elapsed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ordena mandar una señal SIGALRM al proceso actual después de que haya pasado el número de segundos especificados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SECONDS is not
specified, the value stored in C&lt;$_&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no se ha especificado SEGUNDOS, se usará el valor almacenado en C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(On some machines,
unfortunately, the elapsed time may be up to one second less or more
than you specified because of how seconds are counted, and process
scheduling may delay the delivery of the signal even further.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En algunas máquinas, desafortunadamente, el tiempo transcurrido puede ser hasta un segundo más o menos del especificado debido a cómo los segundos son contados, y la planificación de procesos pueden retrasar la entrega de la señal incluso más).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only one timer may be counting at once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo un temporizador puede estar contando cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each call disables the
previous timer, and an argument of C&lt;0&gt; may be supplied to cancel the
previous timer without starting a new one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada llamada desactiva el temporizador anterior, y se puede indicar un argumento C&lt;0&gt; para cancelar el temporizador anterior sin empezar uno nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned value is the
amount of time remaining on the previous timer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto es la cantidad de tiempo restante del temporizador anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For delays of finer granularity than one second, you may use Perl's
four-argument version of select() leaving the first three arguments
undefined, or you might be able to use the C&lt;syscall&gt; interface to
access setitimer(2) if your system supports it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para lapsos más finos que un segundo, puede usar la versión de Perl de cuatro argumentos de select() dejando los 3 primeros argumentos indefinidos, o puede usar la interface C&lt;syscall&gt; para acceder a setitimer(2) si su sistema lo soporta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Time::HiRes
module (from CPAN, and starting from Perl 5.8 part of the standard
distribution) may also prove useful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo Time::HiRes (de CPAN, y siendo desde Perl 5.8 parte de la distribución estándar) puede también ser útil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is usually a mistake to intermix C&lt;alarm&gt; and C&lt;sleep&gt; calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Normalmente es un fallo entremezclar llamadas a C&lt;alarm&gt; y C&lt;sleep&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(C&lt;sleep&gt; may be internally implemented in your system with C&lt;alarm&gt;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(C&lt;sleep&gt; puede internamente estar implementado en su sistema con C&lt;alarm&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use C&lt;alarm&gt; to time out a system call you need to use an
C&lt;eval&gt;/C&lt;die&gt; pair.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere usar C&lt;alarm&gt; controlar la duración de una llamada del sistema necesita una pareja C&lt;eval&gt;/C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't rely on the alarm causing the system call to
fail with C&lt;$!&gt; set to C&lt;EINTR&gt; because Perl sets up signal handlers to
restart system calls on some systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede confiar que la alarma que llama a la llamada del sistema falle y ponga C&lt;$!&gt; a C&lt;EINTR&gt; porque Perl activa manejadores de señal para reiniciar llamadas al sistema en algunos sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;eval&gt;/C&lt;die&gt; always works,
modulo the caveats given in L&lt;perlipc/&quot;Signals&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando C&lt;eval&gt;/C&lt;die&gt; siempre funciona, teniendo en cuenta las advertencias dadas en L&lt;perlipc/&quot;Señales&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval {
	local $SIG{ALRM} = sub { die &quot;alarm\n&quot; }; # NB: \n required
	alarm $timeout;
	$nread = sysread SOCKET, $buffer, $size;
	alarm 0;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval {
	local $SIG{ALRM} = sub { die &quot;alarma\n&quot; }; # NB: se requiere \n
	alarm $timeout;
	$nread = sysread SOCKET, $buffer, $size;
	alarm 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($@) {
	die unless $@ eq &quot;alarm\n&quot;;   # propagate unexpected errors</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($@) {
	die unless $@ eq &quot;alarma\n&quot;;   # propagar errores inesperados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># timed out</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># tiempo agotado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># didn't</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># no se agotó el tiempo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information see L&lt;perlipc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para más información ver L&lt;perlipc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item atan2 Y,X
X&lt;atan2&gt; X&lt;arctangent&gt; X&lt;tan&gt; X&lt;tangent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item atan2 Y,X
X&lt;atan2&gt; X&lt;arcotangente&gt; X&lt;tan&gt; X&lt;tangente&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the arctangent of Y/X in the range -PI to PI.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el arcotangente de Y/X en el rango -PI a PI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the tangent operation, you may use the C&lt;Math::Trig::tan&gt;
function, or use the familiar relation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la operación tangente, puede usar la función C&lt;Math::Trig::tan&gt;, o usar la conocidad relación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub tan { sin($_[0]) / cos($_[0])  }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub tan { sin($_[0]) / cos($_[0])  }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that atan2(0, 0) is not well-defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que atan2(0, 0) no está bien definida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item bind SOCKET,NAME
X&lt;bind&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item bind SOCKET,NOMBRE
X&lt;bind&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binds a network address to a socket, just as the bind system call
does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Enlaza una dirección de red a un socket, como lo hace la llamada del sistema bind.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true if it succeeded, false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tiene éxito; de lo contrario, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NAME should be a
packed address of the appropriate type for the socket.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NOMBRE debe ser una dirección empaquetada del tipo apropiado para el socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the examples in
L&lt;perlipc/&quot;Sockets: Client/Server Communication&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver los ejemplos en L&lt;perlipc/&quot;Sockets: Comunicación Cliente/Servidor&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item binmode FILEHANDLE, LAYER
X&lt;binmode&gt; X&lt;binary&gt; X&lt;text&gt; X&lt;DOS&gt; X&lt;Windows&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item binmode MANEJADOR, CAPA
X&lt;binmode&gt; X&lt;binario&gt; X&lt;texto&gt; X&lt;DOS&gt; X&lt;Windows&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item binmode FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item binmode MANEJADOR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot;
mode on systems where the run-time libraries distinguish between
binary and text files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ordena que el modo de lectura o escritura para el MANEJADOR sea en &quot;binario&quot; o &quot;texto&quot; en sistemas donde las bibliotecas en tiempo de ejecución distingan entre ficheros binarios y de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is an expression, the value is
taken as the name of the filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si MANEJADOR es una expresión, el valor es tomado como el nombre del manejador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true on success,
otherwise it returns C&lt;undef&gt; and sets C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero en éxito; de lo contrario devuelve C&lt;undef&gt; y pone C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some systems (in general, DOS and Windows-based systems) binmode()
is necessary when you're not working with a text file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas (en general, sistemas basados en DOS y Windows) binmode() es necesario cuando no esté trabajando con un fichero de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the sake
of portability it is a good idea to always use it when appropriate,
and to never use it when it isn't appropriate.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para una mejor portabilidad es una buena idea siempre usarlo cuando sea apropiado, y nunca usarlo cuando no sea apropiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, people can
set their I/O to be by default UTF-8 encoded Unicode, not bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También, el personal puede poner su I/O para que sea codificado en Unicode UTF-8, y no bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words: regardless of platform, use binmode() on binary data,
like for example images.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras: indiferentemente de la plataforma, use binmode() en datos binarios, como por ejemplo imágenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LAYER is present it is a single string, but may contain multiple
directives.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si CAPA está presente es un único string, pero puede contener múltiples directivas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The directives alter the behaviour of the file handle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las directivas alteran el comportamiento del manejador del fichero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When LAYER is present using binmode on text file makes sense.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tiene sentido usar binmode sobre un fichero de texto cuando CAPA está presente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LAYER is omitted or specified as C&lt;:raw&gt; the filehandle is made
suitable for passing binary data.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite CAPA o se especifica como C&lt;:raw&gt; el manejador se prepara para pasar datos binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes turning off possible CRLF
translation and marking it as bytes (as opposed to Unicode characters).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto incluye desactivar posibles traducciones CRLF y marcarlas como bytes (como opuesto a los caracteres Unicode).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, despite what may be implied in I&lt;&quot;Programming Perl&quot;&gt; (the
Camel) or elsewhere, C&lt;:raw&gt; is I&lt;not&gt; the simply inverse of C&lt;:crlf&gt;
-- other layers which would affect binary nature of the stream are
I&lt;also&gt; disabled.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que, a pesar de estar implícito en I&lt;&quot;Programming Perl&quot;&gt; (el dromedario) o en otra lugar, C&lt;:raw&gt; I&lt;no&gt; es el inverso simple de C&lt;:crlf&gt; -- otras capas que pudieran afectar la naturaleza binaria del flujo son I&lt;también&gt; desactivadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;PerlIO&gt;, L&lt;perlrun&gt; and the discussion about the
PERLIO environment variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;PerlIO&gt;, L&lt;perlrun&gt; y la discusión sobre la variable de entorno PERLIO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:bytes&gt;, C&lt;:crlf&gt;, and C&lt;:utf8&gt;, and any other directives of the
form C&lt;:...&gt;, are called I/O I&lt;layers&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;:bytes&gt;, C&lt;:crlf&gt; y C&lt;:utf8&gt;, y cualquier otra directiva de la forma C&lt;:...&gt; se llaman I&lt;capas&gt; I/O.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;open&gt; pragma can be used to
establish default I/O layers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El pragma C&lt;open&gt; puede ser usado para establecer las capas I/O por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;open&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;open&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I&lt;The LAYER parameter of the binmode() function is described as &quot;DISCIPLINE&quot;
in &quot;Programming Perl, 3rd Edition&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>I&lt;El parámetro CAPA de la función binmode() se describe como &quot;DISCIPLINA&quot; en &quot;Programming Perl, 3rd Edition&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since the publishing of this
book, by many known as &quot;Camel III&quot;, the consensus of the naming of this
functionality has moved from &quot;discipline&quot; to &quot;layer&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, desde la publicación de este libro, conocido por muchos como &quot;Camel III&quot;, el consenso sobre el nombre de esta funcionalidad se ha movido desde &quot;disciplina&quot; a &quot;capa&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All documentation
of this version of Perl therefore refers to &quot;layers&quot; rather than to
&quot;disciplines&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Toda documentación desde esta versión de Perl se refiere a &quot;capas&quot; en vez de a &quot;disciplinas&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now back to the regularly scheduled documentation...&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ahora volvamos a la documentación normal...&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To mark FILEHANDLE as UTF-8, use C&lt;:utf8&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para marcar MANEJADOR como UTF-8, use C&lt;:utf8&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, binmode() should be called after open() but before any I/O
is done on the filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En general, binmode() debe ser llamada después de open() pero antes de que cualquier I/O se realice sobre el manejador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling binmode() will normally flush any
pending buffered output data (and perhaps pending input data) on the
handle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llamando binmode() normalmente vaciará cualquier dato pendiente almacenado en la salida (y quizás datos pendientes a la entrada) del manejador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An exception to this is the C&lt;:encoding&gt; layer that
changes the default character encoding of the handle, see L&lt;open&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una excepción a esto es la capa C&lt;:encoding&gt; que cambia la codificación por defecto del manejador; ver L&lt;open&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:encoding&gt; layer sometimes needs to be called in
mid-stream, and it doesn't flush the stream.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La capa C&lt;:encoding&gt; algunas veces necesita ser llamada en mitad del flujo de datos y no lo vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;:encoding&gt;
also implicitly pushes on top of itself the C&lt;:utf8&gt; layer because
internally Perl will operate on UTF-8 encoded Unicode characters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;:encoding&gt; también se coloca, implícitamente, por encima de la capa C&lt;:utf8&gt; porque Perl internamente operará con caracteres Unicode codificados en UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operating system, device drivers, C libraries, and Perl run-time
system all work together to let the programmer treat a single
character (C&lt;\n&gt;) as the line terminator, irrespective of the external
representation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El sistema operativo, controladores de dispositivos, bibliotecas C y Perl en tiempo de ejecución trabajan al unísono para permitirle al programador tratar un simple carácter (C&lt;\n&gt;) como el final de línea, independientemente de su representación externa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On many operating systems, the native text file
representation matches the internal representation, but on some
platforms the external representation of C&lt;\n&gt; is made up of more than
one character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En muchos sistemas operativos, la representación nativa de un fichero texto coincide con su representación interna, pero en algunas plataformas la representación externa de C&lt;\n&gt; se realiza con más de un carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mac OS, all variants of Unix, and Stream_LF files on VMS use a single
character to end each line in the external representation of text (even
though that single character is CARRIAGE RETURN on Mac OS and LINE FEED
on Unix and most VMS files).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mac OS, todas las variantes de Unix y los ficheros Stream_LF sobre VMS usan un único carácter al final de cada línea en la representación externa del texto (incluso si el carácter único es un RETORNO DE CARRO en Mac OS y un AVANCE DE LÍNEA en Unix y la mayor parte de los ficheros VMS).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other systems like OS/2, DOS and the
various flavors of MS-Windows your program sees a C&lt;\n&gt; as a simple C&lt;\cJ&gt;,
but what's stored in text files are the two characters C&lt;\cM\cJ&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otros sistemas como OS/2, DOS y los distintos sabores de MS-Windows tu programa vee un C&lt;\n&gt; como un simple C&lt;\cJ&gt;, pero es almacenado en los ficheros de texto como los dos caracteres C&lt;\cM\cJ&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That
means that, if you don't use binmode() on these systems, C&lt;\cM\cJ&gt;
sequences on disk will be converted to C&lt;\n&gt; on input, and any C&lt;\n&gt; in
your program will be converted back to C&lt;\cM\cJ&gt; on output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que, si no usas binmode() en estos sistemas, las secuencias C&lt;\cM\cJ&gt; en disco serán convertidas a C&lt;\n&gt; en la entrada y cualquier C&lt;\n&gt; en tu programa será convertido de nuevo en C&lt;\cM\cJ&gt; en la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is what
you want for text files, but it can be disastrous for binary files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es lo que quiere para ficheros de texto, pero puede ser desastroso para ficheros binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another consequence of using binmode() (on some systems) is that
special end-of-file markers will be seen as part of the data stream.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otra consecuencia de usar binmode() (en algunos sistemas) es que las marcas especiales de fin-de-fichero serán vistas como parte del flujo de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For systems from the Microsoft family this means that if your binary
data contains C&lt;\cZ&gt;, the I/O subsystem will regard it as the end of
the file, unless you use binmode().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para los sistemas de la familia Microsoft esto significa que si sus datos binarios contienenC&lt;\cZ&gt;, el subsistema I/O lo considerarán como el fin del fichero, a menos que use binmode().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>binmode() is not only important for readline() and print() operations,
but also when using read(), seek(), sysread(), syswrite() and tell()
(see L&lt;perlport&gt; for more details).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>binmode() no sólo es importante para las operaciones readline() y print(), sino también cuando se usan read(), seek(), sysread(), syswrite() y tell() (ver L&lt;perlport&gt; para más detalles).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the C&lt;$/&gt; and C&lt;$\&gt; variables
in L&lt;perlvar&gt; for how to manually set your input and output
line-termination sequences.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver las variables C&lt;$/&gt; y C&lt;$\&gt; en L&lt;perlvar&gt; para cómo poner manualmente sus secuencias de fin de línea en su entrada y salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item bless REF,CLASSNAME
X&lt;bless&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item bless REF,NOMBRECLASE
X&lt;bless&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item bless REF</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item bless REF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function tells the thingy referenced by REF that it is now an object
in the CLASSNAME package.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función dice que la cosa referenciada por REF es ahora un objeto del paquete NOMBRECLASE (I&lt;bless&gt; es bendición en inglés, que se podría traducir mejor por bautizar, en el sentido de 'dar un nombre' al objeto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If CLASSNAME is omitted, the current package
is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite NOMBRECLASE, se usa el paquete actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a C&lt;bless&gt; is often the last thing in a constructor,
it returns the reference for convenience.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como un C&lt;bless&gt; a menudo es la última cosa de un constructor, devuelve la referencia por conveniencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always use the two-argument
version if a derived class might inherit the function doing the blessing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre usar la versión de dos argumentos si una clase derivada puede heredar la función con un nuevo bautizo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perltoot&gt; and L&lt;perlobj&gt; for more about the blessing (and blessings)
of objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perltoot&gt; y L&lt;perlobj&gt; para saber más sobre bautizos (y bautizar) de objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider always blessing objects in CLASSNAMEs that are mixed case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considerar siempre bautizar objetos de NOMBRECLASE que mezcle mayúsculas y minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Namespaces with all lowercase names are considered reserved for
Perl pragmata.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio de nombres en minúsculas está considerado reservado para los pragmas de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Builtin types have all uppercase names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los tipos incluidos tienen todos sus nombres en mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent
confusion, you may wish to avoid such package names as well.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para evitar confusiones, evite nombres de paquete también de esta manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure
that CLASSNAME is a true value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Asegúrese de que NOMBRECLASE es un valor verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod/&quot;Perl Modules&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod/&quot;Módulos Perl&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item caller EXPR
X&lt;caller&gt; X&lt;call stack&gt; X&lt;stack&gt; X&lt;stack trace&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item caller EXPR
X&lt;caller&gt; X&lt;call stack&gt; X&lt;stack&gt; X&lt;stack trace&gt; X&lt;pila&gt; X&lt;pila de llamadas&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item caller</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item caller</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the context of the current subroutine call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el contexto de la llamada a la subrutina actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context,
returns the caller's package name if there is a caller, that is, if
we're in a subroutine or C&lt;eval&gt; or C&lt;require&gt;, and the undefined value
otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el nombre del paquete del llamante si aquel es un llamante, es decir, si estamos en una subrutina, C&lt;eval&gt; o C&lt;require&gt;, y el valor indefinido en otro caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, devuelve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($package, $filename, $line) = caller;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($paquete, $nombre_fichero, $linea) = caller;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With EXPR, it returns some extra information that the debugger uses to
print a stack trace.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con EXPR, devuelve alguna información extra que el depurador usa para imprimir un rastreo de la pila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of EXPR indicates how many call frames
to go back before the current one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de EXPR indica cuántos marcos de llamada se ha de retroceder antes del actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($package, $filename, $line, $subroutine, $hasargs,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($paquete, $fichero, $linea, $subritina, $hasargs,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$wantarray, $evaltext, $is_require, $hints, $bitmask) = caller($i);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$wantarray, $evaltext, $is_require, $hints, $bitmask) = caller($i);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here $subroutine may be C&lt;(eval)&gt; if the frame is not a subroutine
call, but an C&lt;eval&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí, $subrutina puede ser C&lt;(eval)&gt; si el marco de llamada no es una llamada a una subrutina, sino un C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a case additional elements $evaltext and
C&lt;$is_require&gt; are set: C&lt;$is_require&gt; is true if the frame is created by a
C&lt;require&gt; or C&lt;use&gt; statement, $evaltext contains the text of the
C&lt;eval EXPR&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En tal caso, se añaden los nuevos elementos $evaltext y C&lt;$is_require&gt;: C&lt;$is_require&gt; es verdadero si el marco es creado por una sentencia C&lt;require&gt; o C&lt;use&gt;, $evaltext contiene el texto de la sentencia C&lt;eval EXPR&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, for an C&lt;eval BLOCK&gt; statement,
$filename is C&lt;(eval)&gt;, but $evaltext is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, para una sentencia C&lt;eval BLOQUE&gt;, $fichero es C&lt;(eval)&gt;, pero $evaltext es indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note also that
each C&lt;use&gt; statement creates a C&lt;require&gt; frame inside an C&lt;eval EXPR&gt;
frame.)  $subroutine may also be C&lt;(unknown)&gt; if this particular
subroutine happens to have been deleted from the symbol table.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Note también que cada sentencia C&lt;use&gt; crea un marco C&lt;require&gt; dentro de un marco C&lt;eval EXPR&gt;).  $subrutina puede ser también C&lt;(unknown)&gt; (desconocida) si esta subrutina en particular parece haber sido borrada de la tabla de símbolos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$hasargs&gt; is true if a new instance of C&lt;@_&gt; was set up for the frame.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$hasargs&gt; es verdadero si una nueva instancia de C&lt;@_&gt; fue creada para este marco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;$hints&gt; and C&lt;$bitmask&gt; contain pragmatic hints that the caller was
compiled with.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;$hints&gt; y C&lt;$bitmask&gt; contienen detalles para los cuales caller fue compilado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;$hints&gt; and C&lt;$bitmask&gt; values are subject to change
between versions of Perl, and are not meant for external use.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores C&lt;$hints&gt; y C&lt;$bitmask&gt; están sujetos a cambios entre versiones de Perl y no se espera que sean utilizados para uso externo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, when called from within the DB package, caller returns more
detailed information: it sets the list variable C&lt;@DB::args&gt; to be the
arguments with which the subroutine was invoked.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg> Además, cuando se le llama desde el interior de un paquete DB, caller devuelve información más detallada: actuliza la variable C&lt;@DB::args&gt; con los argumentos con los que la subrutina fue invocada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be aware that the optimizer might have optimized call frames away before
C&lt;caller&gt; had a chance to get the information.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuidado con el optimizador, que puede optimizar marcos de llamada antes de que C&lt;caller&gt; tenga la oportunidad de obtener la información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means that C&lt;caller(N)&gt;
might not return information about the call frame you expect it do, for
C&lt;&lt; N &gt; 1 &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que C&lt;caller(N)&gt; quizás no devuelva información sobre el marco de llamada que espera, para C&lt;&lt; N &gt; 1 &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, C&lt;@DB::args&gt; might have information from the
previous time C&lt;caller&gt; was called.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, C&lt;@DB::args&gt; podría tener información de la llamada a la anterior llamada a C&lt;caller&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir EXPR
X&lt;chdir&gt;
X&lt;cd&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chdir EXPR
X&lt;chdir&gt; X&lt;cd&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir FILEHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chdir MANEJADOR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir DIRHANDLE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chdir MANEJADORDIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chdir</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chdir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the working directory to EXPR, if possible.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia el directorio de trabajo a EXPR, si es posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
changes to the directory specified by C&lt;$ENV{HOME}&gt;, if set; if not,
changes to the directory specified by C&lt;$ENV{LOGDIR}&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, cambia al directorio especificado por C&lt;$ENV{HOME}&gt;, si está puesto; si no, cambia al directorio especificado por C&lt;$ENV{LOGDIR}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Under VMS, the
variable C&lt;$ENV{SYS$LOGIN}&gt; is also checked, and used if it is set.) If
neither is set, C&lt;chdir&gt; does nothing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Bajo VMS, la variable C&lt;$ENV{SYS$LOGIN}&gt; es también comprobada y usada si está puesta). Si ninguna está puesta, C&lt;chdir&gt; no hace nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns true upon success,
false otherwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero si tuvo éxito, sino, falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the example under C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver ejemplo en C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support fchdir, you might pass a file handle or
directory handle as argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soportan fchdir, podría pasarle como argumento un manejador de fichero o un manejador de directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support fchdir,
passing handles produces a fatal error at run time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que no soportan fchdir, pasarle manejadores produce un error fatal en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chmod LIST
X&lt;chmod&gt; X&lt;permission&gt; X&lt;mode&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chmod LISTA
X&lt;chmod&gt; X&lt;permisos&gt; X&lt;modo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the permissions of a list of files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia los permisos de una lista de ficheros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first element of the
list must be the numerical mode, which should probably be an octal
number, and which definitely should I&lt;not&gt; be a string of octal digits:
C&lt;0644&gt; is okay, C&lt;'0644'&gt; is not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El primer elemento de la lista debe ser un modo numérico, que normalmente estará en octal, y que, definitivamente, I&lt;no&gt; debe ser una cadena de dígitos en octal: C&lt;0644&gt; es correcto, C&lt;'0644'&gt; no lo es.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of files
successfully changed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de ficheros cambiados con éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/oct&gt;, if all you have is a string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/oct&gt;, si todo lo que tiene es una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = chmod 0755, 'foo', 'bar';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$num = chmod 0755, 'foo', 'bar';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod 0755, @executables;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod 0755, @ejecutables;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = '0644'; chmod $mode, 'foo';      # !!!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = '0644'; chmod $modo, 'foo';      # !!!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sets mode to</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pone el modo a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># --w----r-T</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># --w----r-T</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = '0644'; chmod oct($mode), 'foo'; # this is better</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = '0644'; chmod oct($modo), 'foo'; # esto es mejor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mode = 0644;   chmod $mode, 'foo';      # this is best</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$modo = 0644;   chmod $modo, 'foo';      # este es el mejor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support fchmod, you might pass file handles among the
files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soportan fchmod, podría pasar manejadores de fichero en lugar de los ficheros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support fchmod, passing file handles
produces a fatal error at run time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que no soportan fchmod, pasarle manejadores produce un error fatal en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(my $fh, &quot;&lt;&quot;, &quot;foo&quot;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(my $fh, &quot;&lt;&quot;, &quot;foo&quot;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $perm = (stat $fh)[2] &amp; 07777;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $permisos = (stat $fh)[2] &amp; 07777;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod($perm | 0600, $fh);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod($permisos | 0600, $fh);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also import the symbolic C&lt;S_I*&gt; constants from the Fcntl
module:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También puede importar las constantes simbólicas C&lt;S_I*&gt; desde el módulo Fcntl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl ':mode';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl ':mode';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @executables;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @ejecutables;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># This is identical to the chmod 0755 of the above example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Esto es idéntico a chmod 0755 del ejemplo de arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chomp VARIABLE
X&lt;chomp&gt; X&lt;INPUT_RECORD_SEPARATOR&gt; X&lt;$/&gt; X&lt;newline&gt; X&lt;eol&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chomp VARIABLE
X&lt;chomp&gt; X&lt;INPUT_RECORD_SEPARATOR&gt; X&lt;$/&gt; X&lt;newline&gt; X&lt;eol&gt; X&lt;nueva línea&gt; X&lt;fin de línea&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chomp( LIST )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chomp( LISTA )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chomp</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chomp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This safer version of L&lt;/chop&gt; removes any trailing string
that corresponds to the current value of C&lt;$/&gt; (also known as
$INPUT_RECORD_SEPARATOR in the C&lt;English&gt; module).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la versión segura de L&lt;/chop&gt;, que quita cualquier string restante que corresponda al valor actual de C&lt;$/&gt; (también conocido como $INPUT_RECORD_SEPARATOR -separador de registros en entrada- en el módulo C&lt;English&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the total
number of characters removed from all its arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número total de caracteres eliminados de todos sus argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's often used to
remove the newline from the end of an input record when you're worried
that the final record may be missing its newline.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se utiliza a menudo para eliminar el carácter de nueva línea del final de un registro de entrada cuando es importante que el registro al final le pueda faltar ese carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in paragraph
mode (C&lt;$/ = &quot;&quot;&gt;), it removes all trailing newlines from the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En modo párrafo (C&lt;$/ = &quot;&quot;&gt;), elimina todos los caracteres de nueva línea del string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in slurp mode (C&lt;$/ = undef&gt;) or fixed-length record mode (C&lt;$/&gt; is
a reference to an integer or the like, see L&lt;perlvar&gt;) chomp() won't
remove anything.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En modo chupón (C&lt;$/ = undef&gt;) o en modo registros de longitud fija (C&lt;$/&gt; es una referencia a un entero o algo parecido, ver L&lt;perlvar&gt;) chomp() no elimina nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is omitted, it chomps C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE se omite, usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;&gt;) {
	chomp;	# avoid \n on last field
	@array = split(/:/);
	# ...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;&gt;) {
	chomp;	# evitar \n en el último campo
	@array = split(/:/);
	# ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is a hash, it chomps the hash's values, but not its keys.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE es un hash, recorta los valores del hash, pero no sus claves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can actually chomp anything that's an lvalue, including an assignment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede recortar cualquier cosa que sea un lvalue (valor a la izquierda), incluyendo una asignación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($cwd = `pwd`);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($cwd = `pwd`);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($answer = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($respuesta = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you chomp a list, each element is chomped, and the total number of
characters removed is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si recorta una lista, cada elemento es recortado y se devuelve el número total de caracteres eliminados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the C&lt;encoding&gt; pragma is in scope then the lengths returned are
calculated from the length of C&lt;$/&gt; in Unicode characters, which is not
always the same as the length of C&lt;$/&gt; in the native encoding.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el pragma C&lt;encoding&gt; está en el ámbito actual entonces la longitud devuelta es calculada a partir de la longitud de los caracteres C&lt;$/&gt; Unicode, que no siempre es de la longitud de C&lt;$/&gt; en la codificación nativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that parentheses are necessary when you're chomping anything
that is not a simple variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota que los paréntesis son necesarios cuando esté recortando cualquier cosa que no sea una simple variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because C&lt;chomp $cwd = `pwd`;&gt;
is interpreted as C&lt;(chomp $cwd) = `pwd`;&gt;, rather than as
C&lt;chomp( $cwd = `pwd` )&gt; which you might expect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es porque C&lt;chomp $cwd = `pwd`;&gt; es interpretado como C&lt;(chomp $cwd) = `pwd`;&gt;, en vez de un C&lt;chomp( $cwd = `pwd` )&gt; que es lo que se esperaba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly,
C&lt;chomp $a, $b&gt; is interpreted as C&lt;chomp($a), $b&gt; rather than
as C&lt;chomp($a, $b)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Similarmente, C&lt;chomp $a, $b&gt; es interpretado como C&lt;chomp($a), $b&gt; en vez de un C&lt;chomp($a, $b)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chop VARIABLE
X&lt;chop&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chop VARIABLE
X&lt;chop&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chop( LIST )</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chop( LISTA )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chop</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chops off the last character of a string and returns the character
chopped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recorta el último carácter de un string y devuelve el carácter recortado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is much more efficient than C&lt;s/.$//s&gt; because it neither
scans nor copies the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más eficiente que C&lt;s/.$//s&gt; porque ni escanea ni copia el string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is omitted, chops C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE se omite, recorta C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If VARIABLE is a hash, it chops the hash's values, but not its keys.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si VARIABLE es un hash, recorta los valores del hash, pero no sus claves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can actually chop anything that's an lvalue, including an assignment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede recortar cualquier cosa que sea un lvalue (valor a la izquierda), incluyendo una asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you chop a list, each element is chopped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si recorta una lista, cada elemento es recortado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the value of the
last C&lt;chop&gt; is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo se devuelve el valor del último recorte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;chop&gt; returns the last character.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;chop&gt; devuelve el último carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To return all but the last
character, use C&lt;substr($string, 0, -1)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para devolver todos menos el último carácter, use C&lt;substr($string, 0, -1)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/chomp&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/chomp&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chown LIST
X&lt;chown&gt; X&lt;owner&gt; X&lt;user&gt; X&lt;group&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chown LISTA
X&lt;chown&gt; X&lt;owner&gt; X&lt;user&gt; X&lt;group&gt; X&lt;propietario&gt; X&lt;usuario&gt; X&lt;grupo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes the owner (and group) of a list of files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cambia el propietario (y grupo) de una lista de ficheros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two
elements of the list must be the I&lt;numeric&gt; uid and gid, in that
order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los primeros dos elementos de la lista deben ser el valor I&lt;numérico&gt; del uid y gid, en este orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value of -1 in either position is interpreted by most
systems to leave that value unchanged.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un valor de -1 en cualquier posición es interpretado en la mayoría de los sistemas como que se deja el actual valor sin cambiar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = chown $uid, $gid, 'foo', 'bar';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$num = chown $uid, $gid, 'foo', 'bar';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chown $uid, $gid, @filenames;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chown $uid, $gid, @ficheros;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support fchown, you might pass file handles among the
files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soportan fchown, podría pasar manejadores de fichero en lugar de los ficheros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that don't support fchown, passing file handles
produces a fatal error at run time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que no soportan fchown, pasarle manejadores produce un error fatal en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example that looks up nonnumeric uids in the passwd file:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo que obtiene el uid numérico a partir del fichero de contraseñas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;User: &quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Usuario: &quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($user = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($usuario = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Files: &quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Ficheros: &quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($pattern = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($patron = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($login,$pass,$uid,$gid) = getpwnam($user)
	or die &quot;$user not in passwd file&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($login,$pass,$uid,$gid) = getpwnam($usuario)
	or die &quot;$usuario no está en fichero de contraseñas&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ary = glob($pattern);	# expand filenames</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ary = glob($patron);	# expande los nombres de fichero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chown $uid, $gid, @ary;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chown $uid, $gid, @ary;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most systems, you are not allowed to change the ownership of the
file unless you're the superuser, although you should be able to change
the group to any of your secondary groups.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de los sistemas, no se le permite cambiar la propiedad del fichero a menos que sea el superusuario, aunque sí pueda cambiar el grupo a cualquiera de sus grupos secundarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On insecure systems, these
restrictions may be relaxed, but this is not a portable assumption.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas inseguros, estas restricciones pueden estar más relajadas, pero no es una suposición normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On POSIX systems, you can detect this condition this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas POSIX, puede detectar esta condición de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$can_chown_giveaway = not sysconf(_PC_CHOWN_RESTRICTED);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$puedo_hacer_chown = not sysconf(_PC_CHOWN_RESTRICTED);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chr NUMBER
X&lt;chr&gt; X&lt;character&gt; X&lt;ASCII&gt; X&lt;Unicode&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chr NÚMERO
X&lt;chr&gt; X&lt;character&gt; X&lt;ASCII&gt; X&lt;Unicode&gt; X&lt;carácter&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chr</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the character represented by that NUMBER in the character set.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el carácter representado por NÚMERO en el conjunto de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, C&lt;chr(65)&gt; is C&lt;&quot;A&quot;&gt; in either ASCII or Unicode, and
chr(0x263a) is a Unicode smiley face.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;chr(65)&gt; es C&lt;&quot;A&quot;&gt; tanto en ASCII como en Unicode, y chr(0x263a) es una cara sonriente en Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that characters from 128
to 255 (inclusive) are by default not encoded in UTF-8 Unicode for
backward compatibility reasons (but see L&lt;encoding&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota que los caracteres del 128 al 255 (inclusive) no están codificados por defecto en Unicode UTF-8 por razones de compatibilidad hacia atrás (pero vea L&lt;encoding&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If NUMBER is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite NÚMERO, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the reverse, use L&lt;/ord&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para lo contrario, use L&lt;/ord&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that under the C&lt;bytes&gt; pragma the NUMBER is masked to
the low eight bits.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que bajo el pragma C&lt;bytes&gt; el NÚMERO es enmascarado a los 8 bits más bajos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlunicode&gt; and L&lt;encoding&gt; for more about Unicode.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlunicode&gt; y L&lt;encoding&gt; para más información sobre Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chroot FILENAME
X&lt;chroot&gt; X&lt;root&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chroot FICHERO
X&lt;chroot&gt; X&lt;root&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item chroot</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item chroot</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function works like the system call by the same name: it makes the
named directory the new root directory for all further pathnames that
begin with a C&lt;/&gt; by your process and all its children.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta funcion trabaja como la llamada del sistema del mismo nombre: hace que el directorio indicado sea el directorio raíz de los siguientes caminos que comiencen por un C&lt;/&gt; en su proceso y todos sus hijos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It doesn't
change your current working directory, which is unaffected.)  For security
reasons, this call is restricted to the superuser.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(No cambia su actual directorio de trabajo actual, que no queda afectado). Por razones de seguridad, esta llamada está reservada al superusuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILENAME is
omitted, does a C&lt;chroot&gt; to C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si FICHERO se omite, hace un C&lt;chroot&gt; a C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item close FILEHANDLE
X&lt;close&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item close MANEJADOR
X&lt;close&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item close</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item close</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes the file or pipe associated with the file handle, returning
true only if IO buffers are successfully flushed and closes the system
file descriptor.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cierra el fichero o tubería asociada con el manejador, devolviendo verdadero sólo si la memoria intermedia de IO (E/S) se han podido despejar y se ha cerrado el descriptor de archivo del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes the currently selected filehandle if the
argument is omitted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cierra el manejador actualmente seleccionado si se omite el argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to close FILEHANDLE if you are immediately going to do
another C&lt;open&gt; on it, because C&lt;open&gt; will close it for you.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No tiene porqué cerrar el MANEJADOR si inmediatamente va a hacer otro C&lt;open&gt; sobre él mismo, porque C&lt;open&gt; le cerrará por usted.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See
C&lt;open&gt;.)  However, an explicit C&lt;close&gt; on an input file resets the line
counter (C&lt;$.&gt;), while the implicit close done by C&lt;open&gt; does not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver C&lt;open&gt;). Sin embargo, un C&lt;close&gt; explícito en un fichero de entrada reiniza el contador de líneas (C&lt;$.&gt;), mientras que un C&lt;close&gt; implícito hecho por C&lt;open&gt;, no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the file handle came from a piped open, C&lt;close&gt; will additionally
return false if one of the other system calls involved fails, or if the
program exits with non-zero status.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el manejador proviene de una tubería abierta, C&lt;close&gt; adicionalmente devolverá falso si alguna de las otras llamadas del sistema implicadas falla, o si el programa sale con un valor de estado de no cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the only problem was that the
program exited non-zero, C&lt;$!&gt; will be set to C&lt;0&gt;.)  Closing a pipe
also waits for the process executing on the pipe to complete, in case you
want to look at the output of the pipe afterwards, and
implicitly puts the exit status value of that command into C&lt;$?&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si el único problema fue que el programa salió con un valor no cero, C&lt;$!&gt; será puesto a C&lt;0&gt;). Cerrar una tubería implica esperar a que el proceso que ejecuta la tubería termine, para el caso de que quiera obtener después la salida de la tubería, e implícitamente pone el valor del estado de salida del comando en C&lt;$?&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prematurely closing the read end of a pipe (i.e. before the process
writing to it at the other end has closed it) will result in a
SIGPIPE being delivered to the writer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cerrar prematuramente la lectura final de una tubería (p.e. antes de que el proceso de escritura a él desde el otro lado se haya cerrado) resultará en un SIGPIPE enviado al escritor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the other end can't
handle that, be sure to read all the data before closing the pipe.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el otro lado no puede manejar esto, asegúrese de leer todos los datos antes de cerrar la tubería.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(OUTPUT, '|sort &gt;foo')  # pipe to sort</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(OUTPUT, '|sort &gt;foo')  # tubería a sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't start sort: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo iniciar sort: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#...			# print stuff to output</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#...			# pintar material a la salida</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>close OUTPUT		# wait for sort to finish</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>close OUTPUT		# esperar a que termine sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or warn $!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or warn $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Error closing sort pipe: $!&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;Error cerrando tubería sort: $!&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>: &quot;Exit status $?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>: &quot;Estatus de salida $?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from sort&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>desde sort&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(INPUT, 'foo')		# get sort's results</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(INPUT, 'foo')		# obtener el resultado de sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't open 'foo' for input: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo abrir 'foo' para entrada: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value can be used as an indirect
filehandle, usually the real filehandle name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>MANEJADOR puede ser una expresión cuyo valor puede ser usado como un manejador indirecto, normalmente el nombre real del manejador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item closedir DIRHANDLE
X&lt;closedir&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item closedir MANEJADORDIR
X&lt;closedir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes a directory opened by C&lt;opendir&gt; and returns the success of that
system call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cierra un directorio abierto por C&lt;opendir&gt; y devuelve el éxito de la llamada del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item connect SOCKET,NAME
X&lt;connect&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item connect SOCKET,NOMBRE
X&lt;connect&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to connect to a remote socket, just as the connect system call
does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intenta conectarse a un socket remoto, como lo hace la llamada del sistema connect.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item continue BLOCK
X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item continue BLOQUE
X&lt;continue&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;continue&gt; is actually a flow control statement rather than a function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;continue&gt; es realmente una sentencia de control de flujo en lugar de una función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
there is a C&lt;continue&gt; BLOCK attached to a BLOCK (typically in a C&lt;while&gt; or
C&lt;foreach&gt;), it is always executed just before the conditional is about to
be evaluated again, just like the third part of a C&lt;for&gt; loop in C.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si existe un BLOQUE C&lt;continue&gt; adjunto a un BLOQUE (típicamente en un C&lt;while&gt; o C&lt;foreach&gt;), siempre es ejecutado justo antes de que la condicional sea de nuevo evaluada, igual que la tercera parte de un bucle C&lt;for&gt; en C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus
it can be used to increment a loop variable, even when the loop has been
continued via the C&lt;next&gt; statement (which is similar to the C C&lt;continue&gt;
statement).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, puede ser usado para incrementar una variable de bucle, incluso cuando el bucle ha sido interrumpido por medio de una sentencia C&lt;next&gt; (por lo que es similar a la sentencia C&lt;continue&gt; del C).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;last&gt;, C&lt;next&gt;, or C&lt;redo&gt; may appear within a C&lt;continue&gt;
block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;last&gt;, C&lt;next&gt; o C&lt;redo&gt; pueden aparecer dentro de un bloque C&lt;continue&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;last&gt; and C&lt;redo&gt; will behave as if they had been executed within
the main block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;last&gt; y C&lt;redo&gt; se comportarán como si se hubieran ejecutado dentro del bloque principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So will C&lt;next&gt;, but since it will execute a C&lt;continue&gt;
block, it may be more entertaining.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También C&lt;next&gt;, pero como el ejecutará un bloque C&lt;continue&gt;, será algo más divertido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (EXPR) {
	### redo always comes here
	do_something;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (EXPR) {
	### redo siempre viene aquí
	hacer_algo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} continue {
	### next always comes here
	do_something_else;
	# then back the top to re-check EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} continue {
	### next siempre viene aquí
	hacer_algo_despues;
	# entonces regresa arriba a recomprobar la EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### last always comes here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>### last siempre viene aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omitting the C&lt;continue&gt; section is semantically equivalent to using an
empty one, logically enough.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Omitiendo la sección C&lt;continue&gt; es semánticamente equivalente a usar uno vacío, lo cual es lógico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, C&lt;next&gt; goes directly back
to check the condition at the top of the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En este caso, C&lt;next&gt; sube directamente a comprobar la condición al principio del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item cos EXPR
X&lt;cos&gt; X&lt;cosine&gt; X&lt;acos&gt; X&lt;arccosine&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item cos EXPR
X&lt;cos&gt; X&lt;cosine&gt; X&lt;acos&gt; X&lt;arccosine&gt; X&lt;coseno&gt; X&lt;arcocoseno&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item cos</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item cos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the cosine of EXPR (expressed in radians).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el coseno de EXPR (expresado en radianes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted,
takes cosine of C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, devuelve el coseno de C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the inverse cosine operation, you may use the C&lt;Math::Trig::acos()&gt;
function, or use this relation:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la inversa de la operación coseno, puede usar la función C&lt;Math::Trig::acos()&gt;, o usar esta relación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item crypt PLAINTEXT,SALT
X&lt;crypt&gt; X&lt;digest&gt; X&lt;hash&gt; X&lt;salt&gt; X&lt;plaintext&gt; X&lt;password&gt;
X&lt;decrypt&gt; X&lt;cryptography&gt; X&lt;passwd&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item crypt TEXTOPLANO,SALTO
X&lt;crypt&gt; X&lt;digest&gt; X&lt;hash&gt; X&lt;salt&gt; X&lt;plaintext&gt; X&lt;password&gt; X&lt;decrypt&gt; X&lt;cryptography&gt; X&lt;passwd&gt; X&lt;contraseña&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a digest string exactly like the crypt(3) function in the C
library (assuming that you actually have a version there that has not
been extirpated as a potential munitions).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Crea un string resumen exáctamente igual que la función crypt(3) de la biblioteca C (asumiendo que realmente tenga una versión de la que no haya sido exterpida por ser considerada un arma).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>crypt() is a one-way hash function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>crypt() es una función hash de un sólo sentido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The PLAINTEXT and SALT is turned
into a short string, called a digest, which is returned.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El TEXTOPLANO y el SALTO se convierten en un pequeño string, llamado I&lt;digest&gt; (compendio, resumen), que es devuelto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same
PLAINTEXT and SALT will always return the same string, but there is no
(known) way to get the original PLAINTEXT from the hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los mismos TEXTOPLANO y SALTO siempre devolverán el mismo string, pero no hay una forma (conocida) de obtener el TEXTOPLANO original desde el hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Small
changes in the PLAINTEXT or SALT will result in large changes in the
digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pequeños cambios en TEXTPLANO o SALTO resultarán en grandes cambios en el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no decrypt function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe la función decrypt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function isn't all that useful for
cryptography (for that, look for F&lt;Crypt&gt; modules on your nearby CPAN
mirror) and the name &quot;crypt&quot; is a bit of a misnomer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función no es muy útil para criptografía (para esto, mire en los módulos F&lt;Crypt&gt; en su espejo CPAN más cercano) y el nombre &quot;crypt&quot; es un poco equívoco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead it is
primarily used to check if two pieces of text are the same without
having to transmit or store the text itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En cambio se usa principalmente para comprobar si dos trozos de textos son el mismo sin tener que transmitirlo o almacenarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example is checking
if a correct password is given.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un ejemplo es comprobando si se ha dado una contraseña correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The digest of the password is stored,
not the password itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El I&lt;digest&gt; de una contraseña se almacena, no la propia contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user types in a password that is
crypt()'d with the same salt as the stored digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El usuario escribe la contraseña que es en-crypt()-tada con el mismo salto con el que fue almacenado el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the two digests
match the password is correct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si los dos I&lt;digest&gt; coinciden, la contraseña es correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When verifying an existing digest string you should use the digest as
the salt (like C&lt;crypt($plain, $digest) eq $digest&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando verifique un string i&lt;digest&gt; debe usar el propio I&lt;digest&gt; como el salto (como C&lt;crypt($plano, $digest) eq $digest&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SALT used
to create the digest is visible as part of the digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El SALTO usado para crear el I&lt;digest&gt; es visible como parte del I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures
crypt() will hash the new string with the same salt as the digest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto asegura que crypt() hará el hash del nuevo string con el mismo salto que el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows your code to work with the standard L&lt;crypt|/crypt&gt; and
with more exotic implementations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto permite a su código trabajar con el estándar L&lt;crypt|/crypt&gt; y con implementaciones más exóticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, do not assume
anything about the returned string itself, or how many bytes in the
digest matter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, no asuma nada sobre el string devuelto, o que cuántos bytes ocupa el I&lt;digest&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditionally the result is a string of 13 bytes: two first bytes of
the salt, followed by 11 bytes from the set C&lt;[./0-9A-Za-z]&gt;, and only
the first eight bytes of the digest string mattered, but alternative
hashing schemes (like MD5), higher level security schemes (like C2),
and implementations on non-UNIX platforms may produce different
strings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tradicionalmente el resultado es un string de 13 bytes: los dos primeros bytes son el salto, seguido de 11 bytes del conjunto C&lt;[./0-9A-Za-z]&gt;, y sólo los primeros ocho bytes del I&lt;digest&gt; interesan, pero esquemas alternativos de cálculo de hash (como MD5), esquemas de seguridad de alto nivel (como C2) e implementacionesen plataformas no UNIX pueden producir strings diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When choosing a new salt create a random two character string whose
characters come from the set C&lt;[./0-9A-Za-z]&gt; (like C&lt;join '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando escoja un nuevo salto cree un string de dos caracteres elegidos aleatoriamente del conjunto C&lt;[./0-9A-Za-z]&gt; (como por ejemplo C&lt;join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This set of
characters is just a recommendation; the characters allowed in
the salt depend solely on your system's crypt library, and Perl can't
restrict what salts C&lt;crypt()&gt; accepts.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este conjunto de caracteres es sólo una recomendación; los caracteres permitidos en el salto dependen solamente de la función crypt del sistema y Perl no puede restringir el salto que C&lt;crypt()&gt; acepte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example that makes sure that whoever runs this program knows
their password:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo que se asegura que quien corra el programa conoce su contraseña:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$pwd = (getpwuid($&lt;))[1];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$pwd = (getpwuid($&lt;))[1];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty -echo&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty -echo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Password: &quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Password: &quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chomp($word = &lt;STDIN&gt;);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chomp($palabra = &lt;STDIN&gt;);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>system &quot;stty echo&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>system &quot;stty echo&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (crypt($word, $pwd) ne $pwd) {
	die &quot;Sorry...\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (crypt($palabra, $pwd) ne $pwd) {
	die &quot;Lo siento...\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else {
	print &quot;ok\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} else {
	print &quot;correcto\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, typing in your own password to whoever asks you
for it is unwise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Naturalmente es muy imprudente dar la propia contraseña a cualquiera que lo pregunte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The L&lt;crypt|/crypt&gt; function is unsuitable for hashing large quantities
of data, not least of all because you can't get the information
back.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función L&lt;crypt|/crypt&gt; no es apropiada para calcular el hash de grandes volúmenes de información, teniendo en cuenta que no es posible luego volver a obtener la misma información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Look at the L&lt;Digest&gt; module for more robust algorithms.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mire en el módulo L&lt;Digest&gt; por algoritmos más robustos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If using crypt() on a Unicode string (which I&lt;potentially&gt; has
characters with codepoints above 255), Perl tries to make sense
of the situation by trying to downgrade (a copy of the string)
the string back to an eight-bit byte string before calling crypt()
(on that copy).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usa crypt() en un string Unicode (que I&lt;potencialmente&gt; tiene caracteres con codificación superior al 255), Perl intenta hacer sentido a la situación intentando hacer una degradación (una copia del string) a un string de bytes antes de llamar a crypt() (sobre esa copia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that works, good.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si esto funciona, bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, crypt() dies with
C&lt;Wide character in crypt&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no, crypt() muere con C&lt;Wide character in crypt&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dbmclose HASH
X&lt;dbmclose&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item dbmclose HASH
X&lt;dbmclose&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[This function has been largely superseded by the C&lt;untie&gt; function.]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[Esta función ha sido largamente supeditada por la función C&lt;untie&gt;].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Breaks the binding between a DBM file and a hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Rompe la ligadura entre un fichero DBM y un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dbmopen HASH,DBNAME,MASK
X&lt;dbmopen&gt; X&lt;dbm&gt; X&lt;ndbm&gt; X&lt;sdbm&gt; X&lt;gdbm&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item dbmopen HASH,NOMBREDB,MÁSCARA
X&lt;dbmopen&gt; X&lt;dbm&gt; X&lt;ndbm&gt; X&lt;sdbm&gt; X&lt;gdbm&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[This function has been largely superseded by the C&lt;tie&gt; function.]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[Esta función ha sido largamente supeditada por la función C&lt;tie&gt;].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a
hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Liga un fichero dbm(3), ndbm(3), sdbm(3), gdbm(3), o Berkeley DB a un hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HASH is the name of the hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>HASH es el nombre del hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unlike normal C&lt;open&gt;, the first
argument is I&lt;not&gt; a filehandle, even though it looks like one).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(A diferencia de un C&lt;open&gt; normal, el primer argumento I&lt;no&gt; es un manejador, aunque lo parezca).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DBNAME
is the name of the database (without the F&lt;.dir&gt; or F&lt;.pag&gt; extension if
any).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NOMBREDB es el nombre de la base de datos (sin la extensión F&lt;.dir&gt; o F&lt;.pag&gt; si las tuviera).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the database does not exist, it is created with protection
specified by MASK (as modified by the C&lt;umask&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la base de datos no existe, se crea con la protección especificada por MÁSCARA (y modificada por C&lt;umask&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your system supports
only the older DBM functions, you may perform only one C&lt;dbmopen&gt; in your
program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si su sistema sólo soporta las viejas funciones DBM, sólo puede realizar un C&lt;dbmopen&gt; en su programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In older versions of Perl, if your system had neither DBM nor
ndbm, calling C&lt;dbmopen&gt; produced a fatal error; it now falls back to
sdbm(3).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En las viejas versiones de Perl, si el sistema no tenía ni DBM ni ndbm, llamando a C&lt;dbmopen&gt; producía un error fatal; ahora lo intentaría con sdbm(3).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't have write access to the DBM file, you can only read hash
variables, not set them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no tiene permiso de escritura al fichero DBM, sólo podrá leer las variables hash, pero no asignarlas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to test whether you can write,
either use file tests or try setting a dummy hash entry inside an C&lt;eval&gt;,
which will trap the error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere comprobar si puede escribir o no, use comprobaciones de fichero o intente asignar una entrada hash ficticia dentro de un C&lt;eval&gt;, que atrapará el error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that functions such as C&lt;keys&gt; and C&lt;values&gt; may return huge lists
when used on large DBM files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que las funciones como C&lt;keys&gt; y C&lt;values&gt; pueden devolver largas listas cuando se usan con ficheros DBM grandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may prefer to use the C&lt;each&gt;
function to iterate over large DBM files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede preferir usar la función C&lt;each&gt; para iterar sobre ficheros DBM grandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># print out history file offsets</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># imprime los desplazamientos en el fichero histórico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dbmopen(%HIST,'/usr/lib/news/history',0666);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dbmopen(%HIST,'/usr/lib/news/history',0666);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($key,$val) = each %HIST) {
	print $key, ' = ', unpack('L',$val), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (($clave,$valor) = each %HIST) {
	print $clave, ' = ', unpack('L',$valor), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dbmclose(%HIST);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dbmclose(%HIST);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;AnyDBM_File&gt; for a more general description of the pros and
cons of the various dbm approaches, as well as L&lt;DB_File&gt; for a particularly
rich implementation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;AnyDBM_File&gt; para una descripción más general de los pros y contras de las distintas formas dbm, así como L&lt;DB_File&gt; para ver una implementación particularmente rica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can control which DBM library you use by loading that library
before you call dbmopen():</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede controlar qué biblioteca DBM usará cargando la biblioteca antes de llamar a dbmopen():</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use DB_File;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use DB_File;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dbmopen(%NS_Hist, &quot;$ENV{HOME}/.netscape/history.db&quot;)
	or die &quot;Can't open netscape history file: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>dbmopen(%NS_Hist, &quot;$ENV{HOME}/.netscape/history.db&quot;)
	or die &quot;No puedo abrir el archivo histórico del netscape: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item defined EXPR
X&lt;defined&gt; X&lt;undef&gt; X&lt;undefined&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item defined EXPR
X&lt;defined&gt; X&lt;undef&gt; X&lt;undefined&gt; X&lt;definido&gt; X&lt;indefinido&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item defined</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item defined</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Boolean value telling whether EXPR has a value other than
the undefined value C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve un valor Booleano indicando si EXPR tiene un valor que no sea el valor indefinido C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is not present, C&lt;$_&gt; will be
checked.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR no está presnte, C&lt;$_&gt; será lo comprobado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operations return C&lt;undef&gt; to indicate failure, end of file,
system error, uninitialized variable, and other exceptional
conditions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Muchas operaciones devuelven C&lt;undef&gt; para indicar un fallo, fin de fichero, error del sistema, variable no inicializada u otras condiciones excepcionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function allows you to distinguish C&lt;undef&gt; from
other values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función le permite distinguir C&lt;undef&gt; de otros valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A simple Boolean test will not distinguish among
C&lt;undef&gt;, zero, the empty string, and C&lt;&quot;0&quot;&gt;, which are all equally
false.)  Note that since C&lt;undef&gt; is a valid scalar, its presence
doesn't I&lt;necessarily&gt; indicate an exceptional condition: C&lt;pop&gt;
returns C&lt;undef&gt; when its argument is an empty array, I&lt;or&gt; when the
element to return happens to be C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Un simple test Booleano no distinguirá entre C&lt;undef&gt;, cero, el string vacío y C&lt;&quot;0&quot;&gt;, que son todos igualmente falso). Note que como C&lt;undef&gt; es un escalar válido, su presencia no indica I&lt;necesariamente&gt; una condición excepcional: C&lt;pop&gt; devuelve C&lt;undef&gt; cuando su argumento es un array vacío, I&lt;o&gt; cuando el elemento a devolver sea un C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also use C&lt;defined(&amp;func)&gt; to check whether subroutine C&lt;&amp;func&gt;
has ever been defined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar también C&lt;defined(&amp;func)&gt; para comprobar si la subrutina C&lt;&amp;func&gt; ha sido definida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value is unaffected by any forward
declarations of C&lt;&amp;func&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto no es afectado por ninguna declaración posterior de C&lt;&amp;func&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a subroutine which is not defined
may still be callable: its package may have an C&lt;AUTOLOAD&gt; method that
makes it spring into existence the first time that it is called -- see
L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que una subrutina que no ha sido definida puede ser ejecutada: su paquete puede tener un método C&lt;AUTOLOAD&gt; que la hace aparecer la primera vez que es llamada -- ver L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of C&lt;defined&gt; on aggregates (hashes and arrays) is deprecated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El uso de C&lt;defined&gt; sobre datos agregados (hashes y arrays) está desaconsejado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
used to report whether memory for that aggregate has ever been
allocated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se usó para informar si la memoria para los datos agregados había sido reservada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior may disappear in future versions of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comportamiento puede desaparecer en futuras versiones de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should instead use a simple test for size:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Utilize en su lugar una comprobación de tamaño:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (@an_array) { print &quot;has array elements\n&quot; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (@un_array) { print &quot;tiene elementos array\n&quot; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (%a_hash)   { print &quot;has hash members\n&quot;   }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (%un_hash)   { print &quot;tiene elementos hash\n&quot;   }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used on a hash element, it tells you whether the value is defined,
not whether the key exists in the hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa con un elemento de un hash, le indica si el valor está definido, no si la clave existe en el hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use L&lt;/exists&gt; for the latter
purpose.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use L&lt;/exists&gt; para este propósito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print if defined $switch{'D'};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print if defined $switch{'D'};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;$val\n&quot; while defined($val = pop(@ary));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;$valor\n&quot; while defined($valor = pop(@array));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't readlink $sym: $!&quot;
	unless defined($value = readlink $sym);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo hacer un readlink $sym: $!&quot;
	unless defined($valor = readlink $sym);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub foo { defined &amp;$bar ?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub foo { defined &amp;$bar ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;$bar(@_) : die &quot;No bar&quot;; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;$bar(@_) : die &quot;No bar&quot;; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$debugging = 0 unless defined $debugging;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$debugging = 0 unless defined $debugging;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note:  Many folks tend to overuse C&lt;defined&gt;, and then are surprised to
discover that the number C&lt;0&gt; and C&lt;&quot;&quot;&gt; (the zero-length string) are, in fact,
defined values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota: mucha gente tiende a sobrevalorar C&lt;defined&gt; y, para su sorpresa, descubren que el número C&lt;0&gt; y C&lt;&quot;&quot;&gt; (el string de longitud cero) son, de hecho, valores definidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, si dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;ab&quot; =~ /a(.*)b/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;ab&quot; =~ /a(.*)b/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pattern match succeeds, and C&lt;$1&gt; is defined, despite the fact that it
matched &quot;nothing&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El patrón de búsqueda tiene éxito, y C&lt;$1&gt; es definida, a pesar del hecho de que se ha correspondido con &quot;nada&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It didn't really fail to match anything.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No ha fallado al corresponder con cualquier cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather, it
matched something that happened to be zero characters long.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Más bien, ha coincidido con algo que parece tener cero caracteres de longitud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is all
very above-board and honest.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo esto trata sobre la honraded.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function returns an undefined value,
it's an admission that it couldn't give you an honest answer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando una función devuelve un valor indefinido, se asume que no puede dar una respuesta honrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So you
should use C&lt;defined&gt; only when you're questioning the integrity of what
you're trying to do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que puede usar C&lt;defined&gt; sólo cuando está cuestionando la integridad de lo que está intentando hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At other times, a simple comparison to C&lt;0&gt; or C&lt;&quot;&quot;&gt; is
what you want.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras ocasiones, una simple comparación con C&lt;0&gt; o C&lt;&quot;&quot;&gt; es lo que necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/undef&gt;, L&lt;/exists&gt;, L&lt;/ref&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/undef&gt;, L&lt;/exists&gt;, L&lt;/ref&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item delete EXPR
X&lt;delete&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item delete EXPR
X&lt;delete&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an expression that specifies a hash element, array element, hash slice,
or array slice, deletes the specified element(s) from the hash or array.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dad una expresión que especifica un elemento de un hash, un elemento de un array, una porción de hash o una porción de un array, borra los elementos especificados del hash o array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of an array, if the array elements happen to be at the end,
the size of the array will shrink to the highest element that tests
true for exists() (or 0 if no such element exists).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de un array, si los elementos del array se encuentran al final, el tamaño del array se reducirá al mayor elemento que dé verdadero en la comprobación de exists() (o 0 si no existe tal elemento).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a list with the same number of elements as the number of elements
for which deletion was attempted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una lista con el mismo número de elementos que el número de elementos por los cuales se intentó su borrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each element of that list consists of
either the value of the element deleted, or the undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada elemento de la lista consiste del valor del elemento borrado o un valor indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar
context, this means that you get the value of the last element deleted (or
the undefined value if that element did not exist).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, esto significa que obtiene el valor del último elemento borrado (o el valor indefinido si este elemento no existía).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%hash = (foo =&gt; 11, bar =&gt; 22, baz =&gt; 33);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%hash = (foo =&gt; 11, bar =&gt; 22, baz =&gt; 33);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$scalar = delete $hash{foo};             # $scalar is 11</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$escalar = delete $hash{foo};            # $escalar es 11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$scalar = delete @hash{qw(foo bar)};     # $scalar is 22</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$escalar = delete @hash{qw(foo bar)};    # $escalar es 22</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@array  = delete @hash{qw(foo bar baz)}; # @array  is (undef,undef,33)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@array  = delete @hash{qw(foo bar baz)}; # @array es (undef,undef,33)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting from C&lt;%ENV&gt; modifies the environment.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Borrando de C&lt;%ENV&gt; modifica el entorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting from
a hash tied to a DBM file deletes the entry from the DBM file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Borrando de un hash enlazado a un fichero DBM borra esa entrada del fichero DBM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting
from a C&lt;tie&gt;d hash or array may not necessarily return anything.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Borrando de un hash o array C&lt;enlazado&gt; no necesariamente devolverá algo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting an array element effectively returns that position of the array
to its initial, uninitialized state.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Borrando un elemento de un array devolverá efectivamente esa posición del array a su inicial y no inicializado estado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently testing for the same
element with exists() will return false.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Subsiguiente comprobación del mismo elemento con exists() devolverá falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, deleting array elements
in the middle of an array will not shift the index of the elements
after them down.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También, borrando elementos de un array en mitad del array no desplazará el índice de los elementos que estén por debajo de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use splice() for that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use splice() para esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/exists&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/exists&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following (inefficiently) deletes all the values of %HASH and @ARRAY:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo siguiente borra (ineficientemente) todos los valores de %HASH y @ARRAY:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $key (keys %HASH) {
	delete $HASH{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $clave (keys %HASH) {
	delete $HASH{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $index (0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $indice (0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#ARRAY) {
	delete $ARRAY[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#ARRAY) {
	delete $ARRAY[$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And so do these:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así como estos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @HASH{keys %HASH};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @HASH{keys %HASH};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @ARRAY[0 ..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @ARRAY[0 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$#ARRAY];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$#ARRAY];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But both of these are slower than just assigning the empty list
or undefining %HASH or @ARRAY:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero esto es más lento que simplemente asignar una lista vacía o indefiniendo %HASH o @ARRAY:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>%HASH = ();		# completely empty %HASH</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>%HASH = ();		# vacía completamente %HASH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef %HASH;	# forget %HASH ever existed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef %HASH;	# hace que %HASH nunca haya existido</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@ARRAY = ();	# completely empty @ARRAY</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@ARRAY = ();	# vacía completamente @ARRAY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef @ARRAY;	# forget @ARRAY ever existed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef @ARRAY;	# hace que @ARRAY nunca haya existido</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the EXPR can be arbitrarily complicated as long as the final
operation is a hash element, array element,  hash slice, or array slice
lookup:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que EXPR puede ser tan arbitrariamente complicada con tal de que el final de la operación sea un elemento de un hash, de un array o una porción de un hash o array:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $ref-&gt;[$x][$y]{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $ref-&gt;[$x][$y]{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @{$ref-&gt;[$x][$y]}{$key1, $key2, @morekeys};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @{$ref-&gt;[$x][$y]}{$clave1, $clave2, @masclaves};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $ref-&gt;[$x][$y][$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $ref-&gt;[$x][$y][$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete @{$ref-&gt;[$x][$y]}[$index1, $index2, @moreindices];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete @{$ref-&gt;[$x][$y]}[$indice1, $indice2, @masindices];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item die LIST
X&lt;die&gt; X&lt;throw&gt; X&lt;exception&gt; X&lt;raise&gt; X&lt;$@&gt; X&lt;abort&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item die LISTA
X&lt;die&gt; X&lt;throw&gt; X&lt;excepción&gt; X&lt;raise&gt; X&lt;$@&gt; X&lt;abort&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Outside an C&lt;eval&gt;, prints the value of LIST to C&lt;STDERR&gt; and
exits with the current value of C&lt;$!&gt; (errno).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fuera de un C&lt;eval&gt;, imprime el valor de LIST al C&lt;STDERR&gt; y sale con el valor actual de C&lt;$!&gt; (errno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$!&gt; is C&lt;0&gt;,
exits with the value of C&lt;&lt;&lt; ($?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$!&gt; es C&lt;0&gt;, sale con el valor de C&lt;&lt;&lt; ($?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;&gt; 8) &gt;&gt;&gt; (backtick `command`
status).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&gt;&gt; 8) &gt;&gt;&gt; (estatus de la `orden`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;&lt;&lt; ($?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;&lt;&lt; ($?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;&gt; 8) &gt;&gt;&gt; is C&lt;0&gt;, exits with C&lt;255&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&gt;&gt; 8) &gt;&gt;&gt; es C&lt;0&gt;, sale con C&lt;255&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside
an C&lt;eval(),&gt; the error message is stuffed into C&lt;$@&gt; and the
C&lt;eval&gt; is terminated with the undefined value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dentro de un C&lt;eval()&gt;, el mensaje de error es colocado en C&lt;$@&gt; y el C&lt;eval&gt; termina con el valor indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes
C&lt;die&gt; the way to raise an exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es la forma para que C&lt;die&gt; cree una excepcion.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent examples:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplos equivalentes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't cd to spool: $!\n&quot; unless chdir '/usr/spool/news';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo cd a spool: $!\n&quot; unless chdir '/usr/spool/news';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir '/usr/spool/news' or die &quot;Can't cd to spool: $!\n&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir '/usr/spool/news' or die &quot;No puedo cd a spool: $!\n&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the last element of LIST does not end in a newline, the current
script line number and input line number (if any) are also printed,
and a newline is supplied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el último elemento de LISTA no acaba en el carácter de nueva línea, se imprimen también el valor actual del número de línea y el actual número de línea de entrada (si existe), junto con un carácter de nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &quot;input line number&quot; (also
known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to
be currently in effect, and is also available as the special variable
C&lt;$.&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que el &quot;número de línea de entrada&quot; (también conocido como &quot;chunk&quot; -tarugo-) está sujeto a cualquier noción de &quot;línea&quot; que sea efectiva en ese momento, y también está disponible en la variable especial C&lt;$.&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/&quot;$/&quot;&gt; and L&lt;perlvar/&quot;$.&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/&quot;$/&quot;&gt; y L&lt;perlvar/&quot;$.&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hint: sometimes appending C&lt;&quot;, stopped&quot;&gt; to your message will cause it
to make better sense when the string C&lt;&quot;at foo line 123&quot;&gt; is appended.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consejo: algunas veces añadir C&lt;&quot;, parado&quot;&gt; a tu mensaje hará aparecerle con un sentido mejor cuando se le añada el string C&lt;&quot;at foo line 123&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose you are running script &quot;canasta&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Suponga que está corriendo el script &quot;canasta&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;/etc/games is no good&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;/etc/games no está bien&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;/etc/games is no good, stopped&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;/etc/games no está bien, parado&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produce, respectively</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>produce, respectivamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/etc/games is no good at canasta line 123.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/etc/games no está bien at canasta line 123.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/etc/games is no good, stopped at canasta line 123.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/etc/games no está bien, parado at canasta line 123.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also exit(), warn(), and the Carp module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también exit(), warn() y el módulo Carp.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIST is empty and C&lt;$@&gt; already contains a value (typically from a
previous eval) that value is reused after appending C&lt;&quot;\t...propagated&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la LISTA está vacía y C&lt;$@&gt; ya contiene un valor (típicamente de un eval anterior) este valor es reusado después de añadirle C&lt;&quot;\t...propagated&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for propagating exceptions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para propagar excepciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { ... };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { ... };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die unless $@ =~ /Expected exception/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die unless $@ =~ /Excepción esperada/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LIST is empty and C&lt;$@&gt; contains an object reference that has a
C&lt;PROPAGATE&gt; method, that method will be called with additional file
and line number parameters.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LISTA está vacía y C&lt;$@&gt; contiene una referencia a un objeto que tiene un método C&lt;PROPAGATE&gt;, éste método será llamado con los parámetros adicionales del fichero y número de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value replaces the value in
C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de retorno reemplaza el valor en C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>i.e. as if C&lt;&lt; $@ = eval { $@-&gt;PROPAGATE(__FILE__, __LINE__) }; &gt;&gt;
were called.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es decir, como si se ejecutara C&lt;&lt; $@ = eval { $@-&gt;PROPAGATE(__FILE__, __LINE__) }; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;$@&gt; is empty then the string C&lt;&quot;Died&quot;&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;$@&gt; está vacío entonces se usa el string C&lt;&quot;Died&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die() can also be called with a reference argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die() puede ser llamada también con una referencia como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this happens to be
trapped within an eval(), $@ contains the reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ocurre que es atrapado dentro de un eval(), $@ contiene la referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior permits
a more elaborate exception handling implementation using objects that
maintain arbitrary state about the nature of the exception.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comportamiento permite una implementación del manejo de las excepciones más elaborada usando objetos que mantienen el estado sobre la naturaleza de la excepción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a scheme
is sometimes preferable to matching particular string values of $@ using
regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal esquema es algunas veces preferible a emparejar strings particulares de $@ usando expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Scalar::Util 'blessed';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Scalar::Util 'blessed';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { ... ; die Some::Module::Exception-&gt;new( FOO =&gt; &quot;bar&quot; ) };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { ... ; die Some::Module::Exception-&gt;new( FOO =&gt; &quot;bar&quot; ) };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($@) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($@) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (blessed($@) &amp;&amp; $@-&gt;isa(&quot;Some::Module::Exception&quot;)) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (blessed($@) &amp;&amp; $@-&gt;isa(&quot;Some::Module::Exception&quot;)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># handle Some::Module::Exception</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># procesar Some::Module::Exception</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># handle all other possible exceptions</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># procesar el resto de posibles excepciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because perl will stringify uncaught exception messages before displaying
them, you may want to overload stringification operations on such custom
exception objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como Perl convertirá en cadena de caracteres los mensajes de excepción no capturados antes de mostrarlos, quizás quiera sobrecargar las operaciones de conversión a cadena en objetos de excepción propios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;overload&gt; for details about that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;overload&gt; para los detalles sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can arrange for a callback to be run just before the C&lt;die&gt;
does its deed, by setting the C&lt;$SIG{__DIE__}&gt; hook.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede disponer que una retrollamada se ejecute antes de que C&lt;die&gt; haga sus funciones, actualizando el gancho C&lt;$SIG{__DIE__}&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The associated
handler will be called with the error text and can change the error
message, if it sees fit, by calling C&lt;die&gt; again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El manejador asociado será llamado con el texto del error y puede cambiar el mensaje de error, si le parece, llamando de nuevo a C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See
L&lt;perlvar/$SIG{expr}&gt; for details on setting C&lt;%SIG&gt; entries, and
L&lt;&quot;eval BLOCK&quot;&gt; for some examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/$SIG{expr}&gt; para los detalles sobre cómo colocar entradas C&lt;%SIG&gt; y L&lt;&quot;eval BLOCK&quot;&gt; para algunos ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this feature was 
to be run only right before your program was to exit, this is not
currently the case--the C&lt;$SIG{__DIE__}&gt; hook is currently called
even inside eval()ed blocks/strings!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque esta característica está preparada para ser ejecutada sólo antes de que el programa termine, este no es el caso: el gancho C&lt;$SIG{__DIE__}&gt;, ¡es llamado incluso dentro de cadenas y bloques eval()uados!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one wants the hook to do
nothing in such situations, put</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si uno quiere que el gancho no haga nada en estas situaciones, ponga</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die @_ if $^S;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die @_ if $^S;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as the first line of the handler (see L&lt;perlvar/$^S&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>como primera línea del manejador (ver L&lt;perlvar/$^S&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because
this promotes strange action at a distance, this counterintuitive
behavior may be fixed in a future release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que provoca una acción extraña a gran distancia, este comportamiento no intuitivo puede ser arreglado en una distribución futura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item do BLOCK
X&lt;do&gt; X&lt;block&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item do BLOQUE
X&lt;do&gt; X&lt;block&gt; X&lt;bloque&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not really a function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No es realmente una función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the value of the last command in the
sequence of commands indicated by BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el valor del último comando en la secuencia de comandos indicada por BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When modified by the C&lt;while&gt; or
C&lt;until&gt; loop modifier, executes the BLOCK once before testing the loop
condition.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se encuentra acompañado por los modificadores de bucle C&lt;while&gt; o C&lt;until&gt;, ejecuta el BLOQUE una vez antes de comprobar la condición del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(On other statements the loop modifiers test the conditional
first.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En otras sentencias los modificadores de bucle comprueban primero la condición).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;do BLOCK&gt; does I&lt;not&gt; count as a loop, so the loop control statements
C&lt;next&gt;, C&lt;last&gt;, or C&lt;redo&gt; cannot be used to leave or restart the block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;do BLOQUE&gt; I&lt;no&gt; cuenta como un bucle, así que las sentencias de control de bucle C&lt;next&gt;, C&lt;last&gt;, o C&lt;redo&gt; no pueden ser usadas para dejar o reiniciar el bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsyn&gt; for alternative strategies.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsyn&gt; para estrategias alternativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item do SUBROUTINE(LIST)
X&lt;do&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item do SUBRUTINA(LISTA)
X&lt;do&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of subroutine call is deprecated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma de llamada de subrutina ha sido depreciada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item do EXPR
X&lt;do&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item do EXPR
X&lt;do&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uses the value of EXPR as a filename and executes the contents of the
file as a Perl script.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usa el valor de EXPR como el nombre de un fichero y ejecuta los contenidos del fichero como un script Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do 'stat.pl';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do 'stat.pl';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is just like</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es igual que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval `cat stat.pl`;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval `cat stat.pl`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>except that it's more efficient and concise, keeps track of the current
filename for error messages, searches the @INC directories, and updates
C&lt;%INC&gt; if the file is found.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>excepto que es más eficiente y conciso, mantiene el nombre del fichero en los mensajes de error, busca en los directorios @INC y actualiza C&lt;%INC&gt; si el fichero es encontrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlvar/Predefined Names&gt; for these
variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlvar/Nombres predefinidos&gt; para estas variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also differs in that code evaluated with C&lt;do FILENAME&gt;
cannot see lexicals in the enclosing scope; C&lt;eval STRING&gt; does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También difiere en que el código evaluado con C&lt;do NOMBREFICHERO&gt; no puede ver a las variables léxicas en el ámbito en que se ejecuta; C&lt;eval STRING&gt; sí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's the
same, however, in that it does reparse the file every time you call it,
so you probably don't want to do this inside a loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es lo mismo, sin embargo, en que vuelve a parsear el fichero cada vez que lo llama, así que, probablemente, no querrá hacer esto dentro de un bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;do&gt; cannot read the file, it returns undef and sets C&lt;$!&gt; to the
error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;do&gt; no puede leer el fichero, devuelve undef y pone C&lt;$!&gt; al valor del error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;do&gt; can read the file but cannot compile it, it
returns undef and sets an error message in C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si C&lt;do&gt; puede leer el fichero pero no puede compilarlo, devuelve undef y pone un mensaje de error en C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the file is
successfully compiled, C&lt;do&gt; returns the value of the last expression
evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el fichero se compila bien, C&lt;do&gt; devuelve el valor de la última expresión evaluada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that inclusion of library modules is better done with the
C&lt;use&gt; and C&lt;require&gt; operators, which also do automatic error checking
and raise an exception if there's a problem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la inclusión de bibliotecas de módulos es mejor hacerla con los operadores C&lt;use&gt; y C&lt;require&gt;, que también hacen comprobación automática de errores y generan una excepción si existe algún problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might like to use C&lt;do&gt; to read in a program configuration
file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar C&lt;do&gt; para leer en un programa un fichero de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Manual error checking can be done this way:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comprobación manual de errores se puede hacer así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># read in config files: system first, then user</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># leer en ficheros de configuración: primero el sistema, luego el usuario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $file (&quot;/share/prog/defaults.rc&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $fichero (&quot;/share/prog/defaults.rc&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;$ENV{HOME}/.someprogrc&quot;)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;$ENV{HOME}/.someprogrc&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{
	unless ($return = do $file) {
	    warn &quot;couldn't parse $file: $@&quot; if $@;
	    warn &quot;couldn't do $file: $!&quot;    unless defined $return;
	    warn &quot;couldn't run $file&quot;       unless $return;
	}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{
	unless ($return = do $fichero) {
	    warn &quot;no puedo parsear $fichero: $@&quot; if $@;
	    warn &quot;no puedo hacer $fichero: $!&quot;   unless defined $return;
	    warn &quot;no puedo ejecutar $fichero&quot;    unless $return;
	}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dump LABEL
X&lt;dump&gt; X&lt;core&gt; X&lt;undump&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item dump ETIQUETA
X&lt;dump&gt; X&lt;core&gt; X&lt;undump&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item dump</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item dump</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function causes an immediate core dump.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función provoca un volcado inmediato del núcleo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the B&lt;-u&gt;
command-line switch in L&lt;perlrun&gt;, which does the same thing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también la opción de línea de comando B&lt;-u&gt; en L&lt;perlrun&gt;, que hace lo mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primarily this is so that you can use the B&lt;undump&gt; program (not
supplied) to turn your core dump into an executable binary after
having initialized all your variables at the beginning of the
program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Principalmente esto se utiliza en conjunción con el programa B&lt;undump&gt; (no suministrado) para convertir tu volcado del núcleo en un binario ejecutable después de haber inicializado todas las variables al comienzo del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the new binary is executed it will begin by executing
a C&lt;goto LABEL&gt; (with all the restrictions that C&lt;goto&gt; suffers).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando el nuevo binario es ejecutado, comenzará ejecutando un C&lt;goto ETIQUETA&gt; (con todas las restricciones que C&lt;goto&gt; padece).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of it as a goto with an intervening core dump and reincarnation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Piense en él como un goto entre un volcado del núcleo y una reencarnación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If C&lt;LABEL&gt; is omitted, restarts the program from the top.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite C&lt;ETIQUETA&gt;, reinicia el programa desde el principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;WARNING&gt;: Any files opened at the time of the dump will I&lt;not&gt;
be open any more when the program is reincarnated, with possible
resulting confusion on the part of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;ATENCIÓN&gt;: Cualquier fichero abierto en el momento del volcado I&lt;no&gt; será abierto cuando el programa sea reencarnado, con una muy posible confusión por parte de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function is now largely obsolete, partly because it's very
hard to convert a core file into an executable, and because the
real compiler backends for generating portable bytecode and compilable
C code have superseded it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta función es obsoleta desde hace mucho tiempo, en parte porque es muy difícil convertir un volcado del núcleo en un ejecutable, y porque el compilador incorporado para generar bytecode portable y el compilador de código C lo han superado ampliamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's why you should now invoke it as
C&lt;CORE::dump()&gt;, if you don't want to be warned against a possible
typo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y así es por qué debe invocarlo como C&lt;CORE::dump()&gt;, si no quiere ser avisado de que posiblemente ha cometido una falta ortográfica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're looking to use L&lt;dump&gt; to speed up your program, consider
generating bytecode or native C code as described in L&lt;perlcc&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está pensando usar L&lt;dump&gt; para aumentar la velocidad de un programa, considerar el generar bytecode o código nativo C, tal como se describe en L&lt;perlcc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you're just trying to accelerate a CGI script, consider using the
C&lt;mod_perl&gt; extension to B&lt;Apache&gt;, or the CPAN module, CGI::Fast.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sólo está intentando acelerar un guión CGI, considere usar la extensión C&lt;mod_perl&gt; en B&lt;Apache&gt;, o el módulo de CPAN, CGI::Fast.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might also consider autoloading or selfloading, which at least
make your program I&lt;appear&gt; to run faster.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede también considerar el método de autocarga, que le hará I&lt;parecer&gt; que su programa corre más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item each HASH
X&lt;each&gt; X&lt;hash, iterator&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item each HASH
X&lt;each&gt; X&lt;hash, iterator&gt; X&lt;iterador&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called in list context, returns a 2-element list consisting of the
key and value for the next element of a hash, so that you can iterate over
it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se llama en contexto lista, devuelve una lista de dos elementos consistentes en la clave y el valor del siguiente elementos del hash, así que de esta manera puede iterar por el.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called in scalar context, returns only the key for the next
element in the hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se le llama en contexto escalar, sólo devuelve la clave del siguiente elemento del hash. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entries are returned in an apparently random order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las entradas son devueltas en un aparente orden aleatorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual random
order is subject to change in future versions of perl, but it is
guaranteed to be in the same order as either the C&lt;keys&gt; or C&lt;values&gt;
function would produce on the same (unmodified) hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El actual orden aleatorio está sujeto a cambio en futuras versiones de Perl, pero está garantizado que sea en el mismo orden que las funciones C&lt;keys&gt; o C&lt;values&gt; producirían sobre el mismo hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Perl
5.8.1 the ordering is different even between different runs of Perl
for security reasons (see L&lt;perlsec/&quot;Algorithmic Complexity Attacks&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde Perl 5.8.1 la ordenación es diferente incluso entre diferentes ejecuciones de Perl por razones de seguridad (ver L&lt;perlsec/&quot;Ataques por Complejidad Algorítmica&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the hash is entirely read, a null array is returned in list context
(which when assigned produces a false (C&lt;0&gt;) value), and C&lt;undef&gt; in
scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se haya leído completamente el hash, se devuelve un array nulo en contexto lista (que cuando es asignado produce un valor falso (C&lt;0&gt;)) y un C&lt;undef&gt; en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next call to C&lt;each&gt; after that will start iterating
again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La siguiente llamada a C&lt;each&gt; reiniciará la iteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a single iterator for each hash, shared by all C&lt;each&gt;,
C&lt;keys&gt;, and C&lt;values&gt; function calls in the program; it can be reset by
reading all the elements from the hash, or by evaluating C&lt;keys HASH&gt; or
C&lt;values HASH&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existe un único iterador por cada hash, compartido por las llamadas a las funciones C&lt;each&gt;, C&lt;keys&gt; y C&lt;values&gt; en el programa; puede ser reinicializado leyendo todos los elementos del hash, o evaluando C&lt;keys HASH&gt; o C&lt;values HASH&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you add or delete elements of a hash while you're
iterating over it, you may get entries skipped or duplicated, so
don't.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si añades o borras elementos de un hash mientras está iterando sobre él, puede encontrarse con entradas desaparecidas o duplicadas, así que no lo haga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception: It is always safe to delete the item most recently
returned by C&lt;each()&gt;, which means that the following code will work:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Excepción: Siempre es seguro borrar el último item devuelto por C&lt;each()&gt;, por lo que entonces el siguiente código funcionará:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($key, $value) = each %hash) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (($clave, $valor) = each %hash) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $key, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $clave, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>delete $hash{$key};   # This is safe</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>delete $hash{$clave};   # Esto es seguro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following prints out your environment like the printenv(1) program,
only in a different order:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo siguiente imprime su entorno como el programa printenv(1), sólo que en un orden diferente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (($key,$value) = each %ENV) {
	print &quot;$key=$value\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (($clave,$valor) = each %ENV) {
	print &quot;$clave=$valor\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;keys&gt;, C&lt;values&gt; and C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;keys&gt;, C&lt;values&gt; y C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eof FILEHANDLE
X&lt;eof&gt;
X&lt;end of file&gt;
X&lt;end-of-file&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eof MANEJADORFICHERO
X&lt;eof&gt;
X&lt;end of file&gt; X&lt;fin de fichero&gt;
X&lt;end-of-file&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eof ()</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eof ()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eof</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eof</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns 1 if the next read on FILEHANDLE will return end of file, or if
FILEHANDLE is not open.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve 1 si el la siguiente lectura sobre MANEJADORFICHERO devolverá un fin de fichero, o si MANEJADORFICHERO no está abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FILEHANDLE may be an expression whose value
gives the real filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>MANEJADORFICHERO puede ser una expresión cuyo valor da el manejador real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this function actually
reads a character and then C&lt;ungetc&gt;s it, so isn't very useful in an
interactive context.)  Do not read from a terminal file (or call
C&lt;eof(FILEHANDLE)&gt; on it) after end-of-file is reached.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Note que esta función realmente lee un carácter y luego lo C&lt;ungetc&gt;, así que no es muy útil en un contexto interactivo). No lea de un fichero que se ha terminado (o llame a C&lt;eof(MANEJADORFICHERO)&gt; sobre él) después de obtener un fin-de-fichero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File types such
as terminals may lose the end-of-file condition if you do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tipos de ficheros como por ejemplo terminales pueden perder la condición de fin-de-fichero si lo hace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An C&lt;eof&gt; without an argument uses the last file read.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un C&lt;eof&gt; sin argumento usa el último fichero leído.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;eof()&gt;
with empty parentheses is very different.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar C&lt;eof()&gt; con paréntesis vacíos es muy diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It refers to the pseudo file
formed from the files listed on the command line and accessed via the
C&lt;&lt; &lt;&gt; &gt;&gt; operator.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Se refiere a un pseudo fichero formado por los ficheros listados en la línea de comandos y accedidos vía el operador C&lt;&lt; &lt;&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since C&lt;&lt; &lt;&gt; &gt;&gt; isn't explicitly opened,
as a normal filehandle is, an C&lt;eof()&gt; before C&lt;&lt; &lt;&gt; &gt;&gt; has been
used will cause C&lt;@ARGV&gt; to be examined to determine if input is
available.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como C&lt;&lt; &lt;&gt; &gt;&gt; no es explícitamente abierto, como lo sería un manejador de fichero, un C&lt;eof()&gt; antes de que un C&lt;&lt; &lt;&gt; &gt;&gt; sea usado, causará que C&lt;@ARGV&gt; sea examinado para determinar si la entrada está disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, an C&lt;eof()&gt; after C&lt;&lt; &lt;&gt; &gt;&gt; has returned
end-of-file will assume you are processing another C&lt;@ARGV&gt; list,
and if you haven't set C&lt;@ARGV&gt;, will read input from C&lt;STDIN&gt;;
see L&lt;perlop/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma semejante, un C&lt;eof()&gt; después de que un C&lt;&lt; &lt;&gt; &gt;&gt; haya devuelto un fin-de-fichero asumirá que está procesando otra lista C&lt;@ARGV&gt;, y si no ha puesto un nuevo C&lt;@ARGV&gt;, leerá la entrada desde C&lt;STDIN&gt;; ver L&lt;perlop/&quot;Operadores E/S&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a C&lt;&lt; while (&lt;&gt;) &gt;&gt; loop, C&lt;eof&gt; or C&lt;eof(ARGV)&gt; can be used to
detect the end of each file, C&lt;eof()&gt; will only detect the end of the
last file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En un bucle C&lt;&lt; while (&lt;&gt;) &gt;&gt;, C&lt;eof&gt; o C&lt;eof(ARGV)&gt; pueden usarse para detectar el fin de un fichero; C&lt;eof()&gt; sólo detectará el final del último fichero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># reset line numbering on each input file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># reiniciar el numerado de líneas en cada fichero de entrada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;&gt;) {
	next if /^\s*#/;	# skip comments
	print &quot;$.\t$_&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;&gt;) {
	next if /^\s*#/;	# salta comentarios
	print &quot;$.\t$_&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} continue {
	close ARGV  if eof;	# Not eof()!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} continue {
	close ARGV  if eof;	# No eof()!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># insert dashes just before last line of last file</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># inserta guiones justo antes de la última línea del último fichero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;&gt;) {
	if (eof()) {		# check for end of last file
	    print &quot;--------------\n&quot;;
	}
	print;
	last if eof();          # needed if we're reading from a terminal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;&gt;) {
	if (eof()) {		# testea final del último fichero
	    print &quot;--------------\n&quot;;
	}
	print;
	last if eof();          # necesario si estamos leyendo de una terminal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practical hint: you almost never need to use C&lt;eof&gt; in Perl, because the
input operators typically return C&lt;undef&gt; when they run out of data, or if
there was an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Truco práctico: casi nunca necesita usar C&lt;eof&gt; en Perl, porque los operadores de entrada normalmente devuelven C&lt;undef&gt; cuando no hay más datos, o si ocurrió un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eval EXPR
X&lt;eval&gt; X&lt;try&gt; X&lt;catch&gt; X&lt;evaluate&gt; X&lt;parse&gt; X&lt;execute&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eval EXPR
X&lt;eval&gt; X&lt;try&gt; X&lt;catch&gt; X&lt;evaluate&gt; X&lt;parse&gt; X&lt;execute&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eval BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eval BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item eval</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item eval</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first form, the return value of EXPR is parsed and executed as if it
were a little Perl program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la primera forma, el valor devuelto por EXPR es parseado y ejecutado como si fuera un pequeño programa Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the expression (which is itself
determined within scalar context) is first parsed, and if there weren't any
errors, executed in the lexical context of the current Perl program, so
that any variable settings or subroutine and format definitions remain
afterwards.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de la expresión (que es en sí mismo determinada en contexto escalar) es primero parseada, y si no hay ningún error, ejecutada en el contexto léxico del actual programa Perl, por lo que no se mantienen después ningún valor de variable o definiciones de subrutinas o formatos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value is parsed every time the C&lt;eval&gt; executes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que el valor es parseado cada vez que se ejecuta C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, evaluates C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, se evalua C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form is typically used to
delay parsing and subsequent execution of the text of EXPR until run time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma es típicamente usada para retrasar el parseo subsecuente ejecución del texto de EXPR hasta el momento de la ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the second form, the code within the BLOCK is parsed only once--at the
same time the code surrounding the C&lt;eval&gt; itself was parsed--and executed
within the context of the current Perl program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la segunda forma, el código dentro del BLOQUE es parseado sólo una vez -al mismo tiempo que el código que rodea al mismo C&lt;eval&gt; es parseado- y ejecutado dentro del contexto del actual programa Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form is typically
used to trap exceptions more efficiently than the first (see below), while
also providing the benefit of checking the code within BLOCK at compile
time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma es típicamente usada para atrapar excepciones más eficientemente que la primera forma (ver arriba), mientras que también provee del beneficio de comprobar el código dentro del BLOQUE en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final semicolon, if any, may be omitted from the value of EXPR or within
the BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El último punto y coma, si lo hay, puede ser omitido del valor de EXPR o dentro de BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both forms, the value returned is the value of the last expression
evaluated inside the mini-program; a return statement may be also used, just
as with subroutines.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En ambas formas, el valor devuelto es el valor de la última expresión evaluada dentro del mini-programa; una sentencia return se puede usar también, como si fuera una subrutina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression providing the return value is evaluated
in void, scalar, or list context, depending on the context of the C&lt;eval&gt; 
itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La expresión que da el valor de retorno es evaluada en contexto vacío (void), escalar o lista, dependiendo del contexto en que se encuentre el C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/wantarray&gt; for more on how the evaluation context can be 
determined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/wantarray&gt; para saber cómo determinar el contexto de la evaluación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a syntax error or runtime error, or a C&lt;die&gt; statement is
executed, an undefined value is returned by C&lt;eval&gt;, and C&lt;$@&gt; is set to the
error message.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay algún error de sintaxis o en tiempo de ejecución, o se ejecuta una sentencia C&lt;die&gt;, un valor indefinido es devuelto por C&lt;eval&gt; y C&lt;$@&gt; es puesto al mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there was no error, C&lt;$@&gt; is guaranteed to be a null
string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay errores, se garantiza que C&lt;$@&gt; será un string nulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that using C&lt;eval&gt; neither silences perl from printing
warnings to STDERR, nor does it stuff the text of warning messages into C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado porque usar C&lt;eval&gt; ni silencia perl a la hora de imprimir avisos al STDERR, ni rellena el texto de los mensajes de error de los mensajes de aviso dentro de C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do either of those, you have to use the C&lt;$SIG{__WARN__}&gt; facility, or
turn off warnings inside the BLOCK or EXPR using S&lt;C&lt;no warnings 'all'&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para hacer cualquiera de estas dos cosas debe usar C&lt;$SIG{__WARN__}&gt;, o desactivar los avisos dentro del BLOQUE o EXPR usando S&lt;C&lt;no warnings 'all'&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;/warn&gt;, L&lt;perlvar&gt;, L&lt;warnings&gt; and L&lt;perllexwarn&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;/warn&gt;, L&lt;perlvar&gt;, L&lt;warnings&gt; y L&lt;perllexwarn&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, because C&lt;eval&gt; traps otherwise-fatal errors, it is useful for
determining whether a particular feature (such as C&lt;socket&gt; or C&lt;symlink&gt;)
is implemented.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que, como C&lt;eval&gt; atrapa errores considerados fatales, es útil para determinar cuando una característica en particular (como C&lt;socket&gt; o C&lt;symlink&gt;) está implementada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also Perl's exception trapping mechanism, where
the die operator is used to raise exceptions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También es la excepción en el sistema de atrapado de Perl, donde el operador die se usa para levantar excepciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the code to be executed doesn't vary, you may use the eval-BLOCK
form to trap run-time errors without incurring the penalty of
recompiling each time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el código a ser ejecutado no varía, puede usar la forma BLOQUE de eval para atrapar errores en tiempo de ejecución sin incurrir en la penalidad de recompilar cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The error, if any, is still returned in C&lt;$@&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El error, si está, es devuelto en C&lt;$@&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># make divide-by-zero nonfatal</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># hace la división-por-cero no fatal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { $answer = $a / $b; }; warn $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { $respuesta = $a / $b; }; warn $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># same thing, but less efficient</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># lo mismo, pero menos eficiente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval '$answer = $a / $b'; warn $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval '$respuesta = $a / $b'; warn $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a compile-time error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un error en tiempo de compilación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { $answer = };			# WRONG</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { $respuesta = };			# MAL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a run-time error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># un error en tiempo de ejecución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval '$answer =';	# sets $@</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval '$respuesta =';	# pone $@</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the C&lt;eval{}&gt; form as an exception trap in libraries does have some
issues.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar la forma C&lt;eval{}&gt; como una trampa de excepciones en bibliotecas puede tener algunos problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the current arguably broken state of C&lt;__DIE__&gt; hooks, you
may wish not to trigger any C&lt;__DIE__&gt; hooks that user code may have installed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido al posible mal estado de la llamada C&lt;__DIE__&gt;, quizás deseé no activar ninguna de las llamadas C&lt;__DIE__&gt; que el código de usuario puede haber instalado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the C&lt;local $SIG{__DIE__}&gt; construct for this purpose,
as shown in this example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar la construcción C&lt;local $SIG{__DIE__}&gt; para este propósito, como se muestra en este ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># a very private exception trap for divide-by-zero</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># una muy privada trampa de excepción para la división-por-cero</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { local $SIG{'__DIE__'}; $answer = $a / $b; };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { local $SIG{'__DIE__'}; $respuesta = $a / $b; };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn $@ if $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn $@ if $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is especially significant, given that C&lt;__DIE__&gt; hooks can call
C&lt;die&gt; again, which has the effect of changing their error messages:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es especialmente significativo, dado que las llamadas C&lt;__DIE__&gt; pueden llamar de nuevo a C&lt;die&gt;, que tiene el ejecto de cambiar los mensajes de error:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># __DIE__ hooks may modify error messages</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># llamadas __DIE__ pueden modificar los mensajes de error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local $SIG{'__DIE__'} =</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>local $SIG{'__DIE__'} =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { die &quot;foo lives here&quot; };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { die &quot;foo vive aquí&quot; };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $@ if $@;                # prints &quot;bar lives here&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $@ if $@;                # imprime &quot;bar vive aquí&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this promotes action at a distance, this counterintuitive behavior
may be fixed in a future release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debido a que provoca una acción extraña a gran distancia, este comportamiento no intuitivo puede ser arreglado en una futura distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With an C&lt;eval&gt;, you should be especially careful to remember what's
being looked at when:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dentro de C&lt;eval&gt;, debe, especialmente, recordar que es lo que está haciendo en cada momento:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval $x;		# CASE 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval $x;		# CASO 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;$x&quot;;		# CASE 2</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;$x&quot;;		# CASO 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval '$x';		# CASE 3</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval '$x';		# CASO 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval { $x };	# CASE 4</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval { $x };	# CASO 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;\$$x++&quot;;	# CASE 5</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;\$$x++&quot;;	# CASO 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$$x++;		# CASE 6</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$$x++;		# CASO 6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cases 1 and 2 above behave identically: they run the code contained in
the variable $x.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los casos 1 y 2 se comportan idénticamente: ejecutan el código contenido en la variable $x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Although case 2 has misleading double quotes making
the reader wonder what else might be happening (nothing is).)  Cases 3
and 4 likewise behave in the same way: they run the code C&lt;'$x'&gt;, which
does nothing but return the value of $x.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Aunque el caso 2 tiene unas engañosas dobles comillas haciendo maravillar al lector de qué es lo que que puede pasar -que es nada-).  Los casos 3 y 4 se comportan de la misma manera: ejecutan el código C&lt;'$x'&gt;, que no hace nada excepto devolver el valor de $x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Case 4 is preferred for
purely visual reasons, but it also has the advantage of compiling at
compile-time instead of at run-time.)  Case 5 is a place where
normally you I&lt;would&gt; like to use double quotes, except that in this
particular situation, you can just use symbolic references instead, as
in case 6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(El caso 4 es el preferido por razones puramente visuales, pero también tiene la ventaja de la compilación en tiempo de compilación en lugar de en tiempo de ejecución). Caso 5 es aquel donde normalmente I&lt;debería&gt; usar dobles comillas, excepto que en esta situación en particular, puede usar en su lugar referencias simbólicas instead, como en el caso 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;eval BLOCK&gt; does I&lt;not&gt; count as a loop, so the loop control statements
C&lt;next&gt;, C&lt;last&gt;, or C&lt;redo&gt; cannot be used to leave or restart the block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;eval BLOQUE&gt; I&lt;no&gt; cuenta como un bucle, así que las sentencias de control de bucle C&lt;next&gt;, C&lt;last&gt;, o C&lt;redo&gt; no pueden ser usadas para dejar o reiniciar el bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that as a very special case, an C&lt;eval ''&gt; executed within the C&lt;DB&gt;
package doesn't see the usual surrounding lexical scope, but rather the
scope of the first non-DB piece of code that called it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que como caso especial, un C&lt;eval ''&gt; ejecutado dentro del paquete C&lt;DB&gt; no ve el usual ámbito léxico circundante, más bien el ámbito del primer trozo de código no-DB que le llamó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't normally
need to worry about this unless you are writing a Perl debugger.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No necesitará preocuparse de esto a menos que esté escribiendo un depurador Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exec LIST
X&lt;exec&gt; X&lt;execute&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exec LISTA
X&lt;exec&gt; X&lt;execute&gt; X&lt;ejecutar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exec PROGRAM LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exec PROGRAMA LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;exec&gt; function executes a system command I&lt;and never returns&gt;--
use C&lt;system&gt; instead of C&lt;exec&gt; if you want it to return.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función C&lt;exec&gt; ejecuta un comando del sistema I&lt;y nunca regresa&gt; --use C&lt;system&gt; en lugar de C&lt;exec&gt; si quiere que regrese.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It fails and
returns false only if the command does not exist I&lt;and&gt; it is executed
directly instead of via your system's command shell (see below).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Fallará y devolverá falso sólo si el comando no existe I&lt;y&gt; es ejecutado directamente en lugar de hacerlo con el shell de comandos del sistema (ver abajo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it's a common mistake to use C&lt;exec&gt; instead of C&lt;system&gt;, Perl
warns you if there is a following statement which isn't C&lt;die&gt;, C&lt;warn&gt;,
or C&lt;exit&gt; (if C&lt;-w&gt; is set  -  but you always do that).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como es un error normal usar C&lt;exec&gt; en lugar de C&lt;system&gt;, Perl le avisará si hay alguna sentencia a continuación que no sea C&lt;die&gt;, C&lt;warn&gt; o C&lt;exit&gt; (si C&lt;-w&gt; está puesto - pero usted siempre lo tiene así, ¿verdad?).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
I&lt;really&gt; want to follow an C&lt;exec&gt; with some other statement, you
can use one of these styles to avoid the warning:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si I&lt;verdaderamente&gt; quiere continuar un C&lt;exec&gt; con otra sentencia, puede usar algunas de estas formas para evitar el aviso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec ('foo')   or print STDERR &quot;couldn't exec foo: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec ('foo')   or print STDERR &quot;no puedo exec foo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{ exec ('foo') }; print STDERR &quot;couldn't exec foo: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{ exec ('foo') }; print STDERR &quot;no puedo exec foo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is more than one argument in LIST, or if LIST is an array
with more than one value, calls execvp(3) with the arguments in LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si hay más de un argumento en LISTA, o si LISTA es un array con más de un valor, se llama a execvp(3) con los argumentos de LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is only one scalar argument or an array with one element in it,
the argument is checked for shell metacharacters, and if there are any,
the entire argument is passed to the system's command shell for parsing
(this is C&lt;/bin/sh -c&gt; on Unix platforms, but varies on other platforms).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si sólo hay un argumento escalar o un array con un elemento dentro de él, se comprueba si el argumento tiene metacaracteres, y si hay alguno, el argumento entero es pasado al shell de comandos para que sea parseado (suele ser C&lt;/bin/sh -c&gt; en plataformas Unix, pero varía en otras plataformas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no shell metacharacters in the argument, it is split into
words and passed directly to C&lt;execvp&gt;, which is more efficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no hay metacaracteres shell en el argumento, es dividido en palabras y pasadas directamente a C&lt;execvp&gt;, que es más eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec '/bin/echo', 'Your arguments are: ', @ARGV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec '/bin/echo', 'Tus argumentos son: ', @ARGV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec &quot;sort $outfile | uniq&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec &quot;sort $salida | uniq&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't really want to execute the first argument, but want to lie
to the program you are executing about its own name, you can specify
the program you actually want to run as an &quot;indirect object&quot; (without a
comma) in front of the LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si realmente no quiere ejecutar el primer argumento, pero quiere engañar al programa que está ejecutando sobre su propio nombre, puede especificar el programa que quiera ejecutar como un &quot;objeto indirecto&quot; (sin la coma) enfrente de la LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This always forces interpretation of the
LIST as a multivalued list, even if there is only a single scalar in
the list.)  Example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto siempre fuerza la interpretación de la LISTA como una lista multievaluada, incluso si sólo hay un único escalar en la lista). Ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$shell = '/bin/csh';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$shell = '/bin/csh';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec $shell '-sh';		# pretend it's a login shell</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec $shell '-sh';		# pretende ser un shell del login</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or, more directly,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o, más directamente,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec {'/bin/csh'} '-sh';	# pretend it's a login shell</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec {'/bin/csh'} '-sh';	# pretende ser un shell del login</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the arguments get executed via the system shell, results will
be subject to its quirks and capabilities.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando los argumentos son ejecutados vía el shell del sistema, los resultados estarán sujetos a sus peculiaridades y capacidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;`STRING`&quot;&gt;
for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop/&quot;`STRING`&quot;&gt; para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an indirect object with C&lt;exec&gt; or C&lt;system&gt; is also more
secure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar un objeto indirecto con C&lt;exec&gt; o C&lt;system&gt; es también más seguro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This usage (which also works fine with system()) forces
interpretation of the arguments as a multivalued list, even if the
list had just one argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este uso (que también funciona bien con system()) fuerza la interpretación de los argumentos como una lista multievaluada, incluso si la lista sólo tiene un argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That way you're safe from the shell
expanding wildcards or splitting up words with whitespace in them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esta forma estará protegido de la expansión de los comodines del shell o de la división en palabras con un espacio en blanco dentro de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@args = ( &quot;echo surprise&quot; );</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@args = ( &quot;echo sorpresa&quot; );</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec @args;               # subject to shell escapes</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec @args;               # sujeto a los escapes del shell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># if @args == 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># if @args == 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exec { $args[0] } @args;  # safe even with one-arg list</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exec { $args[0] } @args;  # seguro incluso con una lista de un argumento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first version, the one without the indirect object, ran the I&lt;echo&gt;
program, passing it C&lt;&quot;surprise&quot;&gt; an argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La primera versión, sin el objeto indirecto, ejecuta el programa I&lt;echo&gt;, pasándole C&lt;&quot;sorpresa&quot;&gt; como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second version
didn't--it tried to run a program literally called I&lt;&quot;echo surprise&quot;&gt;,
didn't find it, and set C&lt;$?&gt; to a non-zero value indicating failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La segunda versión no: intentó ejecutar un programa llamado literalmente I&lt;&quot;echo surprise&quot;&gt;, no lo encontró, y puso C&lt;$?&gt; a un valor distinto de cero para indicar un fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before the exec, but this may not be supported on some platforms
(see L&lt;perlport&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de la versión v5.6.0, Perl intentará vaciar todos los ficheros abiertos para salida antes de ejecutar exec, pero esto puede no estar soportado en todas las plataformas (ver L&lt;perlport&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, you may need to set C&lt;$|&gt; ($AUTOFLUSH
in English) or call the C&lt;autoflush()&gt; method of C&lt;IO::Handle&gt; on any
open handles in order to avoid lost output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para asegurarse, puede poner C&lt;$|&gt; ($AUTOFLUSH en English) o llamar el método C&lt;autoflush()&gt; de C&lt;IO::Handle&gt; en cualquiera de los manejadores abiertos para evitar la pérdida de datos en la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;exec&gt; will not call your C&lt;END&gt; blocks, nor will it call
any C&lt;DESTROY&gt; methods in your objects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;exec&gt; no llamará a sus bloques C&lt;END&gt;, ni llamará a ningún método C&lt;DESTROY&gt; de sus objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exists EXPR
X&lt;exists&gt; X&lt;autovivification&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exists EXPR
X&lt;exists&gt; X&lt;autovivificación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an expression that specifies a hash element or array element,
returns true if the specified element in the hash or array has ever
been initialized, even if the corresponding value is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dada una expresión que especifica un elemento de un hash o de un array, devuelve verdadero si el elemento especificado en el hash o array ha sido inicializado, incluso si el correspondiente valor es indefinido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
element is not autovivified if it doesn't exist.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El elemento no es autovivificado si no existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Exists\n&quot; 	if exists $hash{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Existe\n&quot;      if exists $hash{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Defined\n&quot; 	if defined $hash{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Definido\n&quot;    if defined $hash{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;True\n&quot;      if $hash{$key};</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Verdadero\n&quot;   if $hash{$clave};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Exists\n&quot; 	if exists $array[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Existe\n&quot;      if exists $array[$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Defined\n&quot; 	if defined $array[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Definido\n&quot;    if defined $array[$indice];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;True\n&quot;      if $array[$index];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Verdadero\n&quot;   if $array[$index];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hash or array element can be true only if it's defined, and defined if
it exists, but the reverse doesn't necessarily hold true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un elemento de un hash o de un array puede ser verdadero sólo si está definido, y definido y existe, pero lo inverso no es necesariamente cierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an expression that specifies the name of a subroutine,
returns true if the specified subroutine has ever been declared, even
if it is undefined.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dada una expresión que especifica el nombre de una subrutina, devuelve verdadero si la subrutina especificada ha sido declarada, incluso si esta está indefinida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mentioning a subroutine name for exists or defined
does not count as declaring it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mencionar el nombre de una subrutina para saber si existe o está definida no cuenta como si fuera su declaración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a subroutine which does not
exist may still be callable: its package may have an C&lt;AUTOLOAD&gt;
method that makes it spring into existence the first time that it is
called -- see L&lt;perlsub&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que una subrutina que no existe puede ser llamada: su paquete puede tener un método C&lt;AUTOLOAD&gt; que la hace aparecer la primera vez que es llamada -- ver L&lt;perlsub&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Exists\n&quot; 	if exists &amp;subroutine;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Existe\n&quot;   if exists &amp;subrutina;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Defined\n&quot; 	if defined &amp;subroutine;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Definida\n&quot; if defined &amp;subrutina;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the EXPR can be arbitrarily complicated as long as the final
operation is a hash or array key lookup or subroutine name:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que EXPR puede ser todo lo arbitrariamente complicada que se quiera con tal de que la operación final sea un escalar de un hash o de un array o el nombre de una subrutina:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;{$key}) 	{ }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;{$clave})  { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $hash{A}{B}{$key}) 	{ }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $hash{A}{B}{$clave})       { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;[$ix]) 	{ }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $ref-&gt;{A}-&gt;{B}-&gt;[$indice]) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $hash{A}{B}[$ix]) 	{ }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $hash{A}{B}[$indice])      { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists &amp;{$ref-&gt;{A}{B}{$key}})   { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists &amp;{$ref-&gt;{A}{B}{$clave}})   { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the deepest nested array or hash will not spring into existence
just because its existence was tested, any intervening ones will.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque el array o hash más profundamente anidado no se autovivifique sólo por que su existencia sea comprobada, cualquiera de los niveles intermedios sí lo hará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;&lt; $ref-&gt;{&quot;A&quot;} &gt;&gt; and C&lt;&lt; $ref-&gt;{&quot;A&quot;}-&gt;{&quot;B&quot;} &gt;&gt; will spring
into existence due to the existence test for the $key element above.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así. C&lt;&lt; $ref-&gt;{&quot;A&quot;} &gt;&gt; y C&lt;&lt; $ref-&gt;{&quot;A&quot;}-&gt;{&quot;B&quot;} &gt;&gt; aparecerán en la existencia debido al actual test por el elemento $clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens anywhere the arrow operator is used, including even:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto sucede en cualquier parte en que se use el operador flecha, incluso en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undef $ref;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>undef $ref;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (exists $ref-&gt;{&quot;Some key&quot;})	{ }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (exists $ref-&gt;{&quot;Alguna clave&quot;})    { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $ref; 	    # prints HASH(0x80d3d5c)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $ref;          # prints HASH(0x80d3d5c)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This surprising autovivification in what does not at first--or even
second--glance appear to be an lvalue context may be fixed in a future
release.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta sorprendente autovivificación en que al primer vistazo -o incluso al segundo- parece que es un contexto lvalor quizás será arreglado en una futura distribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlref/&quot;Pseudo-hashes: Using an array as a hash&quot;&gt; for specifics
on how exists() acts when used on a pseudo-hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlref/&quot;Pseudo-hashes: Usando un array como un hash&quot;&gt; para el caso específico de como exists() actua cuando se usa sobre un pseudo-hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of a subroutine call, rather than a subroutine name, as an argument
to exists() is an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usar una llamada de subrutina en lugar del nombre de una subrutina como argumento a exists() es un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exists &amp;sub;	# OK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exists &amp;sub;	# OK</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exists &amp;sub();	# Error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exists &amp;sub();	# Error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exit EXPR
X&lt;exit&gt; X&lt;terminate&gt; X&lt;abort&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exit EXPR
X&lt;exit&gt; X&lt;terminar&gt; X&lt;abortar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exit</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates EXPR and exits immediately with that value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa EXPR y sale inmediatamente con este valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ans = &lt;STDIN&gt;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ans = &lt;STDIN&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exit 0 if $ans =~ /^[Xx]/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exit 0 if $ans =~ /^[Xx]/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, exits with C&lt;0&gt; status.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR es omitida, sale con estado C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only
universally recognized values for EXPR are C&lt;0&gt; for success and C&lt;1&gt;
for error; other values are subject to interpretation depending on the
environment in which the Perl program is running.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los únicos valores universalmente reconocidos para EXPR son C&lt;0&gt; para éxito y C&lt;1&gt; para error; otros valores están sujetos a interpretación dependiendo del entorno en que el programa Perl está corriendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, exiting
69 (EX_UNAVAILABLE) from a I&lt;sendmail&gt; incoming-mail filter will cause
the mailer to return the item undelivered, but that's not true everywhere.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, saliendo con 69 (EX_UNAVAILABLE) desde un filtrado de un correo entrante hacia I&lt;sendmail&gt; hará que el despachador de correo devuelva el elemento sin entregar, pero no siempre es cierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't use C&lt;exit&gt; to abort a subroutine if there's any chance that
someone might want to trap whatever error happened.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No use C&lt;exit&gt; para abortar una subrutina si existe la posibilidad de que alguien pueda capturar el error que ocurrió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use C&lt;die&gt; instead,
which can be trapped by an C&lt;eval&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use en su lugar C&lt;die&gt;, que puede ser atrapado por un C&lt;eval&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exit() function does not always exit immediately.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función exit() no siempre sale de forma inmediata.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It calls any
defined C&lt;END&gt; routines first, but these C&lt;END&gt; routines may not
themselves abort the exit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>exit() llama primero a cualquier rutina definida C&lt;END&gt;, pero estas rutinas C&lt;END&gt; pueden abortar la salida por sí mismas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise any object destructors that need to
be called are called before the real exit.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Igualmente cualquier destructor de objetos que necesite ser llamado es llamado antes de la salida real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is a problem, you
can call C&lt;POSIX:_exit($status)&gt; to avoid END and destructor processing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si esto es un problema, puede llamar a C&lt;POSIX:_exit($estado)&gt; para saltar el procesado de END y de los destructores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod&gt; para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exp EXPR
X&lt;exp&gt; X&lt;exponential&gt; X&lt;antilog&gt; X&lt;antilogarithm&gt; X&lt;e&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exp EXPR
X&lt;exp&gt; X&lt;exponencial&gt; X&lt;antilog&gt; X&lt;antilogaritmo&gt; X&lt;e&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item exp</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item exp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns I&lt;e&gt; (the natural logarithm base) to the power of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve I&lt;e&gt; (la base natural del logaritmo) a la potencia de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, gives C&lt;exp($_)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si EXPR se omite, devuelve C&lt;exp($_)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fcntl FILEHANDLE,FUNCTION,SCALAR
X&lt;fcntl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item fcntl MANEJADOR,FUNCIÓN,ESCALAR
X&lt;fcntl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implements the fcntl(2) function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Implementa la función fcntl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll probably have to say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Probablemente escribirá</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first to get the correct constant definitions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>primero para obtener las definiciones de las constantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Argument processing and
value return works just like C&lt;ioctl&gt; below.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El procesado de argumentos y el valor devuelto funcionan como C&lt;ioctl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fcntl($filehandle, F_GETFL, $packed_return_buffer)
	or die &quot;can't fcntl F_GETFL: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>fcntl($manejador, F_GETFL, $buffer_empaquetado_devuelto)
	or die &quot;no puedo hacer fcntl F_GETFL: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to check for C&lt;defined&gt; on the return from C&lt;fcntl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No necesita comprobar con C&lt;defined&gt; al regreso de C&lt;fcntl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C&lt;ioctl&gt;, it maps a C&lt;0&gt; return from the system call into
C&lt;&quot;0 but true&quot;&gt; in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como C&lt;ioctl&gt;, mapea un C&lt;0&gt; devuelto de la llamada del sistema en un C&lt;&quot;0 but true&quot;&gt; (&quot;0 pero cierto&quot;) en Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This string is true in boolean context and C&lt;0&gt;
in numeric context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este string es verdadero en contexto booleano y C&lt;0&gt; en contexto numérico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also exempt from the normal B&lt;-w&gt; warnings
on improper numeric conversions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También es una excepción en el sistema de avisos B&lt;-w&gt; sobre conversiones numéricas impropias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;fcntl&gt; will produce a fatal error if used on a machine that
doesn't implement fcntl(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;fcntl&gt; producirá un error fatal si se usa en una máquina que no implemente fcntl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the Fcntl module or your fcntl(2)
manpage to learn what functions are available on your system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el módulo Fcntl o la página de manual fcntl(2) para aprender qué funciones están disponibles en su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example of setting a filehandle named C&lt;REMOTE&gt; to be
non-blocking at the system level.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo de poner un manejador de fichero llamado C&lt;REMOTE&gt; a no bloqueante a nivel de sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll have to negotiate C&lt;$|&gt;
on your own, though.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque, tendrá que negociar también con C&lt;$|&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$flags = fcntl(REMOTE, F_GETFL, 0)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$flags = fcntl(REMOTE, F_GETFL, 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't get flags for the socket: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo obtener los flags para el socket: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or die &quot;Can't set flags for the socket: $!\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or die &quot;No puedo poner los flags para el socket: $!\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fileno FILEHANDLE
X&lt;fileno&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item fileno MANEJADOR
X&lt;fileno&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the file descriptor for a filehandle, or undefined if the
filehandle is not open.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el descriptor de fichero para un manejador, o indefinido si el manejador no está abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is mainly useful for constructing
bitmaps for C&lt;select&gt; and low-level POSIX tty-handling operations.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es principalmente útil para construir bitmaps para C&lt;select&gt; y operaciones POSIX de bajo nivel sobre tty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is an expression, the value is taken as an indirect
filehandle, generally its name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el MANEJADOR es una expresión, el valor es tomado como un manejador indirecto, generalmente su nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this to find out whether two handles refer to the
same underlying descriptor:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar esto para encontrar cuándo dos manejadores se refieren al mismo descriptor subyacente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (fileno(THIS) == fileno(THAT)) {
	print &quot;THIS and THAT are dups\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (fileno(THIS) == fileno(THAT)) {
	print &quot;THIS Y THAT son duplicados\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Filehandles connected to memory objects via new features of C&lt;open&gt; may
return undefined even though they are open.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Manejadores conectados a objetos en memoria vía las nuevas posibilidades de C&lt;open&gt; pueden devolver indefinido incluso si están abiertos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item flock FILEHANDLE,OPERATION
X&lt;flock&gt; X&lt;lock&gt; X&lt;locking&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item flock MANEJADOR,OPERACIÓN
X&lt;flock&gt; X&lt;lock&gt; X&lt;bloqueo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls flock(2), or an emulation of it, on FILEHANDLE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llama a flock(2), o una emulación de ella, sobre  MANEJADOR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns true
for success, false on failure.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve verdadero para éxito, falso en fallo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Produces a fatal error if used on a
machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Produce un error fatal si se usa en una máquina que no implemente flock(2), bloqueo fcntl(2), o lockf(3).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;flock&gt; is Perl's portable file locking interface, although it locks
only entire files, not records.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;flock&gt; es el interface portable de Perl de bloqueo de fichero, aunque sólo bloquea ficheros enteros, no registros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two potentially non-obvious but traditional C&lt;flock&gt; semantics are
that it waits indefinitely until the lock is granted, and that its locks
B&lt;merely advisory&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dos potenciales no obvias pero tradicionales semánticas de C&lt;flock&gt; son que espera indefinidamente hasta que el bloqueo es efectivo, y que B&lt;meramente es un consejo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such discretionary locks are more flexible, but offer
fewer guarantees.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tales bloqueos discrecionalmente son más flexibles, pero ofrecen pocas garantías.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that programs that do not also use C&lt;flock&gt;
may modify files locked with C&lt;flock&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que los programas que no usen C&lt;flock&gt; pueden modificar ficheros bloqueados con C&lt;flock&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport&gt;, 
your port's specific documentation, or your system-specific local manpages
for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport&gt;, la documentación específica de su adaptación Perl, o sus páginas de manual locales para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's best to assume traditional behavior if you're writing
portable programs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es mejor asumir el comportamiento tradicional si está escribiendo programas portables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But if you're not, you should as always feel perfectly
free to write for your own system's idiosyncrasies (sometimes called
&quot;features&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Pero si no, puede siempre sentirse libre de escribir sus propias idiosincrasias del sistema (algunas veces llamadas &quot;features&quot; -características-).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slavish adherence to portability concerns shouldn't get
in the way of your getting your job done.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Adhesión servil a los requerimientos de portabilidad no debe impedirle obtener el trabajo hecho).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with
LOCK_NB.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>OPERACIÓN es una de LOCK_SH, LOCK_EX, o LOCK_UN, posiblemente combinado con LOCK_NB.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are traditionally valued 1, 2, 8 and 4, but
you can use the symbolic names if you import them from the Fcntl module,
either individually, or as a group using the ':flock' tag.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas constantes tienen, tradicionalmente, los valores 1, 2, 8 y 4, pero puede usar los nombres simbólicos si los importa con el módulo Fcntl, tanto de forma indivual o como un grupo usando la marca ':flock'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LOCK_SH
requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN
releases a previously requested lock.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LOCK_SH solicita un bloqueo compartido, LOCK_EX solicita un bloqueo exclusivo y LOCK_UN devuelve un bloqueo solicitado previamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If LOCK_NB is bitwise-or'ed with
LOCK_SH or LOCK_EX then C&lt;flock&gt; will return immediately rather than blocking
waiting for the lock (check the return status to see if you got it).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si LOCK_NB se combina a nivel de bit con 'or' con LOCK_SH o LOCK_EX entonces C&lt;flock&gt; regresará inmediatamente en vez de esperar por el bloqueo (compruebe el valor de estado devuelto para ver si lo ha conseguido).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE
before locking or unlocking it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para evitar la posibilidad de descoordinación, Perl ahora vacía el MANEJADOR antes de bloquearlo o desbloquearlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the emulation built with lockf(3) doesn't provide shared
locks, and it requires that FILEHANDLE be open with write intent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la emulación integrada con lockf(3) no provee de bloqueos compartidos y requiere que el MANEJADOR sea abierto con intención de escribir en el.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
are the semantics that lockf(3) implements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas son las semánticas que lockf(3) implementa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most if not all systems
implement lockf(3) in terms of fcntl(2) locking, though, so the
differing semantics shouldn't bite too many people.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La mayor parte si no todos los sistemas implementan lockf(3) en términos de bloqueo con fcntl(2), aunque, las diferencias en la semántica no llame la atención a mucha gente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE
be open with read intent to use LOCK_SH and requires that it be open
with write intent to use LOCK_EX.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la emulación de fcntl(2) de flock(3) requiere que MANEJADOR sea abierto con intención de leer para usar LOCK_SH y requiere ser abierto con intención de escribir para usar LOCK_EX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that some versions of C&lt;flock&gt; cannot lock things over the
network; you would need to use the more system-specific C&lt;fcntl&gt; for
that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note también que algunas versiones de C&lt;flock&gt; no pueden bloquear cosas sobre la red; necesitará usar un C&lt;fcntl&gt; más específico del sistema para hacer esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you like you can force Perl to ignore your system's flock(2)
function, and so provide its own fcntl(2)-based emulation, by passing
the switch C&lt;-Ud_flock&gt; to the F&lt;Configure&gt; program when you configure
perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si le gusta puede forzar a Perl a ignorar la función del sistema flock(2) y proveer de su propia emulación basada en fcntl(2), pasando la opción C&lt;-Ud_flock&gt; al programa F&lt;Configure&gt; cuando configure perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a mailbox appender for BSD systems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es un agregador de correo para sistemas BSD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Fcntl ':flock'; # import LOCK_* constants</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Fcntl ':flock'; # importar constantes LOCK_*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub lock {
	flock(MBOX,LOCK_EX);
	# and, in case someone appended
	# while we were waiting...
	seek(MBOX, 0, 2);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub lock {
	flock(MBOX,LOCK_EX);
	# y, en el caso de que alguien agregase
	# mientras estábamos esperando...
	seek(MBOX, 0, 2);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub unlock {
	flock(MBOX,LOCK_UN);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub unlock {
	flock(MBOX,LOCK_UN);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(MBOX, &quot;&gt;&gt;/usr/spool/mail/$ENV{'USER'}&quot;)
	    or die &quot;Can't open mailbox: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(MBOX, &quot;&gt;&gt;/usr/spool/mail/$ENV{'USER'}&quot;)
	    or die &quot;No puedo abrir el buzón: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lock();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lock();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print MBOX $msg,&quot;\n\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print MBOX $msg,&quot;\n\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unlock();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unlock();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On systems that support a real flock(), locks are inherited across fork()
calls, whereas those that must resort to the more capricious fcntl()
function lose the locks, making it harder to write servers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En sistemas que soportan un flock() real, los bloqueos se heredan por llamadas fork(), teniendo en cuenta que se recurrirá a la caprichosa función fcntl() que pierde los bloqueos, haciendo difícil escribir servidores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;DB_File&gt; for other flock() examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;DB_File&gt; para otros ejemplos de flock().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item fork
X&lt;fork&gt; X&lt;child&gt; X&lt;parent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item fork
X&lt;fork&gt; X&lt;hijo&gt; X&lt;padre&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does a fork(2) system call to create a new process running the
same program at the same point.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hace una llamada del sistema fork(2) para crear un nuevo proceso ejecutando el mismo programa en el mismo punto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the child pid to the
parent process, C&lt;0&gt; to the child process, or C&lt;undef&gt; if the fork is
unsuccessful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el pid del hijo al proceso padre, C&lt;0&gt; al proceso hijo, o C&lt;undef&gt; si no se consiguió el fork.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File descriptors (and sometimes locks on those descriptors)
are shared, while everything else is copied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Descriptores de fichero (y algunas veces bloqueos en estos descriptores) son compartidos, mientras que todo lo demás es copiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On most systems supporting
fork(), great care has gone into making it extremely efficient (for
example, using copy-on-write technology on data pages), making it the
dominant paradigm for multitasking over the last few decades.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En la mayoría de los sistemas que soportan fork(), se ha tenido gran cuidado en hacerlo extremadamente eficiente (por ejemplo, usando la tecnología copy-on-write en páginas de datos), haciendo de él el paradigma dominante de la multitarea en las últimas décadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before forking the child process, but this may not be supported
on some platforms (see L&lt;perlport&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A partir de la versión v5.6.0, Perl intentará vaciar todos los ficheros abiertos para salida antes de crear un proceso hijo, pero esto puede no estar soportado en todas las plataformas (ver L&lt;perlport&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be safe, you may need to set
C&lt;$|&gt; ($AUTOFLUSH in English) or call the C&lt;autoflush()&gt; method of
C&lt;IO::Handle&gt; on any open handles in order to avoid duplicate output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para asegurarse, puede poner C&lt;$|&gt; ($AUTOFLUSH en English) o llamar el método C&lt;autoflush()&gt; de C&lt;IO::Handle&gt; en cualquiera de los manejadores abiertos para evitar la duplicidad de datos en la salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you C&lt;fork&gt; without ever waiting on your children, you will
accumulate zombies.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted hace un C&lt;fork&gt; sin luego esperar a sus hijos, irá acumulando zombies.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On some systems, you can avoid this by setting
C&lt;$SIG{CHLD}&gt; to C&lt;&quot;IGNORE&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas, puede evitar esto poniendo C&lt;$SIG{CHLD}&gt; a C&lt;&quot;IGNORE&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;perlipc&gt; for more examples of
forking and reaping moribund children.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;perlipc&gt; para más ejemplos de fork y borrado de hijos moribundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if your forked child inherits system file descriptors like
STDIN and STDOUT that are actually connected by a pipe or socket, even
if you exit, then the remote server (such as, say, a CGI script or a
backgrounded job launched from a remote shell) won't think you're done.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que si su hijo hereda los descriptores de archivo del sistema como STDIN y STDOUT que estén conectados a un pipe o a un socket, incluso si usted sale del programa, el servidor remoto (por ejemplo, un script CGI o un proceso lanzado en background desde un shell remoto) no se dará cuenta de que se ha ido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should reopen those to F&lt;/dev/null&gt; if it's any issue.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Deberá reabrirlos a F&lt;/dev/null&gt; si eso es un problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item format
X&lt;format&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item format
X&lt;format&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declare a picture format for use by the C&lt;write&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Declara una imagen de formato para usar con la función C&lt;write&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>format Something =
	Test: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt;
	      $str,     $%,    '$' .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>format Algo =
	Test: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt;
	      $str,     $%,    '$' .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int($num)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>int($numero)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$str = &quot;widget&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$str = &quot;widget&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$num = $cost/$quantity;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$numero = $coste/$cantidad;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$~ = 'Something';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$~ = 'Algo';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>write;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>write;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlform&gt; for many details and examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlform&gt; para más detalles y ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item formline PICTURE,LIST
X&lt;formline&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item formline CUADRO,LISTA
X&lt;formline&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an internal function used by C&lt;format&gt;s, though you may call it,
too.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta es una función interna usada por C&lt;format&gt;, aunque también puede llamarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It formats (see L&lt;perlform&gt;) a list of values according to the
contents of PICTURE, placing the output into the format output
accumulator, C&lt;$^A&gt; (or C&lt;$ACCUMULATOR&gt; in English).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Formatea (ver L&lt;perlform&gt;) una lista de valores de acuerdo a los contenidos de CUADRO, colocando la salida en el acumulador de salida de format, C&lt;$^A&gt; (o C&lt;$ACCUMULATOR&gt; en English).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eventually, when a C&lt;write&gt; is done, the contents of
C&lt;$^A&gt; are written to some filehandle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Finalmente, cuando se hace un C&lt;write&gt;, los contenidos de C&lt;$^A&gt; se escriben al manejador de fichero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could also read C&lt;$^A&gt;
and then set C&lt;$^A&gt; back to C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede también leer C&lt;$^A&gt; y volver a ponerla otra vez a C&lt;&quot;&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a format typically
does one C&lt;formline&gt; per line of form, but the C&lt;formline&gt; function itself
doesn't care how many newlines are embedded in the PICTURE.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que un formato típicamente hace un C&lt;formline&gt; por línea del formato, pero a la misma función C&lt;formline&gt; no le preocupa cuántos avances de línea están incluidos en el CUADRO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means
that the C&lt;~&gt; and C&lt;~~&gt; tokens will treat the entire PICTURE as a single line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que los tokens C&lt;~&gt; y C&lt;~~&gt; tratarán al CUADRO entero como una única línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may therefore need to use multiple formlines to implement a single
record format, just like the format compiler.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede por eso necesitar usar múltiples formline para implementar un único registro format, como lo hace el propio format.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be careful if you put double quotes around the picture, because an C&lt;@&gt;
character may be taken to mean the beginning of an array name.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado si pone dobles comillas alrededor del cuadro, porque un carácter C&lt;@&gt; puede ser tomado como el comienzo del nombre de un array.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;formline&gt; always returns true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;formline&gt; siempre devuelve verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlform&gt; for other examples.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlform&gt; para otros ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getc FILEHANDLE
X&lt;getc&gt; X&lt;getchar&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getc MANEJADOR
X&lt;getc&gt; X&lt;getchar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getc</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the next character from the input file attached to FILEHANDLE,
or the undefined value at end of file, or if there was an error (in
the latter case C&lt;$!&gt; is set).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el siguiente carácter desde el fichero de entrada asociado a MANEJADOR, o el valor indefinido en el final de fichero, o si ocurrió un error (en este último caso, se actualiza C&lt;$!&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If FILEHANDLE is omitted, reads from
STDIN.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si MANEJADOR se omite, se lee desde STDIN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not particularly efficient.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto no es particularmente eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it cannot be
used by itself to fetch single characters without waiting for the user
to hit enter.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, esto no puede ser usado para extraer caracteres sueltos sin esperar a que el usuario pulse la tecla de enter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that, try something more like:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para esto, intente algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($BSD_STYLE) {
	system &quot;stty cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($BSD_STYLE) {
	system &quot;stty cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else {
	system &quot;stty&quot;, '-icanon', 'eol', &quot;\001&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else {
	system &quot;stty&quot;, '-icanon', 'eol', &quot;\001&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$key = getc(STDIN);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$tecla = getc(STDIN);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($BSD_STYLE) {
	system &quot;stty -cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($BSD_STYLE) {
	system &quot;stty -cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else {
	system &quot;stty&quot;, 'icanon', 'eol', '^@'; # ASCII null</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else {
	system &quot;stty&quot;, 'icanon', 'eol', '^@'; # ASCII null</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Determination of whether $BSD_STYLE should be set
is left as an exercise to the reader.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La determinación de cómo poner $BSD_STYLE se deja como ejercicio al lector.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;POSIX::getattr&gt; function can do this more portably on
systems purporting POSIX compliance.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función C&lt;POSIX::getattr&gt; puede hacer esto de forma más portable en sistemas compatibles con POSIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the C&lt;Term::ReadKey&gt;
module from your nearest CPAN site; details on CPAN can be found on
L&lt;perlmodlib/CPAN&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también el módulo C&lt;Term::ReadKey&gt; en su sitio CPAN más cercano; detalles sobre CPAN se pueden encontrar en L&lt;perlmodlib/CPAN&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getlogin
X&lt;getlogin&gt; X&lt;login&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getlogin
X&lt;getlogin&gt; X&lt;login&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implements the C library function of the same name, which on most
systems returns the current login from F&lt;/etc/utmp&gt;, if any.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Implementa la función de la librería C del mismo nombre, que en la mayoría de los sistemas devuelve el login actual desde F&lt;/etc/utmp&gt;, si existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If null,
use C&lt;getpwuid&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si nulo, use C&lt;getpwuid&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$login = getlogin || getpwuid($&lt;) || &quot;Kilroy&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$login = getlogin || getpwuid($&lt;) || &quot;Kilroy&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not consider C&lt;getlogin&gt; for authentication: it is not as
secure as C&lt;getpwuid&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No considere usar C&lt;getlogin&gt; para autenticación: no es tan seguro como C&lt;getpwuid&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpeername SOCKET
X&lt;getpeername&gt; X&lt;peer&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getpeername SOCKET
X&lt;getpeername&gt; X&lt;peer&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the packed sockaddr address of other end of the SOCKET connection.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la dirección sockect empaquetada del otro final de la conexión SOCKET.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Socket;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Socket;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$hersockaddr    = getpeername(SOCK);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$sudireccion          = getpeername(SOCK);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($port, $iaddr) = sockaddr_in($hersockaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($puerto, $direccion) = sockaddr_in($sudireccion);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$herhostname    = gethostbyaddr($iaddr, AF_INET);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$suhost               = gethostbyaddr($direccion, AF_INET);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$herstraddr     = inet_ntoa($iaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$sunombre             = inet_ntoa($direccion);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpgrp PID
X&lt;getpgrp&gt; X&lt;group&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getpgrp PID
X&lt;getpgrp&gt; X&lt;group&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current process group for the specified PID.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el actual grupo del proceso especificado por el PID.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use
a PID of C&lt;0&gt; to get the current process group for the
current process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use un PID de C&lt;0&gt; para obtener el grupo del proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Will raise an exception if used on a machine that
doesn't implement getpgrp(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elevará una excepción si se usa en una máquina que no implemente getpgrp(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If PID is omitted, returns process
group of current process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si PID se omite, devuelve el grupo del proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the POSIX version of C&lt;getpgrp&gt;
does not accept a PID argument, so only C&lt;PID==0&gt; is truly portable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que la versión POSIX de C&lt;getpgrp&gt; no acepta un argumento PID, por lo que sólo C&lt;PID==0&gt; es verdaderamente portable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getppid
X&lt;getppid&gt; X&lt;parent&gt; X&lt;pid&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getppid
X&lt;getppid&gt; X&lt;padre&gt; X&lt;pid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the process id of the parent process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el identificador de proceso del proceso padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note for Linux users: on Linux, the C functions C&lt;getpid()&gt; and
C&lt;getppid()&gt; return different values from different threads.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nota para usuarios Linux: en Linux, las funciones C C&lt;getpid()&gt; y C&lt;getppid()&gt; devuelven valores diferentes para hilos (threads) diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to
be portable, this behavior is not reflected by the perl-level function
C&lt;getppid()&gt;, that returns a consistent value across threads.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ser portable, este comportamiento no está reflejado en la función  C&lt;getppid()&gt;, que devuelve un valor consistente en todos los hilos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want
to call the underlying C&lt;getppid()&gt;, you may use the CPAN module
C&lt;Linux::Pid&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere llamar a la subyacente C&lt;getppid()&gt;, puede usar el módulo de CPAN C&lt;Linux::Pid&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpriority WHICH,WHO
X&lt;getpriority&gt; X&lt;priority&gt; X&lt;nice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getpriority QUÉ,QUIEN
X&lt;getpriority&gt; X&lt;prioridad&gt; X&lt;nice&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current priority for a process, a process group, or a user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la prioridad actual de un proceso, un grupo de procesos o un usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See L&lt;getpriority(2)&gt;.)  Will raise a fatal exception if used on a
machine that doesn't implement getpriority(2).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Ver L&lt;getpriority(2)&gt;). Elevará una excepción fatal si se usa en una máquina que no implemente getpriority(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwnam NAME
X&lt;getpwnam&gt; X&lt;getgrnam&gt; X&lt;gethostbyname&gt; X&lt;getnetbyname&gt; X&lt;getprotobyname&gt;
X&lt;getpwuid&gt; X&lt;getgrgid&gt; X&lt;getservbyname&gt; X&lt;gethostbyaddr&gt; X&lt;getnetbyaddr&gt;
X&lt;getprotobynumber&gt; X&lt;getservbyport&gt; X&lt;getpwent&gt; X&lt;getgrent&gt; X&lt;gethostent&gt;
X&lt;getnetent&gt; X&lt;getprotoent&gt; X&lt;getservent&gt; X&lt;setpwent&gt; X&lt;setgrent&gt; X&lt;sethostent&gt;
X&lt;setnetent&gt; X&lt;setprotoent&gt; X&lt;setservent&gt; X&lt;endpwent&gt; X&lt;endgrent&gt; X&lt;endhostent&gt;
X&lt;endnetent&gt; X&lt;endprotoent&gt; X&lt;endservent&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getpwnam NOMBRE
X&lt;getpwnam&gt; X&lt;getgrnam&gt; X&lt;gethostbyname&gt; X&lt;getnetbyname&gt; X&lt;getprotobyname&gt;
X&lt;getpwuid&gt; X&lt;getgrgid&gt; X&lt;getservbyname&gt; X&lt;gethostbyaddr&gt; X&lt;getnetbyaddr&gt;
X&lt;getprotobynumber&gt; X&lt;getservbyport&gt; X&lt;getpwent&gt; X&lt;getgrent&gt; X&lt;gethostent&gt;
X&lt;getnetent&gt; X&lt;getprotoent&gt; X&lt;getservent&gt; X&lt;setpwent&gt; X&lt;setgrent&gt; X&lt;sethostent&gt;
X&lt;setnetent&gt; X&lt;setprotoent&gt; X&lt;setservent&gt; X&lt;endpwent&gt; X&lt;endgrent&gt; X&lt;endhostent&gt;
X&lt;endnetent&gt; X&lt;endprotoent&gt; X&lt;endservent&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getgrnam NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getgrnam NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gethostbyname NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gethostbyname NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getnetbyname NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getnetbyname NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getprotobyname NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getprotobyname NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwuid UID</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getpwuid UID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getgrgid GID</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getgrgid GID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getservbyname NAME,PROTO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getservbyname NOMBRE,PROTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gethostbyaddr ADDR,ADDRTYPE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gethostbyaddr DIRECCIÓN,TIPODIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getnetbyaddr ADDR,ADDRTYPE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getnetbyaddr DIRECCIÓN,TIPODIR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getprotobynumber NUMBER</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getprotobynumber NÚMERO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getservbyport PORT,PROTO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getservbyport PUERTO,PROTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getpwent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getpwent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getgrent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getgrent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gethostent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gethostent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getnetent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getnetent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getprotoent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getprotoent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getservent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getservent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setpwent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setpwent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setgrent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setgrent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item sethostent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item sethostent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setnetent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setnetent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setprotoent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setprotoent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item setservent STAYOPEN</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item setservent SIGUEABIERTO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endpwent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endpwent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endgrent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endgrent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endhostent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endhostent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endnetent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endnetent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endprotoent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endprotoent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item endservent</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item endservent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These routines perform the same functions as their counterparts in the
system library.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas rutinas realizan las mismas funciones que sus homólogas en la biblioteca del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, the return values from the
various get routines are as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto lista, los valores devueltos por varias de ellas son como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$passwd,$uid,$gid,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($nombre,$contrasena,$uid,$gid,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$quota,$comment,$gcos,$dir,$shell,$expire) = getpw*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cuota,$comentario,$gcos,$dir,$shell,$expira) = getpw*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$passwd,$gid,$members) = getgr*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($nombre,$contrasena,$gid,$miembros) = getgr*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$addrtype,$length,@addrs) = gethost*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($nombre,$alias,$tipodir,$longitud,@direcciones) = gethost*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$addrtype,$net) = getnet*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($nombre,$alias,$tipodir,$red) = getnet*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$proto) = getproto*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($nombre,$alias,$proto) = getproto*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($name,$aliases,$port,$proto) = getserv*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($nombre,$alias,$puerto,$proto) = getserv*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the entry doesn't exist you get a null list.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si la entrada no existe, obtendrá una lista nula).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact meaning of the $gcos field varies but it usually contains
the real name of the user (as opposed to the login name) and other
information pertaining to the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El significado exacto del campo $gcos varía pero usualmente contiene el nombre real del usuario (como opuesto al nombre de login) y otra información perteneciente al usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware, however, that in many
system users are able to change this information and therefore it
cannot be trusted and therefore the $gcos is tainted (see
L&lt;perlsec&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tenga cuidado, sin embargo, que en muchos sistemas los usuarios son capaces de cambiar esta información y por eso no puede confiarse y por eso el $gcos es considerado contaminado (ver L&lt;perlsec&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $passwd and $shell, user's encrypted password and
login shell, are also tainted, because of the same reason.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La $contrasena y el $shell, la contraseña encriptada del usuario y el shell del login, están también contaminados, por la misma razón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, you get the name, unless the function was a
lookup by name, in which case you get the other thing, whatever it is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, obtiene el nombre, a menos que la función fuera localizar por nombre, en cuyo caso obtendrá la otra cosa, cualquiera que sea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the entry doesn't exist you get the undefined value.)  For example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si la entrada no existe obtendrá el valor indefinido). Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$uid   = getpwnam($name);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$uid     = getpwnam($nombre);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getpwuid($num);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$nombre  = getpwuid($numero);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getpwent();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$nombre  = getpwent();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$gid   = getgrnam($name);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$gid     = getgrnam($nombre);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getgrgid($num);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$nombre  = getgrgid($numero);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = getgrent();</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$nombre  = getgrent();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#etc.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In I&lt;getpw*()&gt; the fields $quota, $comment, and $expire are special
cases in the sense that in many systems they are unsupported.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En I&lt;getpw*()&gt; los campos  $cuota, $comentario y $expira son casos especiales en el sentido que en muchos sistemas no están soportados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
$quota is unsupported, it is an empty scalar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la $cuota no está soportada, es un escalar vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is supported, it
usually encodes the disk quota.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está soportada, usualmente codifica la cuota de disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the $comment field is unsupported,
it is an empty scalar.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el campo $comentario no está soportado, es un escalar vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is supported it usually encodes some
administrative comment about the user.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está soportado usualmente codifica algún comentario administrativo sobre el usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some systems the $quota
field may be $change or $age, fields that have to do with password
aging.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas el campo $cuota puede ser $cambio o $edad, campos que tienen que ver con la caducidad de la contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some systems the $comment field may be $class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En algunos sistemas el campo $comentario puede ser $clase.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $expire
field, if present, encodes the expiration period of the account or the
password.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El campo $expira, si está presente, codifica el periodo de expiración de la cuenta o de la contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the availability and the exact meaning of these fields
in your system, please consult your getpwnam(3) documentation and your
F&lt;pwd.h&gt; file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la disponibilidad y el significado exacto de estos campos en su sistema, por favor consulte la documentación de su getpwnam(3) y su fichero F&lt;pwd.h&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also find out from within Perl what your
$quota and $comment fields mean and whether you have the $expire field
by using the C&lt;Config&gt; module and the values C&lt;d_pwquota&gt;, C&lt;d_pwage&gt;,
C&lt;d_pwchange&gt;, C&lt;d_pwcomment&gt;, and C&lt;d_pwexpire&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede también encontrar dentro de Perl que es lo que significan sus campos $cuota, $comentario y $expira usando el módulo C&lt;Config&gt; y los valores C&lt;d_pwquota&gt;, C&lt;d_pwage&gt;, C&lt;d_pwchange&gt;, C&lt;d_pwcomment&gt; y C&lt;d_pwexpire&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shadow password
files are only supported if your vendor has implemented them in the
intuitive fashion that calling the regular C library routines gets the
shadow versions if you're running under privilege or if there exists
the shadow(3) functions as found in System V (this includes Solaris
and Linux.)  Those systems that implement a proprietary shadow password
facility are unlikely to be supported.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ficheros de contraseñas Shadow sólo están soportados si el proveedor los ha implementado con la intuitiva moda de que llamando a las rutinas regulares de la biblioteca C se obtiene las versiones shadow si está corriendo con bajos privilegios o si existe la función shadow(3) tal como se encuentra en System V (esto incluye Solaris y Linux). Los sistemas que implementen un sistema de contraseñas shadow propietario es impropable que sean soportados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $members value returned by I&lt;getgr*()&gt; is a space separated list of
the login names of the members of the group.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de $miembros  devuelto por I&lt;getgr*()&gt; es una lista separada por espacios de los nombres de login de los miembros del grupo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the I&lt;gethost*()&gt; functions, if the C&lt;h_errno&gt; variable is supported in
C, it will be returned to you via C&lt;$?&gt; if the function call fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para las funciones I&lt;gethost*()&gt;, si la variable C&lt;h_errno&gt; está soportada en C, será devuelta vía C&lt;$?&gt; si la llamada a la función falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
C&lt;@addrs&gt; value returned by a successful call is a list of the raw
addresses returned by the corresponding system library call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto C&lt;@direcciones&gt; por una exitosa llamada es una lista de las direcciones en crudo devueltas por la correspondiente llamada a la biblioteca del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the
Internet domain, each address is four bytes long and you can unpack it
by saying something like:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En el dominio de Internet, cada dirección son cuatro bytes de longitud y puede empaquetarlos diciendo algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($a,$b,$c,$d) = unpack('C4',$addr[0]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($a,$b,$c,$d) = unpack('C4',$direccion[0]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Socket library makes this slightly easier:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La biblioteca Socket hace esto ligeramente más fácilmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$iaddr = inet_aton(&quot;127.1&quot;); # or whatever address</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$idireccion = inet_aton(&quot;127.1&quot;); # o la dirección que sea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$name  = gethostbyaddr($iaddr, AF_INET);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$nombre     = gethostbyaddr($idireccion, AF_INET);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># or going the other way</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># o de otra manera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$straddr = inet_ntoa($iaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$direccion = inet_ntoa($idireccion);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you get tired of remembering which element of the return list
contains which return value, by-name interfaces are provided
in standard modules: C&lt;File::stat&gt;, C&lt;Net::hostent&gt;, C&lt;Net::netent&gt;,
C&lt;Net::protoent&gt;, C&lt;Net::servent&gt;, C&lt;Time::gmtime&gt;, C&lt;Time::localtime&gt;,
and C&lt;User::grent&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está cansado de recordar qué elemento de la lista devuelta contiene qué valor, existen interfaces por nombre, en módulos estándar: C&lt;File::stat&gt;, C&lt;Net::hostent&gt;, C&lt;Net::netent&gt;, C&lt;Net::protoent&gt;, C&lt;Net::servent&gt;, C&lt;Time::gmtime&gt;, C&lt;Time::localtime&gt; y C&lt;User::grent&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These override the normal built-ins, supplying
versions that return objects with the appropriate names
for each field.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estas sobreescriben a las integradas, con versiones que devuelven objetos con los nombres apropiados para cada campo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use File::stat;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use File::stat;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use User::pwent;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use User::pwent;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$is_his = (stat($filename)-&gt;uid == pwent($whoever)-&gt;uid);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$es_suyo = (stat($fichero)-&gt;uid == pwent($alguien)-&gt;uid);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though it looks like they're the same method calls (uid),
they aren't, because a C&lt;File::stat&gt; object is different from
a C&lt;User::pwent&gt; object.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso aunque parezcan los mismos métodos (uid), no lo son, porque un objeto C&lt;File::stat&gt; es diferente de un objeto C&lt;User::pwent&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getsockname SOCKET
X&lt;getsockname&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getsockname SOCKET
X&lt;getsockname&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the packed sockaddr address of this end of the SOCKET connection,
in case you don't know the address because you have several different
IPs that the connection might have come in on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la dirección de socket empaquetada de este final de la conexión SOCKET, en el caso de que no conozca la dirección porque tenga diferentes IP por las que la conexión se pudo haber realizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mysockaddr = getsockname(SOCK);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$midirsocket = getsockname(SOCK);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($port, $myaddr) = sockaddr_in($mysockaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($puerto, $midir) = sockaddr_in($midirsocket);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;Connect to %s [%s]\n&quot;,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Conectado a %s [%s]\n&quot;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar gethostbyaddr($myaddr, AF_INET),</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>scalar gethostbyaddr($midir, AF_INET),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>inet_ntoa($myaddr);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>inet_ntoa($midir);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item getsockopt SOCKET,LEVEL,OPTNAME
X&lt;getsockopt&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item getsockopt SOCKET,NIVEL,OPCIÓN
X&lt;getsockopt&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queries the option named OPTNAME associated with SOCKET at a given LEVEL.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Consulta la opción con nombre OPCIÓN asociada con el SOCKET en un determinado NIVEL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options may exist at multiple protocol levels depending on the socket
type, but at least the uppermost socket level SOL_SOCKET (defined in the
C&lt;Socket&gt; module) will exist.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Opciones pueden existir en múltiples niveles de protocolo dependiendo del tipo de socket, pero al menos existirá el más alto nivel de socket SOL_SOCKET (definido en el módulo C&lt;Socket&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To query options at another level the
protocol number of the appropriate protocol controlling the option
should be supplied.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para consultar opciones en otro nivel se debe indicar el apropiado número de protocolo que controle a esa opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to indicate that an option is to be
interpreted by the TCP protocol, LEVEL should be set to the protocol
number of TCP, which you can get using getprotobyname.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, para indicar que una opción a de ser interpretada por el protocolo TCP, NIVEL debe ser puesto al número de protocolo del TCP, que puede obtener usando getprotobyname.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The call returns a packed string representing the requested socket option,
or C&lt;undef&gt; if there is an error (the error reason will be in $!).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La llamada devuelve un string empaquetado representando la opción socket solicitada, o C&lt;undef&gt; si hay un error (la razón del error estará en $!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What
exactly is in the packed string depends in the LEVEL and OPTNAME, consult
your system documentation for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo que exactamente esté en el string empaquetado depende de NIVEL y OPCIÓN, consulte la documentación de su sistema para los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A very common case however is that
the option is an integer, in which case the result will be a packed
integer which you can decode using unpack with the C&lt;i&gt; (or C&lt;I&gt;) format.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un caso muy común es que la opción sea un entero, en cuyo caso el resultado será un entero empaquetado que podrá decodificar usando unpack con el formato C&lt;i&gt; (o C&lt;I&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example testing if Nagle's algorithm is turned on on a socket:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un ejemplo para comprobar su el algoritmo de Nagle está activado en el socket:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Socket qw(:all);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Socket qw(:all);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defined(my $tcp = getprotobyname(&quot;tcp&quot;))
	or die &quot;Could not determine the protocol number for tcp&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>defined(my $tcp = getprotobyname(&quot;tcp&quot;))
	or die &quot;No puedo determinar el número del protocolo tcp&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># my $tcp = IPPROTO_TCP; # Alternative</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># my $tcp = IPPROTO_TCP; # Alternativo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $packed = getsockopt($socket, $tcp, TCP_NODELAY)
	or die &quot;Could not query TCP_NODELAY socket option: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $empaquetado = getsockopt($socket, $tcp, TCP_NODELAY)
	or die &quot;No puedo consultar la opción socket TCP_NODELAY: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $nodelay = unpack(&quot;I&quot;, $packed);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $nodelay = unpack(&quot;I&quot;, $empaquetado);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Nagle's algorithm is turned &quot;, $nodelay ?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El algoritmo de Nagle está activado: &quot;, $nodelay ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;off\n&quot; : &quot;on\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;off\n&quot; : &quot;on\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item glob EXPR
X&lt;glob&gt; X&lt;wildcard&gt; X&lt;filename, expansion&gt; X&lt;expand&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item glob EXPR
X&lt;glob&gt; X&lt;metacaracter&gt; X&lt;fichero, expansión&gt; X&lt;expandir&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item glob</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item glob</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In list context, returns a (possibly empty) list of filename expansions on
the value of EXPR such as the standard Unix shell F&lt;/bin/csh&gt; would do.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contecto lista, devuelve una (posiblemente vacía) lista de la expansión de nombres de fichero del valor de EXPR como si el shell estandar Unix F&lt;/bin/csh&gt; lo hiciera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
scalar context, glob iterates through such filename expansions, returning
undef when the list is exhausted.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, glob itera a través de la expansión de nombres de fichero, devolviendo undef cuando se agote la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the internal function
implementing the C&lt;&lt; &lt;*.c&gt; &gt;&gt; operator, but you can use it directly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es la función interna que implementa el operador C&lt;&lt; &lt;*.c&gt; &gt;&gt;, pero puede usarla directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
EXPR is omitted, C&lt;$_&gt; is used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la EXPR se omite, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;&lt; &lt;*.c&gt; &gt;&gt; operator is discussed in
more detail in L&lt;perlop/&quot;I/O Operators&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El operador C&lt;&lt; &lt;*.c&gt; &gt;&gt; se discute con más detalle en L&lt;perlop/&quot;Operadores I/O&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beginning with v5.6.0, this operator is implemented using the standard
C&lt;File::Glob&gt; extension.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Comenzando con v5.6.0, este operador está implementado usando la extensión estándar C&lt;File::Glob&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;File::Glob&gt; for details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;File::Glob&gt; para detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gmtime EXPR
X&lt;gmtime&gt; X&lt;UTC&gt; X&lt;Greenwich&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gmtime EXPR
X&lt;gmtime&gt; X&lt;UTC&gt; X&lt;Greenwich&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item gmtime</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item gmtime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converts a time as returned by the time function to an 9-element list
with the time localized for the standard Greenwich time zone.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Convierte un tiempo devuelto por la función time en una lista de 9 elementos según la región de la zona horaria estándar Greenwich.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically used as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Típicamente se usa como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#  0    1    2     3     4    5     6     7     8</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#  0    1    2     3     4    5     6     7     8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
					    gmtime(time);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($seg,$min,$hora,$mdia,$mes,$anno,$sdia,$ydia,$esdst) =
					    gmtime(time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All list elements are numeric, and come straight out of the C `struct
tm'.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todos los elementos de la lista son numéricos y derivan de la 'struct tm' del C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$sec, $min, and $hour are the seconds, minutes, and hours of the
specified time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$seg, $min y $hora son los segundos, minutos y horas del tiempo especificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$mday is the day of the month, and $mon is the month
itself, in the range C&lt;0..11&gt; with 0 indicating January and 11
indicating December.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$mdia es el día del mes, y $mes es el propio mes, en el rango C&lt;0..11&gt; con 0 indicando enero y 11 diciembre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$year is the number of years since 1900.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$anno es el número de años desde 1900.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That
is, $year is C&lt;123&gt; in year 2023.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, $anno es C&lt;123&gt; en el año 2023.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$wday is the day of the week, with
0 indicating Sunday and 3 indicating Wednesday.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$sdia es el día de la semaan, con 0 indicando domingo y 3 indicando miércoles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$yday is the day of
the year, in the range C&lt;0..364&gt; (or C&lt;0..365&gt; in leap years).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ydia es el día del año, en el rango C&lt;0..364&gt; (o C&lt;0..365&gt; en años bisiestos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$isdst
is always C&lt;0&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$esdst siempre es C&lt;0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the $year element is I&lt;not&gt; simply the last two digits of
the year.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que el elemento $anno I&lt;no&gt; es simplemente los dos últimos dígitos del año.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assume it is then you create non-Y2K-compliant
programs--and you wouldn't want to do that, would you?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si asume eso entonces estará creado programas no compatibles con el año 2000, y eso no es lo que quiere hacer, ¿verdad?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proper way to get a complete 4-digit year is simply:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma apropiada para obtener un año con los 4 dígitos es simplemente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$year += 1900;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$anno += 1900;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And to get the last two digits of the year (e.g., '01' in 2001) do:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y para obtener los dos últimos dígitos del año (ej., '01' en 2001) hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$year = sprintf(&quot;%02d&quot;, $year % 100);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$anno = sprintf(&quot;%02d&quot;, $anno % 100);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, C&lt;gmtime()&gt; uses the current time (C&lt;gmtime(time)&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, C&lt;gmtime()&gt; usa el tiempo actual (C&lt;gmtime(time)&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar context, C&lt;gmtime()&gt; returns the ctime(3) value:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, C&lt;gmtime()&gt; devuelve el valor de ctime(3):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$now_string = gmtime;  # e.g., &quot;Thu Oct 13 04:54:34 1994&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$ahora_string = gmtime;  # ej., &quot;Thu Oct 13 04:54:34 1994&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need local time instead of GMT use the L&lt;/localtime&gt; builtin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si necesita el tiempo local en lugar del GMT, use L&lt;/localtime&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the C&lt;timegm&gt; function provided by the C&lt;Time::Local&gt; module,
and the strftime(3) and mktime(3) functions available via the L&lt;POSIX&gt; module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también la función C&lt;timegm&gt; proporcionado por el módulo C&lt;Time::Local&gt;, y las funciones strftime(3) y mktime(3) disponibles con el módulo L&lt;POSIX&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scalar value is B&lt;not&gt; locale dependent (see L&lt;perllocale&gt;), but is
instead a Perl builtin.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este valor escalar B&lt;no&gt; es localmente dependiente (ver L&lt;perllocale&gt;), sino que es una función integrada de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get somewhat similar but locale dependent date
strings, see the example in L&lt;/localtime&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para obtener algo similar pero con fechas localmente dependientes, ver el ejemplo en L&lt;/localtime&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport/gmtime&gt; for portability concerns.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport/gmtime&gt; para problemas sobre portabilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item goto LABEL
X&lt;goto&gt; X&lt;jump&gt; X&lt;jmp&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item goto ETIQUETA
X&lt;goto&gt; X&lt;salto&gt; X&lt;jmp&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item goto EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item goto EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item goto &amp;NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item goto &amp;NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto-LABEL&gt; form finds the statement labeled with LABEL and resumes
execution there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-ETIQUETA busca la sentencia etiquetada con ETIQUETA y continua la ejecución desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may not be used to go into any construct that
requires initialization, such as a subroutine or a C&lt;foreach&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede ser usado en ninguna construcción que requiera inicialización, como una subrutina o un bucle C&lt;foreach&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
also can't be used to go into a construct that is optimized away,
or to get out of a block or subroutine given to C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco puede ser usada en una construcción que pueda ser optimizada, o ir fuera de un bloque o subrutina dada a C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used to go almost anywhere else within the dynamic scope,
including out of subroutines, but it's usually better to use some other
construct such as C&lt;last&gt; or C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser utilizada para ir a casi cualquier sitio que esté dentro del ámbito dinámico, incluyendo fuera de las subrutinas, pero es usualmente mucho mejor usar otras construcciones como C&lt;last&gt; o C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The author of Perl has never felt the
need to use this form of C&lt;goto&gt; (in Perl, that is--C is another matter).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El autor de Perl nunca ha sentido la necesidad de usar esta forma de C&lt;goto&gt; (en Perl, desde luego. C es otra historia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The difference being that C does not offer named loops combined with
loop control.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(La diferencia con C es que no ofrece bucles con nombre combinados con control de bucles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl does, and this replaces most structured uses of C&lt;goto&gt;
in other languages.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl sí, y esto reemplaza a la mayor parte de los usos estructurados de C&lt;goto&gt; en otros lenguajes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto-EXPR&gt; form expects a label name, whose scope will be resolved
dynamically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-EXPR espera un nombre de etiqueta, cuyo ámbito será resuelto dinámicamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows for computed C&lt;goto&gt;s per FORTRAN, but isn't
necessarily recommended if you're optimizing for maintainability:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto permite crear C&lt;goto&gt; calculados como en FORTRAN, pero no está necesariamente recomendado si usted está optimizando durante el mantenimiento:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>goto (&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>goto (&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto-&amp;NAME&gt; form is quite different from the other forms of
C&lt;goto&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto-&amp;NOMBRE&gt; es muy diferente de las otras formas de C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it isn't a goto in the normal sense at all, and
doesn't have the stigma associated with other gotos.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De hecho, no es un goto en el sentido normal y no tiene el estigma asociado con los otros gotos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it
exits the current subroutine (losing any changes set by local()) and
immediately calls in its place the named subroutine using the current
value of @_.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En cambio, sale de la subrutina actual (perdiendo cualquier cambio hecho por local()) e inmediatamente llama a la subrutina indicada pasandole el valor actual de @_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is used by C&lt;AUTOLOAD&gt; subroutines that wish to
load another subroutine and then pretend that the other subroutine had
been called in the first place (except that any modifications to C&lt;@_&gt;
in the current subroutine are propagated to the other subroutine.)
After the C&lt;goto&gt;, not even C&lt;caller&gt; will be able to tell that this
routine was called first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se usa por subrutinas C&lt;AUTOLOAD()&gt; que desean cargar otra subrutina y fingen que ésta otra subrutina ha sido llamada en primer lugar (excepto que cualquier modificación a C&lt;@_&gt; en la subrutina actual se propaga a la otra). Después del C&lt;goto&gt;, ni siquiera C&lt;caller()&gt; será capaz de decir qué rutina fue llamada en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NAME needn't be the name of a subroutine; it can be a scalar variable
containing a code reference, or a block that evaluates to a code
reference.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NOMBRE no necesita ser el nombre de la subrutina; puede ser una variable escalar conteniendo una referencia a un código, o un bloque que evalúa a una referencia de código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item grep BLOCK LIST
X&lt;grep&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item grep BLOQUE LISTA
X&lt;grep&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item grep EXPR,LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item grep EXPR,LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar in spirit to, but not the same as, grep(1) and its
relatives.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es similar en espíritu, pero no lo mismo, que con grep(1) y sus hermanos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, it is not limited to using regular expressions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En particular, no está limitado a usar expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluates the BLOCK or EXPR for each element of LIST (locally setting
C&lt;$_&gt; to each element) and returns the list value consisting of those
elements for which the expression evaluated to true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evalúa el BLOQUE o EXPRE para cada elemento de LISTA (poniendo localmente C&lt;$_&gt; a cada elemento) y devuelve un valor de lista consistente en los elementos por los que la expresión evaluada es verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In scalar
context, returns the number of times the expression was true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contexto escalar, devuelve el número de veces que la expresión fue verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = grep(!/^#/, @bar);    # weed out comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = grep(!/^#/, @bar);    # quitar los comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o equivalentemente,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@foo = grep {!/^#/} @bar;    # weed out comments</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@foo = grep {!/^#/} @bar;    # quitar los comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that C&lt;$_&gt; is an alias to the list value, so it can be used to
modify the elements of the LIST.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que C&lt;$_&gt; es un alias al valor de la lista, por lo que puede ser usado para modificar los elementos de la LISTA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this is useful and supported,
it can cause bizarre results if the elements of LIST are not variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras que esto suele ser útil, puede causar resultados extraños si los elementos de la LISTA no son variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, grep returns aliases into the original list, much as a for
loop's index variable aliases the list elements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Semejantemente, grep devuelve alias de la lista original, como los alias de los elementos de la lista de las variables de los bucles for.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, modifying an
element of a list returned by grep (for example, in a C&lt;foreach&gt;, C&lt;map&gt;
or another C&lt;grep&gt;) actually modifies the element in the original list.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es decir, modificar un elemento de la lista devuelto por grep (por ejemplo, en un C&lt;foreach&gt;, C&lt;map&gt; u otro C&lt;grep&gt;) modifica el elemento en la lista original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is usually something to be avoided when writing clear code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es algo usualmente a ser evitado cuando se está escribiendo código claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/map&gt; for a list composed of the results of the BLOCK or EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/map&gt; para una lista compuesta de los resultados del BLOQUE o EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item hex EXPR
X&lt;hex&gt; X&lt;hexadecimal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item hex EXPR
X&lt;hex&gt; X&lt;hexadecimal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item hex</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item hex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interprets EXPR as a hex string and returns the corresponding value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Interpreta EXPR como una cadena en hexadecimal y devuelve el valor correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(To convert strings that might start with either C&lt;0&gt;, C&lt;0x&gt;, or C&lt;0b&gt;, see
L&lt;/oct&gt;.)  If EXPR is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Para convertir strings que pueden comenzar con C&lt;0&gt;, C&lt;0x&gt; o C&lt;0b&gt;, ver L&lt;/oct&gt;.)  Si se omite EXPR, usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print hex '0xAf'; # prints '175'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print hex '0xAf'; # imprime '175'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print hex 'aF';   # same</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print hex 'aF';   # lo mismo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hex strings may only represent integers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Strings hexadecimales sólo pueden representar enteros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings that would cause
integer overflow trigger a warning.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Strings que podrían causar desbordamiento de enteros lanzará un aviso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Leading whitespace is not stripped,
unlike oct().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacios en blanco aledaños, no son eliminados, a diferencia de oct().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To present something as hex, look into L&lt;/printf&gt;,
L&lt;/sprintf&gt;, or L&lt;/unpack&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para presentar algo como hex, mire en L&lt;/printf&gt;, L&lt;/sprintf&gt; o L&lt;/unpack&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item import LIST
X&lt;import&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item import LISTA
X&lt;import&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no builtin C&lt;import&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe la función C&lt;import&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is just an ordinary
method (subroutine) defined (or inherited) by modules that wish to export
names to another module.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es sólo un método (subrutina) ordinario definido (o heredado) por módulos que desean exportar nombres a otro módulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use&gt; function calls the C&lt;import&gt; method
for the package used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función C&lt;use&gt; llama al método C&lt;import&gt; del paquete a usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/use&gt;, L&lt;perlmod&gt;, and L&lt;Exporter&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/use&gt;, L&lt;perlmod&gt; y L&lt;Exporter&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item index STR,SUBSTR,POSITION
X&lt;index&gt; X&lt;indexOf&gt; X&lt;InStr&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item index STRING,SUBSTR,POSICIÓN
X&lt;index&gt; X&lt;índice&gt; X&lt;InStr&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item index STR,SUBSTR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item index STRING,SUBSTR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The index function searches for one string within another, but without
the wildcard-like behavior of a full regular-expression pattern match.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función index busca por un string dentro de otro, pero sin tener el comportamiento de un sistema de coincidencias basado en expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the position of the first occurrence of SUBSTR in STR at
or after POSITION.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la posición de la primera ocurrencia de SUBSTR en STRING en o después de POSICIÓN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If POSITION is omitted, starts searching from the
beginning of the string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite POSICIÓN, comienza a buscar desde el comienzo del string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POSITION before the beginning of the string
or after its end is treated as if it were the beginning or the end,
respectively.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>POSICIÓN antes del comienzo del string o después de su final es tratado como si estuviera al principio o al final, respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POSITION and the return value are based at C&lt;0&gt; (or whatever
you've set the C&lt;$[&gt; variable to--but don't do that).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>POSICIÓN y el valor devuelto están basados en C&lt;0&gt; (o al valor indicado por la variable C&lt;$[&gt;, pero no lo haga, por favor).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the substring
is not found, C&lt;index&gt; returns one less than the base, ordinarily C&lt;-1&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si el substring no se encuentra, C&lt;index&gt; devuelve uno menos que la base, normalmente C&lt;-1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item int EXPR
X&lt;int&gt; X&lt;integer&gt; X&lt;truncate&gt; X&lt;trunc&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item int EXPR
X&lt;int&gt; X&lt;entero&gt; X&lt;truncado&gt; X&lt;truncar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item int</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item int</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the integer portion of EXPR.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve la parte entera de EXPR.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If EXPR is omitted, uses C&lt;$_&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si se omite EXPR, se usa C&lt;$_&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not use this function for rounding: one because it truncates
towards C&lt;0&gt;, and two because machine representations of floating point
numbers can sometimes produce counterintuitive results.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No debe usar esta función para redondear: primero, porque trunca hacia C&lt;0&gt; y segundo, porque las representaciones máquina de números en punto flotante puede producir, algunas veces, resultados dispares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
C&lt;int(-6.725/0.025)&gt; produces -268 rather than the correct -269; that's
because it's really more like -268.99999999999994315658 instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, C&lt;int(-6.725/0.025)&gt; produce -268 en vez del valor correcto -269; esto es porque el valor realmente es -268.99999999999994315658.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually,
the C&lt;sprintf&gt;, C&lt;printf&gt;, or the C&lt;POSIX::floor&gt; and C&lt;POSIX::ceil&gt;
functions will serve you better than will int().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usualmente, las funciones C&lt;sprintf&gt;, C&lt;printf&gt;, o C&lt;POSIX::floor&gt; y C&lt;POSIX::ceil&gt; le servirán mejor que int().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item ioctl FILEHANDLE,FUNCTION,SCALAR
X&lt;ioctl&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item ioctl MANEJADOR,FUNCIÓN,ESCALAR
X&lt;ioctl&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implements the ioctl(2) function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Implementa la función ioctl(2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll probably first have to say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Probablemente primero querrá escribir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>require &quot;sys/ioctl.ph&quot;;	# probably in $Config{archlib}/sys/ioctl.ph</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>require &quot;sys/ioctl.ph&quot;;	# probablemente en $Config{archlib}/sys/ioctl.ph</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get the correct function definitions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>para obtener las correctas definiciones de la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If F&lt;sys/ioctl.ph&gt; doesn't
exist or doesn't have the correct definitions you'll have to roll your
own, based on your C header files such as F&lt;&lt; &lt;sys/ioctl.h&gt; &gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si F&lt;sys/ioctl.ph&gt; no existe o no tiene las definiciones correctas, tendrá que incorporar las suyas propias, basadas en sus ficheros de cabecera C como las de F&lt;&lt; &lt;sys/ioctl.h&gt; &gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(There is a Perl script called B&lt;h2ph&gt; that comes with the Perl kit that
may help you in this, but it's nontrivial.)  SCALAR will be read and/or
written depending on the FUNCTION--a pointer to the string value of SCALAR
will be passed as the third argument of the actual C&lt;ioctl&gt; call.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Existe un script Perl llamado B&lt;h2ph&gt; que viene con el kit Perl que puede ayudarle en esto, pero no es nada trivial). ESCALAR será leído o escrito dependiendo de la FUNCIÓN -- un puntero al valor del string ESCALAR será pasado como tercer argumento de la actual llamada C&lt;ioctl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If SCALAR
has no string value but does have a numeric value, that value will be
passed rather than a pointer to the string value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Si ESCALAR no tiene un valor string sino que tiene un valor numérico, este valor será el que se pase, en lugar de un puntero al valor del string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To guarantee this to be
true, add a C&lt;0&gt; to the scalar before using it.)  The C&lt;pack&gt; and C&lt;unpack&gt;
functions may be needed to manipulate the values of structures used by
C&lt;ioctl&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para garantizar este último comportamiento, añada un C&lt;0&gt; al escalar antes de usarlo). Las funciones C&lt;pack&gt; y C&lt;unpack&gt; pueden ser necesarias para manipular los valores de las estructuras usadas por C&lt;ioctl&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of C&lt;ioctl&gt; (and C&lt;fcntl&gt;) is as follows:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor devuelto de C&lt;ioctl&gt; (y C&lt;fcntl&gt;) es como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if OS returns:		then Perl returns:
	    -1	  		  undefined value
	     0	 		string &quot;0 but true&quot;
	anything else		    that number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si SO devuelve:		entonces Perl devuelve:
	    -1	  		  valor indefinido
	     0	 		string &quot;0 but true&quot;
	cualquier otro		    ese número</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus Perl returns true on success and false on failure, yet you can
still easily determine the actual value returned by the operating
system:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, Perl devuelve verdadero en éxito y falso en fallo, por lo que aún podemos determinar el valor actual devuelto por el sistema operativo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$retval = ioctl(...) || -1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$retval = ioctl(...) || -1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>printf &quot;System returned %d\n&quot;, $retval;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>printf &quot;Sistema devolvió %d\n&quot;, $retval;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special string C&lt;&quot;0 but true&quot;&gt; is exempt from B&lt;-w&gt; complaints
about improper numeric conversions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El string especial C&lt;&quot;0 but true&quot;&gt; es una excepción de los mensajes de aviso activados por B&lt;-w&gt; sobre una conversión numérica impropia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item join EXPR,LIST
X&lt;join&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item join EXPR,LISTA
X&lt;join&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joins the separate strings of LIST into a single string with fields
separated by the value of EXPR, and returns that new string.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Une los strings separados de LISTA en un único string con campos separados por el valor de EXPR y devuelve el nuevo string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that unlike C&lt;split&gt;, C&lt;join&gt; doesn't take a pattern as its
first argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuidado que, a diferencia de C&lt;split&gt;, C&lt;join&gt; no toma un patrón como su primer argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare L&lt;/split&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compare con L&lt;/split&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item keys HASH
X&lt;keys&gt; X&lt;key&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item keys HASH
X&lt;keys&gt; X&lt;key&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a list consisting of all the keys of the named hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve una lista consistente de todas las claves del hash indicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In scalar context, returns the number of keys.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En contexto escalar, devuelve el número de claves).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keys are returned in an apparently random order.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las claves son devueltas en un aparente aleatorio orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual
random order is subject to change in future versions of perl, but it
is guaranteed to be the same order as either the C&lt;values&gt; or C&lt;each&gt;
function produces (given that the hash has not been modified).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El actual orden aleatorios está sujeto a cambio en futuras versiones de perl, pero se garantiza que sea el mismo orden que las funciones C&lt;values&gt; o C&lt;each&gt; producirían (dado que el hash no ha sido modificado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since
Perl 5.8.1 the ordering is different even between different runs of
Perl for security reasons (see L&lt;perlsec/&quot;Algorithmic Complexity
Attacks&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Desde Perl 5.8.1 la ordenación es diferente incluso entre diferentes ejecuciones de Perl por razones de seguridad (ver L&lt;perlsec/&quot;Ataques por Complejidad Algorítmica&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a side effect, calling keys() resets the HASH's internal iterator
(see L&lt;/each&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como efecto colateral, llamando keys() resetea el iterador interno del HASH (ver L&lt;/each&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, calling keys() in void context resets
the iterator with no other overhead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma particular, llamando a keys() en contexto nulo (void) resetea el iterador sin otro efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is yet another way to print your environment:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay otra forma de imprimir su entorno:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@keys = keys %ENV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@keys = keys %ENV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@values = values %ENV;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>@values = values %ENV;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (@keys) {
	print pop(@keys), '=', pop(@values), &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (@keys) {
	print pop(@keys), '=', pop(@values), &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or how about sorted by key:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o de forma ordenada por la clave:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $key (sort(keys %ENV)) {
	print $key, '=', $ENV{$key}, &quot;\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $key (sort(keys %ENV)) {
	print $key, '=', $ENV{$key}, &quot;\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned values are copies of the original keys in the hash, so
modifying them will not affect the original hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores devueltos son copias de las claves originales en el hash, así que modificarlas no afectará al hash original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare L&lt;/values&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Compare con L&lt;/values&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To sort a hash by value, you'll need to use a C&lt;sort&gt; function.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ordenar un hash por valor, necesitará usar la función C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a descending numeric sort of a hash by its values:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es una ordenación numérica descendente de un hash por sus valores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $key (sort { $hash{$b} &lt;=&gt; $hash{$a} } keys %hash) {
	printf &quot;%4d %s\n&quot;, $hash{$key}, $key;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $key (sort { $hash{$b} &lt;=&gt; $hash{$a} } keys %hash) {
	printf &quot;%4d %s\n&quot;, $hash{$key}, $key;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an lvalue C&lt;keys&gt; allows you to increase the number of hash buckets
allocated for the given hash.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usado como valor a la izquierda, C&lt;keys&gt; le permite incrementar el número de alojamientos de memoria hash para ese hash.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can gain you a measure of efficiency if
you know the hash is going to get big.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede hacerle ganar más eficiencia si sabe que el hash va a tener un gran tamaño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is similar to pre-extending
an array by assigning a larger number to $#array.)  If you say</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Esto es similar a pre-extender un array asignándole un gran número a $#array). Si dice</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keys %hash = 200;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>keys %hash = 200;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then C&lt;%hash&gt; will have at least 200 buckets allocated for it--256 of them,
in fact, since it rounds up to the next power of two.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>entonces C&lt;%hash&gt; tendrá al menos 200 slots de memoria reservados para él -- 256 de ellos, de hecho, ya que se redondea a la siguiente potencia de dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
buckets will be retained even if you do C&lt;%hash = ()&gt;, use C&lt;undef
%hash&gt; if you want to free the storage while C&lt;%hash&gt; is still in scope.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Estos slots serán mantenidos incluso si hace C&lt;%hash = ()&gt;. Use C&lt;undef %hash&gt; si quiere liberar el almacenamiento mientras mantiene a C&lt;%hash&gt; en el ámbito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can't shrink the number of buckets allocated for the hash using
C&lt;keys&gt; in this way (but you needn't worry about doing this by accident,
as trying has no effect).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No puede reducir el número de slots reservados para el hash usando C&lt;keys&gt; de esta manera (pero no necesita preocuparse de hacer esto por accidente; intentarlo no tiene ningún efecto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also C&lt;each&gt;, C&lt;values&gt; and C&lt;sort&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también C&lt;each&gt;, C&lt;values&gt; y C&lt;sort&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item kill SIGNAL, LIST
X&lt;kill&gt; X&lt;signal&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item kill SEÑAL, LISTA
X&lt;kill&gt; X&lt;signal&gt; X&lt;señal&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sends a signal to a list of processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Manda una señal a una lista de procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of
processes successfully signaled (which is not necessarily the
same as the number actually killed).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Devuelve el número de procesos señalados exitósamente (que no es necesariamente el mismo número de los llamados).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$cnt = kill 1, $child1, $child2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$cnt = kill 1, $child1, $child2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>kill 9, @goners;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>kill 9, @finalizadores;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SIGNAL is zero, no signal is sent to the process.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si SEÑAL es cero, no se envía señal al proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a
useful way to check that a child process is alive and hasn't changed
its UID.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es útil para comprobar que un proceso hijo está vivo y no ha cambiado su UID.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlport&gt; for notes on the portability of this
construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlport&gt; para notas sobre portabilidad de esta construcción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in the shell, if SIGNAL is negative, it kills
process groups instead of processes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A diferencia del shell, si SEÑAL es negativo , mata el grupo de procesos en lugar de procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(On System V, a negative I&lt;PROCESS&gt;
number will also kill process groups, but that's not portable.)  That
means you usually want to use positive not negative signals.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(En System V, un número de I&lt;PROCESO&gt; negativo también matará grupos de procesos, pero esto no es portable). Esto quiere decir que normalmente querrá usar señales positivas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also
use a signal name in quotes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar también nombres de señales entrecomilladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlipc/&quot;Signals&quot;&gt; for more details.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlipc/&quot;Señales&quot;&gt; para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item last LABEL
X&lt;last&gt; X&lt;break&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item last ETIQUETA
X&lt;last&gt; X&lt;break&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item last</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item last</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;last&gt; command is like the C&lt;break&gt; statement in C (as used in
loops); it immediately exits the loop in question.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;last&gt; es como la sentencia C&lt;break&gt; del C (usada en bucles); inmediatamente sale del bucle en cuestión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the LABEL is
omitted, the command refers to the innermost enclosing loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la ETIQUETA se omite, el comando se refiere al bucle más interior en que se encuentre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
C&lt;continue&gt; block, if any, is not executed:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bloque C&lt;continue&gt;, si está, no es ejecutado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE: while (&lt;STDIN&gt;) {
	last LINE if /^$/;	# exit when done with header
	#...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LINEA: while (&lt;STDIN&gt;) {
	last LINEA if /^$/;	# salir cuando se termine la cabecera
	...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;last&gt; cannot be used to exit a block which returns a value such as
C&lt;eval {}&gt;, C&lt;sub {}&gt; or C&lt;do {}&gt;, and should not be used to exit
a grep() or map() operation.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;last&gt; no puede usarse para salir de un bloque que devuelve un valor, como C&lt;eval {}&gt;, C&lt;sub {}&gt; o C&lt;do {}&gt; y no debe usarse para salir de una operación grep() o map().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a block by itself is semantically identical to a loop
that executes once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que un bloque por sí mismo es semánticamente idéntico a un bucle que se ejecuta una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus C&lt;last&gt; can be used to effect an early
exit out of such a block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, C&lt;last&gt; puede ser usado para salir prematuramente de este bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also L&lt;/continue&gt; for an illustration of how C&lt;last&gt;, C&lt;next&gt;, and
C&lt;redo&gt; work.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver también L&lt;/continue&gt; para una ilustración de cómo funcionan C&lt;last&gt;, C&lt;next&gt; y C&lt;redo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item lc EXPR
X&lt;lc&gt; X&lt;lowercase&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item lc EXPR
X&lt;lc&gt; X&lt;lowercase&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#!/usr/bin/perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>#!/usr/bin/perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item *</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;redo&gt; command restarts the loop block without evaluating the
conditional again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;redo&gt; reinicia la iteración sin evaluar de nuevo la condición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So don't do that.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que no lo haga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>__END__</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>__END__</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 NOMBRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlbook - Perl book information</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlbook - Información sobre libros de Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Camel Book, officially known as I&lt;Programming Perl, Third Edition&gt;,
by Larry Wall et al, is the definitive reference work covering nearly
all of Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El libro del Dromedario, oficialmente conocido como I&lt;Programando en Perl, Tercera Edición&gt;, de Larry Wall y otros, es la referencia definitiva sobre casi todo el lenguaje Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can order it and other Perl books from O'Reilly &amp;
Associates, 1-800-998-9938.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede pedir éste y otros libros Perl a O'Reilly &amp; Asociados, 1-800-998-9938.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local/overseas is +1 707 829 0515.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llamada internacional +1 707 829 0515.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you
can locate an O'Reilly order form, you can also fax to +1 707 829 0104.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si encuentra un formulario de pedido de O'Reilly, puede enviarlo por fax a +1 707 829 0104.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're web-connected, you can even mosey on over to
L&lt;http://www.oreilly.com/&gt; for an online order form.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si puede conectarse por web, puede encontrar un formulario en L&lt;http://www.oreilly.com/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other Perl books from various publishers and authors 
can be found listed in L&lt;perlfaq2&gt; or on the web at
L&lt;http://books.perl.org/&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros libros sobre Perl de otras editoriales y autores pueden encontrarse en L&lt;perlfaq2&gt; o en la web L&lt;http://books.perl.org/&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME
X&lt;syntax&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 NOMBRE
X&lt;sintaxis&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlsyn - Perl syntax</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlsyn - Sintaxis Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Perl program consists of a sequence of declarations and statements
which run from the top to the bottom.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un programa Perl consiste en una secuencia de declaraciones y sentencias que se ejecutan de arriba a abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loops, subroutines and other
control structures allow you to jump around within the code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bucles, subrutinas y otras estructuras de control le permiten saltar a lo largo del código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is a B&lt;free-form&gt; language, you can format and indent it however
you like.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl es un lenguaje de B&lt;forma libre&gt;, puede formatearlo y sangrarlo como quiera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace mostly serves to separate tokens, unlike
languages like Python where it is an important part of the syntax.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El espacio en blanco sirve para separar tokens, a diferencia de lenguajes como Python donde es una parte importante de la sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of Perl's syntactic elements are B&lt;optional&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Muchos de los elementos sintácticos de Perl son B&lt;opcionales&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than
requiring you to put parentheses around every function call and
declare every variable, you can often leave such explicit elements off
and Perl will figure out what you meant.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En vez de obligarle a poner paréntesis en todas las llamadas de función y declarar cada variable, puede, a menudo, dejar algunos elementos de forma explícita y Perl intentará adivinar lo que quiere decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as B&lt;Do What I
Mean&gt;, abbreviated B&lt;DWIM&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es conocido como B&lt;Do What I Mean&gt; (haz lo que digo), abreviado como B&lt;DWIM&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows programmers to be B&lt;lazy&gt; and to
code in a style with which they are comfortable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Permite a los programadores ser B&lt;perezosos&gt; y codificar en un estilo en que se encuentran más cómodos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl B&lt;borrows syntax&gt; and concepts from many languages: awk, sed, C,
Bourne Shell, Smalltalk, Lisp and even English.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl B&lt;toma prestada sintaxis&gt; y conceptos de muchos lenguajes: awk, sed, C, Bourne Shell, Smalltalk, Lisp e incluso inglés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other
languages have borrowed syntax from Perl, particularly its regular
expression extensions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros lenguajes han tomado prestada la sintaxis de Perl, particularmente sus extensiones de expresiones regulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if you have programmed in another language
you will see familiar pieces in Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que si ha programado en otro lenguaje verá partes en Perl que le serán familiares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They often work the same, but
see L&lt;perltrap&gt; for information about how they differ.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>A menudo funcionan de la misma forma, pero mire L&lt;perltrap&gt; para ver en cómo difieren.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Declarations
X&lt;declaration&gt; X&lt;undef&gt; X&lt;undefined&gt; X&lt;uninitialized&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Declaraciones
X&lt;declaración&gt; X&lt;undef&gt; X&lt;indefinido&gt; X&lt;no inicializado&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only things you need to declare in Perl are report formats and
subroutines (and sometimes not even subroutines).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los únicos elementos que necesita declarar en Perl son los informes y las subrutinas (y algunas veces ni siquiera las subrutinas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable holds
the undefined value (C&lt;undef&gt;) until it has been assigned a defined
value, which is anything other than C&lt;undef&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una variable almacena el valor indefinido (C&lt;undef&gt;) hasta que le es asignado un valor definido, que es cualquier otra cosa que no sea C&lt;undef&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as a number,
C&lt;undef&gt; is treated as C&lt;0&gt;; when used as a string, it is treated as
the empty string, C&lt;&quot;&quot;&gt;; and when used as a reference that isn't being
assigned to, it is treated as an error.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando se usa como un número, C&lt;undef&gt; es tratado como C&lt;0&gt;; cuando se usa como una cadena de caracteres (I&lt;string&gt;), se trata como el string vacío, C&lt;&quot;&quot;&gt;; y cuando se usa como una referencia que no ha sido asignada, es tratado como un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you enable warnings,
you'll be notified of an uninitialized value whenever you treat
C&lt;undef&gt; as a string or a number.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si ha activado los avisos (warnings), será notificado de un valor no inicializado cuando trate C&lt;undef&gt; como un string o número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, usually.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Bueno, normalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boolean contexts,
such as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En contextos booleanos, como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $a;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $a;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if ($a) {}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if ($a) {}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>are exempt from warnings (because they care about truth rather than
definedness).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>están exentos de los avisos (porque se fijan en el valor de verdad en vez de ver si está definido).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators such as C&lt;++&gt;, C&lt;--&gt;, C&lt;+=&gt;,
C&lt;-=&gt;, and C&lt;.=&gt;, that operate on undefined left values such as:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Operadores como C&lt;++&gt;, C&lt;--&gt;, C&lt;+=&gt;, C&lt;-=&gt; y C&lt;.=&gt;, que operan sobre valores no definidos como en:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>are also always exempt from such warnings.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>están también exentos de tales avisos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A declaration can be put anywhere a statement can, but has no effect on
the execution of the primary sequence of statements--declarations all
take effect at compile time.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una declaración puede ponerse en  cualquier sitio, como si fuera una sentencia, pero no tiene efecto en la ejecución de las secuencias de sentencias; todas las declaraciones toman efecto en tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically all the declarations are put at
the beginning or the end of the script.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Típicamente, todas las declaraciones se ponen al comienzo o al final del script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you're using
lexically-scoped private variables created with C&lt;my()&gt;, you'll
have to make sure
your format or subroutine definition is within the same block scope
as the my if you expect to be able to access those private variables.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si está usando variables privadas de un contexto local creadas con C&lt;my()&gt;, deberá asegurarse que su definición de formato o subrutina están dentro del mismo bloque que el C&lt;my&gt; si quiere acceder a estas variables privadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring a subroutine allows a subroutine name to be used as if it were a
list operator from that point forward in the program.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Declarar una subrutina permite que su nombre sea usado como si fuera un operador de lista desde el punto de vista del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare a
subroutine without defining it by saying C&lt;sub name&gt;, thus:
X&lt;subroutine, declaration&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede declarar una subrutina sin definirla diciendo C&lt;sub nombre&gt;, como: X&lt;subrutina, declaración&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub myname;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub minombre;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$me = myname $0 		or die &quot;can't get myname&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$yo = minombre $0 		or die &quot;no puedo obtener minombre&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that myname() functions as a list operator, not as a unary operator;
so be careful to use C&lt;or&gt; instead of C&lt;||&gt; in this case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que minombre() funciona como un operador de lista, no como un operador unario; cuidado al usar C&lt;or&gt; en vez de C&lt;||&gt; en este caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if
you were to declare the subroutine as C&lt;sub myname ($)&gt;, then
C&lt;myname&gt; would function as a unary operator, so either C&lt;or&gt; or
C&lt;||&gt; would work.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, si declara la subrutina como C&lt;sub minombre ($)&gt;, entonces C&lt;minombre&gt; funcionará como un operador unario, así que servirán tanto C&lt;or&gt; como C&lt;||&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines declarations can also be loaded up with the C&lt;require&gt; statement
or both loaded and imported into your namespace with a C&lt;use&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las declaraciones de subrutinas pueden cargarse también con la sentencia C&lt;require&gt; o cargadas e importadas en su espacio de nombres con la sentencia C&lt;use&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlmod&gt; for details on this.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlmod&gt; para detalles sobre esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A statement sequence may contain declarations of lexically-scoped
variables, but apart from declaring a variable name, the declaration acts
like an ordinary statement, and is elaborated within the sequence of
statements as if it were an ordinary statement.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Una secuencia de sentencias pueden contener declaraciones de variables de ámbito léxico (privado), pero aparte de declarar un nombre de variable, la declaración actúa como una sentencia normal y es elaborada dentro de la secuencia de sentencias como si fuera una sentencia normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means it actually
has both compile-time and run-time effects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que tiene efectos tanto en tiempo de compilación como en tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Comments
X&lt;comment&gt; X&lt;#&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Comentarios
X&lt;comentario&gt; X&lt;#&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Text from a C&lt;&quot;#&quot;&gt; character until the end of the line is a comment,
and is ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El texto desde un carácter C&lt;&quot;#&quot;&gt; hasta el fin de la línea es un comentario y es ignorado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exceptions include C&lt;&quot;#&quot;&gt; inside a string or regular
expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Excepciones a esto son la inclusión de C&lt;&quot;#&quot;&gt; dentro de un string o una expresión regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Simple Statements
X&lt;statement&gt; X&lt;semicolon&gt; X&lt;expression&gt; X&lt;;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Sentencias simples
X&lt;sentencia&gt; X&lt;punto y coma&gt; X&lt;expresión&gt; X&lt;;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only kind of simple statement is an expression evaluated for its
side effects.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La única clase de sentencia simple que existe es una expresión evaluada por sus efectos colaterales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every simple statement must be terminated with a
semicolon, unless it is the final statement in a block, in which case
the semicolon is optional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada sentencia simple debe terminarse en un punto y coma excepto si es la última sentencia de un bloque, en cuyo caso el punto y coma es opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A semicolon is still encouraged if the
block takes up more than one line, because you may eventually add
another line.)  Note that there are some operators like C&lt;eval {}&gt; and
C&lt;do {}&gt; that look like compound statements, but aren't (they're just
TERMs in an expression), and thus need an explicit termination if used
as the last item in a statement.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Un punto y coma es aún así recomendable si el bloque tiene más de una línea, porque, eventualmente, puede añadir alguna línea más). Note que algunos operadores como C&lt;eval {}&gt; y C&lt;do {}&gt; parecen sentencias compuestas, pero no lo son (son sólo TÉRMINOS en una expresión) y es necesario una terminación explícita si se usa como el último punto de una sentencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Truth and Falsehood
X&lt;truth&gt; X&lt;falsehood&gt; X&lt;true&gt; X&lt;false&gt; X&lt;!&gt; X&lt;not&gt; X&lt;negation&gt; X&lt;0&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Verdad y Falsedad
X&lt;verdad&gt; X&lt;falsedad&gt; X&lt;true&gt; X&lt;false&gt; X&lt;!&gt; X&lt;not&gt; X&lt;negación&gt; X&lt;0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number 0, the strings C&lt;'0'&gt; and C&lt;''&gt;, the empty list C&lt;()&gt;, and
C&lt;undef&gt; are all false in a boolean context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El número 0, las cadenas C&lt;'0'&gt; y C&lt;''&gt;, la cadena vacía C&lt;()&gt; y C&lt;undef&gt; son todos falsos en contexto booleano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other values are true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todos los otros valores son verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negation of a true value by C&lt;!&gt; or C&lt;not&gt; returns a special false value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La negación del valor de verdadero con C&lt;!&gt; o C&lt;not&gt; devuelve un valor falso especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When evaluated as a string it is treated as C&lt;''&gt;, but as a number, it
is treated as 0.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando es evaluado como cadena es tratado como C&lt;''&gt;, pero como número es tratado como 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Statement Modifiers
X&lt;statement modifier&gt; X&lt;modifier&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt;
X&lt;until&gt; X&lt;foreach&gt; X&lt;for&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Modificadores de sentencias
X&lt;modificador de sentencias&gt; X&lt;modificador&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt; X&lt;until&gt; X&lt;foreach&gt; X&lt;for&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any simple statement may optionally be followed by a I&lt;SINGLE&gt; modifier,
just before the terminating semicolon (or block ending).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cualquier sentencia simple puede ser seguida opcionalmente por un I&lt;ÚNICO&gt; modificador, justo antes del punto y coma final (o del final del bloque).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The possible
modifiers are:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los posibles modificadores son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unless EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>unless EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>until EXPR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>until EXPR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach LIST</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach LISTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;EXPR&gt; following the modifier is referred to as the &quot;condition&quot;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La C&lt;EXPR&gt; siguiente al modificador es referida como &quot;condición&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its truth or falsehood determines how the modifier will behave.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Su verdad o falsedad determina como se comportará el modificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;if&gt; executes the statement once I&lt;if&gt; and only if the condition is
true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;if&gt; ejecuta la sentencia una vez I&lt;sí&gt; y sólo si la condición es verdadera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;unless&gt; is the opposite, it executes the statement I&lt;unless&gt;
the condition is true (i.e., if the condition is false).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;unless&gt; es el opuesto, ejecuta la sentencia si la condición I&lt;no es&gt; verdadera (e.d., si la condición es falsa).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Basset hounds got long ears&quot; if length $ear &gt;= 10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;El perro de caza Basset tiene largas orejas&quot; if length $oreja &gt;= 10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>go_outside() and play() unless $is_raining;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>vete_fuera() and juega() unless $esta_lloviendo;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;foreach&gt; modifier is an iterator: it executes the statement once
for each item in the LIST (with C&lt;$_&gt; aliased to each item in turn).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El modificador C&lt;foreach&gt; es un iterador: ejecuta la sentencia una vez por cada elemento en la LISTA (con C&lt;$_&gt; asociado a cada elemento en cada iteración).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Hello $_!\n&quot; foreach qw(world Dolly nurse);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Hola $_!\n&quot; foreach qw(mundo Dolly enfermera);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;while&gt; repeats the statement I&lt;while&gt; the condition is true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;while&gt; repite la sentencia I&lt;mientras&gt; la condición sea cierta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;until&gt; does the opposite, it repeats the statement I&lt;until&gt; the
condition is true (or while the condition is false):</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;until&gt; hace lo opuesto, repite la sentencia I&lt;hasta&gt; que la condición sea verdadera (o mientras la condición sea falsa):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Both of these count from 0 to 10.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Estas dos líneas cuentas de 0 a 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $i++ while $i &lt;= 10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $i++ while $i &lt;= 10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $j++ until $j &gt;  10;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $j++ until $j &gt;  10;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;while&gt; and C&lt;until&gt; modifiers have the usual &quot;C&lt;while&gt; loop&quot;
semantics (conditional evaluated first), except when applied to a
C&lt;do&gt;-BLOCK (or to the deprecated C&lt;do&gt;-SUBROUTINE statement), in
which case the block executes once before the conditional is
evaluated.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los modificadores C&lt;while&gt; u C&lt;until&gt; tienen la usual semántica de los &quot;bucles C&lt;while&gt;&quot; (la condición se evalúa primero), excepto cuando se aplica a un bloque C&lt;do&gt; (o a la depreciada sentencia subrutina C&lt;do&gt;), en cuyo caso el bloque se ejecuta una vez antes de sea evaluada la condición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is so that you can write loops like:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De esa manera puede escribir bucles como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do {
	$line = &lt;STDIN&gt;;
	...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do {
	$linea = &lt;STDIN&gt;;
	...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} until $line  eq &quot;.\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} until $linea  eq &quot;.\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlfunc/do&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlfunc/do&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that the loop control statements described
later will I&lt;NOT&gt; work in this construct, because modifiers don't take
loop labels.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note también que las sentencias de control de bucles descritas más adelante I&lt;NO&gt; funcionarán con esta construcción, porque los modificadores no toman etiquetas de bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorry.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo sentimos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can always put another block inside of it
(for C&lt;next&gt;) or around it (for C&lt;last&gt;) to do that sort of thing.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre puede poner otro bloque dentro de él  (para C&lt;next&gt;) o alrededor de él (para C&lt;last&gt;) para hacer esta suerte de cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;next&gt;, just double the braces:
X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para C&lt;next&gt;, solamente doble las llaves: 
X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do {{
	next if $x == $y;
	# do something here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>do {{
	next if $x == $y;
	# hacer algo aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}} until $x++ &gt; $z;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>}} until $x++ &gt; $z;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C&lt;last&gt;, you have to be more elaborate:
X&lt;last&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para C&lt;last&gt;, tiene que ser un poco más elaborado:
X&lt;last&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LOOP: { 
	    do {
		last if $x = $y**2;
		# do something here
	    } while $x++ &lt;= $z;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>BUCLE: { 
	    do {
		last if $x = $y**2;
		# hacer algo aquí
	    } while $x++ &lt;= $z;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;NOTE:&gt; The behaviour of a C&lt;my&gt; statement modified with a statement
modifier conditional or loop construct (e.g. C&lt;my $x if ...&gt;) is
B&lt;undefined&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;NOTA:&gt; El comportamiento de una sentencia C&lt;my&gt; modificada con una sentencia de modificador condicional o construcción de bucle (p.e. C&lt;my $x if ...&gt;) es B&lt;indefinido&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the C&lt;my&gt; variable may be C&lt;undef&gt;, any
previously assigned value, or possibly anything else.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El valor de la variable C&lt;my&gt; puede ser C&lt;undef&gt;, cualquier valor anteriormente asignado , o posiblemente cualquier otra cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't rely on
it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No confíe en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future versions of perl might do something different from the
version of perl you try it out on.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Futuras versiones de perl pueden hacer algo diferente de la versión de perl que esté probando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here be dragons.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay dragones sueltos...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;my&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;my&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Compound Statements
X&lt;statement, compound&gt; X&lt;block&gt; X&lt;bracket, curly&gt; X&lt;curly bracket&gt; X&lt;brace&gt;
X&lt;{&gt; X&lt;}&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt; X&lt;until&gt; X&lt;foreach&gt; X&lt;for&gt; X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Sentencias compuestas
X&lt;sentencia, compuesta&gt; X&lt;bloque&gt; X&lt;llave, paréntesis&gt; X&lt;corchete&gt;
X&lt;{&gt; X&lt;}&gt; X&lt;if&gt; X&lt;unless&gt; X&lt;while&gt; X&lt;until&gt; X&lt;foreach&gt; X&lt;for&gt; X&lt;continue&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl, a sequence of statements that defines a scope is called a block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En Perl, una secuencia de sentencias que define un ámbito se llama un bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes a block is delimited by the file containing it (in the case
of a required file, or the program as a whole), and sometimes a block
is delimited by the extent of a string (in the case of an eval).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Algunas veces un bloque está delimitado por el fichero que lo contiene (en el caso de un fichero requerido, o el programa entero) y otras veces un bloque está delimitado por la extensión de un string (en el caso de un eval).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But generally, a block is delimited by curly brackets, also known as braces.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Pero generalmente, un bloque está delimitado por llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will call this syntactic construct a BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llamaremos a esta construcción sintáctica un BLOQUE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following compound statements may be used to control flow:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las siguientes sentencias compuestas pueden ser usadas para controlar el flujo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (EXPR) BLOCK else BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (EXPR) BLOQUE else BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (EXPR) BLOQUE elsif (EXPR) BLOQUE ... else BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL while (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA while (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL while (EXPR) BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA while (EXPR) BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL until (EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA until (EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL until (EXPR) BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA until (EXPR) BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL for (EXPR; EXPR; EXPR) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA for (EXPR; EXPR; EXPR) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL foreach VAR (LIST) BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA foreach VAR (LISTA) BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL foreach VAR (LIST) BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA foreach VAR (LISTA) BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LABEL BLOCK continue BLOCK</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>ETIQUETA BLOQUE continue BLOQUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, unlike C and Pascal, these are defined in terms of BLOCKs,
not statements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que, a diferencia del C y Pascal, están definidas en términos de BLOQUES, no sentencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the curly brackets are I&lt;required&gt;--no
dangling statements allowed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que las llaves son I&lt;necesarias&gt; --no se permiten sentencias sueltas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to write conditionals without
curly brackets there are several other ways to do it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere escribir condicionales sin llaves hay varias formas de hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following
all do the same thing:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo lo siguiente hace lo mismo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!open(FOO)) { die &quot;Can't open $FOO: $!&quot;; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (!open(FOO)) { die &quot;No puedo abrir $FOO: $!&quot;; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't open $FOO: $!&quot; unless open(FOO);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo abrir $FOO: $!&quot; unless open(FOO);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO) or die &quot;Can't open $FOO: $!&quot;;	# FOO or bust!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO) or die &quot;No puedo abrir $FOO: $!&quot;;	# ¡FOO o quieto!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO) ?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'hi mom' : die &quot;Can't open $FOO: $!&quot;;
			# a bit exotic, that last one</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>'hola mama' : die &quot;No puedo abrir $FOO: $!&quot;;
			# Un poco exótico, este último</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;if&gt; statement is straightforward.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La sentencia C&lt;if&gt; es sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because BLOCKs are always
bounded by curly brackets, there is never any ambiguity about which
C&lt;if&gt; an C&lt;else&gt; goes with.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Como los BLOQUES están siempre rodeados de llaves, nunca hay ambigüedad sobre dónde van el C&lt;if&gt; y el C&lt;else&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use C&lt;unless&gt; in place of C&lt;if&gt;,
the sense of the test is reversed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usa C&lt;unless&gt; en lugar de C&lt;if&gt;, el sentido del test es invertido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;while&gt; statement executes the block as long as the expression is
true (does not evaluate to the null string C&lt;&quot;&quot;&gt; or C&lt;0&gt; or C&lt;&quot;0&quot;&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La sentencia C&lt;while&gt; ejecuta el bloque mientras la expresión sea verdadera (no evalúe al string nulo C&lt;&quot;&quot;&gt; o C&lt;0&gt; o C&lt;&quot;0&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;until&gt; statement executes the block as long as the expression is
false.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La sentencia C&lt;until&gt; ejecuta el bloque mientras la expresión sea falsa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LABEL is optional, and if present, consists of an identifier followed
by a colon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La ETIQUETA es opcional, y si está presente, consiste en un identificador seguido por el carácter dos puntos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LABEL identifies the loop for the loop control
statements C&lt;next&gt;, C&lt;last&gt;, and C&lt;redo&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La ETIQUETA identifica el bucle para las sentencias de control de bucle C&lt;next&gt;, C&lt;last&gt; y C&lt;redo&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the LABEL is omitted, the loop control statement
refers to the innermost enclosing loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la ETIQUETA se omite, las sentencias de control de bucle se refieren al bucle más interior en que se encuentren.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may include dynamically
looking back your call-stack at run time to find the LABEL.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así se puede implementar dinámicamente una retrollamada a la pila de llamadas en tiempo real para encontrar la ETIQUETA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such
desperate behavior triggers a warning if you use the C&lt;use warnings&gt;
pragma or the B&lt;-w&gt; flag.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tal desesperado comportamiento lanzará un aviso si usa el pragma C&lt;use warnings&gt; o la opción B&lt;-w&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a C&lt;continue&gt; BLOCK, it is always executed just before the
conditional is about to be evaluated again.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si existe un BLOQUE C&lt;continue&gt;, siempre es ejecutado justo antes de que la condición sea evaluada de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus it can be used to
increment a loop variable, even when the loop has been continued via
the C&lt;next&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así, puede ser usada para incrementar una variable de bucle, incluso cuando la iteración ha sido cortada vía la sentencia C&lt;next&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Loop Control
X&lt;loop control&gt; X&lt;loop, control&gt; X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt; X&lt;continue&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Control de bucles
X&lt;control de bucles&gt; X&lt;bucle, control&gt; X&lt;next&gt; X&lt;last&gt; X&lt;redo&gt; X&lt;continue&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;next&gt; command starts the next iteration of the loop:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;next&gt; inicia la siguiente iteración del bucle:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE: while (&lt;STDIN&gt;) {
	next LINE if /^#/;	# discard comments
	...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LINEA: while (&lt;STDIN&gt;) {
	next LINEA if /^#/;	# desecha los comentarios
	...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;last&gt; command immediately exits the loop in question.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El comando C&lt;last&gt; sale inmediatamente del bucle en cuestión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE: while (&lt;STDIN&gt;) {
	last LINE if /^$/;	# exit when done with header
	...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LINEA: while (&lt;STDIN&gt;) {
	last LINEA if /^$/;	# salir cuando se termine la cabecera
	...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;continue&gt; block, if any, is I&lt;not&gt; executed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bloque C&lt;continue&gt;, si está, no es ejecutado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command is normally used by programs that want to lie to themselves
about what was just input.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comando se usa normalmente por los programas que quieren mentirse a sí mismos sobre lo que fue introducido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when processing a file like F&lt;/etc/termcap&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo, cuando se procesa un fichero como F&lt;/etc/termcap&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your input lines might end in backslashes to indicate continuation, you
want to skip ahead and get the next record.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si las líneas de entrada acaban en contra barras para indicar continuación, querrá saltarlo y obtener el siguiente registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;&gt;) {
	chomp;
	if (s/\\$//) {
	    $_ .= &lt;&gt;;
	    redo unless eof();
	}
	# now process $_</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;&gt;) {
	chomp;
	if (s/\\$//) {
	    $_ .= &lt;&gt;;
	    redo unless eof();
	}
	# ahora procesar $_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is Perl short-hand for the more explicitly written version:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>que es la versión corta de la versión más explícita:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE: while (defined($line = &lt;ARGV&gt;)) {
	chomp($line);
	if ($line =~ s/\\$//) {
	    $line .= &lt;ARGV&gt;;
	    redo LINE unless eof(); # not eof(ARGV)!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LINEA: while (defined($linea = &lt;ARGV&gt;)) {
	chomp($linea);
	if ($linea =~ s/\\$//) {
	    $linea .= &lt;ARGV&gt;;
	    redo LINEA unless eof(); # not eof(ARGV)!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
	# now process $line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>}
	# ahora procesar $linea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if there were a C&lt;continue&gt; block on the above code, it would
get executed only on lines discarded by the regex (since redo skips the
continue block).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que si existiese un bloque C&lt;continue&gt; en el código de arriba, sería ejecutado sólo en las líneas descartadas por la expresión regular (debido a que redo salta el bloque continue).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A continue block is often used to reset line counters
or C&lt;?pat?&gt; one-time matches:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un bloque continue se usa a menudo para resetear contadores de línea o patrones de un sólo uso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># inspired by :1,$g/fred/s//WILMA/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># inspirado por :1,$g/fred/s//WILMA/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (&lt;&gt;) {
	?(fred)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while (&lt;&gt;) {
	?(pedro)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp; s//WILMA $1 WILMA/;
	?(barney)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;&amp; s//WILMA $1 WILMA/;
	?(pablo)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp; s//BETTY $1 BETTY/;
	?(homer)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;&amp; s//BETTY $1 BETTY/;
	?(homer)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp; s//MARGE $1 MARGE/;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;&amp; s//MARGE $1 MARGE/;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} continue {
	print &quot;$ARGV $.: $_&quot;;
	close ARGV  if eof();		# reset $.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} continue {
	print &quot;$ARGV $.: $_&quot;;
	close ARGV  if eof();		# resetea $.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset	    if eof();		# reset ?pat?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>reset	    if eof();		# resetea ?patrón?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the word C&lt;while&gt; is replaced by the word C&lt;until&gt;, the sense of the
test is reversed, but the conditional is still tested before the first
iteration.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la palabra C&lt;while&gt; se reemplaza por la palabra C&lt;until&gt;, el sentido del test se invierte, pero la condición es testeada siempre antes de la primera iteración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop control statements don't work in an C&lt;if&gt; or C&lt;unless&gt;, since
they aren't loops.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Las sentencias de control de bucle no funcionan en un C&lt;if&gt; o C&lt;unless&gt;, porque no son bucles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can double the braces to make them such, though.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque puede doblar las llaves para crearlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/pattern/) {{
	last if /fred/;
	next if /barney/; # same effect as &quot;last&quot;, but doesn't document as well
	# do something here</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/patrón/) {{
	last if /pedro/;
	next if /pablo/; # el mismo efecto que &quot;last&quot;, pero no se ve muy claro
	# hacer algo aquí</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>}}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is caused by the fact that a block by itself acts as a loop that
executes once, see L&lt;&quot;Basic BLOCKs and Switch Statements&quot;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es causado por el hecho de que un bloque por sí mismo actúa como un bucle que se ejecuta una vez, ver L&lt;&quot;BLOQUES básicos y sentencias Switch&quot;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The form C&lt;while/if BLOCK BLOCK&gt;, available in Perl 4, is no longer
available.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;while/if BLOQUE BLOQUE&gt;, disponible en Perl 4, ya no lo está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replace any occurrence of C&lt;if BLOCK&gt; by C&lt;if (do BLOCK)&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Reemplace cada ocurrencia de C&lt;if BLOQUE&gt; por C&lt;if (do BLOQUE)&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 For Loops
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Bucles For
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's C-style C&lt;for&gt; loop works like the corresponding C&lt;while&gt; loop;
that means that this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El estilo C del bucle C&lt;for&gt; trabaja como el correspondiente bucle C&lt;while&gt;; esto quiere decir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($i = 1; $i &lt; 10; $i++) {
	...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ($i = 1; $i &lt; 10; $i++) {
	...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is the same as this:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es lo mismo que esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$i = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$i = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while ($i &lt; 10) {
	...</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>while ($i &lt; 10) {
	...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} continue {
	$i++;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>} continue {
	$i++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is one minor difference: if variables are declared with C&lt;my&gt;
in the initialization section of the C&lt;for&gt;, the lexical scope of
those variables is exactly the C&lt;for&gt; loop (the body of the loop
and the control sections).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay una pequeña diferencia: si hay variables declaradas con C&lt;my&gt; en la sección de inicialización del C&lt;for&gt;, el ámbito léxico de estas variables es exactamente el bucle C&lt;for&gt; (el cuerpo del bucle y las secciones de control).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the normal array index looping, C&lt;for&gt; can lend itself
to many other interesting applications.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además del recorrido indexado de arrays, C&lt;for&gt; puede prestarse a otras interesantes aplicaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's one that avoids the
problem you get into if you explicitly test for end-of-file on
an interactive file descriptor causing your program to appear to
hang.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay una que evita el problema al testear explícitamente por el fin de fichero en un descriptor de fichero interactivo, provocando que su programa parezca que se queda colgado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;eof&gt; X&lt;end-of-file&gt; X&lt;end of file&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;eof&gt; X&lt;end-of-file&gt; X&lt;fin de fichero&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$on_a_tty = -t STDIN &amp;&amp; -t STDOUT;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$en_un_tty = -t STDIN &amp;&amp; -t STDOUT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub prompt { print &quot;yes?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub prompt { print &quot;¿si?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot; if $on_a_tty }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot; if $en_un_tty }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ( prompt(); &lt;STDIN&gt;; prompt() ) {
	# do something</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ( prompt(); &lt;STDIN&gt;; prompt() ) {
	# hacer algo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using C&lt;readline&gt; (or the operator form, C&lt;&lt; &lt;EXPR&gt; &gt;&gt;) as the
conditional of a C&lt;for&gt; loop is shorthand for the following.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando C&lt;readline&gt; (o el operador C&lt;&lt; &lt;EXPR&gt; &gt;&gt;) como la condición de un bucle C&lt;for&gt; es la forma corta de lo siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
behaviour is the same as a C&lt;while&gt; loop conditional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este comportamiento es el mismo que en la condición de un bucle C&lt;while&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;readline&gt; X&lt;&lt; &lt;&gt; &gt;&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;readline&gt; X&lt;&lt; &lt;&gt; &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ( prompt(); defined( $_ = &lt;STDIN&gt; ); prompt() ) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ( prompt(); defined( $_ = &lt;STDIN&gt; ); prompt() ) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># do something</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># hacer algo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Foreach Loops
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Bucles Foreach
X&lt;for&gt; X&lt;foreach&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;foreach&gt; loop iterates over a normal list value and sets the
variable VAR to be each element of the list in turn.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El bucle C&lt;foreach&gt; itera sobre los valores de una lista normal y pone la variable VAR a cada uno de los elementos de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the variable
is preceded with the keyword C&lt;my&gt;, then it is lexically scoped, and
is therefore visible only within the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la variable es precedida por la palabra clave C&lt;my&gt;, entonces su ámbito es léxicamente local y por eso es visible sólo dentro del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the variable is
implicitly local to the loop and regains its former value upon exiting
the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dicho de otra forma, la variable es implícitamente local al bucle y recupera su valor anterior saliendo del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the variable was previously declared with C&lt;my&gt;, it uses
that variable instead of the global one, but it's still localized to
the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si la variable fue anteriormente declarada con C&lt;my&gt;, usa esta variable en vez de la global, pero sigue siendo local en el bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implicit localisation occurs I&lt;only&gt; in a C&lt;foreach&gt;
loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta forma implícita de ser local ocurre I&lt;solamente&gt; en un bucle C&lt;foreach&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;my&gt; X&lt;local&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;my&gt; X&lt;local&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;foreach&gt; keyword is actually a synonym for the C&lt;for&gt; keyword, so
you can use C&lt;foreach&gt; for readability or C&lt;for&gt; for brevity.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La palabra clave C&lt;foreach&gt; es realmente un sinónimo de la palabra clave C&lt;for&gt;, así que puede usar C&lt;foreach&gt; por legibilidad o C&lt;for&gt; por brevedad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or because
the Bourne shell is more familiar to you than I&lt;csh&gt;, so writing C&lt;for&gt;
comes more naturally.)  If VAR is omitted, C&lt;$_&gt; is set to each value.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(O porque el shell Bourne le es más familiar que el I&lt;csh&gt;, escribir C&lt;for&gt; le es más natural).  Si VAR se omite, C&lt;$_&gt; se inicializa a cada valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;$_&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;$_&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any element of LIST is an lvalue, you can modify it by modifying
VAR inside the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si cualquier elemento de LISTA es un I&lt;lvalue&gt; (un valor que puede ponerse en el lado izquierdo de una expresión de asignación), puede modificarlo modificando VAR dentro del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, if any element of LIST is NOT an
lvalue, any attempt to modify that element will fail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Recíprocamente, si cualquier elemento de LISTA NOT es un I&lt;lvalue&gt;, cualquier intento de modificar este elemento fallará (provocará un error).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words,
the C&lt;foreach&gt; loop index variable is an implicit alias for each item
in the list that you're looping over.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En otras palabras, la variable índice del bucle C&lt;foreach&gt; es implícitamente un alias de cada elemento de la lista sobre la que estás iterando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;alias&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;alias&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any part of LIST is an array, C&lt;foreach&gt; will get very confused if
you add or remove elements within the loop body, for example with
C&lt;splice&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si cualquier parte de la LISTA es un array, C&lt;foreach&gt; quedará confundido si añade o quita elementos dentro del cuerpo del bucle, por ejemplo al usar C&lt;splice&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;splice&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;splice&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;foreach&gt; probably won't do what you expect if VAR is a tied or other
special variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;foreach&gt; probablemente no hará lo esperado si VAR está enlazada a otra variable especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't do that either.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No haga esto tampoco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (@ary) { s/foo/bar/ }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (@array) { s/foo/bar/ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for my $elem (@elements) {
	$elem *= 2;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for my $elemento (@elementos) {
	$elemento *= 2;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for $count (10,9,8,7,6,5,4,3,2,1,'BOOM') {
	print $count, &quot;\n&quot;; sleep(1);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for $cuenta_atras (10,9,8,7,6,5,4,3,2,1,'BOOM') {
	print $cuenta_atras, &quot;\n&quot;; sleep(1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (1..15) { print &quot;Merry Christmas\n&quot;; }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (1..15) { print &quot;Feliz Navidad\n&quot;; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreach $item (split(/:[\\\n:]*/, $ENV{TERMCAP})) {
	print &quot;Item: $item\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foreach $item (split(/:[\\\n:]*/, $ENV{TERMCAP})) {
	print &quot;Item: $item\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's how a C programmer might code up a particular algorithm in Perl:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un ejemplo de cómo un programador de C codificaría un algoritmo particular en Perl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (my $i = 0; $i &lt; @ary1; $i++) {
	for (my $j = 0; $j &lt; @ary2; $j++) {
	    if ($ary1[$i] &gt; $ary2[$j]) {
		last; # can't go to outer :-(
	    }
	    $ary1[$i] += $ary2[$j];
	}
	# this is where that last takes me</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for (my $i = 0; $i &lt; @array1; $i++) {
	for (my $j = 0; $j &lt; @array2; $j++) {
	    if ($array1[$i] &gt; $array2[$j]) {
		last; # No puede volver al bucle más exterior :-(
	    }
	    $array1[$i] += $array2[$j];
	}
	# Aquí es donde lleva el 'last'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whereas here's how a Perl programmer more comfortable with the idiom might
do it:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y aquí está cómo un programador de Perl, más cómodo con el lenguaje, puede hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OUTER: for my $wid (@ary1) {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>EXTERNO: for my $wid (@array1) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>INNER:   for my $jet (@ary2) {
		next OUTER if $wid &gt; $jet;
		$wid += $jet;
	     }
	  }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>INTERNO:   for my $jet (@array2) {
		next EXTERNO if $wid &gt; $jet;
		$wid += $jet;
	     }
	  }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See how much easier this is?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Ha visto que es mucho más fácil?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's cleaner, safer, and faster.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más limpio, seguro y rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's
cleaner because it's less noisy.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más limpio porque es menos ruidoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's safer because if code gets added
between the inner and outer loops later on, the new code won't be
accidentally executed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es más seguro porque si se añade nuevo código entre los bucles interno y externo, ese nuevo código no será ejecutado accidentalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;next&gt; explicitly iterates the other loop
rather than merely terminating the inner one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El C&lt;next&gt; explícitamente itera sobre el otro bucle en vez de meramente terminar el interno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And it's faster because
Perl executes a C&lt;foreach&gt; statement more rapidly than it would the
equivalent C&lt;for&gt; loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Y es más rápido porque Perl ejecuta un sentencia C&lt;foreach&gt; más rápidamente que su equivalente en un bucle C&lt;for&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Basic BLOCKs and Switch Statements
X&lt;switch&gt; X&lt;block&gt; X&lt;case&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 BLOQUES Básicos y Sentencias Switch
X&lt;switch&gt; X&lt;bloque&gt; X&lt;case&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A BLOCK by itself (labeled or not) is semantically equivalent to a
loop that executes once.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un BLOQUE por sí mismo (etiquetado o no) es semánticamente equivalente a un bucle que se ejecuta una vez. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus you can use any of the loop control
statements in it to leave or restart the block.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Así que puede usar cualquiera de las sentencias de control de bucle dentro de él para salir o reiniciarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this is
I&lt;NOT&gt; true in C&lt;eval{}&gt;, C&lt;sub{}&gt;, or contrary to popular belief
C&lt;do{}&gt; blocks, which do I&lt;NOT&gt; count as loops.)  The C&lt;continue&gt;
block is optional.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(Note que esto I&lt;NO&gt; es verdad en C&lt;eval{}&gt;, C&lt;sub{}&gt;, y contrariamente a la creencia popular, bloques C&lt;do{}&gt;, que I&lt;NO&gt; cuentan como bucles). El bloque C&lt;continue&gt; es opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The BLOCK construct is particularly nice for doing case
structures.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La construcción BLOQUE es particularmente bonita para hacer estructuras I&lt;case&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SWITCH: {
	if (/^abc/) { $abc = 1; last SWITCH; }
	if (/^def/) { $def = 1; last SWITCH; }
	if (/^xyz/) { $xyz = 1; last SWITCH; }
	$nothing = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SWITCH: {
	if (/^abc/) { $abc = 1; last SWITCH; }
	if (/^def/) { $def = 1; last SWITCH; }
	if (/^xyz/) { $xyz = 1; last SWITCH; }
	$nada = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no official C&lt;switch&gt; statement in Perl, because there are
already several ways to write the equivalent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No existe una sentencia oficial C&lt;switch&gt; en Perl, porque existen varias formas de escribir algo equivalente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, starting from Perl 5.8 to get switch and case one can use
the Switch extension and say:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, uno puede obtener switch y case usando Perl 5.8 y superior usando la extensión Switch y diciendo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Switch;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Switch;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>after which one has switch and case.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>después del cual ya se tiene switch y case.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not as fast as it could be
because it's not really part of the language (it's done using source
filters) but it is available, and it's very flexible.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No es tan rápido como se espera porque realmente no forma parte del lenguaje (se hace usando filtros del código fuente) pero está disponible y es muy flexible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the above BLOCK construct, you could write</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Además de la construcción del BLOQUE anterior, puede escribir esto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SWITCH: {
	$abc = 1, last SWITCH  if /^abc/;
	$def = 1, last SWITCH  if /^def/;
	$xyz = 1, last SWITCH  if /^xyz/;
	$nothing = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SWITCH: {
	$abc = 1, last SWITCH  if /^abc/;
	$def = 1, last SWITCH  if /^def/;
	$xyz = 1, last SWITCH  if /^xyz/;
	$nada = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That's actually not as strange as it looks once you realize that you can
use loop control &quot;operators&quot; within an expression.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(No es tan extraño como parece una vez que se de cuenta de que puede usar &quot;operadores&quot; de control de bucle dentro de una expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's just the binary
comma operator in scalar context.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto es solamente el operador coma en contexto escalar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See L&lt;perlop/&quot;Comma Operator&quot;&gt;.)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver L&lt;perlop/&quot;Operador Coma&quot;&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SWITCH: {
	/^abc/ &amp;&amp; do { $abc = 1; last SWITCH; };
	/^def/ &amp;&amp; do { $def = 1; last SWITCH; };
	/^xyz/ &amp;&amp; do { $xyz = 1; last SWITCH; };
	$nothing = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SWITCH: {
	/^abc/ &amp;&amp; do { $abc = 1; last SWITCH; };
	/^def/ &amp;&amp; do { $def = 1; last SWITCH; };
	/^xyz/ &amp;&amp; do { $xyz = 1; last SWITCH; };
	$nada = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or formatted so it stands out more as a &quot;proper&quot; C&lt;switch&gt; statement:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o formateado para que se parezca a una sentencia C&lt;switch&gt; más &quot;limpia&quot;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SWITCH: {
	/^abc/ 	    &amp;&amp; do {
			    $abc = 1;
			    last SWITCH;
		       };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SWITCH: {
	/^abc/ 	    &amp;&amp; do {
			    $abc = 1;
			    last SWITCH;
		       };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^def/ 	    &amp;&amp; do {
			    $def = 1;
			    last SWITCH;
		       };</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/^def/ 	    &amp;&amp; do {
			    $def = 1;
			    last SWITCH;
		       };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^xyz/ 	    &amp;&amp; do {
			    $xyz = 1;
			    last SWITCH;
		        };
	$nothing = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/^xyz/ 	    &amp;&amp; do {
			    $xyz = 1;
			    last SWITCH;
		        };
	$nada = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SWITCH: {
	/^abc/ and $abc = 1, last SWITCH;
	/^def/ and $def = 1, last SWITCH;
	/^xyz/ and $xyz = 1, last SWITCH;
	$nothing = 1;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SWITCH: {
	/^abc/ and $abc = 1, last SWITCH;
	/^def/ and $def = 1, last SWITCH;
	/^xyz/ and $xyz = 1, last SWITCH;
	$nada = 1;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or even, horrors,</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>o incluso, horror,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (/^abc/)
	{ $abc = 1 }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>if (/^abc/)
	{ $abc = 1 }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elsif (/^def/)
	{ $def = 1 }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>elsif (/^def/)
	{ $def = 1 }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elsif (/^xyz/)
	{ $xyz = 1 }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>elsif (/^xyz/)
	{ $xyz = 1 }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else
	{ $nothing = 1 }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else
	{ $nada = 1 }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common idiom for a C&lt;switch&gt; statement is to use C&lt;foreach&gt;'s aliasing to make
a temporary assignment to C&lt;$_&gt; for convenient matching:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un modismo común para una sentencia C&lt;switch&gt; es aliando la asignación temporal de C&lt;$_&gt; en un bucle C&lt;foreach&gt; para realizar el emparejamiento:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SWITCH: for ($where) {
		/In Card Names/     &amp;&amp; do { push @flags, '-e'; last; };
		/Anywhere/          &amp;&amp; do { push @flags, '-h'; last; };
		/In Rulings/        &amp;&amp; do {                    last; };
		die &quot;unknown value for form variable where: `$where'&quot;;
	    }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>SWITCH: for ($donde) {
		/En tarjetas/     &amp;&amp; do { push @flags, '-e'; last; };
		/Cualquiera/      &amp;&amp; do { push @flags, '-h'; last; };
		/En cartones/     &amp;&amp; do {                    last; };
		die &quot;valor desconocido para la variable donde: `$donde'&quot;;
	    }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another interesting approach to a switch statement is arrange
for a C&lt;do&gt; block to return the proper value:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otra interesando aproximación a una sentencia C&lt;switch&gt; es organizar un bloque C&lt;do&gt; para que devuelva el valor apropiado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$amode = do {
	if     ($flag &amp; O_RDONLY) { &quot;r&quot; }	# XXX: isn't this 0?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$acceso_modo = do {
	if     ($flag &amp; O_RDONLY) { &quot;r&quot; }	# XXX: ¿esto no es 0?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elsif  ($flag &amp; O_WRONLY) { ($flag &amp; O_APPEND) ?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>elsif  ($flag &amp; O_WRONLY) { ($flag &amp; O_APPEND) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;a&quot; : &quot;w&quot; }
	elsif  ($flag &amp; O_RDWR)   {
	    if ($flag &amp; O_CREAT)  { &quot;w+&quot; }
	    else                  { ($flag &amp; O_APPEND) ?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;a&quot; : &quot;w&quot; }
	elsif  ($flag &amp; O_RDWR)   {
	    if ($flag &amp; O_CREAT)  { &quot;w+&quot; }
	    else                  { ($flag &amp; O_APPEND) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;a+&quot; : &quot;r+&quot; }
	}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;a+&quot; : &quot;r+&quot; }
	}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print do {</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print do {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($flags &amp; O_WRONLY) ?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($flags &amp; O_WRONLY) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;write-only&quot;          :</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;sólo escritura&quot;      :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($flags &amp; O_RDWR)   ?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>($flags &amp; O_RDWR)   ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;read-write&quot;          :</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;lectura-escritura&quot;   :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;read-only&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&quot;solo-lectura&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or if you are certain that all the C&lt;&amp;&amp;&gt; clauses are true, you can use
something like this, which &quot;switches&quot; on the value of the
C&lt;HTTP_USER_AGENT&gt; environment variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>O si está seguro de que todas las clausulas C&lt;&amp;&amp;&gt; son verdaderas, puede usar algo como esto, con &quot;switches&quot; en el valor de la variable de entorno C&lt;HTTP_USER_AGENT&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># pick out jargon file page based on browser</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># Elige el fichero de la jerga según el navegador utilizado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$dir = 'http://www.wins.uva.nl/~mes/jargon';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$dir = 'http://www.wins.uva.nl/~mes/jargon';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ($ENV{HTTP_USER_AGENT}) { 
	$page  =    /Mac/            &amp;&amp; 'm/Macintrash.html'
		 || /Win(dows )?NT/  &amp;&amp; 'e/evilandrude.html'
		 || /Win|MSIE|WebTV/ &amp;&amp; 'm/MicroslothWindows.html'
		 || /Linux/          &amp;&amp; 'l/Linux.html'
		 || /HP-UX/          &amp;&amp; 'h/HP-SUX.html'
		 || /SunOS/          &amp;&amp; 's/ScumOS.html'
		 ||                     'a/AppendixB.html';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for ($ENV{HTTP_USER_AGENT}) { 
	$pagina  =    /Mac/            &amp;&amp; 'm/Macintrash.html'
		 || /Win(dows )?NT/  &amp;&amp; 'e/evilandrude.html'
		 || /Win|MSIE|WebTV/ &amp;&amp; 'm/MicroslothWindows.html'
		 || /Linux/          &amp;&amp; 'l/Linux.html'
		 || /HP-UX/          &amp;&amp; 'h/HP-SUX.html'
		 || /SunOS/          &amp;&amp; 's/ScumOS.html'
		 ||                     'a/AppendixB.html';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Location: $dir/$page\015\012\015\012&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Location: $dir/$pagina\015\012\015\012&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That kind of switch statement only works when you know the C&lt;&amp;&amp;&gt; clauses
will be true.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta clase de sentencia switch sólo funciona cuando sabe que las clausulas C&lt;&amp;&amp;&gt; serán verdaderas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't, the previous C&lt;?:&gt; example should be used.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no es así, el ejemplo anterior de C&lt;?:&gt; debe ser usado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might also consider writing a hash of subroutine references
instead of synthesizing a C&lt;switch&gt; statement.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Podría también considerar escribir un hash de referencias a subrutinas para sintetizar una sentencia C&lt;switch&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Goto
X&lt;goto&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Goto
X&lt;goto&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although not for the faint of heart, Perl does support a C&lt;goto&gt;
statement.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aunque no sea muy querido, Perl soporta la sentencia C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three forms: C&lt;goto&gt;-LABEL, C&lt;goto&gt;-EXPR, and
C&lt;goto&gt;-&amp;NAME.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existen tres formas: C&lt;goto&gt;-ETIQUETA, C&lt;goto&gt;-EXPR y C&lt;goto&gt;-&amp;NOMBRE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A loop's LABEL is not actually a valid target for
a C&lt;goto&gt;; it's just the name of the loop.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La ETIQUETA de un bucle no es realmente un destino válido para un C&lt;goto&gt;; sólo es el nombre del bucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto&gt;-LABEL form finds the statement labeled with LABEL and resumes
execution there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-ETIQUETA busca la sentencia etiquetada con ETIQUETA y continua la ejecución desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
also can't be used to go into a construct that is optimized away.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Tampoco puede ir en una construcción que esté optimizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
can be used to go almost anywhere else within the dynamic scope,
including out of subroutines, but it's usually better to use some other
construct such as C&lt;last&gt; or C&lt;die&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede ser utilizada para ir a casi cualquier sitio que esté dentro del ámbito dinámico. incluyendo fuera de las subrutinas, pero es usualmente mucho mejor otras construcciones como C&lt;last&gt; o C&lt;die&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto&gt;-EXPR form expects a label name, whose scope will be resolved
dynamically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-EXPR espera un nombre de etiqueta, cuyo ámbito será resuelto dinámicamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>goto((&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i]);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>goto((&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i]);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;goto&gt;-&amp;NAME form is highly magical, and substitutes a call to the
named subroutine for the currently running subroutine.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La forma C&lt;goto&gt;-&amp;NOMBRE es altamente mágica y sustituye a una llamada a una subrutina con nombre desde la actual subrutina que se está ejecutando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is used by
C&lt;AUTOLOAD()&gt; subroutines that wish to load another subroutine and then
pretend that the other subroutine had been called in the first place
(except that any modifications to C&lt;@_&gt; in the current subroutine are
propagated to the other subroutine.)  After the C&lt;goto&gt;, not even C&lt;caller()&gt;
will be able to tell that this routine was called first.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto se usa por subrutinas C&lt;AUTOLOAD()&gt; que desean cargar otra subrutina y fingen que esta otra subrutina ha sido llamada en primer lugar (excepto que cualquier modificación a C&lt;@_&gt; en la subrutina actual se propaga a la otra). Después del C&lt;goto&gt;, ni siquiera C&lt;caller()&gt; será capaz de decir qué rutina fue llamada en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In almost all cases like this, it's usually a far, far better idea to use the
structured control flow mechanisms of C&lt;next&gt;, C&lt;last&gt;, or C&lt;redo&gt; instead of
resorting to a C&lt;goto&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En casi todos los casos como este, es usualmente una mejor, mejor idea, usar los mecanismos de control de flujo de C&lt;next&gt;, C&lt;last&gt; o C&lt;redo&gt; en vez de recurrir a C&lt;goto&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For certain applications, the catch and throw pair of
C&lt;eval{}&gt; and die() for exception processing can also be a prudent approach.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para ciertas aplicaciones, la pareja C&lt;eval{}&gt; y C&lt;die()&gt; puede ser un prudente planteamiento para el procesamiento de excepciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 PODs: Embedded Documentation
X&lt;POD&gt; X&lt;documentation&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 POD: Documentación Embebida
X&lt;POD&gt; X&lt;documentación&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl has a mechanism for intermixing documentation with source code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl tiene un mecanismo para entremezclar documentación y código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it's expecting the beginning of a new statement, if the compiler
encounters a line that begins with an equal sign and a word, like this</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras que él espera el comienzo de una nueva sentencia, si el compilador encuentra una línea que comienza con un signo de igual y una palabra, como esta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 Here There Be Pods!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 Aquí serán los Pods!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then that text and all remaining text up through and including a line
beginning with C&lt;=cut&gt; will be ignored.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Entonces este texto y el siguiente hasta incluir una línea que comience por C&lt;=cut&gt; será ignorada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format of the intervening
text is described in L&lt;perlpod&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El formato del texto intermedio está descrito en L&lt;perlpod&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to intermix your source code
and your documentation text freely, as in</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto le permite entremezclar código fuente y texto de la documentación libremente, como por ejemplo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item snazzle($)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=item snazzle($)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The snazzle() function will behave in the most spectacular</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La función snazzle() se convertirá en la más espectacular</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>form that you can possibly imagine, not even excepting</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>forma que pueda posiblemente imaginar, incluyendo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cybernetic pyrotechnics.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pirotecnia cibernética.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=cut back to the compiler, nuff of this pod stuff!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=cut devuelta al compilador, lejos de este material pod!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sub snazzle($) {
	my $thingie = shift;
	.........</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sub snazzle($) {
	my $cosita = shift;
	.........</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that pod translators should look at only paragraphs beginning
with a pod directive (it makes parsing easier), whereas the compiler
actually knows to look for pod escapes even in the middle of a
paragraph.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note que los traductores pod suelen mirar sólo en los párrafos que comiencen por una directiva pod (hace el parseo más fácil), mientras que el compilador realmente sabe mirar por las secuencias pod incluso en el medio de un párrafo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the following secret stuff will be
ignored by both the compiler and the translators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esto significa que el siguiente material secreto será ignorado tanto por el compilador como por los traductores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$a=3;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$a=3;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=secret stuff</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=material secreto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>warn &quot;Neither POD nor CODE!?&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>warn &quot;Ni POD ni CÓDIGO!?&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=cut back</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=cut regreso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;got $a\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;tengo $a\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You probably shouldn't rely upon the C&lt;warn()&gt; being podded out forever.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Probablemente no se dará cuenta de que el C&lt;warn()&gt; ha sido comentado para siempre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all pod translators are well-behaved in this regard, and perhaps
the compiler will become pickier.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No todos los traductores pod están bien entrenados a este respecto y quizá el compilador sea más quisquilloso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One may also use pod directives to quickly comment out a section
of code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Uno puede también usar directivas pod para comentar, de forma rápida, una sección de código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Plain Old Comments (Not!)
X&lt;comment&gt; X&lt;line&gt; X&lt;#&gt; X&lt;preprocessor&gt; X&lt;eval&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Comentarios a la vieja usanza
X&lt;comentario&gt; X&lt;línea&gt; X&lt;#&gt; X&lt;preprocesador&gt; X&lt;eval&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can process line directives, much like the C preprocessor.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl puede procesar directivas como lo hace el preprocesador de C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using
this, one can control Perl's idea of filenames and line numbers in
error or warning messages (especially for strings that are processed
with C&lt;eval()&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Usando esto, uno puede controlar la idea que tiene Perl de los nombres de archivos y número de líneas un los mensajes de avisos y errores (especialmente para los strings procesados con C&lt;eval()&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for this mechanism is the same as for most
C preprocessors: it matches the regular expression</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La sintaxis de este mecanismo es el mismo que para la mayoría de preprocesadores de C: coincide con la expresión regular</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># example: '# line 42 &quot;new_filename.plx&quot;'</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># ejemplo: '# line 42 &quot;nuevo_fichero.plx&quot;'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/^\#   \s*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>/^\#   \s*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line \s+ (\d+)   \s*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>line \s+ (\d+)   \s*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(?:\s(&quot;?)([^&quot;]+)\2)?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>(?:\s(&quot;?)([^&quot;]+)\2)? </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\s*</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\s*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$/x</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$/x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with C&lt;$1&gt; being the line number for the next line, and C&lt;$3&gt; being
the optional filename (specified with or without quotes).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>con C&lt;$1&gt; siendo el número de línea para la línea siguiente y C&lt;$3&gt; siendo el nombre de fichero opcional (especificado con o sin comillas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a fairly obvious gotcha included with the line directive:
Debuggers and profilers will only show the last source line to appear
at a particular line number in a given file.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existe obviamente un problema con esta directiva: los I&lt;debuggers&gt; y perfiladores sólo mostrarán la última línea del código fuente que aparece en un número de línea en particular de un determinado fichero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Care should be taken not
to cause line number collisions in code you'd like to debug later.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay que tener cuidado para no causar colisiones de números de línea en el código que pretendas debuggear más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some examples that you should be able to type into your command
shell:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay algunos ejemplos que será capaz de escribir en la línea de comandos del shell:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>% perl</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>% perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># line 200 &quot;bzzzt&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># line 200 &quot;bzzzt&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># the `#' on the previous line must be the first char on line</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># el `#' en la línea anterior debe ser el primer carácter de la línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die 'foo';</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die 'foo';</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at bzzzt line 201.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at bzzzt line 201.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval qq[\n#line 2001 &quot;&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval qq[\n#line 2001 &quot;&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at - line 2001.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at - line 2001.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval qq[\n#line 200 &quot;foo bar&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval qq[\n#line 200 &quot;foo bar&quot;\ndie 'foo']; print $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at foo bar line 200.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at foo bar line 200.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># line 345 &quot;goop&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg># line 345 &quot;goop&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval &quot;\n#line &quot; .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>eval &quot;\n#line &quot; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>__LINE__ .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>__LINE__ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>' &quot;' .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>' &quot;' .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>__FILE__ .&quot;\&quot;\ndie 'foo'&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>__FILE__ .&quot;\&quot;\ndie 'foo'&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print $@;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print $@;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foo at goop line 345.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>foo at goop line 345.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=cut</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=cut</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlstyle - Perl style guide</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlstyle - Guía de estilo Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each programmer will, of course, have his or her own preferences in
regards to formatting, but there are some general guidelines that will
make your programs easier to read, understand, and maintain.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cada programador tendrá, naturalmente, sus propias preferencias con respecto al estilo, pero hay algunas directrices que harán sus programas más fáciles de leer, entender y mantener.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most important thing is to run your programs under the B&lt;-w&gt;
flag at all times.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Lo más importante es ejecutar siempre sus programas con la opción B&lt;-w&gt; puesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may turn it off explicitly for particular
portions of code via the C&lt;no warnings&gt; pragma or the C&lt;$^W&gt; variable
if you must.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede desactivarla explícitamente en partes del código con el pragma C&lt;no warnings&gt; o con la variable C&lt;$^W&gt; si así lo desea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should also always run under C&lt;use strict&gt; or know the
reason why not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Debería siempre también correr con C&lt;use strict&gt; o conocer la razón de porqué no hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use sigtrap&gt; and even C&lt;use diagnostics&gt; pragmas
may also prove useful.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El pragma C&lt;use sigtrap&gt; e incluso el C&lt;use diagnostics&gt; pueden ser también muy útiles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regarding aesthetics of code lay out, about the only thing Larry
cares strongly about is that the closing curly bracket of
a multi-line BLOCK should line up with the keyword that started the construct.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Con respecto a la estética del código, a lo único que Larry le preocupa es que la llave de cierre de un BLOQUE multilínea debe alinearse con la palabra reservada que inició esa estructura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond that, he has other preferences that aren't so strong:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aparte de eso, él tiene otras preferencias que no son tan estrictas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4-column indent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sangrado a 4 columnas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opening curly on same line as keyword, if possible, otherwise line up.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llave de apertura en la misma línea que la palabra reservada, si es posible, o si no, alineada en vertical con ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space before the opening curly of a multi-line BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio antes de llave de apertura de un BLOQUE multilínea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-line BLOCK may be put on one line, including curlies.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un BLOQUE de una sola línea puede ser puesto en una sola línea, incluyendo sus llaves.o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No space before the semicolon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin espacio antes de punto y coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Semicolon omitted in &quot;short&quot; one-line BLOCK.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Punto y coma omitido en BLOQUE &quot;pequeño&quot; de una sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space around most operators.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio alrededor de la mayoría de operadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space around a &quot;complex&quot; subscript (inside brackets).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio alrededor de un subíndice &quot;complejo&quot; (entre corchetes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blank lines between chunks that do different things.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Líneas en blanco entre bloques que hacen cosas diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uncuddled elses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>else en nueva línea. No en la misma línea que la llave de cierre del if.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No space between function name and its opening parenthesis.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin espacio entre el nombre de función y su paréntesis de apertura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space after each comma.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio después de cada coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Long lines broken after an operator (except C&lt;and&gt; and C&lt;or&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dividir líneas largas después de un operador (excepto C&lt;and&gt; y C&lt;or&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space after last parenthesis matching on current line.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Espacio después del último paréntesis coincidente en la línea actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line up corresponding items vertically.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alinear elementos correspondientes verticalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omit redundant punctuation as long as clarity doesn't suffer.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Omitir la puntuación redundante mientras no se reduzca la claridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Larry has his reasons for each of these things, but he doesn't claim that
everyone else's mind works the same as his does.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Larry tiene sus razones para cada una de estas ideas, pero el no aspira que la mente de los demás trabaje de la misma forma que la suya.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some other more substantive style issues to think about:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay otras cuestiones de estilo que sí que hay que recordar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just because you I&lt;CAN&gt; do something a particular way doesn't mean that
you I&lt;SHOULD&gt; do it that way.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo porque usted I&lt;PUEDA&gt; hacer algo de una determinada manera no significa que usted I&lt;DEBA&gt; hacerlo de esa manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is designed to give you several
ways to do anything, so consider picking the most readable one.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl está diseñado para darle varias opciones para hacer cualquier cosa, así que elija la más legible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
instance</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por ejemplo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open(FOO,$foo) || die &quot;Can't open $foo: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open(FOO,$foo) || die &quot;No puedo abrir $foo: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is better than</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>es mejor que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>die &quot;Can't open $foo: $!&quot; unless open(FOO,$foo);</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>die &quot;No puedo abrir $foo: $!&quot; unless open(FOO,$foo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the second way hides the main point of the statement in a
modifier.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>porque la segunda forma esconde el objetivo principal de la instrucción dentro de un modificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De otra forma</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>print &quot;Starting analysis\n&quot; if $verbose;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>print &quot;Empezando análisis\n&quot; if $locuaz;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$verbose &amp;&amp; print &quot;Starting analysis\n&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$locuaz &amp;&amp; print &quot;Empezando análisis\n&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the main point isn't whether the user typed B&lt;-v&gt; or not.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>porque el objetivo principal no es si el usuario escribió B&lt;-v&gt; o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, just because an operator lets you assume default arguments
doesn't mean that you have to make use of the defaults.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De forma similar, sólo porque un operador le permite asumir argumentos por defecto no significa que usted tenga que hacer uso de esos valores por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The defaults
are there for lazy systems programmers writing one-shot programs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los valores por defecto son para los programadores de sistemas perezosos escribiendo programas pequeños.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you want your program to be readable, consider supplying the argument.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted quiere que su programa sea legible, considere suplir el argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Along the same lines, just because you I&lt;CAN&gt; omit parentheses in many
places doesn't mean that you ought to:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De la misma forma, sólo porque usted I&lt;PUEDA&gt; omitir paréntesis en muchos lugares no significa que deba hacerlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return print reverse sort num values %array;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return print reverse sort num values %array;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return print(reverse(sort num (values(%array))));</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>return print(reverse(sort num (values(%array))));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in doubt, parenthesize.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En caso de duda, coloque paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the very least it will let some poor
schmuck bounce on the % key in B&lt;vi&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por lo menos esto hará que algún pobre inútil pueda usar la tecla % en B&lt;vi&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if you aren't in doubt, consider the mental welfare of the person
who has to maintain the code after you, and who will probably put
parentheses in the wrong place.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluso si usted no tiene dudas, considerar el bienestar mental de la persona que tenga que mantener el código después de usted, y quien seguramente pondrá los paréntesis en el lugar equivocado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't go through silly contortions to exit a loop at the top or the
bottom, when Perl provides the C&lt;last&gt; operator so you can exit in
the middle.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No haga tontas contorsiones para salir de un bucle al inicio o al final, cuando Perl dispone del operador C&lt;last&gt; para que pueda salir desde el interior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just &quot;outdent&quot; it a little to make it more visible:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sólo &quot;desángrelo&quot; un poco para hacerlo más visible:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LINE:
	for (;;) {
	    statements;
	  last LINE if $foo;
	    next LINE if /^#/;
	    statements;
	}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>LINEA:
	for (;;) {
	    instrucciones;
	  last LINEA if $foo;
	    next LINEA if /^#/;
	    instrucciones;
	}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't be afraid to use loop labels--they're there to enhance
readability as well as to allow multilevel loop breaks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se asuste de usar etiquetas de bucles -están para aumentar la legibilidad así como permitir rupturas de bucles multiniveles-.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the
previous example.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ver el ejemplo anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid using C&lt;grep()&gt; (or C&lt;map()&gt;) or `backticks` in a void context, that is,
when you just throw away their return values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evite usar C&lt;grep()&gt; (o C&lt;map()&gt;) o `acentos graves` en contexto nulos, es decir, cuando usted no va usar los valores de retorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those functions all
have return values, so use them.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todas estas funciones tienen valores de retorno, así que úselos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise use a C&lt;foreach()&gt; loop or
the C&lt;system()&gt; function instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De otra forma, use un bucle C&lt;foreach()&gt; o la función C&lt;system()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For portability, when using features that may not be implemented on
every machine, test the construct in an eval to see if it fails.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para la portabilidad, cuando utilice características que pueden no estar implementadas en todas las máquinas, compruebe el código en un eval para ver si falla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you know what version or patchlevel a particular feature was
implemented, you can test C&lt;$]&gt; (C&lt;$PERL_VERSION&gt; in C&lt;English&gt;) to see if it
will be there.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si usted sabe en qué versión o patchlevel fue implementada una cierta característica, puede comprobar C&lt;$]&gt; (C&lt;$PERL_VERSION&gt; en C&lt;English&gt;) para ver si está incluida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;Config&gt; module will also let you interrogate values
determined by the B&lt;Configure&gt; program when Perl was installed.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El módulo C&lt;Config&gt; le permitirá también interrogar por los valores determinados por el programa B&lt;Configure&gt; cuando Perl fue instalado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose mnemonic identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Elija identificadores mnemónicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you can't remember what mnemonic means,
you've got a problem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si no puede recordar lo que significa un mnemónico, usted tiene un problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While short identifiers like C&lt;$gotit&gt; are probably ok, use underscores to
separate words in longer identifiers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras identificadores cortos como C&lt;$leenombre&gt; están bien, use guiones bajos para separar palabras en los identificadores más largos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is generally easier to read
C&lt;$var_names_like_this&gt; than C&lt;$VarNamesLikeThis&gt;, especially for
non-native speakers of English.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Generalmente es más fácil leer C&lt;$var_nombres_como_este&gt; que C&lt;$VarNombresComoEste&gt;, especialmente para los que no sean castellanoparlantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also a simple rule that works
consistently with C&lt;VAR_NAMES_LIKE_THIS&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es una regla que funciona también con C&lt;VAR_NOMBRES_COMO_ESTE&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Package names are sometimes an exception to this rule.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los nombres de los paquetes son, en alguna ocasión, una excepción a esta regla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl informally
reserves lowercase module names for &quot;pragma&quot; modules like C&lt;integer&gt; and
C&lt;strict&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl, de forma informal, reserva nombres de módulos en minúscula para módulos &quot;pragma&quot; como C&lt;integer&gt; y C&lt;strict&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other modules should begin with a capital letter and use mixed
case, but probably without underscores due to limitations in primitive
file systems' representations of module names as files that must fit into a
few sparse bytes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Otros módulos deben comenzar con una letra mayúscula y usar luego una mezcla de mayúsculas y minúsculas, pero probablemente sin guiones bajos debido a limitaciones en la representación de nombres de módulos como ficheros en sistemas de ficheros primitivos que deben ajustarse a unos pocos bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may find it helpful to use letter case to indicate the scope
or nature of a variable.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede encontrar útil usar el tamaño de caja de las letras para indicar el ámbito o naturaleza de una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ALL_CAPS_HERE   constants only (beware clashes with perl vars!)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$TODO_MAYUSCULAS    Sólo constantes (¡cuidado con variables perl!)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$Some_Caps_Here  package-wide global/static</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$Algunas_Mayusculas Ámbito de paquete/estática</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$no_caps_here    function scope my() or local() variables</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$sin_mayusculas     Ámbito de función, variables my() o local()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function and method names seem to work best as all lowercase.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Funciones y nombres de métodos parece que funcionan mejor con minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>E.g., C&lt;$obj-E&lt;gt&gt;as_string()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ej., C&lt;$obj-E&lt;gt&gt;como_cadena()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a leading underscore to indicate that a variable or
function should not be used outside the package that defined it.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede usar un guión bajo inicial para indicar que una variable o función no debe ser usado fuera del paquete que lo define.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a really hairy regular expression, use the C&lt;/x&gt; modifier and
put in some whitespace to make it look a little less like line noise.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si tiene una expresión regular especialmente complicada, use el modificador C&lt;/x&gt; y ponga algunos espacios en blanco para que no parezca una línea telefónica con ruido de fondo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't use slash as a delimiter when your regexp has slashes or backslashes.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No use barras inclinadas como delimitador cuando en su expresión regular tenga barras o contrabarras inclinadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the new C&lt;and&gt; and C&lt;or&gt; operators to avoid having to parenthesize
list operators so much, and to reduce the incidence of punctuation
operators like C&lt;&amp;&amp;&gt; and C&lt;||&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use los nuevos operadores C&lt;and&gt; y C&lt;or&gt; para evitar poner demasiados paréntesis en listas de operadores y para reducir la incidencia de puntuación de operadores como C&lt;&amp;&amp;&gt; y C&lt;||&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call your subroutines as if they were
functions or list operators to avoid excessive ampersands and parentheses.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Llame a sus subrutinas como si fueran funciones u operadores de lista para evitar el excesivo número de ligaduras (&amp;&amp;) y paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use here documents instead of repeated C&lt;print()&gt; statements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use documentos incluídos en vez de repetir instrucciones C&lt;print()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line up corresponding things vertically, especially if it'd be too long
to fit on one line anyway.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alineé elementos correspondientes verticalmente, especialmente si es demasiado largo el espacio que ocupan como para entrar en una sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_MTIME;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_MTIME;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_ATIME 	   if $opt_u;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_ATIME 	   if $opt_u;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_CTIME 	   if $opt_c;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_CTIME 	   if $opt_c;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$IDX = $ST_SIZE  	   if $opt_s;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$IDX = $ST_SIZE  	   if $opt_s;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mkdir $tmpdir, 0700	or die &quot;can't mkdir $tmpdir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>mkdir $tmpdir, 0700	or die &quot;no puedo hacer mkdir $tmpdir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chdir($tmpdir)      or die &quot;can't chdir $tmpdir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>chdir($tmpdir)      or die &quot;no puedo hacer chdir $tmpdir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mkdir 'tmp',   0777	or die &quot;can't mkdir $tmpdir/tmp: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>mkdir 'tmp',   0777	or die &quot;no puedo hacer mkdir $tmpdir/tmp: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always check the return codes of system calls.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Siempre compruebe los valores devueltos por las llamadas al sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good error messages should
go to C&lt;STDERR&gt;, include which program caused the problem, what the failed
system call and arguments were, and (VERY IMPORTANT) should contain the
standard system error message for what went wrong.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los buenos mensajes de error deben ir al C&lt;STDERR&gt;, incluyendo qué programa causó el problema, qué función del sistema y qué argumentos fueron, y (MUY IMPORTANTE) debe contener el mensaje de error estándar del sistema por el cual falló.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a simple but
sufficient example:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí hay un simple pero útil ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opendir(D, $dir)	 or die &quot;can't opendir $dir: $!&quot;;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>opendir(D, $dir)	 or die &quot;no puedo hacer opendir $dir: $!&quot;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line up your transliterations when it makes sense:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Alinear transliteraciones cuando tengan sentido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tr [abc]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>tr [abc]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[xyz];</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[xyz];</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think about reusability.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Piense en la reutilización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Why waste brainpower on a one-shot when you
might want to do something like it again?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¿Por qué perder la energía cerebral de un acierto cuando puede volver a usarlo otra vez?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider generalizing your
code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere generalizar su código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider writing a module or object class.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere escribir un módulo o una clase de objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider making your
code run cleanly with C&lt;use strict&gt; and C&lt;use warnings&gt; (or B&lt;-w&gt;) in
effect.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere hacer su código limpio utilizando C&lt;use strict&gt; y C&lt;use warnings&gt; (o B&lt;-w&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider giving away your code.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere compartir su código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider changing your whole
world view.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere cambiar su punto de vista vital.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider... oh, never mind.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Considere... ¡oh!, olvídelo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try to document your code and use Pod formatting in a consistent way.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Intente documentar su código y usar formateo Pod de una forma consistente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here
are commonly expected conventions:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Están son las convenciones más usadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; for function, variable and module names (and more
generally anything that can be considered part of code, like filehandles
or specific values).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; por función, variable y nombres de módulos (y más generalmente cualquier cosa que pueda ser considerada parte del código, como manejadores de archivo o valores específicos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that function names are considered more readable
with parentheses after their name, that is C&lt;function()&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Note como los nombres de función se vuelven más legibles con los paréntesis detrás de su nombre, como esta C&lt;funcion()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use C&lt;BE&lt;lt&gt;E&lt;gt&gt;&gt; for commands names like B&lt;cat&gt; or B&lt;grep&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use C&lt;BE&lt;lt&gt;E&lt;gt&gt;&gt; para nombres de comandos como B&lt;cat&gt; o B&lt;grep&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; or C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; for file names.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; o C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt; para nombres de ficheros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; should
be the only Pod code for file names, but as most Pod formatters render it
as italic, Unix and Windows paths with their slashes and backslashes may
be less readable, and better rendered with C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>C&lt;FE&lt;lt&gt;E&lt;gt&gt;&gt; debe ser el único código Pod para nombres de fichero, pero como la mayoría de los formateadores de Pod lo muestran en cursiva, los caminos Unix y Windows con sus barras y contrabarras pueden hacerlo menos legible, por lo que es mejor mostrarlo con C&lt;CE&lt;lt&gt;E&lt;gt&gt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be consistent.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sea coherente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be nice.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sea amable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl - Practical Extraction and Report Language</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl - Practical Extraction and Report Language</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 SYNOPSIS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 SINOPSIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;perl&gt;	S&lt;[ B&lt;-sTuU&gt; ]&gt; S&lt;[ B&lt;-hv&gt; ] [ B&lt;-V&gt;[:I&lt;configvar&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>B&lt;perl&gt;	S&lt;[ B&lt;-sTuU&gt; ]&gt; S&lt;[ B&lt;-hv&gt; ] [ B&lt;-V&gt;[:I&lt;configvar&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S&lt;[ B&lt;-cw&gt; ] [ B&lt;-d&gt;[:I&lt;debugger&gt;] ] [ B&lt;-D&gt;[I&lt;number/list&gt;] ]&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>S&lt;[ B&lt;-cw&gt; ] [ B&lt;-d&gt;[:I&lt;debugger&gt;] ] [ B&lt;-D&gt;[I&lt;number/list&gt;] ]&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 AUTHOR</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 AUTOR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 SEE ALSO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 VEA TAMBIÉN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three principal virtues of a programmer are Laziness,
Impatience, and Hubris.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>The three principal virtues of a programmer are Laziness,
Impatience, and Hubris.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the Camel Book for why.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>See the Camel Book for why.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you read this file _as_is_, just ignore the funny characters you
see.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si lees este fichero _tal_como_es_, ignora los caracteres curiosos que veas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is written in the POD format (see pod/perlpod.pod) which is
specifically designed to be readable as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está escrito en formato POD (ver pod/perlpod.pod) que está específicamente diseñado para ser legible de forma sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.openbsd - Perl version 5 on OpenBSD systems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.openbsd - Perl versión 5 sobre sistemas OpenBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes various features of OpenBSD that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documentos describe varias características de OpenBSD que afectarán a cómo Perl versión 5 (de ahora en adelante sólo Perl) es compilado y/o ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 OpenBSD vuelca el núcleo desde getprotobyname_r y getservbyname_r con ithreads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Perl is configured to use ithreads, it will use re-entrant library calls
in preference to non-re-entrant versions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando Perl está configurado para usar ithreads, usará llamadas de biblioteca reentrantes preferentemente sobre versiones no-reentrantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is an incompatability in
OpenBSD's C&lt;getprotobyname_r&gt; and C&lt;getservbyname_r&gt; function in versions 3.7
and later that will cause a SEGV when called without doing a C&lt;bzero&gt; on
their return structs prior to calling these functions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Existe una incompatibilidad en las funciones de 
OpenBSD C&lt;getprotobyname_r&gt; y C&lt;getservbyname_r&gt; en las versiones 3.7
y superiores que causarán un SEGV cuando se llamen sin haber hecho antes un C&lt;bzero&gt; en sus estructuras de retorno antes de llamar a estas funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Current Perl's
should handle this problem correctly.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El Perl actual debería manejar este problema correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Older threaded Perls (5.8.6 or earlier)
will run into this problem.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Anteriores Perls con threads (5.8.6 o anteriores) tendrán este problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to run a threaded Perl on OpenBSD
3.7 or higher, you will need to upgrade to at least Perl 5.8.7.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere correr un Perl con hilos sobre OpenBSD 3.7 o superior, necesitará actualizar Perl al menos a la versión 5.8.7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Steve Peters &lt;steve@fisharerojo.org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Steve Peters &lt;steve@fisharerojo.org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please report any errors, updates, or suggestions to F&lt;perlbug@perl.org&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Por favor, informe de cualquier error, actualización o sugerencias a  F&lt;perlbug@perl.org&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you read this file _as_is_, just ignore the funny characters you see.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si lees este fichero _tal_como_es_, ignora los caracteres curiosos que veas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is written in the POD format (see pod/perlpod.pod) which is specially
designed to be readable as is.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está escrito en formato POD (ver pod/perlpod.pod) que está específicamente diseñado para ser legible de forma sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.apollo - Perl version 5 on Apollo DomainOS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.apollo - Perl versión 5 sobre Apollo DomainOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following tests are known to fail as of Perl 5.005_03:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los siguientes test se sabe que fallan en 5.005_03:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>comp/decl..........FAILED at test 0
op/write...........FAILED at test 0
lib/filefind.......FAILED at test 2
lib/io_udp.........FAILED at test 2
lib/findbin........stat(/ressel/ABT/USER/vta/jk/proj.local/perl/perl5.005_03-MAINT_TRIAL_5/t/lib/): No such file or directory at ../lib/FindBin.pm line 162
stat(/ressel/ABT/USER/vta/jk/proj.local/perl/perl5.005_03-MAINT_TRIAL_5/t/lib/): No such file or directory at ../lib/FindBin.pm line 163
FAILED at test 1</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>comp/decl..........FAILED at test 0
op/write...........FAILED at test 0
lib/filefind.......FAILED at test 2
lib/io_udp.........FAILED at test 2
lib/findbin........stat(/ressel/ABT/USER/vta/jk/proj.local/perl/perl5.005_03-MAINT_TRIAL_5/t/lib/): No such file or directory at ../lib/FindBin.pm line 162
stat(/ressel/ABT/USER/vta/jk/proj.local/perl/perl5.005_03-MAINT_TRIAL_5/t/lib/): No such file or directory at ../lib/FindBin.pm line 163
FAILED at test 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Johann Klasek &lt;jk@auto.tuwien.ac.at&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Johann Klasek &lt;jk@auto.tuwien.ac.at&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.freebsd - Perl version 5 on FreeBSD systems</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.freebsd - Perl versión 5 sobre sistemas FreeBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes various features of FreeBSD that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documentos describe varias características de FreeBSD que afectarán a cómo Perl versión 5 (de ahora en adelante sólo Perl) es compilado y/o ejecutado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 FreeBSD core dumps from readdir_r with ithreads</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 FreeBSD vuelca el núcleo desde readdir_r con ithreads</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When perl is configured to use ithreads, it will use re-entrant library calls
in preference to non-re-entrant versions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando Perl está configurado para usar ithreads, usará llamadas de biblioteca reentrantes preferentemente sobre versiones no-reentrantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a bug in FreeBSD's
C&lt;readdir_r&gt; function in versions 4.5 and earlier that can cause a SEGV when
reading large directories.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay un bug en la función C&lt;readdir_r&gt; de FreeBSD en la versión 4.5 y anteriores que pueden provocar un SEGV al leer grandes directorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A patch for FreeBSD libc is available
(see http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631 )
which has been integrated into FreeBSD 4.6.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un parche para la libc de FreeBSD está disponible (ver http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631 ) y ha sido integrado en FreeBSD 4.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 $^X doesn't always contain a full path in FreeBSD</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 $^X no siempre contiene el camino completo en FreeBSD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl 5.8.0 sets C&lt;$^X&gt; where possible to a full path by asking the operating
system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl 5.8.0 pone C&lt;$^X&gt; hasta donde sea posible a todo el camino completo preguntando al sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On FreeBSD the full path of the perl interpreter is found by reading
the symlink F&lt;/proc/curproc/file&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En FreeBSD el camino completo del intérprete perl se encuentra leyendo el enlace simbólico F&lt;/proc/curproc/file&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a bug on FreeBSD, where the
result of reading this symlink is can be wrong in certain circumstances
(see http://www.freebsd.org/cgi/query-pr.cgi?pr=35703 ).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Hay un bug en FreeBSD, donde el resultado de leer un enlace simbólico puede ser erróneo en determinadas circunstancias (ver http://www.freebsd.org/cgi/query-pr.cgi?pr=35703 ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these cases perl will fall back to the old behaviour of using C's
argv[0] value for C&lt;$^X&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>En estos casos perl volverá al anterior comportamiento de usar el valor del C argv[0] para C&lt;$^X&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Perl will no longer be part of &quot;base FreeBSD&quot;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Perl ya no formará parte de la &quot;base FreeBSD&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not as bad as it sounds--what this means is that Perl will no longer be
part of the B&lt;kernel build system&gt; of FreeBSD.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-No tan malo como suena- quiere decir que Perl ya no formará parte del B&lt;sistema de construcción del kernel&gt; de FreeBSD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl will still very
probably be part of the &quot;default install&quot;, and in any case the latest
version will be in the ports system.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Perl seguirá, probablemente, formando parte de la &quot;instalación por defecto&quot; y en cualquier caso la último versión será adaptada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first FreeBSD version this
change will affect is 5.0, all 4.n versions will keep the status quo.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La primera versión FreeBSD con este cambio es 5.0. Todas las versiones 4.n mantendrán su status quo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nicholas Clark &lt;nick@ccl4.org&gt;, collating wisdom supplied by Slaven Rezic
and Tim Bunce.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Nicholas Clark &lt;nick@ccl4.org&gt;, recopilando la sabiduría proporcionada por Slaven Rezic y Tim Bunce.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.hurd - Perl version 5 on Hurd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.hurd - Perl versión 5 sobre Hurd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use Perl on the Hurd, I recommend using the Debian
GNU/Hurd distribution ( see http://www.debian.org/ ), even if an
official, stable release has not yet been made.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si quiere usar Perl sobre Hurd, le recomiendo usar la distribución Debian
GNU/Hurd ( ver http://www.debian.org/ ), incluso aunque todavía no exista una versión estable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The old `gnu-0.2'
binary distribution will most certainly have additional problems.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La antigua distribución binaria `gnu-0.2' sigue teniendo problemas adicionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Known Problems with Perl on Hurd</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 Problemas conocidos de Perl sobre Hurd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl test suite may still report some errors on the Hurd.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El conjunto de test Perl seguirá informando de algunos errores sobre Hurd.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
`lib/anydbm' and `pragma/warnings' tests will almost certainly fail.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los test `lib/anydbm' y `pragma/warnings' seguirán fallando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both failures are not really specific to the Hurd, as indicated by the
test suite output.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ambos fallos realmente no son específicos a Hurd, como se indica en la salida de los test.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The socket tests may fail if the network is not configured.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El test de socket fallará si la red no está configurada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have
to make `/hurd/pfinet' the translator for `/servers/socket/2', giving
it the right arguments.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Deberá hacer `/hurd/pfinet' el traductor para el `/servers/socket/2', dándole los permisos adecuados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try `/hurd/pfinet --help' for more
information.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Escriba `/hurd/pfinet --help' para más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are the statistics for Perl 5.005_62 on my system:</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Aquí están las estadísticas de Perl 5.005_62 en mi sistema:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failed Test  Status Wstat Total Fail  Failed  List of failed</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Failed Test  Status Wstat Total Fail  Failed  List of failed</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-------------------------------------------------------------------------</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-------------------------------------------------------------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lib/anydbm.t                 12    1   8.33%  12</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>lib/anydbm.t                 12    1   8.33%  12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pragma/warnings             333    1   0.30%  215</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>pragma/warnings             333    1   0.30%  215</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8 tests and 24 subtests skipped.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>8 tests and 24 subtests skipped.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failed 2/229 test scripts, 99.13% okay.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Failed 2/229 test scripts, 99.13% okay.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2/10850 subtests failed, 99.98% okay.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2/10850 subtests failed, 99.98% okay.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are quite a few systems out there that do worse!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>¡Hay pocos sistemas que lo hagan peor!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since I am running a very recent Hurd snapshot, in which a lot of
bugs that were exposed by the Perl test suite have been fixed, you may
encounter more failures.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Sin embargo, desde que estoy corriendo en la reciente distribución de Hurd, y aunque un montón de errores expuestos por el conjunto de test de Perl han sido arreglados, usted puede encontrar más fallos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likely candidates are: `op/stat', `lib/io_pipe',
`lib/io_sock', `lib/io_udp' and `lib/time'.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los candidatos más probables son: `op/stat', `lib/io_pipe', `lib/io_sock', `lib/io_udp' y `lib/time'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any way, if you're seeing failures beyond those mentioned in this
document, please consider upgrading to the latest Hurd before reporting
the failure as a bug.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De cualquier forma, si está viendo fallos más allá de los aquí mencionados en este documento, considere, por favor, actualizar al último Hurd antes de informar del fallo como si fuera un bug.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mark Kettenis &lt;kettenis@gnu.org&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mark Kettenis &lt;kettenis@gnu.org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last Updated: Fri, 29 Oct 1999 22:50:30 +0200</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Last Updated: Fri, 29 Oct 1999 22:50:30 +0200</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>README.macos - Perl under Mac OS (Classic)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>README.macos - Perl bajo Mac OS (Classic)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document briefly describes perl under Mac OS (Classic).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Este documento describe brevemente perl bajo Mac OS (Classic).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are running perl under Mac OS X, you don't want to be
here (unless you are in the Classic environment under Mac OS X).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Si está corriendo perl bajo Mac OS X, no es necesario que siga leyendo (a menos que esté en un entorno Classic bajo Mac OS X).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and I&lt;not&gt;
Mac OS X.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Cuando decimos bajo &quot;Mac OS&quot;, queremos decir Mac OS 7, 8 y 9, y I&lt;no&gt; Mac OS X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latest perl source itself builds on Mac OS, with some additional
pieces.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El último fuente perl se compila sobre Mac OS, con algunas piezas adicionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Support for Mac OS is now in the perl core, and MacPerl is kept
in close sync with regular perl releases.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Soporte para Mac OS está ahora en el núcleo de perl, y MacPerl se sincroniza con los lanzamientos regulares de perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To build perl for Mac OS (as an MPW tool), you will need the addition
of the F&lt;macos&gt; subdirectory, distributed separately.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para construir perl para Mac OS (como una herramienta MPW), necesitará la adición del subdirectorio F&lt;macos&gt;, distribuido separadamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It includes extra
source files, config files, and make files.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Incluye ficheros fuente adicionales, ficheros de configuración y ficheros make.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also includes extra
Mac-specific modules.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También incluye módulos adicionales específicos para Mac.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To build the MacPerl application, you will also need the F&lt;macperl&gt;
directory, which includes the source files for creating the
application itself.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Para construir la aplicación MacPerl, también necesitará el directorio F&lt;macperl&gt;, que incluye los ficheros fuente para crear la propia aplicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of this is available from the development site, via
HTTP (in the MacPerl Installer, which includes all the source
and binaries) and anonymous CVS.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Todo esto está disponible desde el sitio de desarrollo, vía HTTP (en el instalador MacPerl, que incluye todo el fuente y binarios) y CVS de acceso anónimo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://dev.macperl.org/</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://dev.macperl.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The source is also in the main perl repository in the macperl
branch (the 5.6 source is in the maint-5.6/macperl branch).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>El fuente también está en el depósito principal de perl, en la rama macperl (el fuente 5.6 está en la rama maint-5.6/macperl).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will also need compilers and libraries, all of them freely
available.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>También necesitará compiladores y librerías, todas ellas disponibles libremente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are linked to from the SourceForge site.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Están enlazadas desde el sitio de SourceForge.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go that site
for all things having to do with MacPerl development.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Vaya a este sitio para todo lo relacionado con el desarrollo de MacPerl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MacPerl 5.6.1 and later are supported on Mac OS 8.1 and later, for 68040
and PowerPC architectures.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>MacPerl 5.6.1 y siguientes están soportados en Mac OS 8.1 y siguients, para arquitecturas 68040 y PowerPC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The MPW tool may be used on Mac OS 7.5.5
and 68030 computers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La herramienta MPW puede ser usada sobre Mac OS 7.5.5 y ordenadores 68030.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MacPerl 5.2.0r4 is also available, on the CPAN and on SourceForge.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>MacPerl 5.2.0r4 está también disponible en CPAN y en SourceForge.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
is based on perl 5.004, and works with Mac OS 7.5.5 and 68030 computers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Está basada en perl 5.00 y funciona sobre Mac OS 7.5.5 y ordenadores 68030.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perl was ported to Mac OS by Matthias Neeracher
E&lt;lt&gt;neeracher@mac.comE&lt;gt&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perl fue adaptado a Mac OS por Matthias Neeracher E&lt;lt&gt;neeracher@mac.comE&lt;gt&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is currently maintained by Chris
Nandor E&lt;lt&gt;pudge@pobox.comE&lt;gt&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Actualmente mantenido por Chris Nandor E&lt;lt&gt;pudge@pobox.comE&lt;gt&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 DATE</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 FECHA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last modified 2002.05.02.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Last modified 2002.05.02.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perlcheat - Perl 5 Cheat Sheet</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>perlcheat - Chuleta de Perl 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This 'cheat sheet' is a handy reference, meant for beginning Perl
programmers.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Esta 'chuleta' es una referencia rápida, para los programadores principiantes de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not everything is mentioned, but 194 features may
already be overwhelming.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>No se menciona todo, porque 194 características pueden ser apabuyantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 The sheet</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head2 La hoja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CONTEXTS  SIGILS             ARRAYS        HASHES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>CONTEXTO  CARACT.            ARRAYS        HASHES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void      $scalar   whole:   @array        %hash</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>void      $scalar  completo: @array        %hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scalar    @array    slice:   @array[0, 2]  @hash{'a', 'b'}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>scalar    @array   trozo:    @array[0, 2]  @hash{'a', 'b'}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>list      %hash     element: $array[0]     $hash{'a'}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>list      %hash    elemento: $array[0]     $hash{'a'}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;sub</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;sub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*glob    SCALAR VALUES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>*glob    SCALAR VALUES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>number, string, reference, glob, undef</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>número, cadena, referencia, glob, undef</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REFERENCES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>REFERENCIAS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\     references      $$foo[1]       aka $foo-&gt;[1]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\     referencias     $$foo[1]      igual que $foo-&gt;[1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$@%&amp;* dereference     $$foo{bar}     aka $foo-&gt;{bar}</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>$@%&amp;* desreferencia   $$foo{bar}    igual que $foo-&gt;{bar}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[]    anon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>[]    array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>arrayref  ${$$foo[1]}[2] aka $foo-&gt;[1]-&gt;[2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>anónimo  ${$$foo[1]}[2] igual que $foo-&gt;[1]-&gt;[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{}    anon.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>{}    hash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hashref   ${$$foo[1]}[2] aka $foo-&gt;[1][2]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>anónimo   ${$$foo[1]}[2] igual que $foo-&gt;[1][2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\()   list of refs</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\()   lista de referencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NUMBERS vs STRINGS  LINKS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>NÚMERoS vs CADENAS  ENLACES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OPERATOR PRECEDENCE     =          =        perl.plover.com</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>PRECEDENCIA de OPER.    =          =        perl.plover.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-&gt;                      +          .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>-&gt;                      +          .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>search.cpan.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>search.cpan.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>++ --                   == !=      eq ne         cpan.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>++ --                   == !=      eq ne         cpan.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**                      &lt; &gt; &lt;= &gt;=  lt gt le ge   pm.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>**                      &lt; &gt; &lt;= &gt;=  lt gt le ge   pm.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>~ \ u+ u-             &lt;=&gt;        cmp           tpj.com</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>~ \ u+ u-             &lt;=&gt;        cmp           tpj.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=~ !~                                            perldoc.com</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=~ !~                                            perldoc.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* / % x                 SYNTAX</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>* / % x                 SINTAXIS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+ - .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>+ - .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for    (LIST) { }, for (a;b;c) { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>for    (LIST) { }, for (a;b;c) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;&lt; &gt;&gt;                   while  ( ) { }, until ( ) { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt;&lt; &gt;&gt;                   while  ( ) { }, until ( ) { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>named uops              if     ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>oper. con nombre        if     ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt; &gt; &lt;= &gt;= lt gt le ge   unless ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&lt; &gt; &lt;= &gt;= lt gt le ge   unless ( ) { } elsif ( ) { } else { }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== != &lt;=&gt; eq ne cmp     for equals foreach (ALWAYS)</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== != &lt;=&gt; eq ne cmp     for igual a foreach (SIEMPRE)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>| ^              REGEX METACHARS            REGEX MODIFIERS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>| ^              REGEX METACARACT.          REGEX MODIFICADORES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;&amp;               ^     string begin         /i case insens.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>&amp;&amp;               ^     comienzo de cadena   /i may. y min.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>||               $     str.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>||               $     fin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>end (before \n) /m line based ^$</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg> cad. (antes \n)  /m line based ^$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>..</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>...           +     one or more          /s .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>...           +     one or more          /s .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>includes \n</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>includes \n</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?:               *     zero or more         /x ign.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>?:               *     zero or more         /x ign.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wh.space</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>wh.space</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= += -= *= etc.  ?</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>= += -= *= etc.  ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>zero or one          /g global</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>zero or one          /g global</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>, =&gt;             {3,7} repeat in range</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>, =&gt;             {3,7} repeat in range</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>list ops         ()    capture          REGEX CHARCLASSES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>list ops         ()    capture          REGEX CHARCLASSES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not              (?:)  no capture       .</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>not              (?:)  no capture       .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== [^\n]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>== [^\n]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and              []    character class  \s == [\x20\f\t\r\n]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>and              []    character class  \s == [\x20\f\t\r\n]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or xor           |     alternation      \w == [A-Za-z0-9_]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>or xor           |     alternation      \w == [A-Za-z0-9_]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\b    word boundary    \d == [0-9]</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\b    word boundary    \d == [0-9]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\z    string end       \S, \W and \D negate</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>\z    string end       \S, \W and \D negate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DO</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>DO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use strict;        DON'T            LINKS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use strict;        DON'T            LINKS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use warnings;      &quot;$foo&quot;           perl.com</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use warnings;      &quot;$foo&quot;           perl.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $var;           $$variable_name  perlmonks.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>my $var;           $$variable_name  perlmonks.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open() or die $!;  `$userinput`     use.perl.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>open() or die $!;  `$userinput`     use.perl.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use Modules;       /$userinput/     perl.apache.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>use Modules;       /$userinput/     perl.apache.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>parrotcode.org</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>parrotcode.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FUNCTION RETURN LISTS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>FUNCTION RETURN LISTS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stat      localtime    caller         SPECIAL VARIABLES</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>stat      localtime    caller         SPECIAL VARIABLES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0 dev    0 second     0 package      $_    default variable</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>0 dev    0 second     0 package      $_    default variable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 ino    1 minute     1 filename     $0    program name</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>1 ino    1 minute     1 filename     $0    program name</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 mode   2 hour       2 line         $/    input separator</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>2 mode   2 hour       2 line         $/    input separator</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3 nlink  3 day        3 subroutine   $\    output separator</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>3 nlink  3 day        3 subroutine   $\    output separator</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4 uid    4 month-1    4 hasargs      $|    autoflush</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>4 uid    4 month-1    4 hasargs      $|    autoflush</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5 gid    5 year-1900  5 wantarray    $!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>5 gid    5 year-1900  5 wantarray    $!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sys/libcall error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>sys/libcall error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6 rdev   6 weekday    6 evaltext     $@    eval error</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>6 rdev   6 weekday    6 evaltext     $@    eval error</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>7 size   7 yearday    7 is_require   $$    process ID</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>7 size   7 yearday    7 is_require   $$    process ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8 atime  8 is_dst     8 hints        $.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>8 atime  8 is_dst     8 hints        $.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>line number</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>line number</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9 mtime               9 bitmask      @ARGV command line args</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>9 mtime               9 bitmask      @ARGV command line args</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 ctime  just use                    @INC  include paths</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>10 ctime  just use                    @INC  include paths</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>11 blksz  POSIX::      3..9 only      @_    subroutine args</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>11 blksz  POSIX::      3..9 only      @_    subroutine args</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12 blcks  strftime!</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>12 blcks  strftime!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with EXPR      %ENV  environment</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>with EXPR      %ENV  environment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 ACKNOWLEDGEMENTS</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>=head1 RECONOCIMIENTOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first version of this document appeared on Perl Monks, where several
people had useful suggestions.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>La primera versión de este documentos apareció en Perl Monks, en donde muchas personas dieron sus útiles sugerencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thank you, Perl Monks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Gracias, Perl Monks.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A special thanks to Damian Conway, who didn't only suggest important changes,
but also took the time to count the number of listed features and make a
Perl 6 version to show that Perl will stay Perl.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un agradecimiento especial a Damian Conway, quien no sólo sugirió importantes cambios, sino que se tomó el tiempo suficiente para contar las características listadas y hacer una versión para Perl 6 y demostrar que Perl seguirá siendo Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Juerd Waalboer &lt;juerd@cpan.org&gt;, with the help of many Perl Monks.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Juerd Waalboer &lt;juerd@cpan.org&gt;, con la ayuda de muchos Perl Monks.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://perlmonks.org/?node_id=216602      the original PM post</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://perlmonks.org/?node_id=216602      la publicación original en PM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://perlmonks.org/?node_id=238031      Damian Conway's Perl 6 version</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://perlmonks.org/?node_id=238031      Versión Perl 6 de Damian Conway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://juerd.nl/site.plp/perlcheat        home of the Perl Cheat Sheet</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>http://juerd.nl/site.plp/perlcheat        Casa de la Chuleta Perl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you read this file _as_is_, just ignore the funny characters you</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>If you read this file _as_is_, just ignore the funny characters you</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X&lt;syntax&gt;</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>X&lt;syntax&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Perl program consists of a sequence of declarations and statements</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Un programa Perl consiste de una secuencia de declaraciones e instrucciones of a sequence of declarations and statements</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The C&lt;use sigtrap&gt; and even C&lt;use diagnostics&gt; pragmas</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>The C&lt;use sigtrap&gt; and even C&lt;use diagnostics&gt; pragmas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Long lines broken after an operator (except C&lt;and&gt; C&lt;and&gt; C&lt;or&gt;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Dividir líneas largas después de un operador (excepto C&lt;and&gt; y C&lt;or&gt;).Long lines broken after an operator (except C&lt;and&gt; C&lt;and&gt; C&lt;or&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may turn it off explicitly for particular
portions of code via the C&lt;no warnings&gt; pragma or the C&lt;$^W&gt; variable 
if you must.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Puede desactivarlo explícitamente para una porción de código en particular con el pragma C&lt;no warnings&gt; o con la variable C&lt;$^W&gt; si lo necesita así.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Long lines broken after an operator (except &quot;and&quot; and &quot;or&quot;).</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Líneas largas partidas después de un operador (excepto &quot;and&quot; y &quot;or&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid using grep() (or map()) or `backticks` in a void context, that is,
when you just throw away their return values.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Evite usar grep() (o map()) o `backticks` en contexto nulos, es decir,
cuando usted deshecha sus valores de retorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise use a foreach() loop or
the system() function instead.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>De otra forma, use un bucle foreach() o
la función system().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While short identifiers like $gotit are probably ok, use underscores to
separate words.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Mientras identificadores cortos como $leenombre están bien, use guiones bajos para separar palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is generally easier to read $var_names_like_this than
$VarNamesLikeThis, especially for non-native speakers of English.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Generalmente es más fácil leer $var_nombres_como_este que $VarNombresComoEste, especialmente para los que no sean angloparlantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's
also a simple rule that works consistently with VAR_NAMES_LIKE_THIS.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Es una regla que funciona también con VAR_NOMBRES_COMO_ESTE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>E.g., $obj-E&lt;gt&gt;as_string().</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Ejemplo, $obj-E&lt;gt&gt;como_cadena().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the new &quot;and&quot; and &quot;or&quot; operators to avoid having to parenthesize
list operators so much, and to reduce the incidence of punctuation
operators like C&lt;&amp;&amp;&gt; and C&lt;||&gt;.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use los nuevos operadores &quot;and&quot; y &quot;or&quot; para evitar poner demasiados paréntesis en listas de operadores y para reducir la incidencia de la puntuación de operadores como C&lt;&amp;&amp;&gt; y C&lt;||&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use here documents instead of repeated print() statements.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Use documentos incluídos en vez de repetidas instrucciones print().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good error messages should
go to STDERR, include which program caused the problem, what the failed
system call and arguments were, and (VERY IMPORTANT) should contain the
standard system error message for what went wrong.</seg>
      </tuv>
      <tuv lang="ES-ES">
        <seg>Los buenos mensajes de error deben ir a STDERR, incluyendo qué programa causó el problema, qué función del sistema y qué argumentos fueron, y (MUY IMPORTANTE) debe contener el mensaje de error estándar del sistema por el cual falló.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
